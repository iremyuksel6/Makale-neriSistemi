effici parallel backtrack analyt model experiment result concern averag case behavior ofparallel backtrack present two type backtrack search algorithm areconsid simpl backtrack use heurist order prunesearch heurist backtrack analyt model use compareth averag number node visit sequenti parallel search case forsimpl backtrack shown averag speedup obtain linear thedistribut solut uniform superlinear distribut solut isnonuniform heurist backtrack averag speedup obtain least linearand speedup obtain subset instanc superlinear experiment result formani synthet practic problem run variou parallel machin valid thetheoret analysi present b introduct consid problem find solut statespac tree contain one solutions10 28 26 6 backtrack also call depthfirst search wide use techniqu solv problem storag effici 13 28 throughout paper use two name interchang use acronym df denot backtrack depthfirst search statespac tree mani variant df algorithm tune certain type problem paper deal two import simpl backtrack use heurist inform ii heurist backtrack use order andor prune heurist reduc search complex number parallel formul df develop variou researchers12 7 22 2 25 23 one formulation23 n processor concurr perform backtrack disjoint part statespac tree part statespac search differ processor roughli equal size actual part search space search differ processor sequenc node subspac visit determin dynam differ differ execut result execut sequenc parallel version may find solut visit fewer node sequenti version thu give superlinear speedup speedup defin ratio time taken sequenti parallel df execut sequenc may find solut visit node thu give sublinear speedup type behavior common varieti parallel search algorithm refer speedup anomali 18 19 superlinear speedup isol execut parallel df report mani research 12 25 22 7 33 20 may appear averag speedup would either linear sublinear otherwis even parallel df execut sequenti processor via timesl would perform better sequenti df paper consid averag case speedup anomali parallel df algorithm base techniqu develop 23 17 though simpl backtrack heurist backtrack algorithm analyz use df strategi behavior differ analyz separ develop abstract model search space travers two type df algorithm analyz compar averag number node visit sequenti search parallel search case simpl backtrack show averag speedup obtain linear distribut solut uniform ii superlinear distribut solut nonuniform heurist backtrack averag speedup obtain least linear ie either linear superlinear speedup obtain subset instanc difficult instanc superlinear theoret analysi valid experiment analysi exampl problem problem gener testpattern digit circuits3 n gammaqueen 15puzzle26 hacker problem31 result parallel backtrack search give least linear speedup averag import sinc df current best known practic use algorithm solv number import problem occurr consist superlinear speedup certain problem impli sequenti df algorithm suboptim problem parallel df timesl one processor domin sequenti df highli signific known search techniqu domin sequenti df problem restrict attent paper statespac search tree df algorithm effect search tree overal speedup obtain parallel df depend upon two factor search overhead defin ratio node expand parallel sequenti search commun overhead amount time wast differ processor commun synchro nizat etc orthogon sens caus complet differ search overhead caus sequenti parallel df search node differ order commun overhead depend upon target architectur load balanc techniqu commun overhead parallel df analyz previous publish papers17 16 4 14 experiment valid varieti problem architectur 1 paper analyz search overhead howev experi run real multiprocessor overhead incur henc overal speedup observ experi may less linear ie less n n processor even model predict parallel search expand fewer node sequenti search parallel df effect commun overhead less signific larger instanc ie instanc take longer time execut henc larger instanc problem obey analys accur smaller instanc reader keep mind interpret experiment result present paper section 2 briefli describ two differ kind df algorithm analyz paper section 3 review parallel df simpl backtrack search algorithm analyz section 4 order backtrack search algorithm analyz 5 section 6 contain relat research section 7 contain conclud remark experi parallel df modifi find optim solut number node search sequenti df parallel df becom equal make search overhead 1 2 type df algorithm consid problem formul term find solut path implicit direct statespac tree initi node goal node tree gener fli aid successorgener function given node tree function gener successor backtrack ie df use solv problem follow search begin expand initi node ie gener successor later step one recent gener node expand problem heurist inform use order successor expand node determin order successor visit df method heurist inform also use prune unpromis part search tree prune node discard search recent gener node successor determin node lead solut backtrack done recent gener node remain yet unexpand node select expans major advantag df storag requir linear depth search space search follow two search method use backtrack search strategi 1 simpl backtrack depthfirst search method use find one solut use heurist order successor expand node heurist may use prune node search space search avoid node 2 order backtrack depthfirst search method use find one solut may use heurist order successor expand node may also use heurist prune node search space search avoid node method also refer order dfs13 3 parallel df mani differ parallel formul dfs7 15 19 34 2 8 23 suitabl execut asynchron mimd multiprocessor formul discuss use quit commonli 22 23 2 4 14 formul processor search disjoint part search space whenev processor complet search assign part request busi processor work busi processor split remain search space two piec give one piec request processor solut found processor notifi processor search space finit solut eventu processor would run work search sequenti parallel termin without find solut backtrack search algorithm search termin whole search space exhaust ie either search prune parallel df algorithm analyz theoret differ slightli descript follow simplic analys model assum initi static partit search space suffici good load balanc parallel df use experiment result work partit dynam reader see close agreement experi analys 4 analysi speedup simpl backtrack inform 41 assumpt definit statespac tree leaf node solut occur among leaf node amount comput need visit leaf node execut time search proport number leaf node visit unreason assumpt search tree branch factor greater one number node visit df roughli proport number leav visit also section dont model effect prune heurist explicitli assum number leaf node statespac tree alreadi prune use prune function sequenti parallel df stop find one solut parallel df statespac tree equal partit among n processor thu processor get subtre node least one solut entir tree otherwis parallel search sequenti search would visit entir tree without find solut result linear speedup inform order search statespac tree henc densiti solut across search frontier independ order search solut densiti ae leaf node probabl leaf node solut assum bernoulli distribut solut ie event leaf node solut independ leaf node solut also assum ae 1 wn denot averag total number node visit n processor one processor find solut w 1 averag number leaf node visit sequenti df solut found clearli w 1 wn less equal sinc execut time search sequenti well parallel case proport number node expand wn theta n effici e speedup divid n e denot effect util comput resourc wn 42 effici analysi consid search frontier leaf node static divid n region leav let densiti solut among leav th region ae parallel case processor search region independ one processor find solut sequenti case region arrang random sequenc search order theorem 41 ae 0 densiti region number leav k region larg mean number leav visit singl processor search region 1 ae proof sinc bernoulli distribut mean number larg enough k second term becom less 1 henc mean number trial aesequenti df select one n region probabl 1n search find solut henc averag number leaf node expand sequenti df 2 ae n 2 given express assum solut alway found select region thu one region search probabl solut anoth region would need search take account would make express w 1 precis increas averag valu w 1 somewhat reader verifi overal result analysi chang step parallel df one node n region explor simultan ousli henc probabl success step parallel algorithm approxim ae 1 neglect second order term sinc ae assum small henc inspect equat see w hm hm harmon mean ae 0 arithmet mean sinc know arithmet mean harmon mean hm satisfi relat hm w 1 wn particular ffl ae equal solut uniformli distribut averag speedup parallel df linear ffl differ hm therefor w 1 wn solut densiti differ region nonuniform averag speedup parallel df superlinear assumpt event node solut independ event node solut unlik true practic problem still analysi suggest parallel df obtain higher effici sequenti df provid solut distribut uniformli search space inform densiti differ region avail characterist happen true varieti problem space search simpl backtrack 43 experiment result present experiment result perform parallel df three problem hacker problem 31 ii 15puzzl problem26 iii n gammaqueen problem6 experi discuss section sequenti parallel df visit newli gener successor node random order differ convent df successor visit static defin left right order order df successor visit heurist order visit successor random order rather lefttoright heurist order tri valid model assum heurist inform avail order node henc random order good 3 get averag run time 3 asid reader note order inform alway improv effect df exampl experi ida algorithm 15puzzl problem 11 indic experi repeat mani time note besid random order successor anoth sourc variabl execut time parallel df part statespac tree search differ processor determin dynam highli depend run time event beyond programm control henc parallel df experi repeat even frequent sequenti df hacker problem involv search complet binari tree leaf node solut node path solut node repres correct password among variou binari sequenc fix length may one solut due wild card notat implement program sequent balanc 21000 multiprocessor experi differ case 16 processor experi done two differ kind tree one case one solut distribut uniformli whole search space correspond case branch point due wild card tree 1 solut wild card exactli one solut case predict analysi sequenti search parallel search approxim amount work henc speed parallel df linear case correspond curv label 1 figur 1 effici start decreas beyond 8 processor commun overhead higher larger number processor second case four solut distribut uniformli small subspac total space subspac randomli locat whole space correspond case branch point due charact denot wild card low tree case expect effici parallel df greater 1 region search differ processor tend differ solut densiti result shown figur 1 fraction indic next curv denot size subspac solut locat exampl 1mean curv case solut locat randomli 1of space figur 1 reader would notic peak effici r processor case solut distribut 1 r fraction search space see curv label 18 116 happen possibl one r processor receiv region contain solut thu give substanti higher densiti region compar processor cours sinc search space experi distribut dynam best case happen time probabl occurr becom smaller number processor increas height peak success curv decreas valu 1r also decreas use manhattan distanc heurist order best known admiss heurist 15puzzl make df better hand problem n gammaqueen order inform improv perform df substantially9 32 experi 15puzzl perform bbn butterfli parallel processor 9 processor experi involv instanc 15puzzl uniform distribut nonuniform distribut solut depth bound df use limit search space instanc sequenti df parallel df execut depthbound equal depth shallowest solut node averag time sequenti parallel search obtain run experi 100 time everi 15puzzl instanc figur 2 show averag speedup obtain instanc uniform distribut solut show near linear speedup maximum deviat speedup indic band region width band region expect reduc lot repetit say 1000 everi instanc tri instanc nonuniform distribut solut give superlinear speedup figur 3 show effici versu number processor n gammaqueen problem problem natur known exhibit non uniform solut density8 data point shown obtain averag 100 trial see parallel df exhibit better effici sequenti df number processor increas fix problem size effici goe overhead parallel execut mask gain due parallel execut expect larger instanc problem parallel df exhibit superlinear speedup even larger number processor experi confirm predict model superlinear speedup occur parallel df densiti solut region search differ processor differ linear speedup occur solut uniformli distribut whole search space mean solut densiti region search differ processor parallel number processor n effici figur 1 effici curv hacker problem effici greater 1 indic superlinear speedup number processor n uniform dist non uniform dist singl soln figur 2 speedup curv 15puzzl problem 13queen 16queen 22queen linear speedup number processor n figur 3 effici curv nqueen problem 5 speedup parallel order depthfirst search 51 assumpt definit given balanc binari tree depth tree contain 2 node 2 leaf node 2 solut node find one solut travers tree use sequenti parallel df bound heurist avail make unnecessari search nonleaf node either follow two case 1 identifi solut reach node even identifi node solut 2 identifi solut exist subtre root node thu make unnecessari search node bound heurist succe prune nonleaf node need search node node nonleaf node bound heurist succeed search proce usual node character bound heurist success rate 1 gamma ie probabl procedur succe prune node purpos discuss shall assum 05 ensur effect branch factor greater 1 05 search complex becom insignific consid balanc binari tree depth k prune use bound heurist let f k number leaf node tree clearli f k would 2 k given tree solut df visit f leaf node tree one solut df find solut visit fewer leaf node f actual number leaf node visit depend upon locat left solut tree turn depend upon order successor node visit extrem case correct successor node visit first df solut found visit exactli one leaf node left node search tree solut practic order heurist avail aid us visit promis node first postpon visit inferior one necessari later character order heurist paramet fl heurist make correct choic order probabl fl ie flfraction time subtre contain solut visit remain 1 gamma flfraction time subtre contain solut visit obvious make sens consid 05 mean heurist provid wors inform random coin toss 10 order perfect solut found visit 1 leaf node shall refer tree obtre orderedbound tree order bound inform avail reduc search summar obtre model search problem bound andor order heurist avail guid search error probabl constant reader caution problem may necessarili true 52 effici analysi analyz averag number leaf node visit sequenti parallel df algorithm obtre let sd averag number leaf node prune node termin node visit sequenti search p sum averag number leaf node visit processor parallel df theorem 51 f proof see proof theorem a1 appendix atheorem 52 sd see proof theorem a2 appendix athu use order bound heurist sequenti df cut effect size origin search tree larg factor bound heurist reduc effect branch factor 2 approxim 2 order heurist reduc overal search effort factor 1 gamma fl even though obtre complet binari tree backtrack algorithm use prune heurist reduc branch factor less 2 let consid number node visit parallel df clearli bound heurist use parallel df effect use sequenti df howev might appear parallel df make good use order heurist one processor work promis part space wherea processor work less promis part follow theorem say intuit wrong theorem 53 obtre parallel df expand node averag sequenti df proof first consid two processor parallel df later gener result twoprocessor parallel df tree static partit root processor search two tree depth independ least one succe individu perform sequenti df help bound prune heurist note though second processor violat advic order heurist root node follow advic everywher els consid case root node prune bound heurist two possibl case case 1 solut exist left subtre case happen flfraction time case sequenti df visit sd gamma 1 leaf node averag wherea parallel df visit 2sd gamma 1 leaf node left subtre also solut parallel df visit exactli 2sd gamma 1 leaf node averag otherwis subtre solut averag work done parallel df smaller case 2 solut exist left subtre ie exist right subtre case happen 1gammaflfract time case sequenti df visit f dgamma1sdgamma1 leaf node averag wherea parallel df visit exactli 2sd gamma 1 leaf node thu flfraction time parallel df visit sd gamma 1 extra node 1 gamma fl fraction time visit f node sequenti df henc averag ignor case solut found root 4 0 theorem a2 result extend case 2 processor perform parallel search follow theorem theorem 54 p number node expand parallel search 2 processor 0 p p agamma1 proof theorem compar search effici 2 agamma1 processor use 2 processor use first case entir search tree split 2 agamma1 equal part near root part search one processor 4 root prune ignor differ p sd tree one node second case split two equal part two processor share work one processor use let us compar number node expand one processor first case correspond pair processor second case know subtre deal obtre fore theorem 53 show pair processor much work singl processor first case sum 2 agamma1 part whole tree theorem follow induct theorem show p sd hold case 2 k processor perform parallel search521 superlinear speedup hard solv instanc theorem 53 follow import consequ partit randomli select set problem instanc two subset one subset averag speedup sublinear averag speedup one superlinear one partit accord correct order near root let us call instanc order heurist make correct decis near root easytosolv instanc other hardtosolv instanc sequenti df easytosolv instanc take smaller time solv hardtosolv instanc 2processor case easytosolv instanc flfraction total instanc order heurist make correct decis root parallel version obtain averag speedup 1 ie speedup remain instanc averag speedup roughli 2gammafl arbitrarili high depend upon close fl 1 2 processor easiest solv instanc fl fraction total instanc sequenti search make correct decis first branch start root maximum superlinear avail hardest solv instanc fraction total instanc 53 experiment result problem chose experi test gener problem aris comput aideddesign cad vlsi problem automat test pattern gener atpg obtain set logic assign input integr circuit distinguish faulti faultfre circuit presenc set fault input pattern said test given fault presenc fault produc output differ faulti faultfre circuit studi sequenti parallel implement algorithm call podem pathori decis make 3 use combin circuit sequenti circuit base levelsensit scan design approach one success algorithm problem wide use number fault possibl circuit proport number signal line known sequenti algorithm abl gener test 90 fault reason time spend enorm amount time much 90 execut time tri gener test remain fault result execut algorithm termin fail gener test predefin number node expans backtrack fault solv reason time serial algorithm call hardtodetect htd faults27 practic import gener test mani fault possibl higher fault coverag result reliabl chip atpg problem fit model analyz well follow reason search tree gener binari ii nonredund fault problem typic one small number solut iii good imperfect order heurist avail iv bound heurist avail prune search node either prune node solut longer lead solut experi atpg problem support analysi hardtosolv stanc parallel algorithm show superlinear speedup implement sequenti parallel version podem 128 processor symult 2010 multiprocessor perform experi use iscas85 benchmark file test data detail implement experiment result found 1 experi conduct follow htd fault first filter pick fault seven file whose test pattern could found within 25 backtrack use sequenti algorithm serial parallel podem algorithm use find test pattern htd fault sinc htd fault may solvabl sequenti andor parallel podem algorithm reason time upper limit impos total number backtrack sequenti parallel algorithm could make sequenti parallel algorithm exceed limit sum backtrack made processor count parallel case algorithm abort fault classifi undetect backtrack limit time taken pure sequenti podem parallel podem use comput speedup result shown figur 4 circuit iscas85 benchmark experi 25600 use upperlimit backtrack test variat superlinear hard fault select two set fault first set consist fault serial algorithm abl solv execut total number backtrack node expans rang 16006400 similarli number processor speedup figur 4 speedup curv atpg problem second set fault solv serial algorithm backtrack rang 640025600 fault second set thu harder solv serial algorithm two seven file name c499 c1355 yield fault either two set execut parallel algorithm 16 128 processor averag speedup obtain given number processor separ two set fault runtim fault averag obtain 10 run result shown figur 5 result clear superlinear increas increas hard instanc degre superlinear decreas increas number processor effici parallel df decreas problem size fix number processor increased16 note experiment result valid discuss section 521 valid theorem 53 would necessari find number node expand parallel df even easi detect fault fault experiment run time roughli proport number node search parallel df small tree commun overhead becom signific superlinear hardtodetect fault experiment observ atpg heurist patil banerje 27 6 relat research occurr speedup anomali simpl backtrack studi 22 8 monien et al22 studi parallel formul df solv satisfi problem formul processor tri prove satisfi differ subformula input formula due natur satisfi problem subformula lead search space differ averag densiti solut differ solut densiti respons averag superlinear speedup context model monien et al show possibl obtain averag superlinear speedup sat problem analysi simpl backtrack section 4 done similar model result gener stronger also analyz averag case behavior parallel simpl backtrack 24 theoret result present much stronger 24 24 show region search processor solut uniformli distribut region search rest processor solut averag speedup parallel backtrack would superlinear analysi section 4 show nonuniform solut densiti among region search differ processor lead superlinear speedup averag two type heurist df algorithm discuss outsid scope 22 24 160064003282251751257525number processor figur 5 speedup curv hardtosolv instanc atpg problem search space search random fashion ie newli gener successor node order randomli number node expand solut found random variabl let call t1 one simpl parallel formul df present 21 8 let search space search mani processor independ random order one processor find solut total number node expand processor formul random variabl let call tn clearli g v random variabl averag valu tn less 1 time t1 also expect superlinear speedup21 8 certain distribut t1 happen case exampl probabl find solut level statespac tree property21 note parallel formul df domin one 21 8 term effici parallel formul duplic work henc parallel formul exhibit superlinear speedup search space formul 21 8 exhibit superlinear speedup convers true certain problem probabilist algorithms29 5 perform substanti better simpl backtrack exampl happen problem statespac tree balanc binari tree like hacker problem discuss section 43 overal densiti solut among leaf node rel high solut distribut nonuniformli probabilist search perform better simpl backtrack problem make densiti solut leaf node look virtual uniform reader infer analysi section 4 kind search space parallel df also obtain similar homogen solut densiti even though processor still perform enumer part search space domain applic two techniqu probabilist algorithm vs sequenti parallel df howev differ depth leaf node tree vari probabilist search algorithm visit shallow node much frequent deep node statespac tree mani problem n gammaqueen problem shallow node correspond failur node solut node locat deep tree problem probabilist algorithm perform well simpl backtrack visit failur node frequent note simpl backtrack visit failur node exactli densiti solut among leaf node low expect run time probabilist algorithm also high extrem case solut probabilist search never termin wherea simpl backtrack parallel df case also enum search algorithm simpl backtrack 5 probabilist algorithm state space search obtain gener random walk root node leaf node solut found superior probabilist algorithm parallel variant retain advantag homogen order df random parallel df algorithm given 21 8 perform poorli abl benefit order heurist probabilist algorithm weak decis problem analysi section 5 show util order heurist cut search larg factor sequenti df parallel df case optim problem ie interest find leastcost solut random parallel df algorithm 21 8 well probabilist algorithm use one guarante optim solut unless exhaust search perform saletor kale 30 present parallel formul df quit differ one 22 23 2 formul explicitli ensur number node search sequenti parallel formul nearli equal result paper appli parallel df 5 gener model explain occurr superlinear speedup varieti search problem present shown parallel algorithm perform less work correspond sequenti algorithm superlinear speedup possibl paper identifi analyz problem inde case conclus present analyt model theoret result character averag case behavior parallel backtrack search df algorithm show averag parallel df show deceler anomali two type problem also present experiment result valid claim multiprocessor identifi certain problem characterist lead superlinear speedup parallel df problem characterist parallel df algorithm better sequenti df algorithm even timesl one processor isol occurr speedup anomali parallel df report earlier variou research experiment analyt result show possibl superlinear speedup averag except result 22 24 avail parallel df number question need address research problem sequenti df domin parallel df search techniqu best possibl sequenti search algorithm one deriv run parallel df one processor time slice mode ye optimum number processor emul mode case order backtrack search show parallel search effici hardtosolv instanc sequenti search effici easytosolv instanc practic one therefor use combin sequenti parallel search optim combin paper analyz effici parallel df certain model would interest perform similar analysi model also parallel formul backtrack search given 7 30 acknowledg would like thank sunil arvindam hang ng help us experi would also like thank dr jame c brown dr vineet singh mani help discuss appendic detail analysi order df algorithm theorem a1 f proof clear f 1 consid case k 0 root node prune thu f 1 remain probabl root node prune 2 successor case f henc bound heurist succe root df visit one leaf otherwis visit left subtre root fl fraction time visit left subtre unsuccess visit right subtre fraction time henc 1 moder suffic henc use theorem a1 simplifi previou assumpt 1 d1 term ignor term becom neglig larger 05 say 055 thu theorem a3 error ignor smallin twoprocessor parallel depthfirst search tree static partit root processor search two tree depth d1 independ least one succe individu perform sequenti df consult three wise oracl note though second processor violat advic order heurist root node follow advic everywher els henc time root prune prune liber convent two node expand parallel search otherwis two obtre depth d1 search two node expand step one processor succeed inequ aris averag minimum two trial minimum two averag formula sd use theorem a1 error ignor less 1 theorem a1 inequ becom equal restrict one solut entir search tree theorem a4 averag parallel search visit number node sequenti search larg randomli select set problem instanc singl solut proof see argument r automat test pattern gener multiprocessor implicit enumer algorithm gener test combinatori logic circuit experiment evalu load balanc techniqu hypercub model speedup n greater n fundament comput algorithm parallel search scheme multiprocessor system applic combinatori problem random parallel algorithm prolog program backtrack applic perfect heurist n nonattack queen problem search artifici intellig person commun use parallel implement heurist search scalabl load balanc techniqu parallel comput parallel branchandbound formul andor tree search scalabl parallel formul depthfirst search parallel depthfirst search anomali parallel branch bound algorithm wah comput effici parallel approxim branchandbound algorithm share virtual memori system parallel comput superlinear speedup random algorithm superlinear speedup parallel back track parallel depthfirst search superlinear speedup statespac search parallel implement iterativedeepeninga principl artifici intellig parallel branchandbound algorithm test gener probabilist algorithm consist linear speedup first solut parallel statespac search averag complex depthfirst search backtrack cutoff effici search techniqu empir studi nqueen problem perform pragmat orparallel logic program system tr heurist intellig search strategi comput problem solv averag complex depthfirst search backtrack cutoff dibmyampersandmdasha distribut implement backtrack principl artifici intellig perform orparallel logic program system parallel depth first search part implement parallel depth first search part ii analysi search artifici intellig almost perfect heurist italicnital nonattack queen problem scalabl parallel formul depthfirst search anomali parallel branchandbound algorithm fundament comput alori automat test pattern gener multiprocessor superlinear speedup parallel statespac search ctr jung krishnamoorthi georg nagi andrew shapira ntupl featur ocr revisit ieee transact pattern analysi machin intellig v18 n7 p734745 juli 1996 finkelstein shaul markovitch ehud rivlin optim schedul parallel anytim algorithm case independ process eighteenth nation confer artifici intellig p719724 juli 28august 01 2002 edmonton alberta canada fumiaki okushi parallel cooper proposit theorem prove annal mathemat artifici intellig v26 n14 p5985 1999 jame cheetham frank dehn andrew rauchaplin ulrik stege peter j taillon solv larg fpt problem coarsegrain parallel machin journal comput system scienc v67 n4 p691706 decemb ariel felner sarit krau richard e korf kbf kbestfirst search annal mathemat artifici intellig v39 n12 p1939 septemb daniel j challou maria gini vipin kumar georg karypi predict perform random parallel applic robot motion plan journal intellig robot system v38 n1 p3153 septemb g karypi v kumar unstructur tree search simd parallel comput summari result proceed 1992 acmiee confer supercomput p453462 novemb 1620 1992 minneapoli minnesota unit state weim lin wei xie bo yang perform analysi parallel solut gener search problem proceed 1997 acm symposium appli comput p422430 april 1997 san jose california unit state andrea di bla arun jagota richard hughey optim neural network simd parallel comput parallel comput v31 n1 p97115 januari 2005 g karypi v kumar unstructur tree search simd parallel comput ieee transact parallel distribut system v5 n10 p10571072 octob 1994 ananth grama vipin kumar state art parallel search techniqu discret optim problem ieee transact knowledg data engin v11 n1 p2835 januari 1999 peter krauss andrea ganz kurt j antreich distribut test pattern gener stuckat fault sequenti circuit journal electron test theori applic v11 n3 p227245 dec 1997 luca bordeaux youssef hamadi lintao zhang proposit satisfi constraint program compar survey acm comput survey csur v38 n4 p12e 2006