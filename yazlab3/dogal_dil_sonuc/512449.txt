accur garbag collect uncoop environ previou attempt garbag collect uncoop environ gener use conserv mostlyconserv approach describ techniqu fulli typeaccur garbag collect uncoop environ use shadow stack link struct pointercontain variabl togeth data code need trace implement mercuri compil gener c code present preliminari perform data overhead techniqu also show techniqu extend handl multithread applic b introduct new program languag implement usual need support varieti dierent hardwar architectur programm demand portabl programm also demand ecienc new program languag implement often need eventu gener nativ code whether compil time tradit compil run time jit compil howev implement compil backend jit gener ecient nativ code varieti dierent hardwar architectur dicult timeconsum task furthermor consider amount ongo mainten requir gener ecient code new chip dierent perform characterist new architectur program languag implementor tri implement nativecod gener instead mani program languag implementor reus one exist backend framework one sever way gener anoth moreorless highlevel languag java c gener intermedi languag c 16 java bytecod msil intermedi languag net common languag runtim interfac directli reusabl backend gcc gnu compil collect backend mlrisc permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee ismm02 june 2021 2002 berlin germani unfortun howev system especi matur popular direct support garbag collect one java msil draw back poor perform avail restrict set platform implement garbag collect system direct support pose dicult challeng particular hard garbag collector trace system stack one widelyus solut problem garbag collect uncoop environ approach use conserv 4 mostlyconserv 1 22 collec tion approach often deliv good perform howev conserv collect drawback signific probabilist natur conserv collect make unsuit highreli applic also requir small degre cooper backend certain compil optim safe presenc conserv collect anoth solut use compil c 20 entir avoid store data c stack done implement virtual machin stack regist implement eg c global variabl sourc languag compil code manipul virtual machin state procedur call paramet pass handl explicitli manipul virtual machin stack regist rather use c function call approach collector need trace virtual machin stack c stack sinc sourc languag compil full control virtual machin stack trace stack rel straightforward tradit techniqu accur garbag collect use approach also advantag overcom drawback c eg lack support proper tail recurs optim 5 howev approach discard mani advantag compil highlevel languag 13 sourc languag compil must stack slot regist alloc gener c code lowlevel make code ecient nonport featur must use 14 result system complex fragil furthermor use dierent call convent make interoper dicult propos altern approach allow fulli type accur livenessaccur garbag collect thu allow use normal copi collector without requir support backend target languag still gener code use normal c function call mechan describ approach context compil c although would also work equal well interfac directli compil backend framework gcc backend techniqu formul transform gener c code modifi c code way insert call perform garbag collect nec essari provid garbag collector sucient inform trace necessari updat pointer c stack transform entir independ frontend languag howev requir inform sourc languag frontend compil trace local variabl implement techniqu mercuri com piler run number benchmark implement investig overhead perform techniqu section 2 describ techniqu show code transform explain avoid dicul tie compil optim caus problem conserv collect section 3 describ techniqu extend support multithread applica tion section 4 evalu perform techniqu section 5 discuss relat work 2 gc transform basic idea put local variabl might contain pointer struct one struct stack frame chain struct togeth link list keep global variabl point start chain gc time travers chain struct allow us accur scan c stack function gener struct function struct start substruct contain coupl fix field allow gc travers chain struct function namefram struct stackchain fixedfield fix field follow struct stackchain struct stackchain prev void tracevoid local prev field hold link entri function caller trace field address function trace everyth point stack frame ensur garbag collector tri travers uniniti field insert code zeroiniti uniniti field struct insert chain need keep link topmost frame stack two possibl way could handl one way pass paramet function would get extra paramet stack chain point caller struct altern approach global variabl stack chain point top stack extern void stackchain insert extra code set pointer enter return function make approach thread safe variabl would actual need threadloc rather global approach would probabl work best variabl gnu c global regist variabl would make ecient threadsaf gnu c extens avail function paramet approach probabl best implement mercuri compil current use global variabl simplic 21 exampl function rettyp fooarg1typ arg1 arg2typ arg2 local1typ local1 bararg1 arg2 local1 local2 new object alloc primit alloc garbag collect object say arg1typ local1typ might contain pointer arg2typ dont would transform follow struct foofram stackchain fixedfield arg1typ arg1 static void footracevoid frame struct foofram code trace localsarg1 localslocal1 rettyp fooarg1typ arg1 arg2typ arg2 struct foofram local localsfixedfieldstrac barlocalsarg1 arg2 localslocal1 local2 stackchainprev follow goldberg approach tagfre garbag collect strongli type languag 11 trace arg1typ trace local1typ typespecif garbag collect routin gener frontend compil howev unlik goldberg primarili interest adapt approach uncoop environ techniqu would appli equal well use tag represent case singl trace object function would need instead one type use tabledriven approach 7 rather function per frame case trace field stackchain struct would data tabl rather function pointer final code runtim system travers stack frame follow void traversestackstruct stackchain stackchain stackchain null detail new object depend particular garbag collect algorithm chosen implement new object first check heap exhaust alloc memori increment global heap pointer extern byte heappoint defin newobjecttypes heappoint size type heappoint gc check compar global heap pointer anoth global variabl point end heap call garbag collect heap near exhaust extern byte heapgcthreshold defin gcchecksiz heapgcthreshold well known possibl reduc overhead check heap exhaust combin multipl check singl check howev current implement perform optim garbag collect routin current implement implement simpl copi collector 21 byte fromheap byte toheap void garbagecollectvoid swap heap heap byte tmp reset heap copi live object heap heap note keep separ list global root use global variabl might contain pointer addit stack chain list 22 safeti might ask doesnt techniqu suer problem backend compil optim caus troubl conserv collect reason techniqu work go behind backend compil back everyth done strictli conform c code conserv collector use nonport techniqu trace stack approach collector trace stack travers link list struct although code contain pointer cast behaviour cast defin c standard backend compil unsaf optim pointer variabl localsarg1 localslocal1 weve store address local global variabl must assum call function whose bodi known might updat field local cours inhibit optim way twoedg sword advantag ensur correct ness disadvantag hurt perform backend compil free perform function inlin outlin matter shadow stack link struct need direct relationship stack frame underli machin code backend compil whatev fanci optim want nonpoint variabl arg2 local2 cach valu pointer variabl localsarg1 localslocal1 regist function call appropri alia analysi gener cach valu pointer variabl regist across call noninlin function signific impact perform key contribut work measur impact perform transform 23 improv scheme describ naiv certain respect sever way scheme opti mize rather put variabl might contain pointer shadowstack struct sucient variabl go live across point garbag collect could occur ie live across alloc function call anoth optim bother alloc struct leaf function contain function call memori alloc anoth possibl optim would use local variabl cach field shadowstack struct referenc multipl time sequenc code garbag collect could occur c compil could alloc local variabl regist one optim implement current implement alloc struct function pointercontain variabl 24 nest scope livenessaccuraci issu yet discuss handl variabl declar nest scope within function one way handl ignor nest put pointercontain variabl struct regardless scope requir first ensur function contain two declar variabl name dierent type dierent scope eg renam apart need approach one use current implement two drawback first extend lifetim variabl whole function may increas stack usag second sinc collector scan may turn also lead unnecessari heap retent second drawback could solv insert code zero variabl scope exit otherwis static known dead would ensur collector livenessaccur respect live local variabl c code appli transform note variabl repres local variabl final c code would case use conserv collector might help add code assign zero end lifetim sinc c compil could optim away assign approach variabl repres field local struct whose address taken store global variabl safe unwant optim anoth way handl nest scope would use union ensur storag pointercontain variabl declar nonoverlap scope share howev order collector abl trace union would need store discrimin union record scope activ trace function would know union element trace code would need insert initi discrimin function entri set correspond discrimin entryexit nest scope third way handl nest scope would treat nest scope separ stack frame pointer contain variabl alloc separ struct nest scope would requir ad code entri nest scope link correspond struct stack chain list ad code exit point remov chain second third altern collector would degre livenessaccur sens variabl would definit scan scope exit howev proper static livenessaccuraci desir pointercontain variabl static known die scope exit addit code would need insert zero variabl point death last use variabl function call argument impli copi variabl stack frame struct local tempo rari zero stack frame struct field use local temporari call zero stack frame struct field call would late 3 multithread system also extend support multithread use stop world approach collect fairli straightforward manner littl addit overhead stop world approach mean garbag collect occur everi mutat thread must advanc safe point stop execut program mutat thread stop safe point garbag collect begin collector either sequenti parallel singl multithread import thing approach collector never run parallel mutat case safe point call garbag collect avoid need synchron alloc separ area free heap space thread stack chain heap pointer heap gc threshold variabl need made threadloc one thread run free heap space schedul garbag collect set heap gc threshold variabl everi thread point sentinel valu start heap caus thread enter garbag collect function next invok gc check garbag collect function handl necessari synchron thread ensur thread invok gc check within bound amount time compil need insert addit call gc check bodi longrun loop heap alloc oper system call block also need special handl space limit prevent us elabor point mention earlier stack chain heap pointer gcc global regist variabl remain case even multithread howev heap gc threshold put regist need address assign thread addit modifi thread need declar volatil summar chang requir support multithread extra synchron code insid garbag collect volatil qualifi heap gc threshold variabl extra call gc check loop dont heap alloc special han program line number execut time ratio second hlcgc hlcagc hlcagc code iter hlc hlcgc hlcagc hlc hlc hlcgc cqueen 91 35000 070 129 128 184 183 099 crypt 132 20000 272 506 500 186 184 099 deriv 126 70000 015 075 079 500 527 105 poli 259 1200 057 289 337 507 591 117 prime 78 30000 112 203 258 181 230 127 qsort 64 100000 083 268 311 323 375 116 queen 85 100 231 478 455 207 197 095 queri 96 30000 392 395 409 101 104 104 tak harmon mean 199 208 106 figur 1 benchmark result dling os call may block extra synchron code garbag collect may somewhat costli collect frequent amort cost small loop dont heap alloc also like rare case cost extra gc check per loop iter rel small loop small cost check amort multipl loop iter perform loop unrol prior insert extra gc check final cost special handl need block os call like small comparison cost system call henc expect overal techniqu littl addit overhead compar singlethread version sinc c standard support multithread ing possibl strictli conform c addit function creat synchron thread provid posix thread approach describ also requir assign volatil threadloc pointer variabl heap gc threshold atom technic guarante c posix standard current platform make assign appropri align pointer atom pretti portabl practic 4 perform benchmark machin gateway select 1200 pc 1200mhz amd athlon cpu 64kb l1 instruct cach 64kb l1 data cach 256k l2 cach 256mb ram run debian gnulinux woodi test gnu libc 21 gcc 2954 mercuri rotd 20020419 benchmark compil mmc o5 noreclaimheaponfailur nodeforest time shown best three success run unload machin use set small benchmark previous use benchmark mercuri implement 18 sinc time mani benchmark small ran benchmark mani iter measur total time execut iter ideal would better test larger benchmark current implement yet support full mercuri languag higherord code type class support trace closur yet im plement make dicult find larg benchmark program work implement compar three variant grade mercuri compil hlc grade alloc memori increment heap pointer describ paper code test heap overflow instead perform garbag collect memori reclaim reset heap pointer iter benchmark realist memori manag strategi real applic repres use baselin hlcgc grade use boehm et al conserv collector 4 hlcagc use accur garbag collect techniqu describ paper collector simpl twospac copi collector heap size use 128k per space ie 256k total result shown figur 1 benchmark conserv collector littl faster accur collector accur collector slightli faster averag benchmark conserv collector 6 faster conserv collector accur collector much slower version reset heap pointer benchmark iter profil indic hlcagc grade littl time less 1 spent garbag collect function slowdown compar hlc grade probabl result decreas local overhead store local pointer variabl stack rather regist given boehm collector year tweak tune wherea implement yet well optim eg yet use gcc global regist variabl consid reason result conjectur addit work optim approach achiev perform good boehm collector benchmark increas portabl reliabl approach make desir use regardless whether perform advantag one way current implement yet obtain main benefit logic program languag copi collector name copi collector allow cheap heap reclam backtrack save restor heap pointer requir addit care garbag collector updat save heap pointer garbag collect yet implement properli 5 relat work accept wisdom commun conserv collect approach work uncoop environ exampl highli experienc respect languag implementor robert dewar wrote cant kind type accur gc without inform compil back end note tag architectur cdc 6000 excep 6 similarli garbag collect faq 10 david chase state compil c c reloc object gener possibl even activ pointer regist compilergener temporari may also refer object howev certainli problem techniqu explain section 22 section faq best mislead big part contribut paper disput accept wisdom demonstr possibl implement fulli typeaccur garbag collect within environ lot earlier work literatur address issu quit close issu address use dierent techniqu use similar techniqu dierent purpos boehm 4 bartlett 1 yip 22 address issu uncoop environ use conserv mostlyconserv collect rather accur collec tion boehm chase 2 3 address issu safeti conserv garbag collect presenc compil optim shadow stack use debug berkeley sather 19 implement cdb 12 system use shadow stack garbag collect berkeley sather use boehm et al conserv collector shadow stack use handcod garbag collect sever system awar particular emac gcc rt 8 9 17 system unlik code regist local variabl insert manual shadow stack list array individu variabl rather list frame system perhap closest interest autom techniqu part program languag implementa tion rather use implement garbag collect librari languag manual memori manag far know publish work compar perform handcod shadow stack approach conserv collect far awar none publish work address multithread tarditi et al 20 describ ml c compil support accur garbag collect howev compil work emul virtual machin rather use normal c call convent drawback mention introduct glasgow haskel compil 15 accur garbag collect compil via gnu c reli highli nonport techniqu involv mung gener assembl file gnu c backend finish success techniqu reli continu cooper backend compil c 16 portabl assembl languag support garbag collect anoth approach reli cooper backend compil varieti dierent garbag collect techniqu marksweep collect copi collect address issu locat root stack 6 conclus present scheme perform accur garbag collect uncoop environ simpl transform code pass uncoop compil backend framework implement scheme mercuri compil measur per formanc similar boehm al conserv collector 4 benchmark even though sever import optim yet implement also describ scheme extend handl multithread applic sourc code system freeli avail web httpwwwcsmuozaumercurydownload rotdhtml acknowledg would like thank tom lord comment gcc mail list advantag precis collect zoltan somogyi andrea rossberg tyson dowd ralph becket jon delloro anonym refere comment earlier draft paper microsoft australian research council financi support 7 r simpl garbagecollectorsafeti propos garbagecollectorsaf c compil garbag collect uncoop environ proper tail recurs space e mail gcc mail list david je copi collector c dynam storag reclam c machineindepend debugg compil mercuri highlevel c code compil logic program c use gnu c portabl assembl peyton jone execut algorithm mercuri sather revisit highperform free altern c assembl requir compil standard ml c uniprocessor garbag collect techniqu tr garbag collect uncoop environ tagfre garbag collect strongli type program languag simpl garbagecollectorsafeti machineindepend debugg proper tail recurs space effici uniprocessor garbag collect techniqu run time type inform mercuri c compil mercuri highlevel c code dynam storag reclam c ms thesi ctr martin hirzel amer diwan johann henkel use type live accuraci garbag collect leak detect acm transact program languag system topla v24 n6 p593624 novemb 2002 andrea bauer creat portabl program languag use open sourc softwar proceed usenix annual technic confer 2004 usenix annual technic confer p4040 june 27juli 02 2004 boston