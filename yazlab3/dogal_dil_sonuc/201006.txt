effect cach prefetch busbas multiprocessor compilerdirect cach prefetch potenti hide much high memori latenc seen current futur highperform processor howev prefetch without cost particularli sharedmemori multiprocessor prefetch neg affect bu util overal cach miss rate memori latenc data share simul effect compilerdirect prefetch algorithm run rang busbas multiprocessor show despit high memori latenc architectur necessarili support prefetch well case actual caus perform degrad pinpoint sever problem prefetch sharedmemori architectur addit conflict miss reduct datashar traffic associ latenc multiprocessor greater sensit memori util sensit cach hit rate prefetch distanc measur effect perform solv problem architectur techniqu heurist prefetch could easili incorpor compil 1 victim cach elimin cach conflict miss caus prefetch directmap cach 2 special prefetch algorithm share data significantli improv abil basic prefetch algorithm prefetch individu miss 3 compilerbas shareddata restructur elimin mani invalid miss basic prefetch algorithm predict combin effect improv make prefetch effect much wider rang memori architectur b introduct sever factor contribut increas need processor toler high memori latenc particularli multiprocessor system certainli widen gap speed cpu memori increas memori latenc uniprocessor multiprocessor alike13 fast processor also increas content multiproc sor lengthen actual latenc seen cpu cpu queu interconnect second parallel workload exhibit interconnect oper caus data share among processor result research support onr grant n0001492j1395 nsf pyi award mip9058439 author address depart comput scienc engin fr35 univers washington seattl wa 98195 delay greater memori subsystem content final processor memori becom physic distribut memori latenc necessarili increas softwarecontrol cach prefetch techniqu design make processor speed toler memori latenc softwarecontrol cach prefetch cpu execut special prefetch instruct data load point near futur best case data arriv cach need cpu cpu see load hit lockupfre caches17 21 25 27 allow cpu continu execut prefetch hide prefetch latenc cpu paper address issu prefetch busbas share memori multiprocessor goal work gaug impact perform architectur pinpoint factor respons experi simul parallel workload busbas multiprocessor coupl prefetch algorithm repres ideal current compilerdirect prefetch technolog oracl predict cach miss apart miss caus data share use identifi architectur workload prefetch improv perform perform degrad result give us insight particular problem multiprocessor pose prefetch allow us introduc chang memori subsystem prefetch algorithm share data alloc solv although studi close model busbas system extend multiprocessor architectur memori content issu show prefetch busbas multiprocessor unlik uniprocessor need done care univers win issu increas pressur cach parallel machin greater sensit memori subsystem util interact prefetch data share effect caus perform improv prefetch less expect even nonexist basic prefetch scheme observ speedup higher 29 degrad high 6 address issu variou architectur compilerbas techniqu victim cach compilerbas share data restructur two special prefetch algorithm share data end result prefetch shown effect much wider rang memori architectur effect region alreadi viabl combin techniqu achiev speedup prefetch simul memori speed rang 6 83 remaind paper organ follow section 2 describ relat work compilerdirect prefetch multiprocessor prefetch section 3 describ methodolog justifi choic simul environ section 4 present result basic prefetch strategi use conjunct highli effici cach miss predictor highlight drawback prefetch strategi follow three section explor detail issu prevent better multiprocessor prefetch perform present architectur compil techniqu make prefetch effect section 5 examin problem prefetch dont complet time section 6 cach conflict miss caus prefetch section 7 data share issu princip difficulti predict invalid miss section 8 show effect combin techniqu conclus appear section 9 relat work work build previou studi 29 pinpoint problem prefetch share memori machin addit conflict miss data share traffic multiprocessor greater sensit memori util determin best prefetch distanc measur effect perform paper show despit high memori latenc mani busbas multiprocessor support prefetch well case prefetch actual caus perform degrad paper extend work sever way first examin conflict miss detail use new memori architectur altern victim cach virtual elimin caus prefetch section 6 second present new prefetch strategi make effect use exclus prefetch section 73 third make use sophist share data restructur techniqu section 72 make prefetch viabl fourth improv methodolog previou studi sever respect exampl trace differ region pverifi applic captur parallel also model hardwar barrier accur increas accuraci shortterm share activ topopt applic make frequent use barrier although need make processor toler high memori latenc much sever multiprocessor uniprocessor studi cach prefetch concentr uniprocessor architectures1 6 5 23 3 dash18 hardwar support cach prefetch date publish result microbenchmark throughput test noteworthi except work mowri gupta22 simul driven three parallel program provid analysi potenti speedup programm direct cach prefetch howev multiprocessor architectur examin sixteen dash cluster connect highthroughput interconnect network one processor per cluster avoid type content interfer wish studi result includ full effect content share bu found effect crucial prefetch perform architectur examin addit provid detail analysi multiprocessor cach miss identifi key compon affect perform scheme deal programmerdirect prefetch emul compilerdirect simul sharedmemori refer simul share privat interfer two cach key element studi mowri et al23 detail compilerbas prefetch algorithm uniprocessor model simul prefetch algorithm emul use sever techniqu select prefetch target memori access like miss cach 3 simul environ prefetch studi use tracedriven simul trace gener coarsegrain explicitli parallel workload prefetch instruct insert trace simul sever type busbas multiprocessor differ extent content affect memori latenc ie vari bu speed also examin cach architectur without section 6 victim cach sever prefetch strategi use differ often prefetch done section detail simul environ 31 prefetch algorithm softwaredirect prefetch scheme either cach prefetch bring data data cach closest processor prefetch data separ prefetch buffer prefetch studi concern cachebas prefetch baselin prefetch algorithm contain optim prefetch nonshar ie uniprocessor data miss depend cach configur accur predict nonshar cach hit miss never prefetch data use emul algorithm ad prefetch instruct address trace gener share memori multiprocessor candid prefetch identifi run processor address stream uniprocessor cach filter mark data miss prefetch instruct place instruct stream distanc ahead access miss number cpu instruct prefetch actual access refer prefetch distanc sinc offlin algorithm techniqu repres ideal current prefetch algorithm ie one prefetch scalar array refer accur identifi lead refer first access cach line capac conflict miss mowri et al23 shown compil algorithm approxim well alreadi predict compulsori capac miss array refer exist algorithm improv get closer ideal use prefetch ideal respect nonshar miss enabl us pinpoint exact caus remain miss observ cpu prefetch explain section 4 baselin algorithm strive emul compilerbas algorithm mowri et al23 best exampl rather programmerdirect approach mowri gupta22 feel prefetch predominantli domain compil rather programm mowri gupta show prefetch insert programm intim familiar applic effect methodolog necessarili indic compilerdirect prefetch would mowri et al23 despit target uniprocessor repres best avail compilerdirect prefetch algorithm architectur unreason expect would perform well larg number multiprocessor architectur without enhanc overhead associ prefetch simul rel low singl instruct prefetch access continu assum exist effect effici prefetch algorithm mowri et al report overhead uniprocessor compil algorithm typic less 15 increas instruct count impact total execut time typic half mowri gupta programmerdirect scheme experienc overhead 1 8 total execut time chen baers4 implement mowri et al compil algorithm multiprocessor includ two bench mark mp3d water experienc prefetch instruct overhead 24 total execut time simul overhead never 4 instruct count 2 total execut time multiprocessor writeinvalid cach coher protocol data prefetch either share mode case subsequ write might requir extra invalid bu oper exclus mode would caus cach copi cach line invalid latter refer exclus prefetch simul support type prefetch mowri gupta specifi otherwis howev prefetch share mode 32 workload address trace gener mptrace12 sequent symmetry19 run follow coars grain explicitli parallel applic written c see tabl 1 topopt7 perform topolog optim vlsi circuit use parallel simul anneal algorithm pverify20 determin whether two boolean circuit function ident statist amount share data program found 10 locusrout commerci qualiti vlsi standard cell router mp3d solv problem involv particl flow extrem low densiti water evalu forc potenti system water molecul liquid state latter three part stanford splash benchmarks26 contrast two applic optim programm processor local share number dynam data data percent percent program data set data process set size refer read privat pverifi c88021berk12 130 kb 12 128 kb 54 million 82 59 topopt aplalomim 20 kb 9 20 kb 58 million 85 69 locusrout primary1 16 mb 12 709 kb 72 million 75 87 mp3d 10000 molecul 19 mb 12 459 kb 82 million 69 75 water 343 molecul 227 kb 12 237 kb 67 million 76 94 tabl 1 workload use experi restrict practic limit trace length multiprocessor tracedriven simul balanc must struck desir larg data set dont fit cach trace reason portion program larg data structur one could easili end trace singl loop may may indic rest program attempt solv scale back data set local cach size singl order magnitud rel might consid reason configur current moder parallel multiprocessor thu maintain realist ratio data set offchip cach size ensur case neither critic data structur dynam cach work set fit simul cach except topopt still interest high degre write share larg number conflict miss even small share data set size applic begin collect trace right parallel execut begin initi simul without collect statist 500000 data refer avoid coldstart effect simul least 5 million data refer applic tabl 1 share data column give total amount share data alloc applic dynam data set size column show total amount privat share data touch trace portion program number refer simul statist kept given refer colum last two column show percent data refer read percent privat data benchmark 33 multiprocessor simul prefetch access ad trace run charlie9 multiprocessor simul modifi handl prefetch lockupfre cach splittransact bu protocol victim cach besid model cpu cach bu hardwar low level charli carri lock barrier synchron therefor interleav access differ processor chang behavior memori subsystem charli ensur legal interleav maintain instanc processor vie lock may acquir order trace run still acquir legal order enter critic section one processor time model data cach assum instruct cach insignificantli low miss rate cach direct map writeback one per processor simul present kbyte simul includ privat share data order includ effect interfer two cach cach coher scheme illinoi coher protocol24 invalidationbas protocol import featur purpos privateclean state exclus prefetch simul 16deep buffer hold pend prefetch processor suffici larg almost alway prevent processor stall buffer full bu use roundrobin arbitr scheme favor block load prefetch consid system high memori latenc prefetch less use possibl harm littl latenc hide processor execut singl cycl per instruct 2cycl data load coupl memori subsystem latenc 100 cycl given latenc examin spectrum memori architectur high low memori bandwidth result rang bu util memoryinterconnect model splittransact bu protocol system enough parallel memori bankscontrol make address bu memori access rel conflict free data bu transfer bottleneck vari speed data bu vari maximum throughput memori subsystem way abl model spectrum valu ratio bu latenc bu bandwidth sinc factor mani phenomena describ sensit without vari minimum latenc thu prevent result domin larg chang memori latenc sinc effect prefetch obvious highli sensit paramet specif model splittransact bu result reflect memori architectur potenti satur also ran simul larger block size result present add great deal insight alreadi present essenti larger block size increas amount share traffic due fals share thu increas import techniqu use deal share otherwis impact effect prefetch aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa total miss rate aa aa cpu miss rate adj cpu miss rate miss rate prefetch strategi locusrout water topopt pverifi mp3d figur 1 total cpu miss rate five workload 8cycl data bu latenc simul paper data transfer portion memori latenc vari 4 32 cycl total 100 cycl split transact bu architectur describ data transfer latenc 4 cycl would make address transmiss memori lookup 96 cycl processor cycl speed 400 mhz would model memori subsystem memori latenc 250 nanosecond peak throughput 32 gbytessecond 32 cycl latenc correspond memori throughput 400 mbytessecond 4cycl latenc correspond transfer 64 bit across bu everi cpu cycl also section 6 add victim caches16 architectur hit victim cach take 4 cycl longer hit main cach much less memori access save least one bu oper 4 basic prefetch simul memori architectur basic prefetch algorithm prefetch serv baselin calcul speedup prefetch algorithm execut time experi given rel prefetch memori architectur cach configur basic prefetch algorithm prefetch instruct insert trace potenti cach miss identifi cach filter algorithm prefetch distanc 100 instruct mean bar cpu stall code prefetch associ load would execut 140 cycl given processor model give memori subsystem minimum latenc 100 cycl time complet prefetch content delay larg processor otherwis slow basic prefetch strategi identifi figur pref compar basic prefetch strategi prefetch identifi np result 32 kbyte cach 32byte cach line shown figur 1 2 tabl 2 3 effect prefetch miss rate figur 1 terminolog becom ambigu presenc prefetch use follow term miss total miss rate refer prefetch nonprefetch access hit cach cpu miss cpu miss rate miss nonprefetch access thu observ cpu prefetch miss occur prefetch access access prefetch still progress sinc cpu must stall count cpu miss refer prefetchinprogress miss often compris nonneglig portion cpu miss rate adjust cpu miss rate includ therefor adjust cpu miss rate includ access caus cpu stall entir memori latenc cpu miss rate adjust cpu miss rate plu prefetchinprogress miss rate total miss rate cpu miss rate plu prefetch miss rate miss rate cumul figur 1 total miss rate combin height three bar cpu miss rate combin height black diagon stripe bar without prefetch total miss rate cpu miss rate adjust cpu miss rate ident data figur 1 8cycl datatransf latenc compon miss rate vari significantli across memori throughput prefetchinprogress differ cpu miss rate adjust cpu miss rate rise data bu get slower sever observ made miss rate result first cpu miss rate fell significantli 32 71 3577 adjust result shown figur 1 use oracl prefetch one might naiv expect even miss cover three reason didnt happen first prefetchinprogress miss account signific part cpu miss rate applic second prefetch actual introduc addit cach conflict miss last importantli data share among processor produc invalid miss case largest singl compon cpu miss rate oracl prefetch doesnt predict miss result invalid total miss rate increas simul prefetch previou studi uniprocessor multiprocessor focus cpu miss rate uniprocessor like memori interconnect bandwidth absorb extra memori traffic increas total miss rate signific rel decreas cpu miss rate multiprocessor system total miss rate import metric indic demand bottleneck compon machin particularli true busbas multiprocessor also multiprocessor content memori interconnect signific bu becom satur system perform track throughput bu speed cpu benefici effect sinc bu demand function total miss rate rather cpu miss rate total miss rate better indic perform architectur bu memori bottleneck system prefetch reduc cpu miss rate expens total miss rate may hurt perform tabl 2 see miss rate affect databu util memori architectur vari bu util number cycl bu use divid total cycl simul bu util result mislead interpret correctli two reason bu util increas one workload produc bu oper second number bu oper occur shorter time period instanc bu util increas prefetch 4cycl pverifi simul total miss rate increas execut time reduc pref data transfer latenc program alg 4 cycl 8 cycl locu np 21 33 56 89 mp3d np 48 65 90 100 pverifi np 46 68 96 100 topopt np 13 20 33 51 water np 10 14 22 38 tabl 2 select bu util workload np pref locusrout 127 137 mp3d 424 438 pverifi 577 620 topopt 524 599 water 051 055 tabl 3 bu demand per access bdpa 8cycl data bu latenc result prefetch success overlap memori access instruct execut order see bu demand independ execut speed tabl 3 give bu demand per access bdpa total number bu cycl use divid total number memori access cach hit miss bdpa unlik bu util independ execut time thu give better indic addit demand place memori subsystem prefetch result tabl 2 3 indic applic bu demand increas prefetch expect given total miss rate figur 1 data tabl 3 8cycl data transfer latenc data bu speed shown practic purpos scale linearli bu speed figur 2 see effect prefetch execut time differ memori subsystem figur execut time prefetch bu speed normal execut time prefetch memori architectur examin tabl 2 figur 2 see whenev bu util greater 90 without prefetch use prefetch result increas execut time region enough spare bu bandwidth absorb extra demand prefetch place increas execut time bu satur dramat howev total miss rate rise small amount prefetch increasingli posit effect execut time bu load becom lighter bu get faster gener perform improv larg two reason first alreadi discuss prefetch caus increas memori latenc due increas content processor bu addit overhead prefetch cpu execut time although rel small experi 1 execut time pref scheme summari data bu latency085095105 data bu latency085095105 data bu latency085095105 data bu latency085095105 data bu latenc rel execut time rel execut time topopt water locusrout mp3d pverifi figur 2 rel execut time five workload prefetch pref normal prefetch execut time result indic benefit prefetch busbas multiprocessor margin except case high bandwidth memori subsystem even use highli effici cach miss predictor largest gain execut time observ 29 speedup largest degrad 6 order gain insight much improv actual possibl prefetch look processor util without prefetch instanc averag processor util water 82 fastest bu 81 slowest bu sinc best memorylat hide techniqu bring processor util 1 best speedup could achiev water 12 hand processor util mp3d rang 39 22 room speedup 25 fast bu 45 slow bu ignor overhead prefetch instruct mp3d best speedup fall far short maximum potenti workload averag processor util without prefetch locusrout rang 64 54 pverifi rang 36 17 topopt 13 11 topopt make use hardwar barrier much low processor util due synchron delay aaa aaaaaa aaa aaa aaaaaa aaa aaa aaaaaa aaa aaa aaaaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa top src data nonshar prefetch aa aa nonshar prefetch invalid prefetch aa aa invalid prefetch prefetch progress number prefetch strategi mp3d pverifi topopt figur 3 sourc cpu miss mp3d pverifi topopt 8cycl data bu latenc also note predict effect prefetch particular workload difficult workload achiev largest improv largest degrad depend upon memori subsystem architectur applic put heavi load memori system see larger memori latenc due content benefit hide latenc applic howev first enter bu satur begin degrad prefetch simul exemplifi mp3d pverifi high bu util one reason result prefetch disappoint anoth larg number cpu miss despit use oracl miss predictor order understand variou sourc magnitud remain cpu miss analyz differ type cpu miss figur 3 show breakdown cpu miss three applic topopt pverifi mp3d 8cycl data transfer latenc miss shown fall follow categori either invalid miss tag match state mark invalid nonshar miss first use data replac cach miss type either prefetch disappear cach use prefetch miss predict fifth type miss prefetchinprogress mean prefetch access present memori subsystem complet time cpu request data sum total five type miss combin height five bar cpu miss rate compon total miss rate pref prefetch miss shown prefetch miss miss effect hidden turn hit perspect cpu prefetch access goal prefetch turn mani miss np prefetch miss possibl hope without incur mani addit cach miss use oracl predict nonshar miss allow us categor nonshar miss precis imperfect prefetch would necessarili clear whether miss caus prefetch permut memori refer pattern imperfect prefetch result observ remain signific portion nonshar cpu miss cover prefetch sinc oracl prefetch perfectli predict nonshar miss absenc prefetch remain either caus prefetch access replac data still use nonshar prefetch figur prefetch cach line replac use nonshar prefetch figur impli degre conflict prefetch data current work set signific two compon cpu miss rate particularli import repres cach miss cover prefetch also result bu access werent necessari without prefetch nonshar prefetch miss requir extra bu access prefetch access wast nonshar prefetch miss without prefetch access cach hit therefor remain nonshar miss repres increas demand bu due prefetch prefetchinprogress miss repres much 27 cpu miss figur slowest data bu 32 cycl much 62 total contribut observ memori latenc less howev prefetchinprogress miss latenc typic much less entir memori access latenc see section 5 perhap conspicu result figur 3 prefetch algorithm affect invalid miss one concern motiv studi hypothesi increas interv cach seek hold cach line prefetch would exacerb data share problem result invalid oper invalid miss result dont bear pref prefetch strategi seen prefetch reduc number invalid cpu miss clearli limit effect prefetch doesnt address invalid miss may true prefetch exacerb data share problem expos perform applic effect data share much greater extent result present far suggest three primari opportun improv multiprocessor prefetch larg number prefetchinprogress miss conflict miss addit bu load introduc prefetch inabl hide reduc latenc due data share area investig follow section reduc prefetchinprogress miss pref prefetch distanc rel close bestcas memori latenc 100 cycl content caus real latenc much higher howev reason mowri et al23 suggest use larger prefetch distanc ensur prefetch data time arriv section examin effect increas prefetch distanc 400 instruct label prefetch strategi lpd lpd strategi want prefetch distanc high enough caus prefetchinprogress miss insignific impact execut time bu speed without necessarili remov aaa aaaaaa aaa aaa aaaaaa aaa aaa aaaaaa aaa aaa aaa aaaaaa aaa aaa aaaaaa aaa aaa aaaaaa aaa aaa pver src data aa aa aa aa aa aa aa aa aaa aaa aaa aaa aaa nonshar prefetch aaa aaa nonshar prefetch invalid prefetch aaa aaa aaa invalid prefetch prefetch progress number prefetch strategi mp3d pverifi topopt figur 4 sourc cpu miss mp3d pverifi topopt long prefetch distanc strategi lpd data bu latenc 8 cycl lower valu prefetch distanc quit achiev figur 4 present effect longer prefetch distanc individu compon miss rate figur 5 show effect execut time figur 4 sake consist given data bu latenc 8 cycl prefetchinprogress miss seriou problem 32cycl bu number prefetchinprogress miss increas applic least factor four shown increas prefetch distanc 100 400 success elimin major prefetchinprogress miss bu speed shown virtual elimin worst case 32cycl bu lpd strategi elimin averag 63 prefetchinprogress miss cost conflict miss earlier prefetch begun like replac data still use also longer prefetch data sit cach use like replac number pverifi topopt indic latter particularli critic trade prefetchinprogress miss conflict miss wise prefetchinprogress miss cheapest type miss processor wait access progress complet instead entir access time mp3d exampl prefetchinprogress miss repres 27 cpu miss 8cycl bu add 2 total execut time also incur prefetchinprogress miss increas load bu prefetchinduc conflict miss repres extra bu oper compar prefetch even mp3d lpd add least number conflict miss improv execut time lpd pref result indic increas prefetch distanc point virtual prefetch complet pay argu prefetch algorithm strive receiv prefetch data exactli time penalti cycl late small processor must stall cycl much less time full access penalti cycl earli also small chanc lose data use slight period mowri et al 23 also studi prefetch distanc note one program degrad data bu latency085095105 data bu latency085095105 data bu latency085095105 data bu latency085095105 data bu latenc locusrout mp3d water pverifi topopt rel execut time rel execut time lpd figur 5 rel execut time long prefetch distanc strategi increas prefetch distanc manual restructur four other avoid conflict caus phenomenon inabl long prefetch distanc improv prefetch perform close tie gener problem prefetchinduc conflict miss therefor reexamin lpd strategi next section look one cach architectur design reduc conflict miss 6 victim cach reduc conflict miss shown prefetch increas number replac miss cach due conflict current work set part futur work set prefetch result base directmap cach section investig modifi cach organ reduc magnitud conflict consequ whether improv effect prefetch order see effect altern cach organ magnitud prefetchinduc conflict simul configur addit small 8 entri fullyassoci victim cache16 aa aaaa aa aa aa aa aa aa aaaa aa aa aaaa aa aaa aaaaaa aaa np pref npvict prefvict lpdvict top src data aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa np pref npvict prefvict lpdvict nonshar prefetch aaa aaa aaa nonshar prefetch invalid prefetch aaa aaa aaa invalid prefetch prefetch progress number mp3d pverifi topopt prefetch strategi aaa aaaaaa aaa aaa aaa aaa aaa aaa aaaaaa aaa aa aaaa aa aa aaaa aa np pref npvict prefvict lpdvict figur sourc cpu miss mp3d pverifi topopt victim cach although cach higher level associ greater one also lessen impact prefetch induc conflict chose examin victim cach seem repres less costli approach term criticalpath cach access time size complex appear ideal suit problem prefetchinduc conflict chen2 show victim cach match perform 2way setassoci cach context hardwar prefetch test actual show 8line victim cach gener somewhat less effect 2way setassoci cach reduc number conflict miss suffici elimin particular problem prefetchinduc conflict section show victim cach small cach block recent replac main cach good match prefetchinduc conflict target conflict miss data recent replac cach incur prefetchinduc conflict miss number instruct time block replac cach access result conflict miss bound prefetch distanc victim cach may case requir hardwar ad 2way setassoci cach exampl case 8line victim cach requir 8 line data tag state order 8 x bit 32byte line size 32bit address 2way setassoci cach requir one extra tag bit per cach line lru bit per set 1536 bit configur howev cach configur 64 kbyte larger would requir increasingli storag 8line victim cach cachecoher multiprocessor victim cach slightli complex uniprocessor need hardwar support snoop victim cach tag victim cach distinct advantag add delay critic path cach lookup directmap cach true convent associ cach victim cach lookup occur main cach miss access victim cach take longer access main cach also tie cach longer swap main victim cach much less costli main data bu latency075085095105 data bu latency075085095105 data bu latency075085095105 data bu latency075085095105 data bu latenc lpdvict prefvict npvict locusrout mp3d water pverifi topopt rel execut time rel execut time figur 7 execut time rel prefetch victim cach five workload victim cach memori access requir bu oper figur 6 see victim cach inde signific impact number replac miss caus prefetch exampl pref strategi victim cach prefetchinduc conflict miss combin prefetch nonprefetch nonshar miss repres cpu miss rate topopt 8cycl result strategi victim cach account 1 cpu miss rate figur 7 show execut time result victim cach result normal np result without victim cach result make sever observ first although still see small perform degrad prefetch much smaller without victim cach fact worst case prefvict 1 npvict perhap small enough allow us ignor prefetch induc conflict problem architectur support appropri cach configur eg setassoci cach directmap victim cach level second observ nearli case combin effect speedup prefetch victim cach togeth greater sum individu contribut effect prefetch benefit victim cach without exampl topopt 4cycl bu pref provid 14 speedup np prefvict provid 22 speedup npvict two reason occur alreadi discuss victim cach elimin neg sideeffect prefetch addit conflict miss previous detract potenti speedup prefetch also victim cach lower overal miss rate decreas load bu mean configur less sensit bu content effect shown limit effect prefetch exampl region without victim cach satur bu pverifi 16 cycl case point thu saw benefit prefetch may victim cach longer bu satur would expect increas prefetch effect due victim cach would even greater real prefetch system without oracl determin potenti cach miss sinc conflict miss difficult compil identifi capac miss third observ increas prefetch distanc longer clearli harm one applic topopt lpdvict notic inferior prefvict victim cach catch addit conflict caus increas prefetch distanc one case locusrout increas prefetch distanc effect compar lpdvict prefvict effect high bu util short satur number delay associ prefetchinprogress miss greatest case lpdvict clearli better wors prefvict perform loss due prefetchinprogress miss never great perhap import aspect result allow compil place prefetch earlier perform prefetch less sensit exact placement prefetch cach strictli direct map allow compil much flexibl prefetch placement result 8line victim cach 4line cach found suffici elimin enough prefetchinduc conflict applic studi pref still visibl outperform lpd applic lastli observ although elimin drawback result occasion perform degrad prefetch victim cach prefetch still provid signific speedup bu satur bu 90 util npvict pverifi 1632 cycl mp3d 24 32 cycl although cach organ forgiv cach conflict mitig drawback prefetch memorybottleneck system prefetch still attack problem bottleneck componentthat total number interconnectmemori oper victim cach also fail help largest singl compon cpu miss rate invalid miss dealt follow section 7 reduc share data latenc current know avail compilerbas prefetch algorithm deal invalid miss show section simpl heurist simpler instanc data flow analysi across process recogn writeshar data blindli prefetch often prefetch write differ read recogn readmodifywrit pattern improv perform sever opportun reduc impact share traffic observ pref scheme certainli better job predict prefetch invalid miss achiev much better miss coverag clear figur 3 4 6 current miss predictor although extrem effici predict nonshar miss inadequ predict invalid miss prefetch algorithm emul tailor uniprocessor even better algorithm appear predict invalid miss remain much difficult problem predict nonshar miss due nondeterminist natur invalid traffic investig two mechan make prefetch effect presenc data share traffic section 71 examin better heurist prefetch invalid miss section 72 studi effect prefetch perform compil algorithm reduc invalid miss restructur share data addit prefetch increas share traffic way obviou data shown far success prefetch write miss share data increas bu traffic even caus cpu miss caus unnecessari invalid oper section 73 show exclus prefetch solv problem also gener problem unnecessari invalid oper 71 prefetch invalid miss saw section 4 figur 3 clear limit effect prefetch invalid miss share data none tradit uniprocessorbas prefetch strategi look far success reduc less predict invalid miss largest compon cpu miss workload fact effect prefetch nonshar miss invalid miss becom critic perform applic prefetch exampl seen figur 3 without prefetch invalid miss repres 29 cpu miss rate mp3d prefetch repres 70 cpu miss rate 96 adjust cpu miss rate word prefetch made applic much sensit data share problem improv coverag extern caus therefor less predict miss introduc redund prefetch cach line known writeshar redund uniprocessor sens ie issu data would resid cach invalid emul prefetch algorithm prefetch writeshar data exhibit poor tempor local premis longer share cach line resid cach without access like invalid ran writeshar data trace 16line associ cach filter get firstord approxim tempor local select miss prefetch prefetch addit prefetch identifi pref strategi label pw increas prefetch instruct overhead still less 4 improv coverag invalid miss compil algorithm could obtain effect use mowri et al 23 algorithm assum much smaller cach size deal data known write share aaa aaaaaa aaa aaa aaa aaa aaa aa aa aa aa aaa aaaaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa top src data nonshar prefetch aaa aaa aaa aaa aaa aaa aaa aaa aa aa aa aa aa aa aa nonshar prefetch invalid prefetch aa aa aa invalid prefetch prefetch progress mp3d pverifi topopt prefetch strategi number figur 8 sourc cpu miss enhanc writeshar data prefetch see figur 8 coverag invalid miss improv consider pw invalid portion cpu miss rate drop significantli 20 91 averag 56 drop result rang bu util data transfer latenc prefetch alreadi viabl improv execut time achiev workload seen figur 9 fastest bu 4 cycl result allow us see benefit improv prefetch writeshar data clearli isol memori content effect architectur speedup pw rel pref rang 0 water 15 pverifi pref 27 faster prefetch pw achiev 47 speedup prefetch cpu miss rate pw 11 64 lower pref one reason consist reduct cpu miss writeshar algorithm although pw increas number prefetch significantli increas number prefetchinduc cpu conflict miss 72 restructur share data nondeterminist behavior interprocessor share predict invalid miss multiprocessor difficult predict nonshar miss algorithm uniprocessor multiprocessor section investig extent reduc share traffic compilerbas share data restructur elimin reduc need multiprocessor specif prefetch algorithm share traffic consist true fals share amount true share inher algorithm use program fals share elimin improv processor local share data fals share occur cach line share two processor cach access differ data one processor modifi data locat caus invalid other cach cach coher maintain cach block basi record fals share miss invalid miss caus write anoth processor word local cach line local processor access 2 tabl 4 duboi et al definit fals sharing8 calcul fals share lifetim cach line accur data bu latency075085095105 data bu latency075085095105 data bu latency075085095105 data bu latency075085095105 data bu latenc et data locu pw locusrout mp3d water pverifi topopt rel execut time rel execut time figur 9 execut time rel prefetch five workload enhanc writeshar data prefetch show benchmark half invalid miss could attribut fals share even splash benchmark handtun processor local although total amount fals share benchmark rather low show result 32byte cach line previou work28 11 demonstr fals share goe significantli larger block size 14 15 algorithm present restructur share data reduc fals share techniqu promis improv overal perform purpos studi interest whether make prefetch viabl tabl 5 figur 10 show result prefetch strategi restructur topopt pverifi program improv less significantli alreadi optim processor local programmerbas restructur restructur program certainli run faster origin program evidenc 6 definit use howev measur small differ definit rate less concern exactli much fals share exist measur mani share miss elimin total total invalid total fals workload miss rate miss rate share miss rate pverifi 452 118 111 topopt 416 190 139 locu 088 014 008 mp3d 200 058 019 water tabl 4 total invalid fals share miss rate prefetch prefetch cpu total total total workload disciplin mr mr inval mr fs mr pverifi np 426 426 012 009 pref 191 454 018 009 pw 191 459 018 010 topopt np 137 137 015 005 tabl 5 miss rate restructur program data transfer latenc 8 cycl decreas total miss rate pverifi 67 decreas topopt reduct total miss rate achiev part signific reduct fals share miss rate pverifi reduct offset somewhat increas nonshar miss rate topopt increas data local achiev side effect data restructur caus nonshar miss rate also decreas use tracedriven simul difficult accur compar execut time differ trace sinc alway clear exactli fraction total execut time captur mean calcul raw perform improv restructur howev measur increment perform prefetch program restructur exactli make restructur interest research sinc invalid miss shown limit factor perform prefetch strategi particularli pref figur 10 show perform pref pw strategi appli two restructur program figur result normal execut time restructur program without prefetch despit fact restructur program less sensit memori latenc due lower total miss rate experienc gener greater improv prefetch origin program seen compar figur 9 figur 10 exampl pverifi 4 cycl experi speedup pref strategi 27 without restructur pref rel np 69 prefrestr rel nprestr pw strategi 47 without 70 restructur valid assert invalid miss limit effect prefetch algorithm although prefrestr pwsrestr show improv nprestr pref pw show np program improv much signific prefrestr consequ distinct pref pw almost nonexist restructur program surpris data bu latency070090110 data bu latenc rel execut time pverifi topopt pwsrestr prefrestr rel execut time figur 10 execut time rel prefetch restructur program pverifi topopt appli two prefetch strategi restructur program pw algorithm restructur attempt attack problem conclud restructur effect significantli reduc invalid miss rate simpler uniprocessorbas prefetch algorithm use place one tune multiprocessor data share 73 exclus prefetch prefetch strategi simul thu far prefetch look bu like read illinoi coher protocol line read cach exclus mode cach current hold line otherwis cach share mode read case prefetch write miss would fetch share data share mode write like hit would requir invalid oper bu turn one bu oper read intent modifi load data invalid one oper two avoid exclus prefetch prefetch data cach exclus mode invalid copi cach migratori share one processor time typic access cach line exclus prefetch save bu oper howev interprocessor content cach line exclus prefetch writeshar data caus mani invalid miss problem unnecessari invalid oper limit sharedmod prefetch gener problem parallel applic wrex prefetch strategi target extra invalid caus sharedmod prefetch rdex strategi also target gener problem wrex prefetch strategi expect miss write algorithm issu exclus prefetch line prefetch miss line brought cach exclus mode invalid copi cach prefetch hit cach bu oper initi even cach line share state illinoi protocol read cach line arent current anoth cach enter exclus state immedi differ pref wrex miss occur line share among cach figur 11 see wrex prefetch strategi ineffect reduc execut time pref data bu latency0600801000 8 data bu latency0600801000 8 data bu latency0600801000 8 data bu latency0600801000 8 data bu latenc rdexpw locusrout mp3d water pverifi topopt rel execut time rel execut time figur 11 execut time rel prefetch five workload exclus prefetch four five applic topopt execut time drop 2 primari reason write miss mani write preced short distanc read locat word specif problem unnecessari invalid oper caus prefetch write access evid one applic aggress use exclus prefetch attack gener problem unnecessari invalid unnecessari invalid oper occur readmodifywrit pattern result read miss follow write hit cach line current share anoth cach result two bu oper share read follow invalid preced exclus prefetch write hit requir second bu oper long interven access anoth processor cach line prefetch write compil recogn readmodifywrit pattern short span instruct issu exclus prefetch lead read miss mowri gupta22 take advantag programmerdirect prefetch studi therefor rdex prefetch strategi modifi wrex algorithm also exclus prefetch read miss follow write word within 100 instruct chose recogn read aa aa aa aa aa aaaa aa aa aaaa aa aa aaaa aa aa aaaa aa aaa aaa aaa aaa aaaaaa aaa aaa aaa aaaaaa aaa aaa aaa aaaaaa aaa aaa aaa aaaaaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa aaa nonshar prefetch aaa aaa nonshar prefetch invalid prefetch aaa aaa invalid prefetch prefetch progress mp3d pverifi topopt number prefetch strategi figur 12 sourc cpu miss exclus prefetch modifywrit pattern word rather cach line felt access pattern complex would difficult compil recogn pattern cach line basi access pattern simpl eg uniform access array element result analysi word cach line would ident figur 12 see rdex like wrex reduc miss rate surpris sinc goal elimin invalid oper arent shown miss rate graph effect reduc invalid traffic seen fact execut time decreas without reduct miss rate rdex strategi significantli increas invalid miss rate either signific cost issu invalid earli term addit invalid miss guarante alway true howev exclus prefetch need done caution particular avoid interprocessor content cach line expect high workload np pref wrex rdex rdex pw locusrout mp3d 424 438 438 376 333 pverifi 577 620 620 605 563 topopt 524 599 594 594 598 water 051 055 054 048 047 tabl bu demand per access 8cycl data bu latenc first applic prefetch paper actual decreas number bu oper rel prefetch see tabl 6 figur 11 bu demand improv aggress exclus prefetch strategi consequ improv execut time bu speed signific result show prefetch win even memorysatur multiprocessor data bu latency0600801000 8 data bu latency0600801000 8 data bu latenc locusrout mp3d water pverifi topopt rel execut time rel execut data bu latency0600801000 8 data bu latenc rdexpwsvict normal np rdexpwsvict normal npvict pref normal np figur 13 execut time appli rdex pw prefetch strategi system victim cach also see figur 11 rdex strategi use conjunct pw made write share algorithm significantli effect two work well togeth two reason first exclus prefetch lower bu demand thu make pw use bu satur effect wider rang bu speed second pw allow rdex attack compon miss respons vast major unnecessari invalid operationsinvalid miss instanc see rdex pw provid speedup high 28 rdex alon 34 pw alon combin provid speedup high 45 pref fact five applic rdex pw notic outperform strategi even slowest memori subsystem 8 put togeth demonstr sever architectur compilerori techniqu increas effect prefetch section want see far weve come word use techniqu togeth effect prefetch rang memori architectur applic studi figur 13 appli sever techniqu particular appli combin pw rdex prefetch strategi architectur victim cach figur pref result normal np first rdex pwsvict result normal npvict allow us see overal increas effect enhanc prefetch strategi independ benefit victim cach combinationrdex pwsvict achiev speedup due prefetch much signific origin basic prefetch pref high 83 addit perform degrad minimum speedup 6 result indic right cach architectur care applic prefetch compil perform improv extens cover wide rang memori bandwidth case signific third line figur 13 show absolut perform gain achiev combin use victim cach composit prefetch algorithm appli architectur prefetch techniqu achiev speedup 9 95 base architectur oppos maximum speedup 29 slowdown much 6 base uniprocessorstyl prefetch see none individu solut provid dramat improv taken togeth total solut signific due fact differ techniqu attack differ aspect prefetch problem case actual synergi differ approach interpret result rememb oraclebas prefetch algorithm like underestim prefetch instruct overhead overestim abil identifi nonshar miss latter mix effectmor prefetch minim cpu miss rate also maxim bu demand due cach conflict nonetheless result give us high confid combin techniqu prefetch made profit across wide array multiprocessor memori architectur 9 summari conclus multiprocessor system limit memori bandwidth compilerdirect prefetch algorithm guarante improv perform even success reduc cpuobserv miss rate increas load memori subsystem prefetchinduc cach conflict unnecessari invalid oper difficulti hide invalid miss slowdown possibl perform unpredict found applic benefit prefetch applic suffer architectur vari chang bu speed also show prefetch effect reduc effect nonshar cach miss make applic sensit data share problem assort architectur compil techniqu howev drawback prefetch allevi cach design forgiv cach conflict directmap cach case addit victim cach elimin prefetchinduc conflict miss increas cpu miss rate load bu memori increas effect prefetch make applic less sensit prefetch distanc allow compil freedom prefetch placement prefetch algorithm target invalid miss well nonshar miss greatli increas coverag prefetch sharedmemori multiprocessor prefetch algorithm make effect use exclus prefetch significantli reduc number invalid oper thu reduc load memori subsystem restructur share data increas processor local thu reduc number invalid miss effect make prefetch effect allow use simpler uniprocessorori prefetch algorithm two techniqu victim cach architectur improv restructur share data compil algorithm shown elsewher improv perform independ prefetch also make prefetch effect appli although individu contribut one techniqu dramat combin effect sever techniqu signific combin techniqu prefetch made viabl across much wider rang parallel applic memori subsystem architectur even memori subsystem repres bottleneck multiprocessor system acknowledg author would like thank jeanloup baer insight comment paper sever stage work review journal provid mani insight comment improv present paper tor jeremiassen provid execut trace restructur execut r softwar prefetch data prefetch highperform processor reduc memori latenc via nonblock prefetch cach perform studi softwar hardwar data prefetch scheme effici architectur loop base data preload data access microarchitectur superscalar processor compilerassist data prefetch topolog optim multipl level array logic detect elimin useless miss multiprocessor simul analysi data share share memori multiprocessor simplic versu accuraci model cach coher overhead elimin fals share techniqu inlin trace sharedmemori multiprocessor comput technolog architectur evolv interact comput perprocess summari sideeffect inform static analysi barrier synchron explicitli parallel program improv directmap cach perform addit small fullyassoci cach prefetch buffer dash proto type logic overhead perform symmetri multiprocessor system logic verif algorithm parallel implement toler latenc softwarecontrol prefetch sharedmemori multiprocessor design evalu compil algorithm prefetch splash stanford parallel applic sharedmemori share data placement optim reduc multiprocessor cach miss rate limit cach prefetch busbas multiprocessor tr logic verif algorithm parallel implement techniqu effici inlin trace sharedmemori multiprocessor lockupfre cach highperform multiprocessor softwar prefetch highbandwidth data memori system superscalar processor toler latenc softwarecontrol prefetch sharedmemori multiprocessor data access microarchitectur superscalar processor compilerassist data prefetch comput technolog architectur simplic versu accuraci model cach coher overhead reduc memori latenc via nonblock prefetch cach design evalu compil algorithm prefetch effici architectur loop base data preload detect elimin useless miss multiprocessor limit cach prefetch busbas multiprocessor perform studi softwar hardwar data prefetch scheme data prefetch highperform processor microprocessor user manual fals share spatial local multiprocessor cach dash prototyp comput perprocess summari sideeffect inform static analysi barrier synchron explicitli parallel program lockupfre instruct fetchprefetch cach organ lowoverhead coher solut multiprocessor privat cach memori splash stanford parallel applic sharedmemori simul analysi data share share memori multiprocessor ctr john mellorcrummey david whalley ken kennedi improv memori hierarchi perform irregular applic use data comput reorder intern journal parallel program v29 n3 p217247 june 2001 aleksandar milenkov achiev high perform busbas sharedmemori multiprocessor ieee concurr v8 n3 p3644 juli 2000 pablo ibez vctor vial jo l briz mara j garzarn character improv loadstor cachebas prefetch proceed 12th intern confer supercomput p369376 juli 1998 melbourn australia john mellorcrummey david whalley ken kennedi improv memori hierarchi perform irregular applic proceed 13th intern confer supercomput p425433 june 2025 1999 rhode greec parthasarathi ranganathan vijay pai hazim abdelshafi sarita v adv interact softwar prefetch ilp processor sharedmemori system acm sigarch comput architectur news v25 n2 p144156 may 1997