optim comput effect blockprocess blockprocess decreas time power requir perform given comput simultan process multipl sampl input data effect blockprocess sever limit howev delay dataflow graph comput place suboptim paper investig applic retim improv effect blockprocess comput particular consid kdelay problem given comput dataflow graph posit integ k wish comput retim comput graph origin delay reloc k data sampl process simultan fulli regularli give exact integ linear program formul kdelay problem also describ algorithm solv kdelay problem fast practic reli set necessari condit prune search space experiment result synthet random benchmark demonstr perform improv achiev blockprocess effici algorithm b introduct mani applic domain comput defin semiinfinit long stream data rate incom data dictat natur applic often satisfi straightforward implement specif although speed hardwar compon increas steadili throughput requir new applic increas even faster pace recent studi show comput requir per sampl stateoftheart commun preliminari version work present 33rd acmiee design autom confer june 1996 b figur 1 improv effect blockprocess retim blockprocess factor origin comput dataflow graph part 1 blockprocess factor retim graph part b 3 doubl everi year process power hardwar doubl everi three year 5 furthermor new applic requir low power dissip impos addit design constraint often add gap speed hardwar primit rate incom data order meet increas comput demand today commun ap plicat requir comput simultan multipl sampl incom data stream approach known blockprocess vector wide use satisfi throughput requir use parallel pipelin block process enhanc regular local comput thu greatli facilit effici implement mani hardwar platform 6 9 enhanc regular reduc effort softwar switch address calcul improv local improv effect codes reduct method 13 moreov blockprocess enabl effici util pipelin effici implement vectorbas algorithm fftbase filter errorcorrect code 2 gener block process benefici case net cost process n sampl individu higher net cost process n sampl simultan typic cost measur includ process time memori requir energi dissip per sampl sever way increas blockprocess factor comput number data sampl process simultan exampl one unfold basic iter comput schedul comput block differ iter execut success howev techniqu may uniformli increas blockprocess factor comput block anoth transform use increas blockprocess factor retim contrari architectur transform techniqu target highlevel synthesi 8 17 retim use tradit clock period minim 7 10 12 logic synthesi 14 15 figur 1 illustr use retim improv blockprocess comput dataflow graph cdfg figur three comput block b c three delay input stream come block output stream gener assum comput implement uniprocessor system express block give initi time x comput time per block input initi time includ contextswitch overhead fetch data instruct background memori cost reconfigur pipelin singl iter comput figur 1a complet 75766334 cycl execut block order three iter comput block execut order case new input consum everi 34 cycl entir comput need 3 theta cycl hand function equival cdfg figur 1b obtain retim origin cdfg complet three iter singl block iter requir 7 cycl group three delay one edg comput three iter execut order 1 thu amort initi time block three input recent retim studi context optimum vector class dsp program 16 18 specif techniqu linear vector dsp program use retim present 18 techniqu involv redistribut delay cdfg represent dsp program way maxim concentr delay edg howev fulli regular vector achiev use linear vector approach paper moreov retim problem comput linear vector formul nonlinear program comput expens solv paper consid problem retim comput dataflow graph achiev given blockprocess factor k call kdelay problem first present integ linear program ilp formul kdelay problem formul set necessari condit use develop effici branchand bound algorithm kdelay problem given cdfg posit integ k algorithm comput retim cdfg achiev blockprocess factor k determin retim exist import featur approach block retim cdfg achiev blockprocess factor k execut order across iter result retim cdfg oper faster less expens implement gener blockprocess cdfg provid extens experiment result demonstr effect optim effici algorithm remaind paper organ follow section 2 describ represent comput dataflow graph give background materi block process retim also give precis mathemat formul kdelay problem section 3 present integ linear program formul kdelay problem section 4 describ set effect necessari condit use necessari condit develop branchandbound algorithm section 5 solv kdelay problem effici practic present experiment result section 6 conclud direct futur work section 7 preliminari section first describ dataflow graph represent comput subsequ provid background blockprocess give condit must satisfi effect blockprocess also provid background materi retim give mathemat formul kdelay problem 21 graph represent cdfg comput structur edgeweight direct graph node v 2 v model comput block subroutin arithmet boolean oper ator direct edg e 2 e model interconnect data control depen denci comput block edg e 2 e associ weight denot number delay regist associ interconnect figur 3a give graph represent sampl cdfg delay state behavior synthesi correspond iter boundari softwar compil regist gatelevel descript result paper translat one domain two straightforward manner translat result behavior logic synthesi involv semant interpret 22 blockprocess blockprocess strive maxim throughput comput simultan process multipl sampl incom data maximum number sampl process simultan immedi block v call blockprocess factor k v block blockprocess linear block b figur 2 type linear blockprocess regular linear blockprocess factor 2 b irregular linear blockprocess factor 2 blockprocess factor k given linear blockprocess factor k k delta jv j comput block evalu gener k iter comput constitut block iter linear blockprocess factor k regular k data sampl process simultan everi comput block access block iter retim cdfg figur 2a exampl blockprocess linearli regularli blockprocess factor 2 comput block cdfg execut order 1 two input sampl consum blockiter regular blockprocess lead effici implement cdfg reduc cost address calcul softwar switch cdfg figur 2a illustr indic 1 2 comput block use block b well first blockiter linear blockprocess need regular illustr cdfg figur 2b blockprocess blockprocess factor 2 comput block cdfg execut order delta blockprocess irregular howev comput block process differ sampl given block iter first block iter exampl block b process sampl 1 2 block process sampl 2 3 follow lemma give necessari suffici condit achiev linear regular blockprocess cdfg achiev linear regular block process g factor k everi edg e 2 e proof relat 1 satisfi cdfg blockprocess linearli regularli factor k exist edg u e v 1 process sampl per iter sinc k remain k gamma sampl must access previou block iter contradict regular 23 retim retim cdfg integ valu vertexlabel r integ valu denot assign lag vertex transform g r edg u e defin equat retim cdfg g r wellform edg sever import properti retim transform stem directli relat 2 one properti use repeatedli proof paper given vertex pair u v v retim r chang origin delay count everi path u v amount verifi properti express postretim delay count w r p along path p sum delay count constitu edg sinc sum equat 4 telescop thu chang delay count path depend endpoint path corollari follow immedi equat 4 retim chang delay count around direct cycl cdfg base properti straightforward show given edg e 2 e maximum number delay retim place e exceed w v 24 kdelay problem accord lemma 1 linear regular blockprocess factor k achiev cdfg exactli 0 least k delay edg given cdfg satisfi condit relat 1 redistribut delay retim node achiev desir blockprocess factor k call problem comput retim kdelay problem problem kdp kdelay problem given cdfg posit integ k comput retim function r z everi edg u e e determin retim exist problem kdp express directli linear program form disjunct requir relat 6 section reli notion companion graph describ 10 express problem kdp integ linear program ilp companion graph g cdfg g construct segment everi edg u e two edg v x uv dummi vertex thu edg u e figur 3 illustr construct companion graph follow lemma give necessari suffici condit hold retim solv problem kdp cdfg let g companion graph exist retim function r solv problem kdp g exist retim function r z everi edg u e everi edg u e e f b f figur 3 construct companion graph origin cdfg companion graph gener segment everi edg e two edg introduc dummi vertex first edg delay count 1 edg g segment gener edg c w1 xcd xcd w2 g 0 proof inequ 7 ensur retim circuit wellform inequ 8 ensur delay count g 0 r 0 satisfi definit companion graph inequ ensur everi edg u e x uv one delay retim edg x uv v least k gamma 1 delay thu edg u e e delay least k delay retim construct solut r problem kdp g deriv r 0 simpli set follow theorem express problem kdp set oe integ linear program constraint theorem 3 let comput flow graph let g companion graph exist retim function r solv problem kdp exist retim function r z everi edg everi edg u e e proof follow directli linear relat 2 form inequ lemma 2 necessari condit main challeng solv problem kdp determin edg delay ilp formul problem kdp determin edg explicitli result constraint formul appear special structur thu need resort gener integ linear program solver comput solut comput expens larg cdfg section give set necessari condit determin implicitli edg delay next section develop branchandbound techniqu base necessari condit consider effici practic ilp formul follow four subsect deriv necessari condit feasibl problem kdp given cdfg first deriv condit ensur cycl enough delay around identifi path must necessarili contain delay path must necessarili free delay base path deriv necessari condit feasibl problem kdp final describ construct constraint graph captur explicitli necessari condit feasibl problem kdp 41 delay around cycl retim leav delay count around cycl unchang therefor given cdfg g blockprocess factor k problem kdp feasibl delay count around cycl g greater k follow lemma give mathemat character result feasibl problem kdp cdfg problem kdp feasibl g everi vertex proof contradict let problem kdp feasibl g let exist vertex pair u v inequ 15 hold sinc w u v minimum delay count simpl cycl u v exist direct cycl c g delay count less k sinc retim chang delay count around cycl conclud c edg delay count 1 everi retim contradict assumpt problem kdp feasibl everi vertex pair u v 2 v w u v comput effici allpair shortestpath comput ov step thu assum remaind paper given cdfg g alreadi satisfi inequ 15 42 path delay use properti retim chang delay count path given vertex pair amount determin vertex pair path must necessarili contain delay solut problem kdp follow lemma give necessari condit vertex pair cdfg let r z solut problem kdp g everi vertex pair u v 2 v exist path u p g proof contradict suppos r solv problem kdp w r u v vertex pair u v 2 v satisfi condit lemma show exist edg e 2 e relat 6 hold path u q minimum delay w r u v nonzero delay count exceed k gamma 1 thu edg path violat relat 6 path u q statement lemma furthermor c b figur 4 illustr explicit implicit delayessenti de vertex pair cdfg part transform algorithm addedg gener cdfg part b final cdfg part c bold edg part b explicit de pair weight edg indic excess delay associ correspond vertex pair bold edg part c denot explicit implicit de pair exampl pair b implicitli de becom appar de vertex pair b c c made explicit thu p nonzero delay count exceed k gamma 1 consequ edg p violat relat 6 follow lemma cast necessari condit lemma 5 retim problem appropri construct constraint graph given cdfg let g constraint graph gener g follow everi vertex pair u v 2 v exist path u p g delay count wp w u v wp k add new edg problem kdp g everi edg u e proof relat 2 definit wellformed inequ 17 hold everi edg e 2 e remain show inequ 17 hold edg set e gamma e consid vertex pair u v 2 v connect edg e purpos contradict suppos problem kdp feasibl rv gamma ru construct g sinc r solv problem kdp lemma 5 impli w r u v k contradict inequ 19 call vertex pair u v 2 v delayessenti de shortest path u q everi retim cdfg satisfi relat 6 must contain delay exampl everi vertex exist path u p v w u delayessenti sinc satisfi condit lemma 5 shown suffic compar delay count two shortest path vertex pair check exist path u p v w u algorithm addedges1 figur 5 transform given graph g g algorithm determin delayessenti vertex pair check delay count shortest strictlysecond shortest path everi vertex pair differ less k everi delayessenti vertex pair u v edg u e introduc ensur w r u v k import note order determin whether given vertex pair delay essenti one need compar delay count shortest path strictlysecond shortest simpl path path whose weight strictli greater shortestpath weight although problem comput strictlysecond shortest simpl path given vertex pair npcomplet correspond problem without simpl path requir solv polynomi time 11 graph satisfi inequ lemma 4 straightforward show strictlysecond shortest path nonsimpl delay count exce shortest path least k convers delay count shortest strictlysecond shortest path differ less k strictlysecond shortest path guarante simpl follow lemma show algorithm addedges1 run polynomi time addedges1g 1 everi vertex pair u muv fals 4 run allpair strictlysecondshortest path algorithm g 5 everi vertex pair u v 2 v u p1 two shortest path u v 6 7 muv true 8 introduc u e return g figur 5 algorithm addedges1 transform lemma 7 ov 2 e step algorithm addedges1 transform given cdfg hv ewi g proof step 12 take ov 2 time sinc allpair secondshortest path comput ov ev e time 11 step 4 take ov 2 e time step 510 take ov 2 time complet thu algorithm addedges1 termin ov 2 e step lemma 5 captur explicit delay requir implicit hidden requir ment let us assum exampl wish solv problem kdp cdfg figur 4a 2 sinc shortest secondshortest path vertic b 1 4 delay respect condit lemma 5 appli appear delayessenti verifi howev shortest path b must necessarili contain delay solut problem kdp sinc imposs retim given cdfg zero delay count b sinc vertex pair b c c must satisfi condit lemma 5 need least 2 delay shortest path thu delay along path move outsid b sinc retim chang delay along path vertex pair ident manner delay edg move b order expos implicit delay requir construct new graph g delayessenti vertex pair explicit algorithm addedges2 figur 6 transform graph g gener given cdfg g algorithm addedges1 g determin implicit delayessenti vertex pair delayessenti vertex pair determin compar everi vertex pair delay count shortest path 3 repeat 4 everi delayessenti vertex pair u v 2 q 5 muv true 6 introduc edg u e 8 everi delayfre vertex pair u 9 mvu true run allpair shortest path algorithm g comput w u v everi vertex pair u 20 delet edg u e v g 22 q 23 everi pair u 26 elseif w delet edg v e u g 28 mvu fals figur algorithm addedges2 transform g step new graph g delayessenti delayfre vertex pair g explicit transform graph current iter shortest path origin graph vertex pair u v delay count two path differ edg u e weight introduc ensur w r u v k shown suffici place addit edg delay count two shortest path differ less k differ exce k condit w r u v k implicitli taken care intuit w u excess delay pair u give upper bound number delay contribut pair rest graph new edg introduc new vertex pair becom delay essenti shown figur 4 exampl pair b becom delayessenti delay requir pair b c c becom explicit follow lemma prove constraint introduc delayessenti vertex pair iter algorithm addedges2 necessari problem kdp cdfg let g transform graph gener repeat loop algorithm addedges2 iter let g graph gener iter augment e follow everi vertex pair u v edg u e introduc e let r z solut problem kdp g everi edg u e everi edg u e proof let u e case w inequ 20 follow immedi inequ 19 let u e construct w u v w u v therefor r ad left righthand side part inequ 19 along edg shortest path u v g obtain w r u v 0 inequ 22 impli w r u v 0 sinc r solut problem kdp infer otherwis edg along shortest path g r would contain fewer k delay therefor edg u e thu r satisfi inequ 20 43 path without delay contrast delayessenti path path must contain delay solut call vertex pair u v 2 v delayfre df shortest path u q everi retim cdfg satisfi relat 6 must contain delay exampl g constraint graph construct g vertex pair u v delayfre sinc retim chang delay count around cycl result w r u v k result everi vertex pair condit w r u must hold otherwis relat 6 violat edg along shortest path u p construct graph g algorithm addedges2 delayfre vertex pair determin check everi vertex pair u v whether edg v e introduc ensur w r u process repeat everi delayfre vertex pair made explicit addit edg exampl figur 7a pair b delayessenti introduc bold edg new edg introduc cycl fewer k delay thu vertex pair b must delayfre enforc constraint weight bold edg b chang gammaw b follow lemma prove iter algorithm addedges2 introduc constraint necessari problem kdp feasibl lemma 9 let given cdfg let g transform graph gener repeat loop algorithm addedg iter let g graph gener iter augment e follow everi vertex pair u k edg v e ca b figur 7 delayfre path given cdfg 2 cycl form less k delay therefor b must delayfre weight bold edg chang gammaw b b achiev introduc e let r z solut problem kdp g everi edg u e everi edg u e proof u e inequ 23 follow immedi inequ 22 consid edg v e vertex pair u v 2 v construct e i1 ad part inequ 22 along edg shortest path v u e obtain w r v u 0 therefor r v u sinc r solv problem kdp last inequ impli w r u edg along shortest path u v e contain fewer k delay thu edg v e r satisfi inequ 20 44 constraint graph gener necessari condit lemma 5 8 9 encod edg edgeweight constraint graph g gener algorithm addedges2 de vertex pair u v 2 g algorithm introduc edg u e k moreov df vertex pair u introduc edg v e weight w v follow lemma summar necessari condit feasibl problem kdp given cdfg g term transform graph g cdfg let g transform graph gener algorithm addedges2 let r z solut problem kdp g everi edg u e proof follow directli lemma 8 9 follow lemma give run time algorithm addedges2 lemma 11 ov 3 ev 4 lg v step algorithm addedges2 transform given cdfg g determin transform possibl proof repeat loop step 3 execut ov 2 time worst case iter one addit edg de df vertex pair get ad modifi graph shown delay count addit edg get modifi loop algorithm addedges2 execut ov 2 step sinc ov 2 vertex pair step 15 take ov use johnson algorithm comput allpair shortest path 4 thu bodi repeat loop complet ov 5 practic branchandbound algorithm section describ effici branchandbound scheme solv problem kdp scheme reli necessari condit deriv section 4 effect prune search space comput solut g 1 everi vertex ru 0 6 return r 7 els return infeas figur 8 algorithm solvekdp solv problem kdp figur 8 describ algorithm solvekdp problem kdp gener constraint graph g algorithm initi r search solut use procedur branchandbound describ figur 9 recurs procedur branchandbound comput retim r satisfi constraint g exist violat edg e retim graph g r edg delay count 1 k gamma 1 algorithm branchandbound add constraint g forc e least k delay subsequ comput retim satisfi augment constraint set step repeat solut found obtain set necessari condit satisfi retim case algorithm branchandbound backtrack backtrack step state constraint graph restor new constraint ad forc violat edg e take delay count zero given cdfg g optim blockprocess factor kmax largest number sampl process success comput block g number equal maximum number delay place edg bound f thu kmax determin binari search integ rang 1 f feasibl valu check use algorithm solvekdp 6 experiment result develop three program comput optim blockprocess factor kmax three program kmax determin binari search section present result applic program real synthet dsp comput purpos experi determin much blockprocess speed comput compar effici differ implement evalu effect necessari condit first program ilp solv integ linear program formul problem branchandbound satisfi inequ 24 exist 3 return fail 6 save g r 8 introduc edg u e 12 return success els restor g r 19 return success els restor g r 22 return fail return success figur 9 algorithm branchandbound call algorithm solvekdp solv problem kdp kdp describ section 3 first gener ilp constraint solv integ program separ use lp solv publicdomain mixedinteg linear program solver 1 second program ncilp first check necessari condit given section 4 screen infeas problem problem satisfi necessari condit solv ilp formul fed lp solv third program bb implement algorithm solvekdp given section 5 branchandbound scheme reli necessari condit section 4 effect prune search space order explor comput speedup possibl blockprocess appli kdelay optim comput dataflow graph four real dsp program test suit compris adapt voic echo cancel adapt video coder two exampl 18 size cdfg dsp program rang 10 25 node result speedup experi given tabl figur 10 data obtain uniprocessor implement cdfg improv design cycl kmax cycl improv origin cdfg optim cdfg echo cancel 1215 3 840 31 figur 10 experiment result uniprocessor implement given fraction cycl optim cdfg cycl origin cdfg kdelay retim reduct achiev execut time given fraction sum contextswitch overhead node c sum comput time experi initi comput time obtain use measur typic dsp gener purpos processor tms32020 motorola 56000 order evalu effici implement experi larg synthet graph addit real dsp program synthet graph test suit gener use sprand function random graph gener describ 3 graph gener use sprand connect integ edg weight chosen uniformli rang 0 5 given number vertic edg desir sprand gener graph randomli place edg vertic randomli assign weight specifi rang size comput dataflow graph 10 300 vertic 20 750 edg result applic three program synthet test suit summar figur 11 experi conduct sparc10 64mb main memori cpu time three program comput kmax result show ilp ineffici run time becom impract graph vertic 70 edg ilp search entir solut space detect infeas solut binari search solut feasibl problem comput rel fast fast two program furthermor detect infeas problem extrem timeconsum ncilp effici ilp primarili due quick screen infeas problem base necessari condit section 4 howev ncilp name ilp ncilp bb figur 11 comparison run time cpu second taken ilp ncilp bb comput kmax random graph entri mark indic run time exceed 30000 cpu second handl effici cdfg 50 node bb effici three program order magnitud faster ilp ncilp moreov handl graph least one order magnitud larger graph handl ilp ncilp thu conclud necessari condit effect prune search space 7 conclus futur work blockprocess speed execut comput amort context switch overhead sever data sampl paper investig problem improv blockprocess factor dsp program use retim transform formul problem comput retim achiev given blockprocess factor k integ linear program present set necessari condit problem comput polynomi time base condit design branchandbound scheme comput regular linear blockprocess experi real synthet comput graph branchandbound scheme order magnitud effici gener integ linear program approach thu necessari condit prove particularli power prune search tree branchandbound scheme import question remain open whether necessari condit also suffici far abl prove suffici hand discov situat necessari condit feasibl yet kdelay problem infeas nevertheless conjectur necessari condit suffici interest direct investig reduct critic path length conjunct maxim blockprocess factor preliminari work area show possibl express critic path requir form constraint edg transform graph g futur work area could explor applic techniqu compil code long instruct word vliw architectur main challeng vliw machin issu mani instruct possibl clock cycl view instruct given program delay element comput graph one could model compil problem vliw architectur blockprocess problem cdfg r lp solv mixedinteg linear program solver fast algorithm digit signal process shortest path algorithm theori experiment evalu introduct algorithm softwar chronic crisi optim twophas rel schedul time constraint algorithm highlevel synthesi digit circuit vlsi array processor delay effici tool retim realist delay model comput strictlysecond shortest path retim synchron circuitri storag assign decreas code size retim resynthesi optim sequenti network combin techniqu synchron logic synthesi algorithm cycletim minim optimum vector scalabl synchron dataflow graph behavior transform algorithm level ic design retim dsp program optimum vec toriz tr vlsi array processor introduct algorithm storag assign decreas code size practic applic retim design highperform system comput strictlysecond shortest path fast algorithm digit signal process ctr dongik ko shuvra bhattacharyya model blockbas dsp system journal vlsi signal process system v40 n3 p289299 juli 2005 mingyung ko chungch shen shuvra bhattachryya memoryconstrain block process dsp softwar optim journal signal process system v50 n2 p163177 februari 2008 mingyung ko praveen k murthi shuvra bhattacharyya beyond singleappear schedul effici dsp softwar synthesi use nest procedur call acm transact embed comput system tec v6 n2 p14e may 2007