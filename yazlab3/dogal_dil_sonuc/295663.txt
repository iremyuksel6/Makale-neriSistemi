new simpler lineartim domin algorithm present new lineartim algorithm find immedi domin vertic flowgraph algorithm simpler previou lineartim algorithm rather employ complic data structur combin use microtre memoiz new observ restrict class path compress implement algorithm report experiment result show constant factor low compar standard slightli superlinear algorithm lengauer tarjan much less overhead algorithm run 1020 slower real flowgraph reason size percent slower larg flowgraph b introduct consid problem nding immedi domin vertic graph owgraph direct graph r distinguish start vertex path r vertex v vertex w domin vertex v everi path r v includ w w immedi domin idom v denot domin v 2 everi vertex x domin v also domin w everi vertex owgraph uniqu immedi domin aho ullman 1972 lorri medlock 1969 find immedi domin owgraph eleg problem graph ori applic global ow analysi program optim aho ullman 1972 cytron et al 1991 ferrant et al 1987 lorri medlock 1969 lorri medlock 1969 introduc 4 time algorithm nd immedi domin owgraph success improv materi present thirtieth acm symposium theori com pute 1998 author address att lab shannon laboratori 180 park ave florham park nj 07932 permiss make digitalhard copi part materi without fee grant provid copi made distribut prot commerci advantag acm copyrightserv notic titl public date appear notic given copi permiss associ comput machineri inc acm copi otherwis republish post server redistribut list requir prior specic permiss andor fee c 2 adam l buchsbaum et al ment time bound achiev aho ullman 1972 purdom moor 1972 tarjan 1974 culmin lengauer tarjan 1979 ommntim algorithm standard function invers ackermann function grow extrem slowli n tarjan van leeuwen 1984 lengauer tarjan 1979 report experiment result show algorithm outperform previou domin algorithm owgraph size appear practic reduc asymptot time complex nding domin interest theoret exercis furthermor variou result compil theori reli exist lineartim domin algorithm pingali bilardi 1997 give exampl refer harel 1985 claim lineartim domin algorithm care examin abstract reveal problem argument alstrup et al 1997 detail problem harel approach oer lineartim algorithm employ power data structur base bit manipul resolv problem achiev lineartim domin algorithm relianc sophist data structur add sucient overhead make implement impract present new lineartim domin algorithm simpler alstrup et al 1997 algorithm requir complic data structur use depthrst search fast unionnd data structur tarjan van leeuwen 1984 topolog sort memoiz implement al gorithm report experiment result show even extra overhead need achiev linear time constant factor low rst implement lineartim domin algorithm rest articl organ follow section 2 outlin lengauer tarjan approach section 3 give broad overview algorithm dieren tiat previou work section 4 present algorithm detail section 5 analyz run time section 6 present new pathcompress result analysi reli section 7 describ implement section 8 report experiment result conclud section 9 2 lengauertarjan algorithm outlin lengauer tarjan lt approach lengauer tarjan 1979 high level provid detail need algorithm appel 1998 provid thorough descript lt algorithm r input owgraph n vertic arc let depthrst search df tree g root r sometim refer vertex x df number particular x mean xs df number less ys let w w ancestor necessarili proper v also denot actual tree path similarli w w proper ancestor v repres correspond path tree v parent v let nca u v nearest common ancestor u v drop subscript write pv ncau v context resolv ambigu v path g lengauer tarjan dene p semidomin path abbrevi sdom path x v 1 1 sdom path u v thu avoid tree vertic u new simpler lineartim domin algorithm 3 a13 d14 a13 d14 b fig 1 owgraph g root r vertex label augment df number b df tree g solid arc tree arc dot arc nontre arc break microtre size 3 result four nontrivi microtre root k j g vertic nontrivi microtre encircl v semidomin semi vertex v sdom path u vg exampl consid vertex g df tree figur 1a df number g 10 path e g f g f g f g b f g b f g sdom path g sinc b least df number initi vertic path comput semidomin lengauer tarjan use auxiliari linkev data structur oper follow let tree real valu associ vertex wish maintain forest f contain tree subject follow oper initi f contain arc f let r root tree contain u f return r otherwis return vertex x 6 r minimum valu path r u tarjan 1979a show implement link eval use standard disjoint set union data structur tarjan van leeuwen 1984 use link size path compress n 1 link eval nvertex tree perform ommn n time lt algorithm travers revers df order comput semidomin follow initi semiv v revers df order w v 2 4 adam l buchsbaum et al done linkv done comput immedi domin vertex use semidomin follow fact also use design algorithm lemma 21 lt lem 1 v w path v w g must contain common ancestor v w lemma 22 lt lem 4 vertex v 6 r idomv semiv lemma 23 lt lem 5 let vertic w v satisfi w v w idomv idomw lemma 24 lt thm 2 let w 6 r suppos everi u semiw lemma 25 lt thm 3 let w 6 r let u vertex semiu minimum among vertic u satisfi semiw 3 outlin lineartim algorithm link eval use lt algorithm make run ommn time elimin n term exploit sensit rel dierenc n particular slightli superlinear n eg mn becom constant tarjan van leeuwen 1984 1 domin algorithm proce roughli follow 1 comput df tree g partit region discuss partit detail section 32 suce consid partit collect small vertexdisjoint region call microtre consid separ microtre bottom dthose contain leav dfrom microtre compris interior 0 2 vertex determin whether idom microtre determin actual idom 3 vertex v idomv vs microtre comput idomv appli lt algorithm vertic 0 b nd ancestor u v idomu comput appli lt algorithm vertic 0 partit microtre serv two purpos first subgraph induc microtre root achiev ratio mn necessari reduc n constant second microtre small enough number distinct microtre small compar n thu perform simpl comput microtre use precomput tabl memoiz elimin redund comput log n iter log function log 0 new simpler lineartim domin algorithm 5 31 comparison previou approach contrast use fact previou approach harel 1985 alstrup et al 1997 appli lt algorithm use microtre partit speed link eval harel 1985 divid entir tree microtre contain one vertex perform link eval describ lengauer tarjan 1979 tree 0 induc microtre root alstrup et al 1997 simplifi harel approach harel 1985 restrict nonsin gleton microtre bottom leav upper subtre 0 singleton microtre perform link eval 0 use two novel data structur well gabowtarjan lineartim disjoint set union result gabow tarjan 1985 transform 0 algorithm use precomput tabl process eval intern microtre vertic approach requir inform regard vertic outsid microtre might domin vertic insid microtre deriv ecient encod need tabl lookup techniqu harel 1985 present method restrict set outsid domin candid alstrup et al 1997 demonstr decienc harel argument correct problem use fredman willard qheap fredman willard 1994 manag microtre appli lt algorithm upper portion 0 combin partit scheme new path compress result show lt algorithm run linear time 0 instead process link eval intern microtre vertic determin use simpl domin algorithm whether domin vertic intern microtre comput directli use memoiz elimin redund comput process vertic domin outsid microtre without perform eval intern microtre vertic approach obviat need determin outsid domin candid intern microtre vertic elimin addit complex alstrup et al requir manag inform thu summar key dierenc variou approach follow harel 1985 alstrup et al 1997 partit microtre appli standard lt algorithm use precomput tabl speed comput linkev data structur microtre also partit microtre appli lt algorithm linkev data structur unchang one big region use memoiz speed comput domin microtre word harel 1985 alstrup et al 1997 take pure data structur approach leav lt algorithm unchang employ sophist new data structur improv run time modifi lt algorithm although becom slightli complic simpl standard data structur suce implement minor dierenc two approach regard use tabl harel 1985 alstrup et al 1997 precomput answer possibl queri mi crotre use tabl lookup answer queri actual domin comput build correspond tabl increment use memo izat comput entri actual need given instanc two approach ident asymptot time complex memoiz tend outperform priori tabul practic former comput 6 adam l buchsbaum et al answer queri never need 32 microtre consid follow procedur mark certain vertic paramet g given initi vertic unmark x revers df order child x sy sx g mark children x endif done mark rootd vertex v let nmav nearest mark ancestor necessarili proper v nma function partit vertic microtre follow let v mark vertex vg microtre contain vertic x v nearest mark ancestor x say root microtre v vertex x microx microtre contain x see figur 1 v v g descend children v mark fore microtre size g call microtre nontrivi contain leaf nontrivi microtre contain one vertex subtre process use memoiz remain microtre call trivial compos singleton intern vertic vertic compris upper subtre 0 addit children vertex form trivial microtre microtre root call vertex v form trivial microtre special child v root nontrivi microtre figur 1b c e special vertic remov nontrivi microtre special vertic would leav result tree sinc special vertex g descend descend two special vertic form disjoint set ong special vertic note alstrup et al 1997 dene microtre includ leav nontrivi microtre wherea denit make everi vertex member microtre could adopt alstrup et al 1997 denit dene microtre vertex allow uniform discuss particularli statement proof lemma theorem gabow tarjan 1985 pioneer use microtre produc lineartim disjoint set union algorithm special case union known advanc work microtre combin microset precomput tabl gener microset dixon tarjan 1997 introduc idea process microtre bottom tree 33 path denit v path g dene p extern domin path abbrevi xdom path p sdom path domin path simpli semidomin new simpler lineartim domin algorithm 7 path resid wholli outsid microtre target vertex hit target vertex extern domin vertex v xdom path u vgg particular vertex v form singleton microtre dene p push extern domin path abbrevi pxdom path nontrivi microtre occur bottom pxdom path v exit reenter microv would requir travers back arc proper ancestor rootmicrov therefor pxdom path v xdom path vertex x 2 microv caten b xtov path insid microv either b may null path push extern domin vertex v pxdom path u vg note pxdomv 62 microv sinc arc p rootmicrov rootmicrov caten tree path rootmicrov pxdom path v pxdomv pd rootmicrov exampl consid vertic l h df tree figur 1b df number l 4 path sdom path r l xdom path path c j l xdom path c l xdom path exist r l 2 p pxdom path howev r b e n xdom path r n 2 microl n l path intern microl thu semil continu df number h 12 sdom path h g h path b f g h pxdom path h howev gener vertex semi xdom pxdom valu need match use follow lemma note similar lemma 32 lemma 22 lemma 31 vertex v form singleton microtre semiv proof let v pxdom path u v v form singleton microtre denit pxdom x v 1 k without loss gener howev sinc u minimum vertex pxdom path v assum x 6 v 1 k therefor p semidomin path semiv u semidomin path howev pxdom path fact lemma 32 idomv 62 microv idomv pxdomv proof let observ u 62 microv denit pxdom path u v avoid vertic u tree path u therefor idomv 62 microv idomv lie tree path next section give detail algorithm 4 detail lineartim algorithm high level abstract algorithm follow 8 adam l buchsbaum et al f f b fig 2 microtre consist vertic f figur 1b well incid arc extern b induc graph augt 1 use memoiz reduc run time determin vertex v actual valu idomv 2 use lt algorithm comput idom v idomv 62 microv remaind section provid detail behind approach clariti describ separ phase resolut idomv 2 microv question comput pxdomv overal algorithm comput idomv discuss section 7 unit phase one travers 41 comput intern domin begin show determin whether idomv 2 microv nd actual valu idomv vertex v compris singleton microtre decis trivial idomv 62 microv nonsingleton microtre dene follow augment graph let gt subgraph g induc vertic let augt graph gt plu follow 1 vertex call root augt rootaugt 2 arc v v 2 exist arc u v 2 call blue arc note blue arc roott vertex repres contract ignor arc exit see figur 2 use augment graph captur intuit remov arc exit microtre 2 chang domin relationship dene intern immedi domin iidom vertex x iidomx immedi domin x augmicrox show iidomx 2 convers comput iidom use memoiz augmicrov thu yield fast procedur deter exit microu v 62 microu new simpler lineartim domin algorithm 9 x z x b fig 3 augmicrox plu incid extern arcspath g solid line arc dot line path case z z 62 microx eg gure path x augt use blue arc v avoid gure path intern microt z x avoid either case contradict assumpt iidomx b similar case z path p augt x avoid z p contain blue arc path g contradict z idomx mine whether idomv 2 microv v give detail memoiz procedur lemma 41 iidomx 6 rootaugmicrox proof let idomx 6 6 z z full graph g exist path p z x avoid use p demonstr path p 0 augt z 0 2 ft zg x avoid contradict assumpt v last arc p u 62 augt arc p yield immedi contradict otherwis arc u v induc blue arc v 2 augt arc togeth subpath p v x provid path p 0 see figur 3a hand z path p augt x avoid z hypothesi 6 p contain blue arc arc 62 p therefor p also path g contradict z idomx figur 3b lemma 42 proof let path p augt x avoid z p contain blue arc path origin graph contradict claim z idomx p contain blue arc v v g arc u v u 62 tree path rootg caten arc u v subpath p v x give path g x avoid z x fig 4 augmicrox plu incid extern arcspath g solid line arc dot line path case path p augt x avoid z p contain blue arc follow path b around z contradict z idomx p exist g p contain blue arc v path g x use arc u v u 62 p avoid z contradict z give contradict see figur 4 memoiz comput iidomv follow rst time comput intern immedi domin augment graph augt store result tabl index graph augt vertex v encod augt bit string correspond adjac matrix repres rowmajor order comput bit string travers augt df order assign df valu one root augt use df valu vertex identi refer canon encod augt subsequ microtre 0 augment graph isomorph encod ident simpli look iidom valu augt 0 tabl obviat recomput iidom augt 0 simpli map iidom valu store tabl rel canon encod augt 0 current instanti augt 0 vertex x augt 0 correspond vertex x rootaugt canon encod augt 0 42 comput push extern domin prove follow procedur label vertic pxdom show process allow us avoid perform link eval within nontrivi microtre initi use linkev data structur labelv valu vertex v see theorem 44 pxdomv v becom link linkev valu thu pxdom microvg extern neighbor v vertic outsid microv arc v procedur process microtre new simpler lineartim domin algorithm 11 revers df order 1 6 c labelv minfvg lemma 43 prove label v xdomv 2 v set vertic path consist arc gt set labelv min y2i v flabelyg call push v push done comput strongli connect compon gt process topolog order theorem 44 prove push label v pxdomv trivial microtre linkv due push step 2 pxdom valu nonincreas along path microtre root allow us perform eval parent microtre root pxdom push eectiv substitut eval vertic insid microtre prove procedur correctli label vertic microtre assum induct procedur alreadi label pxdom vertic tree preced revers df order base case vacuous true lemma 43 step 1 proof let show 1 labelx w 2 labelx w 1 consid xdom path p w x let 62 microx last vertex p x let z least vertex exclud w p touch tree path w els p xdom path prex p 0 p w z semidomin path otherwis exist u 6 w p 0 u z lemma 21 p 0 contain common ancestor u z contradict assert z least vertex p tree path therefor pxdomz semiz w induct labelz w z 2 microy labelz got push thu labe w note step 1 z 62 microy c step 1 contain valu greater labelz due previou link via step 3 either case label consid x via x arc greater labelz w figur 5 2 consid arc x 62 microx let pxdom path p w 0 p caten arc x xdom path similarli pxdom path p w labelz z p caten tree path z arc x form xdom path w 0 x either case figur 5 demonstr potenti path theorem 44 step 2 12 adam l buchsbaum et al x fig 5 microtre contain x incid extern path solid line arc dot line path sdom path w z ncay x thu gure labe w z 62 microy gure labelevalrootmicroy w proof argu analog proof lemma 43 let show 1 w consid label x via intern push path 2 w 0 consid valid pxdom path w 0 x 1 consid pxdom path p w x let v rst vertex p insid step 2 w push x via path v x 2 consid w 0 push x w 0 xdom pxdom vertex 2 valid pxdom path w 0 x 43 comput domin use inform comput section 41 42 give algorithm comput immedi domin algorithm proce like lt algorithm fact subtre induc trivial microtre exactli lt algorithm algorithm reli follow two lemma lemma 45 v exist w 2 microv 3 4 proof proof proce follow rst nd appropri vertex w tree path rootmicrov v show new simpler lineartim domin algorithm 13 x x b fig 6 graph induc microv plu incid extern arcspath g solid line arc dot line path pxdom path x v w least vertex p path rootmicrov v prex p 0 p x w includ vertic greater v except w b p 0 includ descend w less v must take back arc w either case p 0 sdom path x w sinc w least vertex p path rootmicrov v argu resolv postul 13 final prove idomw 62 microx impli postul 4 consid pxdom path p x v let w least vertex p tree path rootmicrov v argu prex p 0 p x w semidomin path vertex 6 x p 0 w sinc w v must 2 microv otherwis violat pxdom path denit sinc allow v p 2 microv lemma 21 subpath p 0 w contain common ancestor z w sinc w must z w must also z 2 microv els z violat pxdom path denit impli z tree path rootmicrov v contradict assert w least vertex p therefor semiw x see figur 6 argu semiw x semidomin path p x w p caten tree path w v howev form pxdom path v contradict assumpt similarli argu semidomin path also pxdom path pxdomw x pxdom path p x howev p caten tree path w v pxdom path contradict assumpt x thu shown denit pxdom pxdomw rootmicrow therefor semiw impli semiw 62 microw lemma 22 therefor idomw 62 microw thu lemma 41 lemma 46 let w v vertic microtre 14 adam l buchsbaum et al fig 7 graph induc microv plu incid extern arcspath g dot line path idomv idomw sdom path idomw x idomw tree path x v x lie tree path idomw w gure howev contradict denit idomw x lie tree path w v gure contradict 3 proof condit 3 lemma 42 impli idomv idomw 62 particular idomv w lemma 23 impli idomv idomw idomv idomw path p idomv v avoid idomw must contain semidomin subpath p 0 idomw x idomw x v x lie tree path idomw would contradict denit idomw x lie tree path w v would impli pxdomv pxdomw lemma 32 idomw pxdomw p 0 exist see figur 7 lemma 45 46 impli follow formal proof theorem 47 consid path microtre root leaf vertic path partit pxdom pxdom valu monoton nonincreas vertex w top partit thermor idomw 62 microw anoth vertex v partit w either idomv actual partit els outsid microtre see figur 8 impli algorithm devolv lt algorithm upper subtre 0 consist trivial microtre comput immedi domin algorithm idom given figur 9 v 2 idom either comput idomv determin proper ancestor new simpler lineartim domin algorithm 15 x z c fig 8 microtre incid extern path dot line path vertic tree path w pv pxdom path x b prex xdom path aect pxdom valu wpv part partit vertic partit need share idom howev pictur u v descript straightforward postprocess phase resolv latter ident idom use second linkev data structur pxdomv valu vertex v begin idom link done theorem 47 algorithm idom correctli assign immedi domin proof lemma 41 show assign idomv iidomv iidomv 2 microv correct assum iidomv 62 microv thu idomv 62 microv lemma 42 consid process vertex v bucketu assum rst child u tree path u v claim z vertex tree path u 0 v minimum semi assum claim true observ w 2 microv w pxdomw semiw thu v claim hold hand vertex tree path pd rootmicrov minimum pxdom claim hold sinc 1 pxdomu 0 consid remain case pxdomv 6 semiv lemma 45 show exist w 2 microv w rootaugmicrov pxdomw w place bucket algorithm idom revers df order processv done fug trivial microtre revers df order linku done processv iidomv 2 microv els add v bucketpxdomv endif z v els z evalp rootmicrov endif idomv u els endif done fig 9 algorithm idom idom therefor idom comput valu idomv idomw previou argument comput correct valu idomw 5 analysi analyz run time algorithm clear gener initi df tree divis microtre perform linear time discuss section 32 51 comput iidom recal memoiz comput iidom describ section 41 iidom comput run linear time overal augment graph must small enough 1 uniqu descript possibl graph augt comput ojaugt j time 2 immedi domin possibl augment graph comput linear time comput immedi domin augment graph futur tabl lookup take constant time requir descript augt one comput word assum hold log n bit recal microtre g vertic paramet g thu augment graph g1 vertic without aect time bound use g 1 place g assum augt g vertic therefor augt g 2 arc new simpler lineartim domin algorithm 17 uniqu describ string g 2 bit one comput word travers augt comput bitstr identi ojaugt j time assum 1 initi comput word 0 2 set bit comput word o1 time assum vertic number 1 jt j jt j number vertic part df g assign secondari df number v rel rootmicrov satisfi label constraint total time gener bitstr identi thu microtre sinc vertex respect arc g attribut one vertex respec tive arc exactli one augment graph one extra root vertex augment graph express rst encount particular augt use naiv domin algorithm comput immedi domin polyg time store valu iidomv v 2 augt tabl time ojaugt j worst case would memoiz iidom valu possibl distinct graph g fewer vertic 2 g 2 graph total time o2 polyg induc constraint polyg n simpl analysi show use memoiz comput need iidom valu time 52 comput pxdom step 1 comput initi label vertex v process vertex arc g throughout label vertic v addit step 1 perform one eval oper trivial microtre root per arc g step 2 implement comput strongli connect compon scc subgraph g induc microtre initi assign vertex scc minimum label among vertic scc push label scc topolog order comput scc done linear time tarjan 1972 topolog process scc step 3 link roott trivial microtre thu time comput pxdom sum microtre n plu time perform n 1 link eval oper analyz linkev time section 6 53 comput idom implement bucket associ vertex link list take constant time look iidomv either assign idomv place v bucketpxdomv process vertex v bucketpxdomv requir constant time plu time perform eval pd rootmicrov vertex appear one bucket process bucket take time plu time n eval trivial microtre root sinc pxdomv 62 microv trivial microtre root bucket perform linkv trivial microtre root total time taken idom om n plu linkev time 54 summari analysi total time requir comput immedi domin owgraph g n vertic arc omn plu time perform link eval next prove sinc link eval trivial microtre root total linkev time om n appropri choic paramet g 6 disjoint set union bottomup link recal link eval base disjoint set union yield n term lt time bound show restrict tree appli link eval leav result correspond set union oper requir linear time let u set n vertic initi partit singleton set set subject standard disjoint set union oper c name set oper unit set b name result c ndu return name set contain u well known tarjan van leeuwen 1984 n 1 union intermix nd perform ommn n time set repres tree forest union oper link root one tree root anoth oper ndu trace path u root tree contain u link smaller tree child root larger tree union compress path u root tree contain u ndu time bound achiev show given sucient restrict order union improv time bound know previou result base type restrict previous gabow tarjan 1985 use priori knowledg unord set union implement union nd oper om time requir advanc knowledg union order constrain result improv bound path compress buchsbaum et al 1995 loebl nesetril 1997 luca 1990 gener restrict order nd union perform n vertic design l special remaind n l ordinari follow theorem show requir union favor small set vertic time bound becom linear theorem 61 consid n vertic l special remain n l ordinari let sequenc n 1 union nd new simpler lineartim domin algorithm 19 union involv least one set contain least one special vertex oper perform omm l proof restrict union ensur time sequenc process set either contain least one special vertex singleton set contain ordinari vertex observ prove induct number union follow algorithm use maintain set standard unionnd data structur creat contain special vertic singleton set recal data structur consist forest root tree built vertic one tree per set root tree contain name set also array index name map set name root correspond tree call smaller data structur u 0 denot union nd union 0 nd 0 ordinari vertic kept separ ordinari vertex contain pointer initi null oper perform follow x name set contain least one special vertex perform union 0 x suppos one x say singleton set contain ordinari vertex set pointer ordinari vertex point root set x relabel root z ndx x special vertex execut nd 0 x x ordinari null pointer return x singleton set x ordinari nonnul pointer special vertex return nd 0 intuit simpl unless ordinari vertex x form singleton set equat special vertex oper involv o1 step plu possibl oper unionnd data structur u 0 contain l vertic let k total number oper done u 0 total run time okk lmn omm ln conveni implement algorithm complet within framework singl standard unionnd forest data structur use path compress union size follow initi special vertic given weight one ordinari vertic given weight zero recal size vertex sum weight descend includ see implement essenti equival describ theorem 61 observ follow point first induct number oper ordinari vertex alway leaf unionnd forest union bysiz rule ensur whenev singleton ordinari set unit set contain special element ordinari vertex made child root set standard nd oper done follow parent pointer root reset vertic path point root henc leaf vertex particular ordinari vertex remain leaf forest ordinari vertex thu either singleton root contain pointer special vertex proof theorem 61 furthermor sinc ordinari vertic weight zero aect size decis made unit set contain special vertic nd ordinari vertex equival 20 adam l buchsbaum et al nd parent special vertex proof theorem 61 dierenc pointer ordinari vertex possibl chang point dierent special vertex root add o1 run time 61 bottomup link let sequenc union u describ root undirect union tree vertex correspond element u edg label zero one initi label zero vertic connect path edg label one set label edg fv pvg one correspond unit set contain v pv union sequenc bottomup link properti edg fv pvg label one edg subtre root v label one corollari 62 let union tree l leav bottomup link properti n 1 union nd perform omm l time proof let leav class special intern vertic class ordinari union indic edg fx pxg occur descend x particular least one leaf set x therefor union sequenc properti hypothesi theorem 61 alstrup et al 1997 prove variant corollari 62 mm l term replac l log l suce purpos deriv weaker result process long path unari vertic outsid standard set union data structur appli standard set union data structur directli need weight leav one intern vertic zero 62 applic domin recal denit special vertic section 32 vertex special children root nontrivi microtre theorem 63 n link eval perform comput pxdom algorithm idom requir time proof consid subtre induc trivial microtre root link eval perform vertic special vertic precis leav view union tree induc link link perform bottomup due revers df process order shown section 32 ong special vertic thu ong leav choos log 13 n suce comput iidom linear time corollari 62 linkev time thu omm n log 13 n n theorem follow sinc n algorithm complet gener run linear time input owgraph g corollari 62 howev impli implement unionnd describ standard lt algorithm lengauer tarjan 1979 actual run linear time class graph correspond df tree follow properti number l leav sucient sublinear new simpler lineartim domin algorithm 21 7 implement section describ implement dier somewhat earlier descript algorithm ecienc reason input owgraph adjac list format ie vertex v associ list successor figur present toplevel routin initi comput perform depthrst search partit df tree microtre comput domin initi code creat initi memoiz tabl partit code assign df number initi vertic store array vertic df order comput size subtre root vertex identi microtre use subtre size vertex mark plain mtroot trivmtroot depend whether nonroot vertex microtre root nontrivi microtre root trivial microtre also vertex assign weight use linkev comput special vertic recal vertex special children root nontrivi microtre weight one ordinari vertic weight zero see lengauer tarjan 1979 implement link eval final initi array pmtroot contain parentv v array eventu store parentrootmicrov v initi vertex parent updat vertic nontrivi microtre processmt code comput domin given partit df tree dier earlier present two way first combin process vertic bucket singl pass elimin pass vertex set lengauer tarjan 1979 second separ code process trivial microtre code process nontrivi microtre allow us special algorithm situat result simpler ecient code chang simpl rearrang code alter time complex algorithm computedom call processv handl trivial microtre processmt handl nontrivi microtre processv shown figur 11 comput xdom pxdom v store v appropri bucket link v parent process bucket vs parent code exhibit chang first follow lt approach combin process vertic bucket link v p parent process ps bucket immedi follow process v vertic subtre root v ps bucket ad link v p complet path vertex p allow us process bucket second exploit idomv guarante outsid vs microtre therebi elimin condit express processmt figur 12 perform similar step complex process entir microtre rst step nd microtre root sinc vertic microtre contigu df number nd root search backward v vertic array rst vertex mark nontrivi microtre root microtre root updat pmtrootv appropri v microtre 1 comput xdom vertex microtre encod augment graph correspond microtre 2 comput iidom 3 comput pxdom 22 adam l buchsbaum et al initi comput partitionroot statusroot trivmtroot computedomroot partitionvertex v assign df number v mark v visit bucketv null linkv null labelv dfsnumv statusv plain 2 successorsv visit endif add v predecessorss done sizev g vs children plain mark plain children v df tree mtroot statusv trivmtroot endif computedomvertex root revers df order processvv elseif v process processmtv endif done df order samedomv 6 null endif done fig 10 pseudocod comput domin new simpler lineartim domin algorithm 23 processvvertex v labelv dfsnumv labelp labelv labelv labelp endif dfsnump dfsnumv evalnod labelevalnod labelv labelv labelevalnod endif endif done add v bucketverticeslabelv z els samedomw z endif delet w bucketparentv done fig 11 pseudocod process trivial microtre 4 process bucket parent microtre root comput xdom microtre encod togeth comput examin predecessor arc microtre encod simpl two bit pair microtre vertic plu one bit blue arc computa tion also identifi special class microtre microtre isol target blue arc microtre root use inform speed comput pxdom iidom comput use memoiz maintain linear time bound increas eectiv remov unnecessari bit elimin unnecessari inform microtre encod use index memoiz tabl first remov bit selfloop second exploit blue arc v impli iidomv 62 microv none inform vs intern arc use particular sinc know root microtre alway target blue arc elimin encod bit arc root chang reduc size iidom encod g 2 g bit 12 bit six addit reduc size encod reduc number popul slot memoiz tabl use observ blue arc nonroot vertex w zero remain bit arc irrelev processmtvertex v find mtroot vertic start v initi encod isol true labelv dfsnumv includ p v encod els includ blue arc v encod v 6 mtroot isol fals endif labelp labelv labelv labelp endif dfsnump dfsnumv evalnod labelevalnod labelv labelv labelevalnod endif endif endif done done iidomencod reduc encod iidommemoiidomencod dene iidommemoiidomencod computeiidomencod endif iidom iidommemoiidomencod isol els endif delet w bucketparentmtroot done fig 12 pseudocod process nontrivi microtre new simpler lineartim domin algorithm 25 isolatedpushmicrotre mt int iidom mtroot mt 0 labelv labelmtroot done add mtroot bucketlabelmtroot fig 13 pseudocod push isol microtre remov bit want xedlength encod bit extra blue arc w comput reduc encod look memoiz tabl determin futher comput necessari determin iidom use 2 time bitvector algorithm aho et al 1986 augment exploit blue arc necessari iidom express term df number augment graph translat augment graph vertex correspond vertex current microtre ad secondari df number primari df number root microtre implement two form push rst shown figur 13 simpli form use isol microtre absenc blue arc nonroot vertic impli 1 xdom microtre root pxdom vertic microtre 2 immedi domin nonroot vertic local microtre rootmicrov root vertex nonloc idom simpli add bucket pxdom second shown figur 14 handl gener case first comput strongli connect compon scc use memoiz case memoiz use ecienc iidom calcul use reduc encod scc scc encod use g 2 g bit includ selfloop blue arc sinc neither aect comput comput scc use lineartim twopass algorithm cormen et al 1991 given scc either memoiz tabl comput process topolog order nd minimum xdom vertic within scc incom pxdom assign valu vertex pxdom given vs pxdom iidom either assign idomv directli put v appropri bucket push nish process bucket pmt parent mi crotre root vertex bucket must pmt immedi domin denit pxdom vertex v microtre minimum pxdom along path pmt v result skip eval vertex pmt bucket assign pmt immedi domin directli 8 result section describ experiment result would interest compar algorithm bkrw alstrup et al ahlt 1997 judg rel constant factor ahlt reli atom heap fredman willard 26 adam l buchsbaum et al mtroot mt 0 sccencod reduc encod sccmemosccencod dene sccmemosccencod computesccmtroot encod endif topolog order iidomssecdfsnumv 62 mt add v bucketlabelv els endif done done fig 14 pseudocod push gener case atom heap turn compos qheap store log 14 n element given preprocess time atom heap construct requir qheap store 12 log 15 n element atom heap thu ahlt algorithm run linear time therefor n must exceed 2 12 20 fredman altern one consid ahlt run linear time impract high addit constant term alstrup et al 1997 provid variant algorithm use atom heap none run linear time thu implement lineartim algorithm therefor compar implement bkrw implement lt algorithm deriv paper lengauer tarjan 1979 perform two set experi rst set use owgraph collect spec 95 benchmark suit spec 1995 use cfg librari machin suif compil holloway young 1997 harvard 3 six le integ suit could compil machin suif v 112 omit data second set use larg graph collect lab perform experi one processor eightprocessor sgi origin 2000 2048mb memori process node r10000 processor 32kb data instruct cach 4mb uni secondari cach implement compil mongoos c compil version 70 report aggreg number spec test set contain larg number owgraph tabl report size owgraph averag benchmark tabl ii contain averag run time lt bkrw microtre size two three figur 15 display scatter plot 3 machin suif extens suif compil amarasingh et al 1995 stanford use machin suif version 112 new simpler lineartim domin algorithm 27 tabl graph size averag flowgraph benchmark spec 95 flowgraph benchmark number averag averag flowgraph vertic arc cint95 suit 129compress 132ijpeg 524 14 20 147vortex 923 23 34 134perl 215 cfp95 suit 145fpppp 37 19 26 103su2cor 37 104hydro2d 43 35 46 125turb3d 24 52 71 tabl ii run time spec 95 flowgraph averag flow graph benchmark number parenthes measur dier enc two algorithm comput follow formula lt 1000 posit number indic lt better neg number indic bkrw better benchmark lt bkrw cint95 suit 130li 2001 us 3391 us 6949 3699 us 8490 129compress 2261 us 3762 us 6642 4384 us 9392 132ijpeg 2546 us 4043 us 5878 4586 us 8011 147vortex 3670 us 5359 us 4602 6129 us 6700 us 5661 us 4393 6373 us 6204 099go 5039 us 6987 us 3866 7937 us 5751 126gcc 6656 us 8787 us 3201 9561 us 4363 134perl 8954 us 11223 us 2534 12113 us 3528 cfp95 suit 145fpppp 3275 us 4663 us 4237 4933 us 5061 us 5314 us 3793 5990 us 5547 107mgrid 3836 us 5372 us 4002 6032 us 5723 103su2cor 4674 us 6206 us 3278 6728 us 4395 104hydro2d 4999 us 6671 us 3345 7282 us 4568 146wave5 5171 us 6845 us 3238 7446 us 4400 125turb3d 7366 us 10356 us 4060 11036 us 4982 us 9901 us 2660 10672 us 3646 101tomcatv 17460 us 21020 us 2039 21520 us 2325 28 adam l buchsbaum et al number vertices1525 number vertices101000 number flowgraph fig 15 rel dierenc run time bkrw lt 3 point top plot owgraph gener spec 95 benchmark bottom plot display number owgraph respect number vertic note yaxi bottom plot repres logarithm scale point repres run time bkrw microtre size two three rel lt singl owgraph plot show overhead bkrw larger lt small graph dierenc tail 10 quickli gure combin data integ oatingpoint suit separ two tabl ii would yield two similar plot tabl iii list larg test graph come varieti sourc along new simpler lineartim domin algorithm 29 tabl iii graph size larg test graph graph vertic arc ati 4950 515080 phone 2048 4095 7166 size ati nab pw graph deriv weight nitest automata use automat speech recognit pereira riley 1997 pereira et al 1994 remov weight label multipl arc phone graph repres telephon call pattern augment binari graph ab1 ab2 gener synthet build binari tree given size shown tabl graph label replac leaf sub graph see figur 16 ab1 graph use subgraph shown figur 16b ab2 graph use subgraph shown figur 16c graph design distinguish bkrw lt subgraph treat isol microtre bkrw mean nonroot vertic microtre domin within microtre back cross arc handl cheapli without eval bkrw particular call eval relat arc avoid bkrw result link linkev forest compress bkrw observ expect bkrw perform fewer link eval lt run time tell metric howev present run time experi tabl iv speech phone graph overhead process microtre includ initi memoiz tabl comput iidom comput microtre encod push outweigh save call link eval bkrw outperform lt larger augment binari graph expect sinc bkrw substanti fewer call eval compress zero link graph addit overhead process microtre low isol note improv bkrw lt decreas graph get larger benet gain algorithm small rel cost due page increas graph get larger a1b13 c fig 16 k kdepth binari tree augment binari graph ab1 respect ab2 gener replac leaf subgraph shown b respect c tabl iv run time larg test graph number parenthes measur dierenc two algorithm comput follow lt 1000 posit number indic lt better neg number indic bkrw better graph lt bkrw ati 38450 ms 42338 ms 1011 42725 ms 1112 ms 283625 ms 355 284475 ms 386 ms 319598 ms 220 318915 ms 199 phone 831362 ms 859475 ms 338 861638 ms 364 1024 200 ms 200 ms 000 250 ms 2500 2048 500 ms 500 ms 000 500 ms 000 ms 1000 ms 909 1200 ms 909 ms 2200 ms 974 2300 ms 564 ms 4838 ms 808 4838 ms 808 ms 11750 ms 775 11788 ms 746 2097152 2018800 ms 1949900 ms 341 1949838 ms 342 1024 400 ms 312 ms 2188 400 ms 000 2048 800 ms 700 ms 1250 700 ms 1250 ms 1562 ms 234 1600 ms 000 ms 3425 ms 486 3275 ms 903 ms 7425 ms 511 7038 ms 1006 ms 18212 ms 414 17538 ms 770 2097152 5192062 ms 5146125 ms 088 5102988 ms 172 new simpler lineartim domin algorithm 31 given overhead bkrw pay comput microtre encod push small bkrw surprisingli competit even small owgraph experi suggest lt algorithm choic current practic applic lt simpler bkrw perform better graph bkrw perform better graph high percentag isol microtre 9 conclus present new lineartim domin algorithm simpler previou algorithm implement algorithm experiment result show constant factor low rather decompos entir graph microtre harel approach domin pathcompress result allow microtre process restrict bottom tree travers graph appli techniqu buchsbaum et al 1998 simplifi previou lineartim algorithm least common ancestor minimum span tree mst veric random mst construct also show buchsbaum et al 1998 appli techniqu pointer machin tarjan 1979b allow implement pure function languag acknowledg thank bob tarjan mikkel thorup phong vo help discuss glenn holloway help machin suif jame abello provid phone graph r compil principl theori pars domin linear time manuscript avail ftpftp suif compil scalabl parallel machin modern compil implement c introduct algorithm optim parallel veri program depend graph use optim lineartim algorithm special case disjoint set union linear time algorithm ow analysi transform librari machin suif fast algorithm linear strong postord object code optim postord disjoint set union linear speech recognit composit weight finitest languag process weight ration transduct applic human languag process optim control depend comput roman chariot problem algorithm 430 immedi predomin direct graph find domin direct graph applic path compress balanc tree class algorithm requir nonlinear time maintain disjoint set accept june tr worstcas analysi set union algorithm compil principl techniqu tool linear algorithm find domin flow graph relat problem program depend graph use optim introduct algorithm postord disjoint set union linear effici comput static singl assign form control depend graph transdichotom algorithm minimum span tree shortest path datastructur bootstrap linear path compress caten heapord doubleend queue linear unprov set union problem strategi optim control depend comput roman chariot problem modern compil implement java lineartim pointermachin algorithm least common ancestor mst verif domin applic path compress balanc tree fast algorithm find domin flowgraph immedi predomin direct graph h object code optim theori pars translat compil ctr adam l buchsbaum haim kaplan ann roger jefferi r westbrook corrigendum new simpler lineartim domin algorithm acm transact program languag system topla v27 n3 p383387 may 2005 g ramalingam loop domin domin frontier acm sigplan notic v35 n5 p233241 may 2000 loop domin domin frontier acm transact program languag system topla v24 n5 p455490 septemb 2002 andrzej murawski ch luke ong fast verif mll proof net via imll acm transact comput logic tocl v7 n3 p473498 juli 2006 louka georgiadi robert e tarjan find domin revisit extend abstract proceed fifteenth annual acmsiam symposium discret algorithm januari 1114 2004 new orlean louisiana louka georgiadi robert e tarjan domin tree verif vertexdisjoint path proceed sixteenth annual acmsiam symposium discret algorithm januari 2325 2005 vancouv british columbia effici algorithm find doublevertex domin circuit graph proceed confer design autom test europ p406411 march 0711 2005 adam buchsbaum yihfarn chen hual huang eleftherio koutsofio john mocenigo ann roger michael jankowski spiro mancoridi visual analyz softwar infrastructur ieee softwar v18 n5 p6270 septemb 2001 ren krenz elena dubrova fast algorithm find common multiplevertex domin circuit graph proceed 2005 confer asia south pacif design autom januari 1821 2005 shanghai china elena dubrova structur test base minimum kernel proceed confer design autom test europ p11681173 march 0711 2005