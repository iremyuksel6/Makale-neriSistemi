memori latenc effect decoupl architectur decoupl comput architectur partit memori access execut function comput program achiev highperform exploit finegrain parallel two architectur make use access processor perform data fetch ahead demand execut process henc often less sensit memori access delay convent architectur past perform studi decoupl comput use memori system interleav pipelin studi latenc effect partial hidden due interleav detail simul studi latenc effect decoupl comput undertaken paper decoupl architectur perform compar singl processor cach memori latenc sensit cach base uniprocessor decoupl system studi simul perform determin signific data cach decoupl architectur observ decoupl architectur reduc peak memori bandwidth requir total bandwidth wherea data cach reduc total bandwidth captur local may conclud despit capabl partial mask effect memori latenc decoupl architectur still need data cach b introduct execut comput program involv two interrel process access data element memori true comput larg amount parallel exist two task concurr execut task result high perform principl decoupl access execut architectur mani earli high perform comput ibm 360370 cdc 6600 cray1 incorpor techniqu exploit parallel access execut task sever architectur past year like map200 4 dae 19 24 pipe 8 23 sma 15 sdp 17 fom 2 zs1 20 25 26 wm 28 partit access oper comput function program distinctli almost aforement architectur consist two processor one perform address calcul load store oper oper data produc result two processor often refer access processor execut processor respect essenc job part perform execut processor execut processor perform role without inform furnish access processor decoupl architectur fifo buffer queue provid access execut processor maxim overlap independ two processor independ two process allow access processor fetch data element ahead demand execut processor phenomenon call slip previou research 9 24 27 slip actual refer extent decoupl access execut process memori latenc effect decoupl architectur studi 24 8 26 28 etc smith et al 24 compar perform pipelin decoupl architectur scalar cray1 particular research effort also includ studi effect memori latenc vari access time main memori sinc comparison made cray1 interleav memori configur cray1 assum memori bank conflict also ignor memori access time vari 5 cycl 32 cycl sinc memori system 16 way interleav memori latenc effect may hidden first twelv lawrenc livermor loop use simul workload goodman et al evalu perform pipe vlsi decoupl architectur use lawrenc livermor loop 8 9 work includ effect memori speed perform conduct studi fast slow memori modul fast memori access time one clock cycl slow one access time four clock cycl four way interleav system includ memori control overhead incur control effect delay seen case fast memori 3 cycl 6 cycl slow memori 9 also ignor memori modul conflict studi smith abraham davidson 26 report result effect memori latenc fine grain parallel astronaut zs1 connect pipelin memori system observ slip limit high comput system almost insensit memori latenc studi also base lawrenc livermor loop wulf 28 present preliminari result perform wm architectur though specif memori latenc studi perform mention data fifo would partial mask effect memori latenc also comment probabl achil heel architectur would build memori system capabl suppli bandwidth processor absorb 11 object perform studi present paper three goal first compar perform decoupl comput uniprocessor system cach second studi memori latenc sensit decoupl comput noninterleav nonpipelin memori third determin signific data cach decoupl architectur perform decoupl comput compar singl processor without cach previou studi conceptu decoupl system use processor access task elimin delay data operand cach base system util cach captur local elimin long delay requir access main memori would interest find two scheme compar one anoth paper investig whether access processor hide memori latenc comput system better data cach henc perform comparison perform decoupl mode uniprocessor cach anoth object paper studi sensit decoupl architectur memori latenc memori noninterleav nonpipelin previou studi report decoupl comput less sensit memori path length convent system 24 8 also report speed singl processor configur becom greater memori becom slower mention studi use interleav pipelin memori system want studi whether system behavior exhibit similar pattern even memori noninterleav suggest decoupl architectur need interleav memori aim isol memori latenc insensit contribut decoupl third object paper studi signific data cach decoupl architectur memori system interleav decoupl architectur gener data cach architectur describ zs1 data cach reduc sensit memori access time observ previou studi tend suggest improv possibl data cach would minor interleav memori pipelin obscur memori latenc suspect one reason insensit longer memori cycl time studi past investig whether data cach would result seriou perform advantag decoupl architectur noninterleav memori unit 12 overview section 2 briefli describ decoupl architectur use conduct perform studi descript illustr architectur similar decoupl architectur henc result obtain system appli least qualit decoupl architectur well section 3 analyz mechan decoupl comput allevi memori latenc problem section 4 explain simul tool describ benchmark use section 5 detail simul result obtain compar cach base uniprocessor decoupl system studi sensit decoupl system memori latenc examin limit cach decoupl architectur elimin memori latenc studi signific data cach decoupl architectur conclud paper section 6 2 deap architectur section describ decoupl execut access processor deap use conduct simul studi deap architectur use two processor execut processor ep access processor ap shown fig1 standard decoupl access execut architectur 19 ep execut program instruct perform requir data comput access data memori done ap two processor commun architectur queue avoid memori content ep ap processor equip separ memori unit access relat instruct fetch ap comput instruct fetch ep respect instruct cach data operand need ep fetch data memori unit ap pass ep via architectur queue result ep comput deposit queue transfer data memori ap ep access path data memori ap instruct store instruct memori privat ap avoid bu content data fetch sinc pin limit ap vlsi implement might pose problem ap instruct could also store global data memori unit degrad perform problem loop sinc ap instruct cach perform result paper base deap architectur ap instruct store memori unit data architectur exist simul form time ap ep see entir differ instruct stream code split compil time way comput instruct put ep section code address calcul access instruct put ap section execut time two differ instruct stream enter two processor two respect instruct memori ap make address calcul perform data memori access furnish ep data requir comput ep thu free perform data comput ap wait access request satisfi memori two instruct stream run speed queue absorb excess data unlik pipe two queue deap read queue write queue see fig 1 ep read data read queue store result write queue may notic queue name refer ep ap wherev coordin requir ap ep use token ensur correct oper access multipleel data structur ap use endofdata eod token separ batch data array column matrix entir matrix ap use read queue pass eod token ep ep use token control iter potenti problem due send control inform intermingl data queue explicit instruct use deposit token also access correct program ensur long eod token deposit complet issu load instruct addit keep system simpl two queue implement effici system separ data control inform queue sinc use token denot endofdata would necessit use one bit call eod bit element queue problem static data bound ap prior knowledg insert eod token problem dynam bound c librari string copi strcpi string compar strcmp end string known actual encount scenario differ exploit advantag decoupl architectur applic ap fetch string element one one without check delimit ep perform comparison find end string due slip ap would fetch beyond end string time ep find end string case ep send eod token ap whereupon ap stop fetch oper also flush unnecessari data fetch ep meanwhil continu oper read data ap flush queue accomplish ap send token ep mark flush queue ep wait token read data operand queue creat certain amount busi wait seem inevit parallel exploit problem 3 memori latenc access processor access processor ap elimin latenc main memori perform access process ahead demand execut processor program loop access instruct stream often preced execut stream least one iter read queue buffer prefetch data execut processor wait obtain data comput access processor would alreadi load data read queue henc suffici slip present ep obtain operand delay similarli case memori write ep put data write queue proceed ap would store back main memori later assum queue like regist access singl cycl henc ap run ahead load queue data ep reach section code refer data write queue long enough ep dump result proceed ep never experi delay access main memori ap thu hide memori latenc ep length queue critic factor decoupl architectur sinc often distanc access process run ahead limit queue slow memori access path compens use longer queue 24 suffici long queue high averag transfer rate achiev even memori rel low peak transfer rate capac queue enabl system util given memori bandwidth effici memori latenc insensit achiev decoupl architectur depend slip attain case fast memori address calcul instruct consum signific fraction total execut time limit slip attain slower memori environ permit slip memori pose bottleneck slip limit memori speed decreas beyond certain point consid optimum memori speed optimum constant depend characterist program execut fraction load store instruct rel ap ep workload etc 4 simul methodolog perform simul develop uniprocessor actual mip r2000 11 deap system access execut processor mip instruct set deap modif necessari r2000 queue oper epap interfac assum simul written c run dec 3100 station unix oper system result mip r2000 system form baselin comparison ap ep instruct pipelin fetchdecodealuwriteback stage fashion similar mip r2000 11 hardwar interlock r2000 tri achiev singl cycl execut instruct delay load delay branch techniqu uniprocessor form baselin system comparison well ep decoupl implement incorpor techniqu ident manner effect decoupl could easili identifi decoupl mode length queue kept 20 simul report 24 29 8 short queue suffici achiev perform close maximum avail unbound queue also perform experi queue length observ confirm past result except loop unrol slightli increas queue length requir perform simul lawrenc livermor loop lll two signal process algorithm convolut correl saxpi routin linpack benchmark c librari string copi strcpi lll chosen sinc use research past 24 8 9 sinc import wide rang scientif algorithm applic signal process algorithm use contain address pattern sequenti 10 exhibit good local properti also sinc studi involv cach base system algorithm relev studi saxpi routin linpack benchmark run loop increment equal one also unequ increment strcpi routin oper charact data 8 bit wide benchmark use data 32 bit wide benchmark compil dec 3100 workstat compil highest level optim assembl output compil machin code requir trace format uniprocessor case decoupl version assembl code manual split access execut stream code requir trace format could includ result larg benchmark spec due difficulti gener two stream trace without compil decoupl system dec compil perform loop unrol loop use uniprocessor trace unrol degre unrol retain trace decoupl system also 5 discuss simul result section present simul result first compar perform decoupl system singl processor cach order relat work previou research also simul uniprocessor without cach simul run vari main memori access time find sensit system perform memori path length simul result analyz identifi limit decoupl architectur cach base system final relev data cach decoupl architectur studi simul system cach ap stage comprehens comparison uniprocessor without cach decoupl system without cach present similar studi handcod trace present 13 51 comparison uniprocessor cach perform decoupl system comparison uniprocessor without cach shown fig 2 memori cycl time denot mm express term processor cycl sinc block size cach size critic effect perform cach base system perform simul differ cach paramet order clutter figur much data plot one typic organ cach size 1024 byte cach size might seem unrealist small rememb benchmark use small cach assum singl cycl access time fig 2 seen 5 cycl case decoupl architectur execut code faster uniprocessor without cach 15 cycl uniprocessor cach perform better decoupl system sever trace behavior similar trace except strcpi strcpi even cycl uniprocessor cach superior decoupl system strcpi trace uniqu data element size smaller buswidth multipl data element fetch one access 52 sensit perform memori access time variat execut time increas memori cycl time illustr fig 3 tabl three type behavior observ fig 3 memori latenc sensit first graph correspond strcpi trace abl make use cach due spatial local uniprocessor cach exhibit less sensit memori access time decoupl system second graph illustr typic behavior benchmark make use local uniprocessor cach decoupl architectur exhibit rang variat execut time third graph illustr convolut correl trace contain true tempor local cach uniprocessor exhibit signific insensit memori access time wherea decoupl architectur sensit access time tabl illustr convolut correl strcpi increas execut time decoupl architectur significantli higher cach uniprocessor five trace cach uniprocessor decoupl architectur exhibit rang variat benchmark uniprocessor cach decoupl architectur lll1 12022 10422 lll3 20000 20000 lll11 19524 20065 convolut 1938 31560 correl 1070 30580 saxpyun 24497 25435 strcpi tabl increas execut time cycl tripl memori cycl time fig 4 illustr chang speed decoupl system memori access time vari result report 24 8 indic speedup decoupl organ improv memori speed decreas loop observ effect report also notic beyond certain memori speed speedup declin loop show effect report 24 8 use handcod trace 13 8 though mention perform advantag signific slower memori actual 5 12 lawrenc livermor loop use show smaller speedup slower memori modul sinc consid interleav memori decreas speedup certain latenc evid loop rang memori speed use 53 limit decoupl architectur decoupl smooth burst bandwidth requir total bandwidth requir higher time execut processor would take complet section code memori becom bottleneck unless techniqu allevi bottleneck incorpor quantifi memori bandwidth problem decoupl architectur compar total access time requir pure comput time time ep take complet section code assum alway find request data load queue without wait abl deposit result store queue without wait ep execut time perfect memori perfect ap let us denot time ep standalon execut time total memori access time analog bandwidth requir less ep standalon execut time suffici memori bandwidth avail fig 5 show memori access take 18 36 54 time time ep take complet comput memori speed 5 10 15 cycl respect memori system capabl furnish requir bandwidth complet entir access time period less ep standalon execut time decoupl system would perform better decoupl architectur elimin memori latenc long total time requir data fetch accommod within time execut processor would consum complet section code without wait operand beyond point effect memori latenc evid total execut time explain sensit decoupl system exhibit memori access speed simul might note increas queue length hide latenc memori becom bottleneck like decoupl architectur reduc peak bandwidth requir total bandwidth cach reduc total bandwidth requir captur local limit address section 55 load unbal access execut processor might also limit speed achiev decoupl configur typic gener purpos instruct stream contain access relat instruct true comput access processor often execut instruct execut processor illustr instruct count tabl ii sever load unbal exist saxpyunequ trace use report result gener highest level compil optim o4 address calcul instruct appear within loop except saxpyunequ code less optim exhibit apep unbal due presenc address calcul instruct ratio ap load ep load less 21 saxpyequ optim success remov address calcul saxpyunequ detail address calcul iter correspond ratio greater 51 averag ratio ap instruct count ep instruct count 2151 perform extens studi memori bandwidth apep unbal bottleneck decoupl architectur due space con straint present result interest reader may refer 14 present result benchmark ap instr count ep instr count ap countep count convolut 5000 3975 126 correl 11083 5926 187 saxpyunequ 12253 2251 544 saxpyequ strcpi 10012 6001 167 tabl ii ap ep instruct count ratio anoth limit decoupl processor relat overhead incur process exploit access execut parallel comput process slight code expans result apep code gener branch instruct must appear processor execut processor support oper operand queue read queue one operand move queue regist also contribut code expans problem allevi two read queue two data element load altern queue case two regist address use queue certain problem transposit matrix array copi etc whole problem access natur role execut processor play effort parallel problem result seriou overhead may increas execut time uniprocessor mode compil recogn problem dae system slower uniprocessor 54 signific data cach decoupl architectur section 51 observ uniprocessor data cach perform consider better decoupl architectur slow memori see t15 cycl case fig 2 observ natur lead question whether decoupl architectur could also benefit cach perform simul investig result appear fig 6 total execut time benchmark plot decoupl system cach uniprocessor without cach ordinari decoupl architectur result characterist memori referenc behavior benchmark convolut correl algorithm decoupl system cach perform better system attribut strong tempor local present data refer benchmark strcpi program benefit spatial local benchmark also decoupl system cach exhibit superior speedup system lll saxpi benefit cach benchmark cach similar effect uniprocessor decoupl architectur t15cycl benchmark uniproc cach decoupl decoupl cach saxpi 096 115 110 mean 096 115 114 correl 335 222 629 convolut 395 219 515 strcpi 297 106 363 mean 342 182 502 t5cycl benchmark uniproc cach decoupl decoupl cach saxpi 096 143 135 mean 093 141 127 correl 159 239 308 convolut 189 247 247 strcpi 145 119 191 mean 164 202 249 tabl iii speedup comparison speedup figur memori access time equal 5 cycl 15 cycl present tabl iii speedup calcul refer uniprocessor without cach mean valu speedup figur shown separ program differ local characterist lawrenc loop saxpi benefit cach form one group convolut correl strcpi exhibit local characterist form anoth group limit associ cach cach hide latenc main memori captur tempor spatial local data refer local refer enabl cach reduc bandwidth requir program illustr previou section data cach improv perform decoupl architectur also sever limit associ cach lack tempor local limit capabl problem exploit cach fig 2 one note cach caus increas execut time benchmark consid lawrenc livermor loop 3 program step array henc spatial local studi element array represent data bu width bit well main memori organ word size 32 bit access furnish one word 32 bit block size 4 byte use array element demand load time miss sinc array element use word tempor local cach 4 byte block improv perform larger block size would exploit spatial local sinc fetch larger block requir proportion larger number cycl cach decreas total execut time cach yield advantag fetch cycl could run parallel comput cycl cpu busi use bu otherwis cach slow system ad cach access time refer phenomenon observ lll fig 2 execut time cach base system higher system without cach could avoid look cach main memori time case would deterior still would improv thu notic problem spatial local sometim benefit cach data size smaller word word one data element could fetch expens one fetch perform improv could obtain among benchmark use strcpi trace exhibit characterist benchmark achiev strong insensit memori latenc success cach organ depend minim miss ratio delay due miss penalti updat main memori number fetch requir load block given size depend bu width larger block size captur spatial local may decreas miss ratio increas delay due miss also updat penalti increas hit ratio obtain larger block size may mislead design architect caution sever case bu traffic memori bandwidth requir increas dramat increas block size overal effect reduct perform despit increas hit ratio typic exampl shown fig 7 saxpi unequ increment execut time increas threefold block size increas 4 byte 16 byte similar behavior observ sever trace spatial local anoth fact observ figur limit associ cach affect uniprocessor decoupl system ident sensit perform block size also illustr correl algorithm fig 7 observ benchmark strong tempor local exhibit sensit cach block size also execut time system cach alway less system without cach gener observ tempor local often stronger spatial local may conclud precis tune cach paramet essenti success cach organ also observ 12 1 21 unless care design implement cach may result minim perform improv may even constitut burden 6 conclus present simul result memori latenc effect decoupl access execut architectur sinc cach timetest mechan solv memori access problem also compar decoupl architectur perform uniprocessor cach see cach decoupl system achiev best perform differ domain sinc mechan allevi memori bottleneck depend differ characterist comput program case might result perform advantag problem one scheme might contribut significantli perform cach potenti effici hide main memori latenc program exhibit strong local properti may also slow system care design one fix organ cach go use applic heavi risk cach affect system advers condit anoth observ tempor local often produc stronger effect spatial local case decoupl system note scope improv decoupl slip main memori fast enough provid bandwidth processor demand slow memori effect memori latenc clearli evid total execut time memori pose bottleneck decoupl comput lower execut time total memori access time even region program might benefit cach strong tempor local present spite memori pose bottleneck case speedup decoupl system rel noncach uniprocessor signific also perform simul determin whether decoupl architectur obtain perform advantag data cach contribut cach minor main memori fast case strong tempor local decoupl architectur cach achiev level memori path insensit superior configur conclud cach relev decoupl comput uniprocessor though use noninterleav memori studi paper major conclus paper hold system interleav memori also memori latenc high interleav hide latenc effect certain latenc bandwidth like becom bottleneck beyond certain latenc cach would signific decoupl architectur interleav memori also memori bandwidth bottleneck use noninterleav memori simpli enabl us see effect low latenc r perform tradeoff microprocessor cach mem ori organ architectur tradeoff fom queue base instruct cach memori function parallel architectur array processor perform evalu onchip regist cach organ improv perform small onchip instruct cach implement pipe processor pipe vlsi decoupl architectur perform evalu pipe comput architectur perform analysi address gener coprocessor classif perform evalu instruct buffer techniqu memori latenc effect decoupl architectur singl data memori modul bottleneck decoupl architectur perform structur memori access architectur featur structur memori access sma architectur architectur programm digit signal processor cach memori decoupl accessexecut comput architectur zs1 central processor line block size choic cpu cach memori dynam instruct schedul astronaut zs1 pipe high perform vlsi architectur simul studi decoupl architectur comput perform comparison ibm rs6000 astronaut zs1 effect memori latenc finegrain parallel astronaut zs1 perform perform structur memori access archi tectur evalu wm architectur simul studi architectur data queue preparetobranch instruct tr simul studi decoupl architectur comput line block size choic cpu cach memori zs1 central processor perform evalu onchip regist cach organ mip risc architectur dynam instruct schedul astronaut zs1 improv perform small onchip instruct cach implement pipe processor perform comparison ibm rs6000 astronaut zs1 classif perform evalu instruct buffer techniqu memori latenc effect decoupl architectur singl data memori modul evalu wm architectur cach memori decoupl accessexecut comput architectur perform tradeoff microprocessor cach memori ctr milidoni n alachioti v porpoda h michail p kakarounta c e gouti interact present decoupl architectur processor scratchpad memori hierarchi proceed confer design autom test europ april 1620 2007 nice franc roger espasa mateo valero simul studi decoupl vector architectur journal supercomput v14 n2 p124152 sept 1999 joanmanuel parcerisa antonio gonzalez improv latenc toler multithread decoupl ieee transact comput v50 n10 p10841094 octob 2001 w ro stephen p crago alvin despain jeanluc gaudiot design evalu hierarch decoupl architectur journal supercomput v38 n3 p237259 decemb 2006