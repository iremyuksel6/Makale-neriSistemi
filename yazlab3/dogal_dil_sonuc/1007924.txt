onlin hierarch cooper cach address hierarch gener wellknown disk page problem hierarch cooper cach problem set n machin resid ultrametr space cooper one anoth satisfi sequenc read request collect readonli file semin result area competit analysi state lru widelyus determinist onlin page algorithm base least recent use evict polici constantcompetit given constantfactor blowup capac offlin algorithm constantcompetit determinist algorithm constantfactor blowup machin capac exist hierarch cooper cach problem main contribut present paper answer question neg specif establish log log n lower bound competit ratio onlin hierarch cooper cach algorithm capac blowup olog n1 denot arbitrarili small posit constant b introduct tradit page problem extens studi defin follow given cach sequenc request file uniform size system satisfi request one one file f request cach cost incur otherwis uniform retriev cost incur place f cach need file determin onlin cach algorithm know futur request sequenc evict make room f object minim total retriev cost wise choos file evict cost onlin algorithm compar optim oin algorithm opt full knowledg request sequenc follow sleator tarjan 10 call onlin algorithm ccompetit cost c time opt request sequenc wellknown optim oin strategi evict file request furthest futur page problem also known cach file nonuniform size retriev cost semin paper sleator tarjan 10 shown lru least recentlyus sever determinist page algorithm k competit k cach space use lru h use opt also shown k kh1 best possibl among determinist algorithm call k h capac blowup lru file nonuniform size retriev cost young 13 propos landlord algorithm shown landlord k kh1 competit state 13 focu landlord simpl local cach strategi rather distribut strategi cach cooper cach page across network cooper cach 6 set cach cooper serv request make cach deci sion benefit cooper cach support sever studi exampl harvest cach 5 introduc notion hierarch arrang cach harvest use internet cach protocol 12 support discoveri retriev document cach harvest project later becam public domain squid cach system 11 adapt web cach 14 build mesh overlap multicast tree popular file pull toward user origin server localarea network environ xf system 1 util cooper cach obtain serverless file system cooper cach scheme roughli divid three compon placement determin place copi file search direct request appropri copi request file consist maintain desir level consist among variou copi file paper studi placement problem assum separ mechan enabl cach locat nearest copi file free cost assum file readonli ie copi file alway consist focu class network call hierarch network precis definit given section 2 call cooper cach problem network hierarch cooper cach hcc problem notion hierarch network constantfactor relat notion hierarch wellsepar tree metric introduc bartal 3 refin earlier result bartal 3 fakcharoenphol et al 7 shown metric space approxim wellsepar tree metric logarithm distort henc mani result tree metric impli correspond result arbitrari metric space addit logarithm factor access frequenc file cach known advanc korupolu et al 9 provid exact approxim algorithm minim averag retriev cost practic access frequenc often unknown expens track sinc lru landlord provid constant competit singl cach natur ask whether exist determinist constantcompetit algorithm constant capac blowup hierarch cooper cach problem paper answer question neg show log n lower bound competit ratio determinist onlin algorithm capac blowup olog n 1 n number cach hierarchi arbitrarili small posit constant particular construct hierarchi sucient larg depth show adversari gener arbitrarili long request sequenc onlin algorithm incur costt1 log n time adversari terestingli oin algorithm associ lower bound argument replic file hand onlin algorithm given suffici larg capac blowup constant competit easili achiev appendix show result given od capac blowup depth hierarchi ie n lrulik onlin algorithm constantcompetit note term lower bound result yield capac blow od 1 competit ratio henc result impli small rang valu capac blowup separ region constant competit achiev unachiev draw analog tradit cach lru landlord provid constant competit may think constantcompetit algorithm exist hcc perhap hierarch variant lru landlord fact began investig search algorithm sinc hcc problem gener page problem hope achiev constant compet without least constant capac blowup regard remark result 9 incompar requir capac blowup sever page problem eg distribut page file mi gration file alloc consid lit eratur relat hcc problem see eg survey paper bartal 4 definit problem particular hcc problem formul readonli version distribut page problem ultrametr hcc problem without replic special case constrain file migrat problem access migrat file cost exist work problem focus upper bound result lower bound result appli algorithm without capac blowup exampl distribut page problem awerbuch et al 2 shown given polylogn capac blowup exist determinist polylogn competit algorithm gener network normal diamet net work constrain file migrat problem bartal 3 given determinist upper bound total size cach random lower bound 55 network topolog olog log 2 n random upper bound arbitrari network topolog use recent result fakcharoenphol et al 7 last upper bound improv olog log n rest paper organ follow section 2 give preliminari problem section 3 4 present main result paper lower bound constant capac blowup section 5 provid conclud remark appendix present upper bound su cientli larg capac blowup 2 preliminari section formal defin hcc problem given fix sixtupl f set file c set cach dist function cc n size function f n cap function c n penalti function f n n denot nonneg integ assum dist ultrametr defin c assum everi file f f penaltyf diamc diamu denot maxuvu distu v everi set cach u 21 ultrametr hierarch network distanc function c c n defin metric nonneg symmetr satisfi triangl inequ du special case metric satisfi inequ subsum triangl inequ equival perhap intuit character ultrametr assumpt cach c form hierarch tree simpli tree defin follow everi leaf node tree correspond distinct cach everi node tree associ nonneg valu call diamet node everi two cach u v distu v equal diamet least common ancestor u v sinc hierarch network natur correspond tree rest paper use tree terminolog develop algorithm analysi follow definit ancestor descend parent children follow standard tree terminolog use denot tree cach use root denot root depth root 0 depth maximum depth node capac node total capac cach within subtre root node impos arbitrari order children everi intern node 22 hcc problem goal hcc algorithm minim total cost incur movement file serv sequenc request respect capac constraint cach facilit formal definit problem introduc addit definit copi pair u f u cach f file set copi call placement u f belong placement p say copi f place u p placement p bfeasibl total size file place cach b time capac cach 1feasibl placement simpli refer feasibl placement given placement p upon request file f cach u algorithm incur access cost serv request p place least one copi f cach cost defin sizef distu v v closest cach copi f place otherwis cost defin penaltyf serv request algorithm may modifi placement via arbitrarili long sequenc follow two oper 1 may add copi p incur access cost defin 2 may remov copi p incur cost given capac blowup b goal hcc algorithm maintain bfeasibl placement total cost minim 3 lower bound section show given constant capac blowup b competit ratio onlin hcc algorith is85 depth hierarchi prove lower bound algorithm show exist suitabl hierarchi set file request sequenc feasibl oin hcc algorithm incur factor lower cost request sequenc onlin bfeasibl hcc algorithm result easili extend analyz lower bound competit ratio vari function nonconst capac blowup depth hierarchi particular capac blowup 1 fix 0 competit ratio onlin hcc algorithm still ill present adversari argument lower bound let denot bfeasibl onlin hcc algorithm adv adversari oin feasibl hcc algorithm choos fix valu capac blowup b adv subsequ choos instanc hcc problem ie sixtupl introduc section 2 follow hi erarchi tree consist n units cach form leav regular kari tree depth given choic k set file consist units file diamet everi leaf node ie cach 0 diamet node depth 4bk 1 1 diamet everi intern node least time diamet child 1 file f penaltyf least diamroot given instanc hcc problem describ section 2 give program take input gener request sequenc oin hcc algorithm incur less cost high level on lack futur knowledg empow adv play game analog shell game 1 game maintain compact placement file tailor request sequenc adv gener forc guess off placement incur reloc cost guess incorrectli final zero off placement switch placement around incur small fraction reloc cost alreadi expend repeat game exampl consid simpl twolevel hierarchi associ equals depart within univers set file say universitywid interest remain file departmentspecif interest capac constraint set way depart either cach file interest univers set simultan store file idl depart ie one access activ hand guess ident idl de partment guess incorrectli adv creat request forc move file dierent depart best strategi evenli distribut file across depart yet expos nonidl unfortun even strategi end incur significantli higher cost cours simplist case circumv predica simpli twofold blowup capac use algorithm describ appendix rest paper present formal shellgamelik adversari strategi extens strategi hierarchi nonconst depth 31 adversari algorithm adv fix disjoint set file s0 s1 sd sd call depth file f f defin function gi j adv shown figur 1 key notat use algorithm rest paper explain tabl 31 adv nonneg integ n specifi number request gener code figur 1 show adv gener bad request sequenc section 4 show augment code obtain oin algorithm serv request sequenc incur much lower cost everi node adv maintain two integ field x summar state adv global variabl record current node adv gener next request initi set root program proce round end round algorithm gener request base on adjust placement adv adjust use loop loop former move ancestor latter move descend play especi three walnut shell notat mean parent parent anc ancestor desc descend depth depth diam diamet file cap total capac blowup cach ch children hierarchi place set distinct file place cach load number file f place depth f less depth miss set file f depth f depth f place act gdepth r activ valu react gdepth k reactiv valu deact gdepth 2k deactiv valu tabl 1 key notat initi 1 count n main loop load deact loop 4 everi child set x 0 5 parent 6 od end loop 7 miss loop 8 child satisfi x 0 load react els exactli one child x equal 0 12 everi child set x 0 child set x act 17 od end loop gener request element miss arbitrari cach 19 serv request arbitrarili updat placement count count od end main loop figur 1 adv algorithm 32 correct adv show section adv welldefin ie root line 5 leaf line 8 line 14 find child round termin gener request sake breviti reason call predic global invari hold everywher adv ie hold initi hold two adjac line pseudocod figur 1 lemma 31 let i1 denot everi intern node child x field equal 0 i2 denot intern node i3 denot load deact i1 i2 global invari i3 hold everywher loop proof predic i1 i2 hold initi root i3 hold loop due guard loop next show everi line code loop preserv i1 i2 ie i1 i2 hold line hold line everi line code loop preserv i1 i2 i3 everi line code loop preserv i1 none assign nonzero valu x field line aect i2 line 5 observ root line 5 due guard loop observ root load root deact 0 henc line 5 preserv i2 loop line aect i1 15 i3 inner statement establish least two children x field equal 0 line 14 henc line 15 preserv i1 line aect i2 line 9 14 first observ line 8 depth 4bk 1 i2 state depth 4bk i3 impli depth 4 sinc load integ impli load bk impli miss 4bk contradict guard loop henc depth 4bk1 line 8 therefor line 9 preserv i2 show line 14 also preserv i2 let ch x 0 let r denot denot depth observ load load load load deact react deriv second equal due guard loop definit load first inequ due guard outer statement henc averag argument exist child load act henc line 14 find child shown depth line 8 henc line 14 preserv i2 line aect i3 9 14 line preserv i3 definit act deact react deact claim lemma follow lemma 32 loop termin proof everi iter loop move parent root load root deact definit henc loop termin lemma 33 loop termin proof everi iter loop move one children i2 lemma 31 alway intern node henc loop termin lemma 34 adv termin gener sequenc n request proof follow lemma 32 33 4 cost account section show exist oin hcc algorithm serv sequenc request gener adv incur cost log less incur bfeasibl onlin hcc algorithm 41 properti adv first prove properti adv follow directli structur sake breviti properti global invari sometim state properti omit state properti hold everywher lemma 41 react proof claim hold initi line assign nonzero valu x 15 preserv claim definit act react lemma 42 equal 0 react x proof claim hold initi rooti rootx line modifi x 4 12 15 line modifi 3 4 12 15 inspect code line trivial preserv claim lemma 43 let p denot predic everi node anc posit x valu everi node neither anc child node anc zero x valu p hold initi loop invari loop loop main loop proof initi p hold let denot anc let b denot set node neither children node everi iter loop move parent avoid confus use denot old node ie child denot new node ie parent iter loop remov add ch b set x valu ch 0 therefor preserv p everi iter loop move one chil dren avoid confus use denot old node ie parent denot new node ie child suppos loop take first branch outer statement add posit x valu remov ch b henc preserv p suppos loop take second branch outer state ment line 12 execut p preserv line 12 preserv b chang x valu node neither b line 14 15 preserv p add posit x valu line 15 remov ch b henc preserv p main loop preserv p loop loop preserv p lemma 44 x proof claim hold initi line modifi x field 3 4 12 15 line 4 12 15 x field becom valu follow lemma 43 guard loop line 3 root x 0 follow lemma 41 42 line 3 preserv x introduc notion activ sequenc subsequ proof sequenc a0 a1 ar call iactiv lemma 45 everi intern node nonzero x field children form iactiv sequenc proof claim hold initi root line modifi x field 4 12 15 line 4 12 preserv claim x field children becom preserv claim parent x becom act definit equal gi 1 k j j equal number children parent posit x field lemma 46 let p denot predic ancestor react p hold initi p loop invari loop loop main loop proof predic p hold initi root loop preserv everi iter first establish react move parent loop preserv set field nonzero valu main loop preserv p loop loop preserv p 42 color order facilit present oin algorithm section 43 introduc notion color section notion consist placement next color recal tree cach assign one color white black everi node follow rule observ 1 root white 2 everi intern white node exactli one black child k1 white children 3 children black node black color call consist adv everi x 0 white color c pair sibl node defin swapcc swap color color obtain c exchang color node subtre root correspond node subtre root note subtre root ident structur 43 consist placement placement color exist color c 1 white intern node set file file store fill cach associ uniqu black child 2 white leaf set file file store fill cach note preced definit color place ment color c exist uniqu placement call consist color associ color consist placement p pair sibl defin swappp swap placement placement obtain p exchang content cach correspond cach note color placement p associ color c pair sibl node placement swappp color associ color swapcc 44 offlin algorithm everi intern node maintain addit variabl last defin follow first partit execut adversari algorithm epoch respect first epoch begin start execut subsequ epoch begin either line 4 line 12 execut variabl last updat start epoch set child line 15 execut furthest futur one children line 15 never execut futur last set arbitrari child note variabl last introduc sole purpos analysi impact execut adv point execut adv valu last field determin uniqu color denot coff follow root white black child intern white node last defin oin algorithm maintain placement poff follow initi poff arbitrari consist placement associ color coff updat poff swapppoff whenev line 4 line 12 execut denot valu last execut line algorithm use placement poff serv request gener line 18 placement poff updat serv request poff updat line 4 12 lemma 47 throughout execut adv poff color associ color coff proof immedi way poff updat whenev last field updat lemma 48 execut line 4 line 12 preserv consist coff proof assum coff consist line 4 white coff line 4 lemma 43 x posit line 4 definit coff line 4 last black let last line 4 let last line 4 line 4 x valu descend equal 0 lemma 43 x valu proper descend equal 0 line 4 sinc line 4 x valu descend equal 0 line 4 henc swapp oper preserv consist coff argument appli line 12 lemma 49 execut line 15 preserv consist coff proof assum coff consist line 15 line 14 impli root line 15 let denot parent lemma 43 x 0 henc white line 15 therefor lemma 47 last black child let denot start current epoch ie recent time last assign time x valu children equal 0 definit child set 0 sinc time lemma 31 everi intern node least one child x equal 0 therefor time execut line 15 k 1 children x valu set nonzero valu note line 15 line set x nonzero valu thu definit last lastx remain 0 execut line thu last sinc white last black coff conclud white coff coff remain consist even addit constraint requir white note x set posit valu line 15 lemma 410 placement poff alway consist proof observ coff alway consist due lemma 48 49 observ line 4 12 15 line aect consist coff line modifi last field x field node follow lemma 47 poff alway consist 45 potenti function argument let denot arbitrari onlin bfeasibl algorithm section use potenti function argument show let ton denot total cost incur similarli let toff denot total cost incur except exclud toff cost initi poff initi cost taken account proof theorem 1 defin potenti ancroot parent diam x parent diam x conveni exposit account cost move empti placement first placement separ lemma 411 cost incur swappp parent diam proof cost incur cost exchang file place parent diam note capac lemma 412 predic 0 loop invari loop proof everi iter loop move parent avoid confus use refer old node ie child use refer new node ie parent consid chang singl iter loop incur cost loop definit line 3 preserv lemma 44 line 4 increas let execut line 4 incur cost diam move current consist mark placement next thu total chang iter deriv first inequ due guard loop line 3 second inequ due assumpt diamet node separ lemma 413 predic 0 loop invari loop proof everi iter loop move one children avoid confus use refer old node ie parent refer new node ie child incur cost loop consid follow three case suppos outer statement take first branch case incur cost thu chang inequ due lemma 46 guard outer statement suppos outer statement take second branch line 12 execut case incur cost thu chang first inequ due lemma 44 second inequ due line 14 15 suppos outer statement take second branch line 12 execut lemma 411 case incur cost thu chang due line 12 ch ch deriv first inequ follow lemma 46 first equal follow lemma 45 analysi previou case ie outer statement take second branch line 12 execut line 14 15 increas thu everi iter loop preserv 0 lemma 414 line preserv 0 proof guard loop ensur exist file miss line 18 thu incur cost least parent diam diam line 19 incur cost diam store file miss child let u cach request gener let set node path u exclud sinc add file miss u chang parent diam deriv last inequ follow 8 line 19 allow make arbitrarili mani updat placement suppos updat caus load node increas definit load set node increas load valu form path say leaf incur cost least parent diam let set node path b sinc diamet node path separ chang parent diam parent diam parent diam parent diam parent diam claim lemma follow theorem 1 competit proof initi 0 loop invari main loop therefor lemma 41 44 ton hold initi loop invari main loop let c cost incur move empti placement first placement note ton serv everi request cost least 1 diamet intern node least 1 henc given arbitrarili long sequenc request ton grow unbound therefor make arbitrarili close increas length n request sequenc gener program log bound competit ratio capac claim begin section 3 follow 4bk choos arbitrarili larg 5 discuss cooper cach fact found applic area distribut system exampl nuca nonuniform cach architectur switch network allow data migrat dierent cach region accord access frequenc 8 although nuca support singl processor time write multiprocessor nuca develop data replic possibl 6 r serverless network file system distribut page gener network approxim arbitrari metric tree metric distribut page harvest inform discoveri access system cooper cach use remot client memori improv file system perform tight bound approxim arbitrari metric tree metric adapt placement algorithm hierarch cooper cach amort e squid internet object cach tr amort effici list updat page rule harvest inform discoveri access system serverless network file system distribut page gener network placement algorithm hierarch cooper cach adapt nonuniform cach structur wiredelay domin onchip cach distribut page tight bound approxim arbitrari metric tree metric probabilist approxim metric space algorithm applic