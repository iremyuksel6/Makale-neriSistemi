modulo schedul reduc regist pressur abstractsoftwar pipelin schedul techniqu use product compil order expos instruct level parallel innermost loop modulo schedul refer class algorithm softwar pipelin previou research modulo schedul focus reduc number cycl initi consecut iter term ii consid effect regist pressur produc schedul regist pressur increas instruct level parallel increas regist requir schedul higher avail number regist loop must reschedul perhap higher ii therefor regist pressur import impact perform schedul paper present novel heurist modulo schedul strategi tri gener schedul lowest ii possibl schedul ii tri select lowest regist requir propos method implement experiment compil test perfect club benchmark result show propos method achiev optim ii least 975 percent loop compil time compar convent topdown approach wherea regist requir lower addit propos method compar exist method result indic propos method perform better heurist method almost well linear program method obtain optim solut impract product compil comput cost grow exponenti number oper loop bodi b introduct increas instruct level parallel observ trend design current microprocessor requir combin effort hardwar softwar order effect sinc execut time common program spent loop mani effort improv perform target loop nest softwar pipelin 5 instruct schedul techniqu exploit instruct level parallel loop overlap execut success iter loop differ approach gener softwar pipelin schedul loop 1 modulo schedul class softwar pipelin algorithm propos begin last decad 23 incorpor product compil eg 21 7 besid mani research paper recent appear topic 11 14 25 13 28 12 26 22 29 17 modulo schedul framework reli gener schedul iter loop schedul repeat regular interv depend violat resourc usag conflict aris interv succes iter term initi interv ii constant initi interv impli resourc may use time modulo ii modulo schedul approach consist two step first comput schedul tri minim ii without care regist alloc variabl alloc regist execut time softwar pipelin loop depend ii maximum number live valu schedul term maxliv length schedul one iter ii determin issu rate loop iter regard second factor maxliv higher number avail regist comput schedul feasibl influenc execut time otherwis action must taken order reduc regist pressur possibl solut outlin 24 evalu 16 ffl reschedul loop increas ii gener increas ii reduc maxliv decreas issu rate neg effect execut time ffl add spill code neg effect sinc increas requir memori bandwidth result addit memori penalti eg cach miss besid memori may becom satur resourc therefor ad spill code may requir increas ii final length schedul one iter determin cost epilogu execut main loop order finish last iterarion initi main loop complet see section 21 cost may neglig iter count loop high previou work focus reduc ii sometim also length schelud one iter consid regist requir propos schedul may sever impact perform outlin current trend design new processor increas amount instruct level parallel exploit exploit instruct level parallel result signific increas regist pressur 19 18 exacerb problem ignor effect perform given schedul order obtain effect schedul recent propos modulo schedul approach tri minim ii regist requir produc schedul approach 10 9 base formul problem term optim problem solv use integ linear program approach may produc optim schedul unfortun approach comput cost grow exponenti number basic oper loop bodi therefor impract big loop case time consum part program thu may one benefit softwar pipelin practic modulo schedul approach use product compil use heurist guid schedul process two relev heurist approach propos literatur tri minim ii regist pressur slack schedul 12 stage schedul 8 slack schedul iter algorithm limit backtrack iter schedul choos oper base previouli comput dynam prioriti prioriti function slack oper ie measur schedul freedom oper also depend much critic resourc use oper select oper place partial schedul either earli possibl late possibl choic two altern made basic determin mani oper input output stretchabl choos one minim involv valu lifetim schedul place select oper due lack conflictfre issu slot forc particular slot conflict oper eject partial schedul order limit type backtrack oper eject mani time ii increment schedul start stage schedul whole modulo schedul set heurist techniqu reduc regist requir given modulo schedul object achiev shift oper multipl ii cycl result schedul ii lower regist requir paper present hypernod reduct modulo schedul hrm 1 heurist modulo schedul approach tri gener schedul lowest ii possibl schedul ii tri select lowest regist requir main part hrm order strategi order phase order node schedul predecessor successor node schedul schedul except recurr schedul step node schedul earlyl possibl predecessorssuccessor preliminari version work appear 17 previous schedul perform hrm evalu compar convent approach topdown schedul care regist pressur evalu use thousand loop perfect club benchmark suit 4 account 78 execut time result show hrm achiev optim ii least 975 loop compil time compar topdown approach wherea regist requir lower addit hrm test set loop taken 10 compar two heurist strategi two strategi previous mention slack schedul frlc 27 heurist strategi take account regist requir addit hrm compar spilp 10 linear program formul problem comput requir latter approach small loop use comparison result indic hrm obtain better schedul two heurist approach result close one produc optim schedul compil time hrm similar heurist method much lower linear program approach rest paper organ follow section 2 exampl use illustr motiv work reduc regist pressur modulo schedul loop achiev near optim ii section 3 describ propos modulo schedul algorithm call hrm section 4 evalu perform propos approach final section 5 state main conclus work 2 overview modulo schedul motiv ex ampl section includ overview modulo schedul motiv work present paper detail discuss modulo schedul refer 1 21 overview modulo schedul softwar pipelin loop schedul iter divid stage execut consecut iter distinct stage overlap number stage one iter term stage countsc number cycl per stage ii figur 1 show depend graph run exampl use along section graph node repres basic oper loop edg repres valu gener consum oper graph figur 2a show execut six iter softwar pipelin loop ii 2 sc 5 oper schedul assum fourwid issu machin generalpurpos function unit fulli pipelin latenc two cycl schedul iter obtain use topdown strategi give prioriti oper g f figur 1 sampl depend graph critic path addit constraint resourc use cycl modulo ii figur also show correspond lifetim valu gener iter execut loop divid three phase ramp phase fill softwar pipelin steadi state phase softwar pipelin achiev maximum overlap iter ramp phase drain softwar pipelin code implement ramp phase term prologu steadi state phase execut pattern oper execut stage achiev iter piec code term kernel correspod one stage steadi state phase third piec code call epilogu requir drain softwar pipelin execut steadi state phase initi interv ii two success iter bound either loopcarri depend graph recmii resourc constraint architectur resmii lower bound ii term minimum initi interv reader refer 7 22 extens dissert calcul resmii recmii sinc graph figur 1 recurr circuit initi interv constrain avail resourc number oper divid number resourc notic schedul figur 2a depend violat everi function unit use even cycl cycl modulo odd cycl cycl modulo code correspond kernel softwar pipelin loop obtain ovelap differ stage constitut schedul one iter shown figur 2b subscript code indic rel iter distanc origin loop oper instanc exampl iter kernel execut instanc oper instanc oper b previou iter initi loop valu use loop correspond either loopinvari variabl loopvari variabl loopinvari repeatedli use never defin loop execut loopinvari singl valu iter loop therefor iter 1 iter 2 iter 3 iter 4 iter 5 prologu steadi epilogu ii kernel code iter 6 g f g f g f g f g f g f figur 2 softwar pipelin loop execut b kernel c regist requir requir one regist regardless schedul machin configur loopvari valu gener iter loop therefor differ valu correspond iter natur softwar pipelin lifetim valu defin iter overlap lifetim valu defin subsequ iter figur 2a show lifetim loopvari correspond everi iter loop overlap lifetim differ iter pattern length ii cycl indefinet repeat obtain pattern shown figur 2c pattern indic number valu live given cycl shown 24 maximum number simultan live valu maxliv accur approxim number regist requir schedul 2 section regist requir given schedul approxim maxliv howev experi section measur actual regist requir regist alloc valu lifetim greater ii pose addit difficulti sinc new valu gener previou one use one approach fix problem provid form regist renam success definit valu use distinct regist renam perform compil time use modulo variabl expans 15 ie 2 extens discuss problem alloc regist softwarepipelin loop refer 24 strategi present paper almost alway achiev maxliv lower bound particular wandsonli strategi use endfit adjac order never requir maxliv regist unrol kernel renam compil time multipl definit variabl exist unrol kernel rotat regist file use solv problem without replic code renam differ instanti loopvari execut time 6 22 motiv exampl mani modulo schedul approach lifetim valu unnecessarili larg exampl figur 2a show topdown schedul figur 3a bottomup schedul exampl graph figur 1 machin four generalpurpos function unit twocycl latenc topdown strategi oper schedul predecessor alreadi schedul node place earli possibl order delay possibl successor similari bottomup strategi oper readi schedul successor alreadi schedul case node place late possibl order delay possibl predecessor strategi sever candid schedul algorithm choos one critic schedul topdown schedul node e schedul node f sinc e predecessor place cycl order delay possibl successor place earli possibl figur 2a show lifetim loop variant topdown schedul assum valu aliv begin produc oper begin last consum notic loop variant unnecessari larg lifetim due earli placement e schedul bottomup approach e schedul f therefor place late possibl reduc lifetim figur 3b unfortun c schedul b order delay possibl predecessor schedul late possibl notic vb unnecessari larg lifetim due late placement c hrm oper readi schedul even predecessor successor schedul condit guarante preorder step oper schedul partial schedul contain predecessor successor none absenc recurr order done aim oper previous schedul refer oper except first oper schedul instanc consid node graph figur 1 schedul order fa b c f gg notic node f schedul node fe gg predecessor successor respect partial schedul contain predecessor f schedul order c e two conflict oper topdown bottomup strategi refer oper alreadi schedul place partial schedul figur 4a show hrm schedul one iter oper schedul cycl 0 oper b depend schedul cycl 2 c later schedul cycl 4 point oper f schedul earli possibl g c9 cycl c figur 3 bottomup schedul schedul one iter b lifetim variabl c kernel regist requir ie cycl 6 depend avail resourc cycl delay cycl 7 schedul place oper e late possibl schedul successor e previous place partial schedul thu oper e place cycl 5 final sinc oper g predecessor previous schedul place earli possibl schedul ie cycl 9 figur 4b show lifetim loop variant notic neither c e place late earli schedul alway take previous schedul oper refer point sinc f schedul e schedul refer oper decid late start e figur 4d show number live valu kernel figur 4c steadi state phase execut loop 6 live valu first row 5 second contrast topdown schedul simultaneosli live valu bottomup schedul 9 follow section describ algorithm order node schedul schedul step 3 hypernod reduct modulo schedul depend innermost loop repres depend graph set vertic graph g vertex oper loop e depend edg set edg u v 2 e repres depend two oper u v edg may correspond follow type depend regist depend memori depend control depend depend distanc ffi uv nonneg integ associ edg depend distanc ffi uv two node u v execut oper v depend execut oper u ffi uv iter latenc u nonzero posit integ associ node u 2 v defin cycl c figur 4 hrm schedul schedul one iter b lifetim variabl c kernel regist requir number cycl taken correspond oper produc result hrm tri minim regist requir loop schedul oper u close possibl rel ie predecessor u p redu successor u succu schedul oper way shorten operand lifetim therefor reduc regist requir loop softwar pipelin loop schedul must handl cyclic depend caus recurr circuit schedul oper recurr circuit must stretch beyondomega theta ii whereomega sum distanc edg constitut recurr circuit hrm solv problem split schedul two step preorder step order node actual schedul schedul node time order given preorder step preorder step order node depend graph goal schedul loop ii close possibl mii use minimum number reg ister give prioriti recurr circuit order stretch recurr circuit also ensur node schedul current partial schedul contain predecessor successor node never unless node last node recurr circuit schedul order step assum depend graph connect compon g connect compon decompos set connect compon fg g g order separ final list node g concaten give higher prioriti g restrict recurr circuitin term recmii next preorder step present first assum depend graph function pre orderingg l h freturn list node g orderedg fit take input g fthe depend graph g g fa list node partial order l g fan initi node ie hypernod h g list return list figur 5 function preorder node depend graph without recurr circuit recurr circuit section 31 section 32 introduc modif order deal recurr circuit final section 33 present schedul step 31 preorder graph without recurr circuit order node graph initi node call hypernod select iter process node depend graph reduc hypernod reduct set node hypernod consist delet set edg among node set hypernod replac edg rest node reduc set node edg rest node hypernod final delet set node reduc preorder step figur 5 requir initi hypernod partial list order node current implement select first node graph ie node correspond first oper program order node graph taken initi hypernod 3 node insert partial list order 3 preliminari experi show select differ initi node produc differ schedul function hypernod reductionv 0 gh f creat subgraph g f reduc g 0 node h graph g g els return g 0 figur function hypernod reduct node preorder algorithm sort rest node step predecessor successor hypernod determin node appear path among predecessor successor obtain function search path 4 predecessor successor path connect obtain node reduc see function hypernod reduct figur hypernod subgraph contain topolog sort topolog sort determin partial order predecessor successor append order list node predecessor topolog sort use pala algorithm pala algorithm like alap late possibl algorithm list order node invert successor topolog sort use asap soon possibl algorithm exampl consid depend graph figur 7a next illustr order node graph step step 1 initi list order node empti list fg start design node graph hypernod h figur 7 assum first node graph result graph shown figur 7b append approxim regist requir minor differ caus resourc constraint 4 execut time search path okv k list order node list fag 2 next step predecessor h select sinc predecessor successor select ie node c node c reduc h result graph figur 7c c ad list order node list fa cg 3 process repeat select node g h case select multipl node may path connect node algorithm look possibl path topolog sort node involv sinc path connect g h ad list list fa c g hg reduc hypernod result graph figur 7d 4 h predecessor thu reduc produc graph figur 7e append list list fa c g hdg 5 j successor h order list fa c g hdjg reduc produc graph figur 7f 6 point h two predecessor b path b contain node e therefor b e reduc h produc graph figur 7g subgraph contain b e topolog sort partial order list fi e bg append list order circuit order depend graph shown subsect 31 present order algorithm recurr circuit let us put forward consider recurr recurr circuit classifi ffl singl recurr circuit figur 8a g f g f g f f f f b c e f g h figur 7 exampl reorder without recurr b c figur 8 type recurr recurr circuit share set backward edg figur 8b call recurr subgraph set recurr circuit share set backward edg way figur 8a 8b recurr subgraph ffl sever recurr circuit share node figur 8c 8d distinct set backward edg case consid recurr circuit differ recurr subgraph recurr circuit identifi calcul recmii instanc recurr circuit graph figur 8b fa eg fa b c eg recurr circuit group recurr subgraph worst case may recurr subgraph backward edg instanc recurr circuit figur 8b group recurr subgraph fa b c eg recurr subgraph order base highest recmii valu recurr circuit contain subgraph decreas order node appear one subgraph remov except restrict subgraph term recmii instanc procedur order recurrencesg l list h fthi procedur take depend graph gg fand simplifi list recurr subgraph lg fit return partial list order node listg fand result hypernod hg list pre orderingg 0 list h l 6 function gener subgraphv g fthi function take depend graph g subset node v g fand return graph consist node v edgesg famong themg figur 9 procedur order node recurr circuit list recurr subgraph associ figur 8c ffa c dg fb c egg simplifi list ffa c dg fb egg algorithm order node grah recurr circuit see figur take input list l recurr subgraph order decreas valu recmii entri list list node travers associ recurr subgraph trivial recurr circuit ie depend oper affect preorder step sinc impos schedul constraint schedul previous ensur ii recmii algorithm start gener correspond subgraph first recurr circuit without one backward edg caus recurr remov backward edg higher ffi uv therefor result subgraph recurr order use algorithm without recurr present section 31 whole subgraph reduc hypernod node path hypernod next recurr subgraph identifi order properli use algorithm search path requir backward edg caus recurr remov graph graph contain hypernod next recurr circuit node path connect order appli algorithm without recurr circuit reduc hypernod path hypernod next recurr circuit node recurr circuit reduc hypernod recurr circuit connect hypernod f g ih ka f g kh g b c e figur 10 exampl order recurr procedur process repeat recurr subgraph list point node recurr circuit path connect order reduc hypernod therefor graph contain hypernod remain node graph without recurr circuit order use algorithm present previou subsect instanc consid depend graph figur 10a graph two recurr subgraph fa c fg fg j mg next illustr reduct recurr subgraph 1 subgraph fa c fg one highest recmii therefor algorithm start order isol subgraph remov backward edg obtain graph figur 10b order graph list order node list fa c dfg graph figur 10b reduc hypernod h origin graph figur 10a obtain depend graph figur 10c 2 next step reduc follow recurr subgraph fg j mg purpos algorithm search node possibl path h recurr subgraph graph contain node construct see figur 10d sinc backward edg remov graph recurr circuit order use algorithm present previou section graph order list node append previou one result partial list list fa c df g j mg subgraph reduc hypernod graph figur 10c produc graph figur 10e 3 point partial order node belong recurr initi graph reduc graph without recurr circuit figur 10e graph without recurr circuit order present subsect 31 final list order node list fa c df g j mheb l kg 33 schedul step schedul step place oper order given order step schedul tri schedul oper close possibl neighbor alreadi schedul oper schedul schedul differ way depend neighbor oper partial schedul ffl oper u predecessor partial schedul u schedul earli possibl case schedul comput earli start u earli start v cycl v schedul v latenc v ffi vu depend distanc v u psp u set predecessor u previous schedul schedul scan partial schedul free slot node u start cycl earli start u cycl earli start u 1 notic due modulo constraint make sens scan ii cycl ffl oper u successor partial schedul u schedul late possibl case schedul comput late start u late start pssu set successor u previous schedul schedul scan partial schedul free slot node u start cycl late start u cycl late start ffl oper u predecessor successor schedul scan partial schedul start cycl earli start u cycl minlat start ffl final oper u neither predecessor successor schedul comput earli start u earli start scan partial schedul free slot node u cycl earli start u cycl earli start u found node ii increas 1 schedul step repeat increas ii result opportun find slot advantag hrm node order even schedul step sever trial 4 evalu hrm section present result experiment studi first complex perform hrm evalu benchmark suit compos larg number number registers6080100 loop l4 hrm l4 topdown l6 topdown figur cumul distribut regist requir loop variant innermost loop perfect club 4 select loop includ singl basic block loop condit bodi previous convert singl basic block loop use ifconvers 2 includ loop subroutin call condit exit depend graph obtain use experiment ictineo compil 3 total 1258 loop account 78 total execut time 5 perfect club schedul loop perform hrm compar perform topdown schedul second compar hrm schedul method propos literatur use small set depend graph previous publish result 41 perform evalu hrm use two machin configur evalu perform hrm configur 2 loadstor unit 2 adder 2 multipli 2 divsqrt unit assum unit latenc store instruct latenc 2 load latenc 4 con figur l4 6 configur l6 addit multipl latenc 17 divis latenc root unit fulli pipelin except divsqrt unit pipelin order evalu perform execut time cycl schedul loop estim ii loop time number iter loop perform ie number time bodi loop execut purpos program perfect club instrument obtain number iter select loop hrm achiev loop mean optim term ii least 975 loop averag schedul achiev 5 execut hp 9000735 workstat hrm topdown hrm topdown memori ideal reg reg figur 12 memori traffic infinit regist 64 regist regist hrm topdown hrm topdown l4 l61030cycl reg reg figur 13 cycl requir execut loop infinit regist 64 regist regist consid dynam execut time schedul loop would execut 984 maximum perform regist alloc perform use wandsonli strategi use endfit adjac order extens discuss problem alloc regist softwarepipelin loop refer 24 figur 11 compar regist requir loopvari two schedul techniqu topdown care regist requir hrm two configur mention figur plot percentag loop schedul given number regist without spill code averag hrm requir 87 regist requir topdown schedul sinc machin limit number regist also interest evalu effect regist requir perform memori traffic loop requir avail number regist spill code ad loop reschedul 16 differ altern heurist propos speedup gener spill code among use heurist spill variabl maxim quotient lifetim number addit load store requir spill variabl heurist one produc best result figur 12 13 show memori traffic execut time respect loop schedul schedul infinit 64 regist avail notic gener hrm requir less memori traffic topdown number regist limit differ memori traffic requir schedul increas number avail regist decreas instanc configur l6 hrm requir 88 traffic requir topdown schedul 64 regist avail 32 regist avail requir 825 traffic requir topdown schedul addit assum ideal memori system loop schedul hrm execut faster one schedul topdown hrm give prioriti recurr circuit loop recurr usual produc better result top addit factor increas perform hrm topdown reduc regist requir instanc configur l6 schedul loop hrm produc speedup topdown 118 ideal assumpt infinit regist file avail speedup 120 regist file 64 regist 125 regist notic schedul agress configur l6 requir regist l4 configur degre pipelin function unit import effect regist pressur 19 16 high regist requir aggress configur produc signific degrad perform memori traffic limit number regist avail 16 instanc loop schedul hrm requir 6 cycl execut configur l6 l4 infinit number regist assum 32 regist avail l6 requir 16 cycl l4 42 complex hrm schedul testbench consum 55 second sparc1040 workstat time compar 69 second consum topdown schedul breakdown schedul execut time differ step shown figur 14 notic hrm comput recurr circuit consum 7 preorder step consum 66 schedul step consum 27 even though time spent preorder step overal time extrem short extra time lost preorder node allow simpl fast schedul step topdown schedul preorder step consum small percentag time schedul step requir lot time schedul fail find schedul given ii loop reschedul increas initi interv topdown reschedul loop much often hrm time second hrm topdown schedul prioriti function find recurr comput mii figur 14 time schedul 1258 loop hrm topdown schedul 43 comparison schedul method section compar hrm three schedul heurist method take account regist requir frlc 27 lifetim sensit heurist method slack 12 linear program approach spilp 10 schedul 24 depend graph machin 1 fp adder 1 fp mul tiplier 1 fp divid 1 loadstor unit assum unit latenc add subtract store instruct latenc 2 multipli load latenc 17 divid tabl 1 compar initi interv ii number buffer buf total execut time schedul sparc1040 workstat four schedul method result three method obtain 10 depend graph perform comparison suppli author number buffer requir schedul defin 10 sum buffer requir valu loop valu requir mani buffer number time produc instruct issu issu last consum addit store requir one buffer 20 shown buffer requir provid tight upper bound total regist requir tabl 2 summar main conclus comparison entri tabl repres number loop schedul obtain hrm better ii equal ii wors ii schedul obtain method term applic hrm spilp slack frlc program ii buf sec ii buf sec ii buf sec ii buf sec liver loop5 3 5 linpack whet cycle1 4 4 tabl 1 comparison hrm schedul schedul method initi interv initi interv also show number loop hrm requir less buffer buf equal number buffer buf buffer buf notic hrm achiev perform spilp method term ii buffer requir compar method hrm obtain lower ii 33 loop remain 66 loop ii mani case hrm requir less buffer special compar frlc final tabl 3 compar total compil time second four method notic hrm slightli faster two heurist method addit method perform notic wors find good schedul hand linear program method spilp requir much higher time construct schedul turn perform schedul produc hrm fact time spent spilp due livermor loop 23 even without take account loop hrm 40 time faster slack 7 1 tabl 2 comparison hrm perform versu 3 method hrm spilp slack frlc compil time 032 29072 093 071 tabl 3 comparison hrm compil time 3 method conclus paper present hypernod reduct modulo schedul hrm novel effect heurist techniqu resourceconstrain softwar pipelin hrm attempt optim initi interv reduc regist requir schedul hrm work three main step comput mii preorder node depend graph use prioriti function schedul node follow order order function ensur node schedul partial schedul contain least refer node predecessor successor except particular case recurr tend reduc lifetim loop variant thu reduc regist requir addit order function give prioriti recurr circuit order penal initi interv provid exhaust evalu hrm use 1258 loop perfect club benchmark suit seen hrm gener schedul optim term ii least 974 loop although preorder step consum high percentag total compil time total schedul time smaller time requir conventi topdown schedul addit hrm provid signific perform advantag topdown schedul limit number regist better perform come reduct execut time memori traffic due spill code softwar pipelin execut also compar propos three method spilp integ program formul slack schedul frlc schedul schedul exhibit signific improv perform term initi interv buffer requir compar frlc signific improv initi interv compar slack lifetim sensit heurist obtain similar result spilp integ linear program approach obtain optim solut prohibit compil time real loop r softwar pipelin convers control depend data depend uniform represent highlevel instructionlevel transform perfect club benchmark effect perform evalu supercomput approach scientif array process architectur design ap120bfps164 famili overlap loop support cydra 5 compil cydra 5 stage schedul techniqu reduc regist requir modulo schedul optimum modulo schedul minimum regist requir minim regist requir resourceconstrain softwar pipelin highli concurr scalar process circular schedul new techniqu perform softwar pipelin softwar pipelin effect schedul techniqu vliw machin systol array optim compil reduc impact regist pressur softwar pipelin loop hypernod reduct modulo schedul regist requir pipelin loop effect perform regist requir pipelin processor novel framework regist alloc softwar pipelin ing softwar pipelin parisc compil iter modulo schedul algorithm softwar pipelin loop schedul techniqu easili schedul horizont architectur high perform scientif comput regist alloc softwar pipelin loop parallelis loop exit pipelin architectur decompos softwar pipelin new perspect new approach enhanc modulo schedul loop condit branch modulo schedul multipl initi interv tr ctr spyridon triantafylli manish vachharajani neil vachharajani david august compil optimizationspac explor proceed intern symposium code gener optim feedbackdirect runtim optim march 2326 2003 san francisco california david lpez josep llosa mateo valero eduard ayguad widen resourc costeffect techniqu aggress ilp architectur proceed 31st annual acmiee intern symposium microarchitectur p237246 novemb 1998 dalla texa unit state david lpez josep llosa mateo valero eduard ayguad costconsci strategi increas perform numer program aggress vliw architectur ieee transact comput v50 n10 p10331051 octob 2001 josep llosa eduard ayguad antonio gonzalez mateo valero jason eckhardt lifetimesensit modulo schedul product environ ieee transact comput v50 n3 p234249 march 2001