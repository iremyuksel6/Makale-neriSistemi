use term rewrit verifi softwar paper describ uniform approach autom verif task associ statement represent function abstract data type gener program unit abstract base class program unit annot equat contain symbol defin algebra axiom oper axiom develop use strategi guarante crucial properti converg suffici complet set axiom develop stepwis extens preserv properti verif perform aid program incorpor term rewrit structur induct heurist base idea use boyermoor prover program provid valuabl mechan assist manag induct argument provid hint necessari lemma without formal proof would imposs success limit approach illustr exampl domain b introduct mani differ method use annot softwar prove properti fewer attempt made adapt singl notat varieti differ annot task explor interact type task properti specif demand verif techniqu paper appli equat specif reason techniqu verifi properti statement abstract data type gener program unit deriv class present new techniqu comput weakest precondit statement annot abstract base class class deriv design algebra specif converg suffici complet addit discuss experiment tool partial autom verif activ report experi use techniqu tool research support part nation scienc foundat grant ccr8908565 offic naval research grant n0001487k0307 n001490j4091 rewrit 10 26 central approach use rewrit concept design small specif desir properti complet consist extend specif increment preserv properti also use rewrit concept prove program correct respect specif abstract factor reduc amount detail need consid solv problem specif play key role abstract hide detail implement factor program compon collect program unit common semant rather common syntax weakest precondit 11 statement abstract particular state transform induc statement class state transform satisfi particular postcondit 17 notion weakest precondit extend method propos 20 includ termin sinc termin verif program unsolv somewhat surpris one comput first order express weakest precondit statement 8 32 express howev involv concept godel ture machin reason automat introduc notat call power function describ statement state transform power function describ algebra equat oper appear statement postcondit thu may reason power function autom way reason oper appear program annot power function also allow us address incomplet problem aris verif statement involv abstract data type 24 30 abstract data type permit program proof factor two part proof program depend abstract properti object proof implement type guarante abstract properti second type proof implement manipul concret object must satisfi pre postcondit contain abstract object hoar 21 introduc represent map map concret object correspond abstract object make reason possibl show represent map cast within equat framework allow us reap benefit equat reason autom term rewrit parameter subprogram factor similar oper differ object type thu reduc size program gener claus like ada extend benefit factor program unit manipul object differ type gener formal type paramet repres class type provid basic oper eg assign equal addit gener formal subprogram paramet specifi access addit oper gener unit instanti syntact discrep report type formal actual gener subprogram paramet alphard design 31 among first suggest function defin gener type paramet semant restrict guarante function properli instanti sever research project current investig restrict state check 13 14 16 use equat reason show formal paramet specif denot properti requir actual paramet check gener program compon instanti objectori program languag permit new class defin via inherit superclass defin interfac perhap implement oper inherit subclass order factor implement common oper superclass subclass redefin oper use implement common oper must ensur new oper behavior consist respect superclasss oper subclass must behav like subtyp supertyp group research 31 28 29 current defin subtyp relat present method annot abstract base class class deriv use equat reason ing show deriv class subtyp abstract base class manner similar 19 section 2 discuss four class verif problem although limit size exampl dimens suitabl technic present repres increasingli larger program problem common denomin verif task use equat annot program compon reason annot section 3 address problem qualiti express specif annot base motiv need structur specif rewrit system ensur crucial properti specif overcom inher difficulti equat reason present design strategi extend specif preserv properti rewrit system section 4 briefli describ autom tool formal prove oblig aris verif problem section 5 discuss use tool inform compar perform anoth autom prover section 6 contain conclus annot verif 21 statement power function 2 devic express weakest precondit statement form use state verifi program correct briefli review techniqu show applic two exampl later section show autom step process statement w postcondit r weakest precondit wpw r w respect r describ set state w activ state termin state r satisfi r 11 w statement condit b bodi stmt r defin recurs follow statement defin state wpw rs fals sinc h k rs hold k power function function f whose domain rang ident embodi kfold composit f stmt function comput statement stmt state power function pf stmt defin undefin otherwis everi function uniqu power function total comput primit recurs function impli similar properti power function 2 use notion power function obtain first order express weakest precondit statement respect first order postcondit stmt total function pf power function express p stand minimum nonneg integ exist p hold precis second conjunct right side short hand bpf k least valu k applic stmt origin state produc state b evalu fals yield follow equat right side requir pf power function stmt immedi obtain via equat 1 often find conveni express power function term function captur higher level abstract show one exampl loos speak say power function maximum accumul maximum sequenc case must ensur valid claim ie must prove function pf power function given function f call step valid pf respect f weakest precondit statement manag equat 2 conjunct solv respect k ie valu k explicitli determin call step minim loop loop minim obvious unsolv problem sinc difficult demonstr loop termin follow exampl show minim loop oper consider simplifi weakest precondit exampl 1 consid follow program statement w postcondit r maxa1n largest valu set ang function comput statement bodi stmt return program state examin one compon array power function pf return program state examin slice array maxaij largest valu set mg use induct valid pf ie show inde power function stmt base minim loop requir us demonstr kik n substitut express k calcul wpw r although annot appear use familiar welldefin function addit max actual overload function symbol max assum scalar valu natur number one version max defin two natur anoth array natur third array natur natur algebra axiom permit us defin relat symbol appear specif natarray theta nat theta nat nat natarray theta nat theta nat theta nat nat definit wpw r express initi statement 2 a1 transform equat verifi n 0 verif task outlin express equat verifi chanic task 1 power function valid base case add0 induct case addk 2 loop minim 3 loop initi exampl 2 previou exampl show one may need defin new symbol analysi loop peculiar method classic approach correct verif may fail due lack express data type specif 24 30 exampl kamin show program contain follow statement properli annot lack express usual theori type stack similar result appear 30 equat 2 impli one need properli annot loop power function function abstract loop bodi rather use equat 1 chose formul power function loop term highlevel abstract abstract captur formal intuit concept allow programm code program repeat execut loop bodi effect chop topmost portion revers place top concept separ sequenc initi portion remaind gener usual head tail oper sequenc associ symbol drop take gener oper axiomat stack newstack stack newstack newstack oper drop denot pop 24 requir make type stack express drop power function pop oper take return portion stack drop drop formul power function loop pf function abstract bodi stmt exactli inform state earlier pf k concat revers defin usual stack theta stack stack concatpush stack newstack valid pf prove last equat instanc second case equat 1 stem simpl result 2 th 57 concern equival two formul power function ie accumul vs recurs minim loop defin oper size comput size stack axiomat isnewstack verifi kisnewstacktakek minim loop obtain prove latter equival isnewstackdrops substitut permit us calcul wpw r rpf initi newstack 0 result follow wp program hold 0 22 data type implement modern program languag provid special construct implement userdefin data type construct specif design hide represent type user codelevel verif techniqu discuss exampl 1 2 insuffici address correct implement wide gap lowlevel oper perform code highlevel oper describ oper interfac exampl decrement integ variabl may take pop stack howev verifi variabl decrement ensur code correctli implement pop oper need show code fulfil oblig abstract oper 21 exampl 3 implement data type stack may repres instanc type record follow subtyp index integ rang 1size type data array index item type stack record rang 0size 0 item code fragment belong packag gener argument size posit item privat type correct implement type stack entail type represent map 21 function denot map concret instanc stack repres record abstract counterpart newstack implement stack oper pop straightforward procedur popq stack begin rais underflow els qpntr qpntr gamma input stack q pop rais except qpntr 0 qpntr 0 precondit normal termin procedur precondit satisfi pop simpli decrement qpntr implement correct client stack packag stack represent procedur code may hidden inde perceiv decrement qpntr pop q proof method propos hoar reduc correct implement individu oblig procedur packag omit readabl qualif pntr item oblig procedur pop standard techniqu 20 reduc correct code truth fals first disjunct describ imposs initi state would result normal termin procedur pop except underflow rais represent map defin equat proof oblig discharg automat use tool discuss section 4 23 instanti gener program unit modular essenti featur design implement larg program gener type subprogram paramet ad static type program languag avoid duplic oper sourc code case manipul object oper either implicitli defin gener formal type paramet appear gener formal subprogram paramet interconnect error becom like subtl languag featur use compil andor loader verifi syntact properti modul interconnect verif semant correct entail activ similar requir verif loop data type discuss earlier ie axiomat symbol use assert properti requir modul prove theorem express mean symbol modul exampl 4 mani comput set sequenc element instanc gener paradigm refer accumul 4 exampl find maximum element comput sum element count mani element certain properti comput implement loop whose bodi process new element sequenc iter special variabl whose initi valu depend comput perform accumul result comput portion sequenc process thu far exampl 1 present earlier instanc accumul sequenc element repres array process perform find maximum languag support gener paramet interfac simpl accumul type element accumul result appear follow type type vector arrayinteg rang elem function stepa b elem return elem return elem begin v 0 first last loop stepa vi return gener subroutin instanti eg actual paramet natur nat vect 0 max shown discrep may detect type gener subprogram paramet type actual object bound procedur main function max array new accumulatorelem unfortun syntact discrep report implement accumul may reli semant properti hold bind detect compil exampl certain accumul perform parallel simplest form parallel implement accumul may simultan activ two task task accumul oper half input array feed result function step return desir valu improv implement effici use treelik cascad task execut singl invoc step parallel howev parallel implement accumul assum function bound gener paramet step associ element bound paramet init left ident ie elem step init monoid result establish follow manner let e 1 sequenc valu process accumul function defin techniqu describ section 21 prove function comput code accumul k k j follow equat hold implement accumul parallel describ easi show equat 3 hold elem monoid algebra notat use specifi properti gener subroutin paramet verifi specif actual paramet restrict made explicit write condit includ text specif accumul stepstepx function accumul instanti actual argument replac formal param ter identifi axiom actual replac name formal specif actual argument use prove condit exampl easi verifi condit oper max 0 maximum two natur number specifi exampl 1 likewis instanti requir hold addit multipl exponenti thu exponenti legal bound gener paramet step 24 inherit objectori program languag permit definit new class via inherit subclass inherit data represent oper superclass may add redefin compon use algebra equat specifi behavior class verifi subclass relat also subtyp relat exampl 5 follow exampl shape abstract class serv superclass anoth class object type shape may creat class shape public virtual point center const return point left virtual void move const point void recent const point p move pcenter virtual doubl top virtual doubl bottom virtual doubl left virtual doubl right abstract class use defin interfac oper manipul object creat subclass exampl recent move object new posit circl declar subclass shape redefin latter center oper effici version provid definit oper pure virtual function shape ie move top etc class circl public shape public circl const point c const doubl inlin void radiu const doubl r assert r0 radiu r inlin doubl radiu const return radiu inlin void center const point c center c inlin point center const return center inlin void move const point p centermovep doubl top const return centeri doubl bottom const return centeri radiu doubl left const return centerx radiu doubl right const return centerx privat point doubl radiu pass refer circl object recent invok circl center move oper point p11010 p255 circl cp120 use algebra specif defin mean shape oper first argument abstract oper f model correspond concret oper f class instanc f belong exampl refer program fragment recenterc p2 abstract counterpart crecenterp2 specifi abstract class shape mean sort rather describ relationship class defin oper complet specif critic issu heurist consid pair tripl etc member function shape captur mutual depend algebra equat remov obvious redund equat specif defin mean oper manipul object type shape use specif may prove correct implement member function pure virtual assum correct futur implement member pure virtual discuss earlier verif condit conjunct ensur argument recent remain constant proof implement recent reli pre postcondit shape center move oper proof hold recent pass object whose type deriv shape object type must subtyp mere subclass type shape show must demonstr relationship among oper shape hold oper instanc circl specif circl shown differ shape sinc latter classic abstract data type rather abstract class c sens first condit class invari ensur everi circl nonneg radiu circl oper annot usual 21 although standard proof techniqu imper languag 11 20 may fall short prove objectori code concern differ problem want prove circl subtyp shape task verifi annot shape hold everi instanc circl activ similar prove circl implement shape techniqu propos 19 minor differencea circl shape thu represent function equal interpret involv proof proof easili formul problem theorem prover complet automat design specif annot problem discuss previou section formul resolv use first order formula formula involv symbol specif whose atom compon equat section discuss design equat specif goal produc equat specif easi process automat process limit prove formula express correct piec softwar also includ analyz specif determin satisfi properti whose absenc often sign flaw major obstacl autom declar natur equat chang equat rewrit rule make specif oper simplifi problem 31 rewrit unrestrict freedom provid equat reason replac term equal term lead combinatori explos possibl hard manag prover whether autom human equat orient yield rewrit rule rewrit rule still defin equal 1 2 allow replac instanc 1 correspond instanc 2 forbid replac opposit direct orient equat transform algebra specif term rewrit system 10 26 two crucial properti must achiev equat orient two term provabl equal equat reason common reduct ie third term rewritten properti refer confluenc churchross addit possibl rewrit term forev particular circular rewrit properti refer termin noetherian system properti canon complet converg knuthbendix complet procedur 27 attempt transform equat specif complet rewrit system termin procedur guarante execut may requir human intervent difficulti stem undecid whether rewrit system canon 9 22 reason attempt convert equat specif correspond complet rewrit system rather ask specifi structur specif rewrit system characterist task eas consider two strategi use design specif techniqu also ensur properti suffici complet deem essenti framework 32 suffici complet constructorbas system appli techniqu consid constructorbas system ie partit signatur symbol constructor defin oper constructor type gener data instanc valu repres term call normal form reduc term contain defin oper repres comput exampl constructor natur number 0 successor denot postfix 1 exampl constructor type stack discuss exampl 2 newstack push sinc stack either empti obtain push element stack concat revers exampl defin oper consid constructorbas system rais problem suffici complet yet anoth undecid properti 25 specif type suffici complet must assign valu term type 18 specif structur constructorbas rewrit system suffici complet equival properti normal form constructor term left side axiom defin oper outermost oper constructor term argument state necessari suffici condit suffici complet specif constructor enumer 7 set c tupl constructor term substitut constructor term variabl tupl c exhaust unambigu gener set tupl constructor term set tupl argument defin oper constructor enumer exampl set tupl argument drop discuss exampl 2 shown constructor enumer hnat stacki sinc everi pair hx yi x natur stack instanc one one element c set tupl argument oper max 0 discuss exampl 1 constructor enumer sinc h0 0i instanc h0 ii hi 0i second axiom although differ affect specif latter axiomat remov triv ial ambigu note right side second axiom defin specif would inconsist sinc would consequ axiom oper overspecifi two rule use rewrit combin argument underspecifi rule use rewrit combin argument overspecif detect superposit algorithm 27 use unif detect overlap underspecif natur condit oper although creat nonneglig problem systemat avoid exampl framework ordersort specif 15 underspecif detect algorithm inform describ 23 oper underspecifi call complet defin huet hullot devis algorithm detect incomplet defin oper algorithm assembl argument axiom tupl term th posit tupl check see includ variabl instanc constructor constructor c tupl remain argument constructor c variabl posit form recurs test rigor descript appear 23 way exampl execut algorithm set c input constructor 0 posit 1 tupl 1 consid set tupl remain argument fhsig trivial complet constructor successor posit 1 tupl 2 3 consid set tupl remain argument fhnewstacki hpush eig contain instanc constructor stack posit 1 complet recurs problem fhig newstack fh eig push obviou ensur confluenc constructorbas specif suffici avoid overspecifi cation ensur suffici complet necessari suffici avoid underspecifica tion oper complet defin termin specif suffici complet fact everi term normal form obvious contain constructor symbol term contain defin oper reduc underspecif overspecif easili check syntact properti howev termin rewrit system undecid 9 next section discuss syntact properti suffici ensur termin show obtain design strategi 33 design strategi axiom confluenc suffici complet undecid although essenti properti spec ific lack confluenc impli comput ambigu specifi lack suffici complet impli comput unspecifi regard condit seriou flaw specif describ two design strategi gener confluent suffici complet specif binari choic strategi interact iter nondeterminist procedur sequenc binari decis gener left side axiom defin oper use symbol call place placehold decis let f oper type consid templat th place sort get rule left side must replac place templat either variabl constructor term appropri sort form left side neither want forget combin argument includ combin twice want avoid underspecif overspecif equival form constructor enumer achiev goal select place templat chose one two option variabl induct choic variabl replac select place fresh variabl choic induct place sort split correspond templat sever new templat one constructor c sort new templat replac select place c mani place ariti c formal descript strategi appear 3 appli strategi design left side rule oper drop discuss exampl 2 initi templat chose induct first place sinc sort place natur split templat two new templat one associ 0 successor chose variabl remain place first templat variabl first place second templat obtain chose induct last remain place sinc sort place stack split templat two new templat one associ newstack push obtain remain choic variabl select complet rule left side describ second strategi ensur termin recurs reduct term term obtain strip recurs constructor constructor sort call recurs argument sort exampl successor push recurs constructor strip term ct deriv oper recurs constructor remov outermost applic constructor strip process recurs appli throughout term formal descript recurs reduct function appear 3 show applic exampl reason becom clear shortli interest comput recurs reduct left side rewrit rule use correspond right side symbol right side rule denot recurs reduct rule left side convent last axiom drop written sinc recurs reduct left side dropi obtain replac 1 sinc recurs argument successor replac push e sinc recurs argument push constructor sever recurs argument recurs reduct requir explicit indic select argument may also specifi partial rather complet strip recurs constructor recurs reduct strategi consist defin right side rule use function composit symbol termin term rewrit system recurs reduct correspond left side specif design use binari choic recurs reduct strategi canon suffici complet 3 34 design strategi specif strategi lead natur design approach call stepwis specif extens 12 given specif step extend specif ad oper yield new specif i1 i1 complet consist extens 12 everi data element i1 alreadi distinct element remain distinct i1 furthermor canon suffici complet i1 3 clarifi concept show step yield specif exampl 2 initi specif 0 consist sort boolean natur stack constructor ie true fals 0 successor newstack push sinc rewrit rule ie constructor free canon suffici complet 0 trivial establish extend 0 oper concat obtain 1 concatpush recurs reduct left side concat sinc design concat axiom use binari choic recurs reduct strategi 1 complet consist extens 0 canon suffici complet specif step may also extend take size isnewstack howev extend 0 revers right side one axiom revers contain concat must first establish properti specif contain concat henc separ step necessari extend 1 oper revers obtain 2 newstack strategi togeth stepwis approach ensur 2 complet consist extens 1 canon suffici complet specif specif present note design manner binari choic strategi forc us construct left side plausibl axiom want defin right side complet definit axiom place distinguish symbol right side specif languag follow equival approach control incomplet exampl larch would declar exempt term appear left side one axiom singl strategi use also presenc nonfre constructor properti specif nonfre constructor confluenc longer automat guarante check easili strategi use design specif 3 prove theorem annot exampl previou section contain mani small theorem need prove autom proof make easier carri less prone error section report experi task 41 induct mani equat eg prove rewrit ie use equat reason equat prove via structur induct 6 data type induct 19 induct variabl type replac term determin constructor induct hypothes establish f formula prove v induct variabl type v induct proof carri follow manner everi constructor c skolem constant induct hypothesi 42 autom theorem prover implement prototyp theorem prover incorpor mani concept boyermoor theorem prover 5 howev except builtin knowledg term equal data type induct knowledg theorem prover suppli specif theorem prover check function complet defin execut huet induct definit check identifi induct argument fill instanc constructor discoveri induct argument allow prover gener automat theorem constitut case proof induct theorem prover execut four basic action reduc fertil gener induct reduc appli rewrit rule formula prove fertil respons use induct hypothesi ie replac subterm current formula equival term induct hypothesi gener tri replac nonvari subterm common side formula fresh variabl induct select induct variabl gener new equat induct variabl chosen set induct argument heurist includ popular 5 senior theorem prover comput boolean recurs function call prove whose input equat whose output true equat prove axiom lemma specif access global data proof theorem gener side effect comput prove user may overrid automat choic made prover induct variabl gener techniqu discuss later allow user use case analys proof function prove begin e form x x term x return true end e reduc return provereduce end e fertil return provefertilize end contain induct variabl return return fals attempt prove theorem may exhaust avail resourc sinc induct may gener infinit sequenc formula prove howev termin properti rewrit system guarante equat reduc forev elimin previous use induct hypothes 5 guarante equat fertil forev 5 experi prove theorem proof discuss previou section complet gener theorem prover except two proof inherit properti mani proof produc automat prover other gener suppli addit lemma independ prove use theorem prover valid proof power function statement exampl done automat term rewrit other rewrit induct minim proof slightli challeng array exampl requir three simpl lemma eg prove ad set axiom theorem prover could finish proof lemma suggest similar term opposit side equat gener theorem prover gener inhibit obtain minim proof stack exampl explain relationship differ skolem constant insert time may lost gener replac term contain constant new constant attempt verifi gener equat gener replac sizea1 new skolem constant b2 start verifi lemma relat a1 b2 lost gener crucial valid theorem nest induct equat rewritten proof attempt fail simpli inhibit gener case solv problem theorem prove rewrit induct howev gener essenti proof illustr exampl also show discov lemma make proof possibl simpler proof total correct exampl 2 requir verifi induct formula prove becom prover simultan gener reversetakesizea1 a1 pushnewstack a2 attempt prove proof easili complet nest induct a6 a7 without gener proof continu induct a1 induct hypothesi strong enough complet proof prover keep gener new induct formula increas complex avail resourc exhaust regard gener formula lemma often abl gener lemma suggest prover exampl equat 4 suggest newstack might right ident concat thu prove use lemma origin proof immedi reduc origin formula presenc lead revers side equat suggest equal may depend argument thu attempt prove proof succe use result lemma origin proof two lemma origin proof becom trivial lemma obtain remov context gener hypothes truth equat depend certain intern specif portion side latter exampl hypothes truth equat depend certain extern specif portion side ie proof condit requir semant correct gener instanti accumul attempt oper max 0 see exampl 1 addit multipl exponenti theorem rel first three instanti prove automat howev attempt prove associ exponenti fail prover attempt verifi nest induct equat reduc prover halt messag fail case thu first three instanti gener accumul semant correct interestingli fact equat 3 hold step associ init left ident prove automat prover revers stack discuss exampl 2 parallel divideandconqu techniqu similar discuss accumul program instanc complex case accumul type result accumul differ type element accumul sequenc may exploit parallel assum stack dynam alloc chunk chunk consist fixeds arraylik group contigu memori locat address index chunk alloc demand necessarili occupi contigu locat memori rather thread togeth pointer link list revers stack parallel stack consist sever chunk case split stack two nonempti portion say x link togeth whole chunk assum bottommost chunk x point topmost chunk revers link recurs revers x portion stack consist singl chunk swap content chunk memori locat achiev revers correct parallel implement stack revers reli equat revers concat defin exampl 2 oper concat stand oper link togeth two portion stack repres argument revers overload multichunk stack partit recur wherea singlechunk stack swap proof equat entail mutual relationship symbol implement thu represent chunk type stack issu proof obvious comprehens proof correct differ two comput associ revers must account eg discuss section 22 prover prove equat without human help interestingli proof induct x prover automat gener prove independ lemma case induct one lemma state newstack right ident concat concat associ section 24 present annot involv c predefin type doubl axiomat type mean algebra induct specif consequ could use prover theorem reli intrins properti type howev proof section except left right bottom top easili prove provid simpl unprov lemma commut doubl 51 inform comparison need suppli guidanc automat prover peculiar implement exampl larch theorem prover lp 13 design proof checker well autom prover consid approach sensibl guidanc requir prover form lemma lemma simplifi proof improv understand remov context case also overcom lack certain proof tactic friendli interfac implement briefli compar lp prover prove two sampl theorem propos 13 proof involv type linear contain prioriti queue whose axiom shown total order type boolean standard oper member next nextinsertq els nextq c nextq els c symbol axiom next correspond larch declar exempt nextnew lp use prove theorem e e first theorem prove induct variabl c explicitli pick second theorem requir intervent rewrit produc lp given seri command divid proof case appli criticalpair compl tion case isemptyq requir criticalpair complet case isemptyq requir case analysi truth v nextq case subdivid base truth case v nextq criticalpair complet request prover also verifi theorem first automat second ad lemma axiom sinc prover knowledg deriv axiom treat condit express implic special manner repres mean userdefin oper exampl implic defin follow axiom true fals thu often need lemma manipul function sinc prover handl equat formul second theorem prover automat choos a0 induct variabl base case new trivial prove rewrit induct case true induct hypothesi reduc left side larg nest condit express use two standard lemma simplifi one distribut respect condit ie replac instanc x b els z b x els x z transform allow use properti order relat irreflex impli equat 13 fig 9 lemma split implic whose anteced disjunct ie replac instanc x z z z transform allow use anteced independ applic lemma left side equat prove becom enabl use anteced conjunct formula mean two specif lemma approach directli inspir 5 one lemma replac instanc lemma replac instanc q hold specif instanc latter membera2 a1 ie contraposit form first theorem prove problem sever infer step left side reduc continu case nexta2 a3 express negat appear formula although prover lack proofbycas tactic simul lemma p formula prove x boolean subexpress p use lemma rewrit p x p replac subexpress x p known impli x likewis conjunct reason case allow us crossfertil p 5 use lemma trigger addit rewrit activ transform left side conjunct anteced nexta2 a3 rewritten fertil induct hypothesi reduc true continu case membera2 a1 truth theorem depend standard properti order relat first conjunct rewritten consequ hold transit success reduc consequ true second conjunct eventu reduc true true thu proof termin success complex proof compar obtain lp induct variabl chosen automat less case analysi requir need invok knuthbendix complet although techniqu occasion use find proof gener difficult understand thu prefer tactic situat allow data type induct eg non constructorbas specif provid lemma prover lemma either trivial instanc trivial lemma schema although suggest requir understand proof mix bless effort understand proof go help discov relev properti specif may lead better specif even code enhanc user interfac prover primit consequ iter proof attempt sever time complet creat manual instanc lemma schema suppli prover 6 conclud remark discuss formal verif techniqu problem character differ size address properti loop critic compon small program problem solv domain correct termin lack express axiomat use annot inher difficulti reason repeat modif program state data type implement repres medium size program crucial problem solv mutual intern consist group relat subroutin bound choic represent abstract concept mean structur offer hardwar architectur andor program languag proof correct domain entail code also represent map physic presenc softwar modul interconnect signific featur larg program syntact semant commit one compon may match expect anoth problem exacerb languag allow custom softwar unit mean unit prove correct involv code directli annot gener proof correct previou problem task address common formal equat specif proof techniqu rewrit induct particular formal base specif qualit extent quantit point view independ task size furthermor discuss conceptu practic tool design use specif crucial requir specif adequaci assumpt specif good often mistaken unless consider care devot design sever properti unfortun undecid gener use address qualiti specif shown restrict express power specif languag common fundament properti guarante hard say whether restrict sever encourag discov typic verif problem propos literatur pose sever problem propos specif easi use human autom tool rewrit fundament idea behind approach design strategi present design rewrit rule ensur properti smaller unit specif defin oper strategi also allow us build specif increment way preserv properti smaller unit build larg specif smaller one gloss problem modular parameter specif approach compat variou techniqu propos featur respect properti abl guarante eas composit specif hardest task nearli verif problem prove theorem inform proof easier understand formal one less reliabl formal proof except simplest problem complic human without autom tool proof contain hundr infer major simpl rewrit step prover becom effect occasion hint lemma suppli macrostep prover lack knowledg experi would carri complet certain context find appropri lemma alway easi howev lemma discuss comparison lp rel standard other suggest prover gener gener sometim find eleg lemma final inspect proof attempt abl detect repeat pattern formula increas complex gener lead proof failur condit aris look lemma overcom problem believ specif approach adequ larg number case howev prover still fail solv nontrivi problem autonom manag bookkeep induct provid hint necessari lemma complet remov tedium rewrit cleric mistak associ activ print readabl proof although sometim make infer necessari prover rewrit strategi nermost outermost rewrit strategi would produc shorter readabl proof show remark skill find induct variabl despit consider limit user interfac proof tactic prover increas qualiti specif enhanc consider human abil produc formal proof softwar problem r parallel objectori languag inherit subtyp automat provabl specif design strategi rewrit rule develop iter program function specif comput logic prove properti program structur induct complex analysi termrewrit system mathemat theori program correct termin rewrit rewrit system disciplin program fundament algebra specif 1 equat initi semant debug larch share languag specif ieee comput oper semant ordersort algebra introduc obj3 note type abstract algebra specif abstract data type abstract data type softwar valid axiomat basi comput program proof correct data represent confluent reduct abstract properti applic termrewrit sy tem proof induct equat theori constructor express theori stack sufficientcomplet relat properti term rewrit system rewrit system simpl word problem univers algebra modular specif verif objectori program famili valu semant notion subtyp new incomplet result hoar system introduct construct verif alphard program verif program predic transform tr reus interconnect softwar compon express theori stack termin rewrit complex analysi termrewrit system parallel objectori languag inherit subtyp debug larch share languag specif rewrit system rewrit system new incomplet result hoar system confluent reduct abstract properti applic term rewrit system abstract data type softwar valid axiomat basi comput program mathemat theori program correct disciplin program fundament algebra specif modular specif verif objectori program oper semant ordersort algebra design strategi rewrit rule ctr olivi ponsini carin fdle emmanuel kounali rewrit imper program logic equat scienc comput program v56 n3 p363401 mayjun 2005 antoy dick hamlet automat check implement formal specif ieee transact softwar engin v26 n1 p5569 januari 2000