parallel ram own global memori determinist contextfre languag recognit identifi studi natur frequent occur subclass concurr read exclus write parallel random access machin crewpram call concurr read owner write crowpram machin global memori locat assign uniqu owner processor processor allow write consid difficulti would involv physic realizinga full crewpram model demonstr stabil sever definit chang second precis character power crowpram show class languag recogniz time olog n implic polynomi number processor exactli class logdcfl languag log space reduc determinist contextfre languag third use basic machineri show recognit problem determinist contextfre languag solv quickli determinist auxilliari pushdown autom random access input tape log n space work tape pushdown store small maximum height exampl time on1 egr achiev pushdown height olog2 n result extend unifi work von braunmhl cook mehlhorn verbeek klein reif rytter b sever definit chang second precis character power crowpram show class languag recogniz time olog n exactli class logdcfl languag log space reduc determinist context free languag third use basic machineri show recognit problem determinist contextfre languag solv time 1ffl sn ffl 0 log 2 n sn n determinist auxiliari pushdown automaton log n space work tape pushdown store maximum height sn random access input tape result extend unifi work von braunmuhl cook mehlhorn verbeek klein reif rytter 1 introduct relat work fairli larg bodi literatur parallel random access machin pram model algorithm nearli mani definit model paper subject agre gener featur model collect less ordinari sequenti processor privat local memori access share global memori model synchron time unit processor execut one instruct much divers regard featur model exampl differ whether model singl multipleinstruct stream mani processor number activ instruct set input convent use simultan read write request singl global storag locat arbitr variat make littl differ power model two featur seem substanti impact power model one uniform gener consid uniform model paper ie one singl program suffic input length singl processor initi activ creat processor desir second sensit featur arbitr memori access conflict two main variant intens studi follow nomenclatur introduc vishkin 37 crcw concurrentread concurrentwrit pram allow memori access conflict processor read given locat given step receiv valu among processor crowpram dcfl recognit 3 write given locat given step one allow succeed eg one lowest processor number resolut rule write conflict propos known equival power constant factor run time polynomi factor number processor global memori size although model separ processor memori tightli constrain crew concurrentread exclusivewrit model concurr read allow concurr write crew algorithm must arrang two processor attempt write global memori locat time paper introduc third variant argu natu ral model crew pram give surpris character power sever reason studi restrict crew pram crewpram model critic power serv realist model physic realiz parallel machin due unbound fanin anderson snyder 1 point twostag program process first use crewpram model develop straightforward fulli parallel algorithm eg n bit emul algorithm physic realiz network could lead suboptim algorithm thetalog n 2 exampl nevertheless crewpram arguabl popular theoret model design specif analysi parallel algorithm due princip simplic use global memori model programm use therefor consid power restrict crow pram model order understand feasibl model parallel program note crewpram algorithm fact crowpram algorithm easili modifi crewpram algorithm ensur obey exclusivewrit restrict two except discuss crewpram algorithm consid achiev easili modifi achiev write exclus follow simpl stratagem global memori locat own one processor processor ever allow write cell map global memori address processor number easi comput processor difficulti determin cell own ex 4ampl processor p might block k consecut cell begin global memori address kp call ownerwrit restrict call pram obey restrict concurrentread ownerwrit pram crowpram ownership restrict seem natur framework design exclusivewrit algorithm similar ident notion ownership appear earlier lower bound work cook et al 7 also proven use practic certain cach coher protocol see eg archibald baer 2 mani current architectur parallel system machin provid global memori program model implement use physic hardwar everi memori cell local processor cach techniqu use amelior cost access nonloc memori nonloc write prohibit necessari cach coher algorithm simplifi fact posit solut crow versu crew problem discuss section 3 would presum suggest interest new approach cach coher problem give precis definit crowpram model section 2 main goal paper investig power crow pram unexpectedli question turn intim relat complex determinist contextfre languag dcfl recognit recognit problem determinist contextfre languag l decid given word x whether x 2 l sequenti complex problem wellstudi mani practic sequenti algorithm solv space time smallspac parallel time complex problem less wellunderstood two main result area von braunmuhl cook mehlhorn verbeek 5 38 klein reif 20 cook 5 present sequenti algorithm dcfl recognit problem run polynomi time ture machin use polynomi log n space result improv von braunmuhl et al 38 give ture machin algorithm optim timespac product space bound rang log n 2 n build somewhat idea 5 38 klein reif 20 present olog n time crewpram algorithm dcfl recognit known result stockmey vishkin 35 combin crowpram dcfl recognit 5 algorithm ruzzo 32 yield olog n time algorithm gener cfl recognit power crcwpram model main result follow character crowpram theorem 1 languag l accept crowpram olog n time l logspac reduc dcfl class logdcfl languag logspac reduc dcfl first defin studi sudborough 36 show equal class languag recogniz polynomi time logspac bound determinist auxiliari pushdown automata dauxpda defin cook 4 result appear first precis character parallel time complex class constant factor term sequenti one exampl sudborough hardest dcfl 36 provid natur exampl problem complet crowpram time olog n complet problem discov chandra tompa crcwpram time class 3 know analog natur problem complet crew class follow earlier version paper 12 lang niedermei 22 establish character pram variant term sequenti complex class use dcfl character demonstr stabil crowpram complex class definit chang exampl follow dcfl simul crowpram simul time loss parallel machin global memori processor contain singl extern visibl regist may read written processor model seem closer way parallel machin actual construct model independ global memori associ processor dcfl recognit algorithm von braunmuhl et al 38 klein reif 20 difficult one use superfici differ approach third goal paper provid unifi approach problem although base believ simpler either obtain small time parallel algorithm small space sequenti algorithm dcfl recognit use basic approach small space algorithm provid improv result rytter 33 technic refin optim result von braunmuhl et al 38 rytter shown use sequenti implement 20 possibl obtain polynomi time olog 2 n space algorithm dcfl recognit use space mainli pushdown store precis log n space dauxpda olog 2 n bound pushdown rather unrestrict olog 2 n space 38 improv result perform simul dauxpda like rytter attain timespac product similar von braunmuhl et al section 2 present crowpram model discuss variat definit section 3 present simul determinist auxiliari pushdown automata establish crowpramtimelog n logdcfl section 4 introduc definit notat need dcfl recognit algorithm section 5 present high level descript correct proof dcfl recognit algorithm section 6 discuss crowpram implement algorithm establish inclus need theorem 1 ie logdcfl crowpram timelog n final section 7 refin simul section 5 obtain faster sequenti algorithm obtain combin crow pram algorithm section 6 gener simul section 3 work involv own global memori concept pram appear follow preliminari version paper 12 fich wigderson give lower bound separ erow crow pram 14 rossmanith introduc studi owner read owner write pram show exampl list rank olog n time 31 nishimura consid owner concept crcwpram 29 nieder meier rossmanith 27 26 consid owner concept pram variant lin et al show crowpram suffici power execut variant cole parallel merg sort algorithm time olog n 23 work restrict crowpram model lam ruzzo 21 dymond et al 11 describ end section two crowpram dcfl recognit 7 2 definit crowpram start defin crewpram model use mention detail definit critic specif use definit fortun wylli 15 call simpli pram unbound global memori unbound set processor accumul instruct counter unbound local memori memori cell hold arbitrari nonneg integ instruct repertoir includ indirect address load store add subtract jump jumpifzero read fork halt input place sequenc special readonli regist one bit per regist read instruct allow processor read input bit concurr read allow fork instruct caus new processor creat local memori cell zero accumul initi valu accumul creator initi one processor activ local memori zero length input given accumul model accept initi activ processor halt one accumul reject two processor attempt write global memori locat time crewpram processor number id builtin concept need adopt follow processor number scheme uniqu processor activ initi number 0 first child processor creat processor number 2i second number 2 1 correspond natur embed arbitrari tree processor activ tree binari tree rule eldest child becom right child next younger sibl becom left child reversepreord travers activ tree binari tree ident see mani number scheme also work one fairli natur processor automat know number easi program comput need algorithm crewpram algorithm exist function owneri n comput determinist space olog n input length n processor p attempt write global memori locat intuit definit given earlier said owner function simpl particular requir logspac comput oblivi ie independ input except length requir model detect illbehav program ie one attempt global write violat ownership constraint program simpli crow program seem natur choic also show main result fairli insensit issu could gener model follow way g1 allow owner function depend input g2 allow owner function depend time g3 allow bound multipl ownership ie owneri n set size o1 processor number g4 allow illbehav program defin model halt reject attempt write violat ownership constraint g5 allow processor number scheme give processor uniqu number allow one comput logarithm space parent given processor p number older sibl number k th child g6 allow owner parent sibl function comput determinist logspac auxiliari pushdown automaton run polynomi time altern could restrict model follow way r1 requir owner function ident equival say machin global memori instead collect processor privat local memori one global readabl commun regist r2 requir processor use o1 local memori locat crowpram dcfl recognit 9 r3 requir machin writeoblivi ie time locat write global memori independ input except length one consequ result crowpram even one satisfi rel weak condit g1g6 simul crow pram satisfi strict condit r1r3 constant factor increas time polynomi increas number processor possibl crew crowpram equival power posit side condit g1g6 fairli gener difficult imagin protocol pram algorithm could achiev writeexclus would cover exampl note gener crew pram algorithm consid crowpram algorithm owner function allow input timedepend condit g1 g2 sens comput crewpram real time know say crewpram time olog n simul logarithm space determinist auxiliari pushdown automaton run time n olog n realtim crewpram comput function may differ n o1 dauxpda comput one thu seem possibl time crowpram crewpram might ident least provid intuit support empir observ known crewpram algorithm crowpram algorithm one context know two model equival follow appear extend abstract paper 12 ragd person com munic see also fich 13 nisan 28 observ nonuniform crow pram ie one arbitrari instruct exponenti mani processor initi activ allow differ program valu n run time equival boolean decis tree depth 2 nisan 28 establish set recogn nonuniform crew pram time olog n n equival boolean decis tree problem depth 2 tn taken togeth result show time two model constant factor nonuniform set leav open stronger conjectur set recogn crewpram time log n recogn crowpram time olog n ordinari uniform varieti use polynomi mani processor note nisan simul crew crow use nonuniform fundament way use 2 2 tn initi activ pro cessor nonuniform model languag recogniz olog n step one restrict set know two uniform nonuniform model differ suppos processor 1 n activ know one bit b want comput bit given one b 1 crewpram solv one step processor 1 bit write global locat 0 writeconflict happen sinc one 1 bit howev marc snir person commun shown crowpram n step solv problem initi state snir result settl gener question howev problem discuss defin one input bit one call partial domain fich contrast usual situat algorithm requir produc correct answer nbit input sequenc know result cook et al 7 even crewpram requir time omegagammam n test whether input contain one 1 bit conceiv crew algorithm exploit someth like snir could alway transform crow algorithm use preprocess time better advantag full domain problem known us uniform crew pram seem power crowpram recognit problem unambigu contextfre languag problem rytter 34 given olog n crewpram algorithm appear use power nonown exclus write fundament way loos speak seem unambigu underli grammar allow one repeatedli exploit featur like snir crowpram appear nearli power crew pram interest compar possibl weaker parallel model parallel pointer machin dymond cook 10 ppm consist unbound pool finitest transduc finit set pointer processor ppm oper sens output neighbor processor move pointer processor adjac current neighbor cook propos model exampl simplest possibl parallel machin variabl structur 6 crowpram dcfl recognit 11 lam ruzzo 21 establish time ppm linearli relat time restrict version crowpram doubl ad one arithmet oper permit fact also show simultan linear relationship amount hardwar use two machin conjectur crowpram abil access twodimension array constant time directli emul crowpram whose arithmet capabl limit prove recent dymond et al 11 sinc twodimension array appear play import part dcfl simul algorithm section 6 suggest quit differ techniqu would need recogn dcfl time olog n ppm inde possibl analog nonconst lower bound two dimension array access prove sequenti unit cost successor ram dymond 9 3 simul crowpram dauxpda section prove first half theorem 1 name theorem 2 set recogn time olog n crowpram logdcfl recal logdcfl class languag log space reduc determinist contextfre languag sudborough 36 defin class character set languag recogn polynomi time logarithm space determinist auxiliari pushdown automaton main construct similar analog one given pratt stockmey 30 fortun wylli 15 goldschlag 17 show pram time log n contain dspacelog 2 n defin three mutual recurs procedur statet p return state processor p time ie th instruct execut localt return content locat local memori processor p time globalt return content global memori locat time depend valu procedur time gamma 1 recurs depth furthermor procedur requir olog n bit local storag wellknown techniqu procedur implement logarithm space determinist auxiliari pda whose pushdown height olog 2 n much proof essenti 15 17 30 main novelti proof algorithm run polynomi time rather time n log n earlier result possibl owner function allow us globalt directli identifi possibl writer global memori locat time gamma 1 allow procedur make recurs call per invoc give polynomi run time simul gener crewpram algorithm would appear necessari check processor time gamma 1 see whether wrote whether one appear requir polynomi time extens basic procedur accommod gener g1 g6 quit direct except g4 illbehav program g4 also possibl delic sinc effect must check step none mani nonown attempt write global cell maintain properti algorithm make o1 recurs call per invoca tion possibl similar gener crew model would increas power proof theorem 2 detail descript three procedur follow typic pram instruct global indirect store l whose mean store accumul global memori locat whose address given content local memori locat l describ rest pram instruct set great detail see fortun wylli 15 state processor p time order pair contain instruct counter content accumul p end th step defin three auxiliari function accumul instructioncount instruct state give accumul portion instruct counter portion instruct point instruct counter respect assum valu 0 instruct counter design halt instruct crowpram dcfl recognit 13 convent instruct execut step processor p activ halt also assum instruct halt instruct otherwis defin eg jump locat beyond end program conveni assum local memori processor set zero soon halt accumul retain last valu assum processor 0 initi execut instruct 1 processor activ fork l instruct initi execut instruct l also assum processor maintain local memori locat 0 count number fork instruct execut count initi 0 increment immedi fork execut easi modifi pram algorithm achiev also use two function parentp siblingcountp processor number p return processor number parent p number older sibl p respect processor number scheme chosen function easi comput name k largest integ p evenli divis 2 k procedur simulatecrowpram comment main program begin ne comment upper bound run time pram statet function globalt comment return content global memori locat time begin store l return accumul els return function localt comment return content local memori locat processor p time begin case local store return accumul indirect local store l return accumul return crowpram dcfl recognit 15 function statet p comment return state processor p time begin comment ac initi length input return 1 n els comment processor idl time 0 return 0 ac accumul ic instructioncount case indirect load l return ic global indirect load l add sub read similar load return l ac els return ic parent activ p step return l accumul 0 els comment p activ pass ac return 0 ac correct simul straightforward induct implement procedur dauxpda also easi note procedur local variabl requir olog n bit storag dauxpda need much space work tape recurs depth equal pram run time ie olog n pushdown height product two quantiti ie olog 2 n procedur make o1 recurs call per recurs level run time simul o1 olog n n o1 complet proof theorem 2 2 simul given easili adapt accommod gener g1g6 definit crowpram propos earlier allow gener owner function say depend input time g1g2 trivial add appropri paramet call use differ processor number convent equal easi provid parentp siblingcountp easili comput g5 allow function logspac polynomi time dauxpda comput effect asymptot complex bound g6 bound multipl ownership g3 also easi global procedur check whether owner global memori cell wrote would need check among set owner see wrote sinc set size o1 run time would still polynomi chang procedur accommod illbehav pram algorithm g4 subtl first chang requir must determin exact run time algorithm use upper bound caus us fals reject due invalid global store processor valu easili determin evalu statet halt accept accept need worri ownership violat second interest chang check store instruct activ processor p time basic depthfirst search processor activ tree crowpram dcfl recognit 17 procedur simulateg4crowpram comment modifi main program incorpor g4 begin instructionstatet 0 6 halt accumulatorstatet 0 6 1 halt reject treewalk0 halt accept procedur treewalkt p comment visit processor p time descend creat interv verifi nonown write occur begin store l halt reject comment owner violat quit correct procedur argu follow crowpram algorithm owner write violat procedur correct hand suppos violat say time processor p procedur correctli determin state pram time state pram undefin wherea procedur call return valu violat occur ever eventu treewalk detect fault may reject evalu branch processor activ tree happen explor ps branch latest howev detect fault evalu statet p count sinc simul faith time state pram time contain inform need deduc processor p activ time execut store violat ownership constraint henc eventu evalu statet p detect fault halt run time algorithm still polynomi sinc treewalk p call exactli activ processor p polynomi mani processor check thu shown follow theorem 3 set recogn time olog n gener crowpram ie one satisfi gener g1g6 basic defi nition logdcfl complet proof direct theorem 1 convers shown follow section 4 dpda definit notat assum familiar determinist pushdown automata dpda defin exampl harrison 19 well standard variat model dpda state set q input alphabet sigma pushdown alphabet gamma empti string denot ffl length string jsj string concaten delta step either current topmost pushdown symbol pop pushdown singl new symbol push onto pushdown current symbol assum transit function defin everi possibl state input symbol pushdown symbol thu dpda begin state q 0 initi pushdown content input head left input accept enter state q fl pushdown content advanc input head right end input assum dpda never fail read crowpram dcfl recognit 19 input alway empti pushdown symbol except fl end comput furthermor assum oe 2 gamma transit push oe standard techniqu see eg harrison 19 section 56 constant c 0 dpda assum properti halt time c delta n maximum pushdown depth n input length n effici simul dpda describ make use concept surfac configur instantan descript defin rel particular input configur tripl q oe q state integ code binari 0 n repres posit input head oe repres topmost pushdown symbol set surfac configur denot u instantan descript id dpda pair hu si u surfac configur string repres topmost symbol pushdown bottommost pushdown repres rightmost posit conveni refer stack thu initi id hq uniqu accept id hq n fl ffli id stack compon ffl call fflid note fflid correspond pushdown one symbol surfac configur id hu si defin heighti jsj defin project function surfac configur said pop transit defin q x oe pop pushdown push otherwis id pop push surfac configur pop push write 1 2 id 2 follow id 1 one step dpda input x 1 2 2 follow 1 exactli step 1 2 1 2 0 definit id repres configur machin least one pushdown symbol 1 pop fflid id 2 1 2 thu pop fflid said block true even though dpda make one final move 1 depend input state singl pushdown symbol surfac configur empti pushdown conveni assum final accept configur defin pop block id denot hu id modifi symbol 2 place symbol 1 stack illustr notat three use proposit proposit 4 bottompad surfac configur u v string note convers true gener follow case proposit 5 bottomunpad surfac configur u v string 1 proposit 6 blockcontinu surfac configur addit restrict dpda discuss assum id occur twice comput dpda start given id 19 section 56 justifi use id refer particular point comput eg j could refer id j uniqu identifi point comput step id crowpram dcfl recognit 21 5 basic dpda simul algorithm describ procedur effici simul dpda input x length n algorithm motiv repeat doubl idea use eg fortun wylli 15 39 klein reif 20 describ set follow suppos comput surfac configur u 2 u string si could easili comput 2 k1 step transit function k1 compos k howev effici consider preclud defin k possibl stack observ comput 2 k step top 2 k symbol stack access split write contain everyth first 2 k symbol 2 empti length could rewritten although could use limit number stack consid length 2 k still mani polynomi number processor comput olog n time key observ construct effici algorithm number stack need consid much limit suggest shown suffici consid polynomials set stack provid use stack split somewhat complic doubl techniqu simplifi set stack consid comput function delta k place describ give result least 2 k step rather exactli step advantag use appropri chosen break point keep stack simpl first describ algorithm assum stack explicitli manipul section 6 describ pram implement avoid use succinct represent stack selv two function id use delta k low k defin induct paramet k id return id 2 result step dpda start id 1 valu implicitli determin algorithm shown block id reach 1 less 2 k step case number step need reach block id formal id 1 2 delta k satisfi 2 block 1 function low k return id 2 id lowest height among id comput 1 delta k inclus one id minim height comput earliest id ie one closest 1 formal 1 c given definit determin dpda accept x suffici check whether sinc dpda run time c delta n input length n discuss necessari restrict number stack must defin care definit delta inform need comput delta k1 delta k restrict consider id whose stack content suffix stack produc delta k oper fflid polynomi mani fact state precis defin ss k mnemon simpl stack set string repres bottom portion stack id rang delta k oper fflid ie suffix stack contain 2 element one u 2 u suffix uniqu stack determin u motiv crowpram dcfl recognit 23 pp pp ppp pp ppp ppp pppp pppppppppp ppppp pp ppp ppp ppppp pp pp pppp pppppp pppp pp time height stack figur 1 illustr ss k definit ss k consid diagram figur 1 plot stack height versu time part comput dpda diagram show stack 1 built delta k comput start hu ffli must complementari comput start hv 1 eventu empti stack figur 1 part 1 remov comput start continu hw 2 rest 1 consist 2 remov later begin hy 2 note 2 suffix 1 illustr ss k contain stack aris delta k oper fflid also suffix stack show later k 0 stack ss k1 restrict concaten two string ss k ie ss technic reason import maintain inform specifi stack ss k1 split two stack ss k rather simpli treat stack undifferenti charact string interest simplic howev larg ignor issu current section treat fulli section 6 argu correct algorithm prove follow induct k welldefin id stack ss k ss k satisfi properti 1 2 3 respect crux algorithm correct proof captur follow lemma show progress least 2 k step simul simultan restrict attent limit set stack appli delta k select low point lemma 7 id 2 ss k let j 0 b j unblock 2 k c stackj 2 ss k delta ss k proof see figur 2 plot stack height versu time comput dpda three distinct case first simplest shown diagram dpda block attempt pop stack height zero complet 2 k step second comput hsurfacel ffli block complet 2 k step argu overal lowdelta comput complet least step third case none subcomput block part follow directli properti 1 2 correct properti 2 l lowest point comput l least stackl must suffix ss k assumpt thu stackl ss k definit also ss k thu stackj ss k delta ss k satisfi c assum j unblock let delta stackl unblock correct properti j least 2 k step past l part b follow hand block j unblock stackl must nonzero height case j preced delta k sinc otherwis id succeed j would point lower height l rang crowpram dcfl recognit 25 height stack pp ppp ppppp ppppp pp ppp pp ppp ppp ppppp pp pppp ppppppppppp ppppp ppp pp time stack j 2 ss k1 stack stack figur 2 lowdelta lemma delta k inclus contradict correct properti 2 follow unblock part b follow correct properti 1the express j lemma occur frequent conveni introduc special notat defin e l stackl exampl lowdelta lemma show e step block note l j lowdelta lemma heightl 0 j necessarili unblock e necessarili progress 2 k step lemma appli id stack ss k need analog result stack consist two three segment ss k desir low point stack found follow iter low function use later defin function handl constant number stack segment rather three see figur 3 ppp pp pp pp pppp pp ppp ppppp pppp pp pp pppppp pp ppp ppp ppppppp ppppp pp time e sd stack height e figur 3 ilow k function ilow k return id comment assum 2 u theta ss k return id low k point nonzero height comput one exist return result fflid begin return comment everi segment empti return hu ffli desir gener lowdelta lemma follow crowpram dcfl recognit 27 id 2 j 0 b j unblock 2 k c stackj 2 ss k d1 proof part follow proposit 1 2 let modifi stack argument call stackl suffix stacki henc hypothesi ss k stack segment ad call e k establish part c key point establish b low k point henc lowdelta lemma appli specif let 0 last valu taken loop let u 0 valu taken u last call low k let l last valu taken hu si return let j easi see 0 delta lemma appli 0 particular j 0 unblock least 2 k step past 0 henc j least 2 k past satisfi part b thu suffic show j 0 unblock whenev j unblock two case consid first suppos ilow k return heightl necessarili unblock hand ilow k return heightl 0 inspect thu either case j unblock j 0 unblock part b follow 2 code ilow k given indic determin decomposit stack paramet segment ss k brief suggest remark follow definit ss k retain decomposit inform stack initi comput detail explan issu defer next section defin low k conveni use auxiliari function min take argument sequenc id return id minim height sequenc sever minim height return leftmost applic alway earliest time construct final readi defin delta k low k correct follow part definit function provid enclos squar bracket appropri part correct argument establish basi j 9 j j otherwis ie block correct assumpt oe 2 gamma state push oe see ss 0 must exactli gamma ffflg exactli set stack domain delta 0 low 0 inspect domain block thu 1 satisfi 2 hold two point rang point consider min select lower 3 hold vacuous induct definit delta k1 low k1 done two phase first consid id empti stack determin ss k consid id stack ss k gamma ffflg induct definit delta k1 low k1 empti stack see figur 4 k 0 u basic procedur comput deltalowdelta assum comput block id reach first delta 2 k step past start point satisfi hypothesi lowdelta lemma thu subsequ lowdelta pair achiev anoth 2 k step progress keep result stack simpl ie ss k1 argument main ingredi correct proof case initi id crowpram dcfl recognit 29 ppp pp pp ppp ppppppp pppp pp pp ppppppppp pppp pp ppp pppp ppppppp ppp ppp pppp pp pp ppp pppppp ppppppppp ppppppp pppp ppppp pp pppp pp pp ppp pp pp height stack time e figur 4 delta k1 hu ffli nonempti stack turn similar except need preced anoth low two correct let delta k hu ffli note definit ss k hypothesi lowdelta lemma satisfi delta k1 hu ffli block 1 immedi satisfi block neither least 2 k step past hu ffli properti 1 appli lowdelta lemma e least 2 k step past henc 2 k1 past hu ffli thu delta k1 hu ffli also satisfi 1 clearli hu ffli earliest id height zero properti 2 trivial satisfi low k1 hu ffli properti 3 follow directli lowdelta complet definit delta k1 low k1 must defin id nonempti stack 2 ss k1 defin delta k1 action fflid induct definit delta k1 low k1 nonempti stack use ilow k defin delta k1 low k1 hu si result follow comput see time pppp pp ppp pp ppp pp ppppp pppppp pp ppp ppp pppp ppp ppp pp ppppppp pppppp ppp ppp pp ppp ppppppppppp ppp pppp ppppppp ppp pp height stack ilow k e e e figur 5 figur correct properti 1 follow immedi appli ilowdelta lemma twice properti 2 satisfi low k1 sinc two point min appli subsum low point subcomput compris delta k1 properti 3 inapplic remark ilowdelta lemma stackj may consist three stack segment even though stacki contain two main reason defin ilow k two stack segment final remark ilow k ident function id empti stack equal low k crowpram dcfl recognit 31 definit reduc exactli comput given earlier empti stack case sinc case similarli definit low k1 also suffic case ffl thu one could use gener definit handl case complet definit delta low proof correct summar key featur construct low k1 delta k1 requir constant number call level procedur guarante least 2 k1 progress simul need defin domain polynomi size next two section exploit featur give fast implement pram small space implement pda 6 crowpram implement one import issu ignor discuss far question effici handl stack obtain desir olog n run time need manipul stack lengthomegagamma n unit time particular defin ss k necessari abl split two segment stack ss k done retain inform split compon origin construct fact decomposit inform realli inform need appli induct definit actual content stack never consult definit except base case fact allow us replac actual stack abbrevi avoid explicit manipul long charact string provid decomposit inform kept avail introduc succinct notat stack revis algorithm use notat discuss crowpram implement use notat definit stack 2 ss k suffix stack surfac configur u name specifi k u valu h give length suffix consid stack refer level k 0 abbrevi krefer pair u h stack refer said valid krefer u h said base u height h level k conveni ffl also consid valid krefer denot empti stack height 0 k 0 algorithm maintain array summari k index surfac configur valu store summari 0 u actual symbol stack ffli valu summari k1 u pair valid krefer turn recurs specifi actual symbol stack delta k1 hu ffli valid krefer u h may refer suffix stack thu conveni extend summari notat handl refer summari valid krefer length h suffix summari 0 u k 1 pair krefer summari k u adjust height h adjust carri follow suppos summari k u order pair krefer v order pair v 1 singl krefer v 2 h correspond pop referenc stack desir height h reach defin variant r k l k il k min function delta k low k respect section 5 oper use stack refer summari inform place stack function min behav like version section 5 except return surfac configur height rather full id leftmost earliest argument minimum height code r k need provid case empti stack definit delta k hu si 6 ffl given section 5 support definit low k hu si associ correct assert otherwis use final note code content global array summari k alway set function r k referenc l k crowpram dcfl recognit 33 function r 0 u surfac return surfac 0refer comment return surfac refer correspond side effect store stack global array var begin u pop return u ffl let hu ffli hv oei oe r u 1 return v r function l 0 u surfac r 0refer return surfac 0refer comment return surfac refer low point interv u r r 0 u r var string begin return v ffl function il k u surfac r 1 sequenc krefer return surfac sequenc krefer comment return surfac sequenc krefer defin stack unblock low point comput start u r 1 procedur handl fix number krefer var r krefer begin return u ffl function r k1 u surfac return surfac comment return surfac refer correspond side effect store summari stack var 1refer begin return v 3 r crowpram dcfl recognit 35 function l return surfac comment return surfac refer correspond low point interv u r r k1 u r var sequenc krefer 1refer begin let r w h result prepend r 2 sequenc 1 return correct follow argument given section 5 use correspond elucid induct defin string b r associ valid krefer r follow valid 0refer string b r consist length h suffix string store summari 0 u furthermor k 0 valid associ induct string b induct k one show r string associ krefer r return r k u exactli stack defin section 5 provid algorithm section 5 stack b decompos specifi summari call exact decomposit use ilow k left unspecifi section 5 note proof given particular proof lemma 8 ilowdelta lemma hold decomposit stack substr ss k although need proof hold specif decomposit given summari final function r k l k defin use time olog n parallel algorithm dcfl recognit crowpram algorithm tabul r k summari k l k success higher valu k k 0 dlog cn e u 2 u parallel comput store tabl global memori side effect store summari k u u v 2 u h 0 valid krefer parallel comput store tabl global memori iter loop perform constant number refer previous store valu r k l k summari k implement tabl index surfac configur ref erenc initi uniqu processor everi array entri done use nowstandard parallel ram program techniqu see gold schlager 17 wylli 39 exampl surfac refer code integ olog n bit use tabl sub script techniqu also suffic implement algorithm crowpram satisfi restrict r1r3 sinc surfac 2 refer number array entri henc number processor kept 3 reus array space rather separ array valu k 0 log n valu summari k exampl discard soon valu summari k1 comput thu shown follow theorem theorem 9 everi dcfl recogn crowpram satisfi restrict r1r3 time olog n 3 processor theorem 2 9 togeth establish theorem 1 also obtain follow corollari crowpram dcfl recognit 37 gener g1g4 simul crowpram subject restrict r1r3 constant time loss polynomi increas number processor proof shown section 3 gener crowpram satisfi g1g6 simul determinist auxiliari pda log n space polynomi time thu languag recogn machin sudborough class logdcfl languag log space reduc determinist contextfre languag log spacebound reduct done crowpram time olog n use determinist pointer jump techniqu fortun wylli 15 see cook dymond 8 detail descript simul log space parallel pointer machin olog n time see lam ruzzo 21 simul later model olog n timebound crowpram simul easili made obey restrict r1r3 final theorem 9 result languag recogn crowpram also obey restrict follow appear earlier version paper monien et al 25 gave crewpram algorithm dcfl recognit ffl 0 use olog n time n 2ffl processor algorithm use function similar suggest approach improv processor bound crowpram algorithm theorem 9 7 small space sequenti implement section 3 present algorithm simul olog n time crowpram determinist auxpda use polynomi time olog 2 n stack height combin theorem 9 yield altern proof follow result rytter theorem 11 rytter 33 l accept polynomi time logarithm space dauxpda l accept machin furthermor use stack height olog 2 n analog result previous known nondeterminist pda ruzzo 32 best result previou rytter stack height reduct dauxpda requir superpolynomi time harju 18 cf 32 altern proof corollari 12 harju 18 dcfl dauxpda space olog n stack height olog 2 n follow result also corollari corollari 13 cook 5 von braunmuhl et al 38 dcfl time bound algorithm sketch polynomi particularli attract shown von braunmuhl cook mehlhorn recognit simultan space sn time 1ffl sn dtm random access input tape log 2 n sn n algorithm make gener use space resourc ie use pushdown store even stack stack automaton sens ginsburg greibach harrison 16 goal remaind section sketch improv algorithm achiev time bound match von braunmuhl et al still use dauxpda modif borrow key idea von braunmuhl et al construct first outlin direct algorithm bypass simul gener crowpram section 5 6 present algorithm simul dpda base procedur r k l k procedur r k set global summari k array side effect l k read easi reformul procedur recurs fulli recurs version r k would return summari inform addit compon function valu access summari k l k would replac appropri call r k recomput desir stack summari recurs procedur straightforward implement spacebound determinist auxiliari pda auxpda work tape need long enough hold local variabl procedur pushdown crowpram dcfl recognit 39 height must time larg depth recurs hold stack frame hold copi local variabl return address etc procedur local variabl consist integ plu bound number surfac requir olog n space recurs depth dlog 2 cne thu procedur implement dauxpda use space olog n pushdown height olog 2 n furthermor procedur level k make bound number call level k procedur sinc depth recurs olog n total number call o1 olog n n o1 exclus recurs call procedur take time olog n manipul surfac etc plu necessari read input thu total time algorithm polynomi main idea improv time bound gener construct section 5 give integ 2 procedur r k etc reflect comput length least k rather 2 k easili done machineri alreadi develop exampl basic dfold composit f r k delta level od call level k procedur thu number recurs call main compon run time log keep induct simpl arrang stack need consid suffix built r k1 u turn concaten suffix stack built r k v variou vs import list vs provid succinct use summari stack content one final refin idea simul sn step dpda base case procedur rather one step r k simul least sn delta k step implement procedur dauxpda olog n work tape olog 2 n stack height straightforward random access input tape use algorithm von braunmuhl et al follow reason simul pop move requir recomput portion stack necessit access portion input read correspond push move ordinari sequenti access input tape even though reposit tape head may timeconsumingomegagamma n von braunmuhl et al show dcfl recognit possibl simultan space sn time 2 sn log provabl optim techniqu appear like use case well although pursu acknowledg thank michael bertol philipp derom faith fich klausjorn lang prabhakar ragd marc snir care read earli draft use discuss special acknowledg due allan borodin without would never begun research r comparison share nonshar memori model parallel comput cach coher protocol evalu use multiprocessor simul model complex short twoperson game character pushdown machin term timebound comput determinist cfl accept simultan polynomi time log squar space toward complex theori synchron parallel compu tation upper lower time bound parallel random access machin without simultan write parallel pointer machin indirect address time relationship model sequenti comput hardwar complex parallel computa tion pointer versu arithmet pram parallel random access machin own global memori determinist contextfre languag recognit complex comput parallel random access machin toward understand exclus read parallel random access machin stack automata com pile univers interconnect pattern parallel comput er simul result auxiliari pushdown automata introduct formal languag theori parallel time olog n accept determinist cfl exclusivewrit pram power parallel pointer manipul implement cole parallel mergesort algorithm ownerwrit parallel random access machin logic algorithm fast recognit determinist cfl smaller number processor optim orowpram algorithm comput recurs defin function pram toward realist parallel bram crew pram decis tree restrict crcw pram character power vector machin owner concept pram recognit contextfre languag parallel time olog n recognit unambigu contextfre languag simul parallel random access machin circuit tape complex determinist contextfre lan guag synchron parallel comput survey recognit determinist cfl small time space complex parallel comput tr cach coher protocol evalu use multiprocessor simul model upper lower time bound parallel random access machin without simultan write parallel ram own global memori determinist contexfre languag recognit parallel time italico log italicn recognit unambigu contextfre languag parallel time italicolog italicn accept determinist cfl exclusivewrit pram power parallel pointer manipul complex short twoperson game toward understand exclus read owner concept pram crew pram decis tree fast recognit determinist cfl smaller number processor restrict crcw pram parallel pointer machin pointer versu arithmet pram stack automata compil character pushdown machin term timebound comput tape complex determinist contextfre languag univers interconnect pattern parallel comput introduct formal languag theori dataindepend parallel random access machin pram toward realist parallel parallel merg sort concurrentread ownerwrit pram parallel random access machin determinist cfl accept simultan polynomi time log squar space complex parallel comput ctr bertsch mj nederhof fast parallel recognit lr languag suffix inform process letter v92 n5 p225229 decemb 2004