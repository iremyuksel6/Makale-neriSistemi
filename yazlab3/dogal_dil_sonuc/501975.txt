complex exponenti output size problem topdown bottomup tree transduc exponenti output size problem determin whether size output tree tree transduc grow exponenti size input tree paper complex problem studi shown nlcomplet total topdown tree transduc dexptimecomplet gener topdown tree transduc pcomplet bottomup tree tranduc copyright 2001 academ press b introduct topdown bottomup tree transduc introduc late sixti round thatcher 13 16 17 18 generalis finitest transduc string main motiv provid simpl formal model syntaxdirect transform grammar mathemat linguist syntaxdirect translat compil construct latter see recent book fulop vogler 8 sinc time turn tree transduc use tool mani area properti extens studi varieti author refer see eg 9 8 part paper topdown tree transduc studi mention seen generalis finitest string transduc also call generalis sequenti machin tree 1 like topdown tree transduc oneway devic process input one direct use finit number state howev string transduc usual process input left right topdown tree transduc transform input tree output tree root toward leav cours reason call topdown tree transduc roughli speak partial support ec tmr network getgrat gener theori graph transform system esprit work group appligraph univers bremen short version paper present fct99 3 1 context tree label order tree whose label taken rank alphabet signatur ie term string case obtain consid monad input output tree view vertic string although generalis quit direct one fact tree instead string consid make rather crucial differ certain respect concern exampl closur properti hold string case carri topdown tree transduc instanc infinit hierarchi obtain consid composit topdown tree transduc see 5 anoth import differ intuit comput topdown tree transduc usual ramifi topmost node input tree process comput proce subtre parallel fact subtre also delet copi one distinct consequ fact contrast string case size output tree topdown tree transduc necessarili linearli bound size input tree exampl consid two rule fla consid term rewrit rule usual way fl special symbol rank 1 call state f g symbol rank 2 1 0 respect without go detail clear rule transform monad tree height n complet binari tree height thu output size exponenti size input tree follow directli definit topdown tree transduc exponenti size output tree maximum growth achiev howev well possibl build topdown tree transduc whose maximum output size given polynomi degre k given n simpl exampl consid rule use state fl fl 0 take fl initi state input tree size n 1 turn output tree f tree word size output tree quadrat size input tree paper complex correspond decis problem studi given topdown tree transduc td output size os td n exponenti size n input tree turn problem effici solvabl name nlcomplet 2 total topdown tree transduc hard name dexptimecomplet gener use known result nl respect dexptimehard two variant rel easi es tablish effort necessari order prove resourc inde suffici apart interest right result use tree transduc consid model syntaxdirect translat 8 practic reason exponenti behaviour translat often accept exampl translat express highlevel program languag primit instruct littl practic use 2 throughout paper complet mean logspac complet output code exponenti size close relat use tree transduc order gener tree interpret express domain see eg 4 2 order estim evalu cost gener express cost comput tree transduct necessari estim size output tree ie solv exponenti output size problem fact topdown tree transduc use two area often total natur reason therefor result exponenti output size problem nl class tree transduc may particular interest notion generalis syntaxdirect translat close relat total determinist topdown tree transduc aho ullman investig output size alreadi 1 show output size generalis syntaxdirect translat either polynomi exponenti 1 theorem 52 result prove topdown tree transduc gener section 4 paper corollari 47 aho ullman also prove exponenti output size problem generalis syntaxdirect translat decid 1 theorem 43 howev complex issu address paper propos algorithm highli ineffici result paper yield nlalgorithm formul generalis syntaxdirect translat due close relationship total determinist topdown tree transduc bottomup tree transduc somewhat less interest comput structur simpler polynomialtim reduct one exploit result total topdown tree transduc order show exponenti output size problem bottomup tree transduc p fact use known result turn problem pcomplet interestingli case assumpt total make differenceth problem remain pcomplet even total determinist bottomup tree transduc paper structur follow next section basic notion recal section 35 concern topdown tree transduc section 3 definit recal auxiliari notion introduc shown exponenti output size problem reduc case total determinist topdown tree transduc monad input signatur section 4 combinatori result tree shown use obtain characteris exponenti output size latter turn decis algorithm section 5 main result paper present section 6 deal complex exponenti output size problem bottomup tree transduc final section 7 short conclus given preliminari set natur number includ 0 denot n n denot n nf0g n 2 n n denot set ng set finit sequenc set denot empti sequenc denot length sequenc jsj concaten sequenc juxtaposit like length sequenc cardin set denot jaj canon extens function f b powerset denot f henc 2 reflex transit closur binari relat r theta b denot r domain r ie set fa 2 j b 2 r b 2 bg denot domr assum reader familiar basic notion complex theori least basic experi concern estim resourc need algorithm especi respect polynomi exponenti time logarithm space function f n n said polynomi bound polynomi p fn pn n constant c 2 r c 1 n 0 2 n fn c n said exponenti thu latter lower bound wherea former upper one finit order unlabel tree finit prefixclos subset n element call node rank node v number distinct rank maximum rank node leaf node rank 0 node u descend node v v proper prefix u convers u ancestor v proper prefix v subtre root v tree fv 0 j vv 0 2 tg direct subtre subtre root v size jt j height ie number node longest path root leaf width denot wdt number leav label tree map unlabel tree l set label underli unlabel tree also denot n case notion notat introduc unlabel tree carri label tree obviou way follow attribut label unlabel mostli drop speak tree gener rule unlabel tree denot capit letter usual wherea label tree denot lowercas letter usual tree denot tree usual denot f actual mean identifi singlenod tree label node symbol pair f n consist label f number n 2 n call rank symbol symbol also denot f n simpli f n minor import signatur finit set sigma symbol sigma monad signatur sigma 0 whose symbol rank 1 arbitrari set mon denot monad signatur ff 1 g tree call monad form f 1 note monad tree identifi string f 1 signatur sigma set tree sigma denot set tree set tree sigma subtre smallest set tree notat sigma use abbrevi sigma rest paper let us fix index set pairwis distinct symbol rank 0 call variabl everi n 2 n g order avoid confus set x assum disjoint signatur consider variabl x 1 also denot x tree denot substitut x 2 n precis rewrit work usual except leftlinear rule consid thu context paper rewrit rule pair ae l r tree call left righthand side respect l contain everi variabl everi variabl r occur l rewrit rule usual denot l r deriv relat determin ae binari relat ae tree exactli r set rewrit rule r denot union ae ae 2 r 3 topdown tree transduc topdown tree transduc transform input tree output tree topdown manner use restrict type term rewrit rule special symbol rank 1 use state everi step consum input symbol beneath replac tree consist output symbol state process copi direct subtre consum symbol 31 definit topdown tree transduc topdown tree transduc tupl ffl sigma sigma 0 signatur call input signatur output signatur respect signatur state rank 1 disjoint sigma sigma 0 finit set rewrit rule initi state sigma monad signatur td topdown stringtotre transduc topdown tree transduct comput td denot td well set pair td td denot rewrit relat r pi follow everi topdown tree transduc everi state fl 2 gamma topdown tree transduc sigma sigma 0 gamma r fl denot td fl convent assum variabl lefthand side rule read left right alway x n thu everi rule topdown tree transduc form fl denot rule way alway meant impli chosen way contain everi variabl x l exactli carri denot deriv step flf everi assum correspond one particular occurr subtre notic may distinct cours rule topdown tree transduc call flf rule form thu flf rule rule process input symbol f state fl topdown tree transduc contain least one flf rule everi contain one rule everi total domtd sigma determinist comput partial function latter case one may therefor use function notat write 32 definit output size output size topdown tree transduc td given function os td n n n 2 n ng usual exponenti output size problem problem determin arbitrari topdown tree transduc td whether os td exponenti pi note technic conveni fact os td monoton function clearli one alway find c os td n c n n 2 n follow fact rank output tree bound 2 td impli maximum height righthand side rule td remaind section consist three lemma proof purpos lemma show topdown tree transduc simplifi certain way without affect output size much particular modif preserv polynomi bounded well exponenti first lemma show suffic consid topdown tree transduc whose righthand side contain exactli one output symbol let theta denot set topdown tree transduc sigma h gamma r fl 0 everi righthand side rule r element h gammax 2 n thu standard output symbol h n use n may vari label alway h overload h essenti help reduc notat complex proof clearli standardis harmless sinc size output tree independ node label 33 lemma everi topdown tree transduc td one construct topdown tree transduc td 0 2 theta constant 2 n n 2 n construct preserv determin well total carri logarithm space proof let low everi rule flf x r let r 0 contain rule flf x let h consist symbol h l appear sodefin righthand side clearli construct carri logarithm space preserv determin total remain estim differ os td os td 0 let maximum number node righthand side rule r label symbol sigma 0 obviou onetoon correspond deriv td td 0 fact everi applic rule r 0 add exactli one output symbol correspond rule r add consequ n n 2 n convers everi 0 2 td wdt 0 wdt notic necessarili hold respect size rule r may righthand side gammax use inequ fact htt 0 word os td 0 n n delta os td n n 2 n next two lemma quit use order check exponenti output size allow restrict one attent case determinist total stringtotre transduc consider easier deal gener topdown tree transduc particular construct use follow see eg proof lemma 35 reli assumpt everi state given topdown tree transduc determin partial function tree tree therefor shall first show logarithm space suffici order transform topdown tree transduc determinist one therebi affect output size modestli simplifi proof topdown tree transduc theta consid lemma 33 fact logarithm space reduct close composit restrict make differ let us first inform discuss idea underli construct get rid nondetermin preserv output size modifi input signatur use intuit node input tree augment addit inform determin rule appli proceed f f f e e figur 1 sampl deriv nondeterminist topdown tree transduc way potenti output tree may get lost sinc new transduc forc use rule whenev process two copi subtre state fortun matter respect output size affect maxim size output tree exampl let consist rule ae duplic ith subtre tree appli delet one sampl deriv appli rule parallel shown figur 1 note second step differ rule chosen process copi tree f f e e e left one process ae 2 right one ae 1 obtain output tree maxim size ae 1 would chosen copi order convert td determinist topdown tree transduc td 0 one may use two version f say f 1 f 2 account fact choos two possibl flf rule rule thu turn one flerul kept note provid input tree figur 1 appropri indic order make td 0 simul shown deriv contradictori choic rule second step ever possibl find indic lead output tree maxim size name dash indic irrelev indic generalis construct everi symbol origin input signatur sigma would provid mani indic state td choic rule copi process differ state must cours independ unfortun would result exponenti number state could handl logarithm space therefor instead indic shall use addit input symbol hfl ii rank 1 fl state td index rule intuit occurr hfl ii input tree may read fl current state use ith flf rule td order process next input symbol f 2 sigma encount order rememb state form fl use 34 lemma everi topdown tree transduc td 2 theta one construct determinist topdown tree transduc td 0 2 theta constant 2 n n 2 n construct preserv total carri logarithm space proof let defin largest natur number distinct flf rule r contain rule fl hfl fflg rule order defin r 1 consid r contain least one flf rule let arbitrari order set flf rule r r 1 contain rule rule righthand side one need order preserv total choic superscript 1 state righthand side arbitrari could replac clear td 0 construct logarithm space sinc requir mainli manipul fix number counter rang furthermor td 0 determinist construct preserv total moreov everi 2 td 0 remov symbol form hfl ii yield tree 0 prove os td 0 n os td n n 2 n order see inequ hold well one cope difficulti discuss name possibl deriv td counterpart td 0 sinc latter alway appli rule copi subtre process state proof proce explicitli turn arbitrari input tree td one td 0 yield output tree maxim size everi tree 2 sigma everi choos arbitrari fix deriv td 0 0 2 th js 0 j maxim let first rule appli deriv jth flf rule r respect order use defin r 1 root symbol deriv chosen arbitrarili recal inform discuss preced lemma fl index rule must appli fl order obtain output tree maximum size suppos defin everi tree clearli therefor defin establish requir inequ os td na os td 0 n follow claim prove claim let fl td deriv prove claim proceed induct structur suppos due definit fl assum without loss gener rule appli first step deriv fl td flth flf rule td thu given deriv form appli induct hypothesi subderiv tree 0 l 2 th es k l es l td l j 2 l prove claim take l thu finish proof lemma intuit deriv topdown tree transduc produc larg output tree must path input tree whose node copi exponenti number time thu turn topdown tree transduc td string totre transduc st interpret input path input tree td simul correspond part deriv output size st differ output size td much follow lemma prove inde case lemma everi determinist topdown tree transduc td 2 theta one construct total determinist stringtotre transduc st 2 theta constant 2 n st n max1 os td delta n n 2 n construct carri logarithm space td total exponenti time otherwis proof let indic main idea construct st way input tree st correspond path input tree td comput st path produc output tree consist node td produc process symbol path technic reason leaf f 0 end path taken account treat ffl order cope possibl nontot td state enrich second compon set state use order keep track state copi remain input process make precis auxiliari definit turn use everi f k 2 sigma denot lstatesf set state flf rule r exist furthermor rstate denot set state righthand side flf rule fl 2 delta intuit delta set state process copi tree f simultan deriv step rstate delta f set state process copi final everi set state delta gamma let dom st construct follow consid hfl deltai suppos domrstat case flf x flf rule r r 0 contain rule note h origin flf rule rank l wherea new one rank p otherwis ie case 1 2 hold r 0 contain rule hfl deltaif furthermor rule hfl deltaiffl h r 0 everi state hfl deltai construct st total determinist order show state inequ hold two claim prove first claim concern inequ os st n max1 os td delta n claim 1 constant 2 n follow hold everi state hfl deltai everi deriv hfl deltai st tree depend delta js 0 j delta jsj fl 0 prove maximum rank symbol sigma 0 smallest posit natur number everi nonempti 3 recal symbol f 0 2 sigma treat ffl st therefor f f rank need appear set dom contain tree size 0 notic 0 exist powerset gamma finit let us proceed induct length deriv claim certainli hold consid deriv form hfl deltai st h choos 0 smallest tree dom delta assum deriv hfl deltai st read st hhfl st rule appli first step one construct rule r describ definit r 0 k tree whose subtre 0 defin fol low j smallest tree domrstat delta f j construct r 0 nonempti set furthermor 0 tree provid induct hypothesi size delta js j deriv p 0 notic induct hypothesi yield input tree 0 p deriv 0 depend delta follow td td tree contain particular subtre 0 p mean finish proof claim 1 claim yield os st n os td delta n everi tree 2 mon mean os st formul second claim conveni formalis notion path tree 2 sigma defin pathss 2 mon follow 2 let hfl deltai dom delta everi tree 2 th td hold proof induct length deriv deriv length 1 assert trivial hold assum given deriv form td td l 1 first notic 2 dom assumpt 2 dom delta definit delta set state occur 0 fl 0 2 delta 0 uniqu tree one state would mean exist deriv 0 thu violat assumpt 2 domtd fl fact 2 dom impli 2 definit r 0 1 obvious satisfi well consequ deriv step st exist induct hypothesi j 2 sum get st claim choos path 0 2 pathss wdst 0 wdtwd due fact prove inequ os td nn 2 os st n n 2 n sinc much time take construct st clearli time consum part determin set necessari order construct rule done standard algorithm follow defin set exist input symbol f k 2 sigma delta lstatesf rstate delta f time suffici order determin i1 sinc enumer 2 jgammaj set test whether satisfi requir follow straightforward induct i2n furthermor definit i1 smallest index 0 show comput exponenti time complet proof gener case remain consid special case td total total td mean dom therefor construct rule condit 1 2 alway satisfi regardless delta consequ second compon state gamma 0 useless one simplifi construct set rule flf figur 2 tree branch depth 2 branch index 3 proof claim 2 rule comput logarithm space complet proof lemma reader notic inequ three lemma guarante polynomi bounded exponenti preserv respect polynomi bounded clear upper bound obvious polynomi os td one exponenti preserv well os td na constant clear c os td npn p polynomi choos order get c n exponenti second factor larger 1 suffici larg n sinc 1 4 branch index output tree section shown intuit tree whose size exponenti height must necessarili contain subtre mani ramif everi path order formalis branch depth branch index tree introduc 41 definit branch depth branch index let tree branch depth smallest natur number b leaf exactli b distinct ancestor rank 2 branch index maximum branch depth tree 0 pi exampl shown figur 2 branch depth tree 2 branch depth subtre indic hollow edg 3 latter turn branch index tree whole subtre larger branch depth reader notic everi tree contain tree 0 rank 2 branch depth b therefor tree 0 definit 41 assum rank 2 without loss gener may furthermor instruct note one could remov node b pairwis distinct ancestor rank 2 yield tree leav exactli b ancestor rank 2 intuit turn tree full binari tree height b node rank 1 disregard henc branch index one less height largest full binari tree embed follow lemma yield equival recurs descript branch index straightforward induct proof omit 42 lemma let tree direct subtre branch index 0 branch index branch index distinct b indic exist pi lemma state size tree polynomi bound height place upper bound branch index provid rank bound 43 lemma let set tree rank r branch index b n polynomi p b degre b1 jt j p b htt tree 2 proof proceed induct b tree branch index 0 rank 1 impli jt let tree branch index b k r direct subtre branch index one greater b distinct branch index j b branch index would least b therefor one direct subtre 1 say branch index b remain one strictli smaller branch index accord induct hypothesi polynomi p bgamma1 degre b sinc coeffici p bgamma1 assum posit therefor jt repeat argument 1 tree size 1 reach yield polynomi htt degre b one degre b corollari branch index bound size tree set grow exponenti height 44 corollari let set tree bound rank let size ng n 2 n size polynomi bound upper bound branch index tree pi let us say tree contain bifurc node v 0 2 nt two distinct descend v 0 v next lemma state everi set label tree finit mani label unbound branch index tree contain bifurc use proof theorem 46 order creat kind pump situat characteris stringtotre transduc exponenti output size lemma let set tree label finit set l branch index tree unbound exist tree 2 contain bifurc proof denot set label path g mainli prove follow claim done induct n claim let 2 n 2 n let nt tree branch depth contain distinct node v 0 v v 0 v 0 satisfi node w 2 trivial take w node therefor let n 1 assum claim hold tree 0 nt branch depth bn gamma 1 point definit 41 may assum without loss gener rank 2 consid tree 0 consist node bn gamma 1 ancestor rank 2 thu branch depth 0 1 induct hypothesi impli node v 0 2 0 noth show choos leaf v 0 u 2 juj minim sinc v 0 ancestor rank 2 wherea v 0 u least bn sinc branch depth least n ancestor v 0 u 1 v 0 u whose rank 2 minim assumpt juj mean set jujg least n1 element assumpt label twice among label node n impli exist node v 0 v 2 n tv 0 v 62 tv 0 thu complet proof claim sinc mean order prove lemma choos tree 2 branch index least bjlj tree nt branch depth bjlj howev sinc node w 2 tw jlj follow claim contain bifurc decis algorithm develop next section base theorem prove next characteris class total determinist stringto tree transduc st 2 theta exponenti output size fact theorem could generalis arbitrari topdown tree transduc would technic difficult need prove result paper order formul theorem use well notion comput tree need intuit comput tree deriv tree state copi subtre input tree process need definit stringtotre transduc theta therefor let st sigma h gamma r comput tree deriv fl st tree label gamma defin follow deriv st h comput tree tree fl otherwis deriv must form flf 0 st st case comput tree flt 0 comput tree ith subderiv st k set comput tree deriv st 2 sigma 2 th denot ctst 46 theorem output size total determinist stringtotre transduc st 2 theta exponenti tree ctst contain bifurc proof let st sigma h gamma r fl 0 proof notic comput tree ct deriv fl st structur ie thu make differ whether consid size output tree size comput tree due remark fact comput tree ct deriv fl st size ctst n os st n n 2 n size ctst defin corollari 44 corollari 44 mean branch index tree ctst unbound thu implic follow lemma 45 consid deriv st whose comput tree ct contain node requir type one decompos ct comput tree uniqu deriv st induct follow jct trivial 0 sinc ctv 0 deriv fl st tree contain least two subtre form fl consequ comput tree ct deriv fl st st contain ct twice subtre prove jct fact ctv 0 impli exist deriv st tree contain subtre fl quentli comput tree deriv st st 0 contain ct subtre mean size least 2 st exponenti 2 gammam 0 constant factor 2 1m1 1 note 1m 1 defin byproduct result section result similar theorem 52 1 obtain output size topdown tree transduc exponenti polynomi bound fact result 1 slightli stronger state case output size satisfi c 1 c 1 word element 47 corollari output size topdown tree transduc either polynomi bound exponenti proof let td topdown tree transduc lemma 33 34 35 total determinist stringtotre transduc st 2 theta os st polynomi bound exponenti td polynomi bound respect exponenti os st polynomi bound onlyif direct proof theorem 46 remain valid show comput tree ctst contain bifurc use direct theorem follow os st exponenti mean os td exponenti 5 main result section main result paper prove exponenti output size problem nlcomplet total topdown tree transduc dexp timecomplet gener case first shown decis algorithm obey resourc bound start total case 51 lemma total determinist stringtotre transduc theta exponenti output size problem nl proof theorem 46 suffic prove follow total determinist stringtotre transduc st 2 theta decid nondeterminist ture machin logarithm space whether comput tree ctst contain bifurc sketch ture machin could work let st everi state fl 2 gamma everi input symbol f 1 2 sigma let nextfl f denot set state occur righthand side uniqu flf rule r comput consist two phase first phase start repeatedli make nondeterminist choic guess next symbol f 1 arbitrari input string state fl i1 2 nextfl initi state st thu fl 0 sequenc label path uniqu comput tree determin guess input string phase comput nondeterminist select one encount state say store tape step j 0 0 next phase initi guess two state need distinct must correspond two distinct node righthand side respect rule formal righthand side fl j0 f j0 rule fl j0 distinct node v intuit place two path bifurc separ two sequenc construct parallel alway choos f 1 state accept st encount j 0 sinc st total everi deriv final yield tree th therefor accept input step comput tree ct deriv input exist obvious accept condit mean ct contain bifurc convers exist input tree lead comput tree contain bifurc clear one possibl run make suitabl nondeterminist choic order detect fact moreov requir logarithm space sinc thing must keep track current symbol f complet proof 52 theorem exponenti output size problem nlcomplet total topdown tree transduc dexptimecomplet gener one part statement remain true determinist topdown tree transduc consid proof let td topdown tree transduc lemma 3335 one construct total determinist stringtotre transduc st 2 theta os st exponenti os td exponenti furthermor construct perform logarithm space td total exponenti time otherwis use lemma 51 test logarithm space size st whether os st exponenti thu exponenti output size problem nl total topdown tree transduc dexptim gener remain prove nlhard dexptimehard respect order establish total case shown nlcomplet problem reachabl see eg 12 also known graph access problem reduc exponenti output size problem total topdown tree transduc given direct graph g two node v v 0 reachabl problem determin whether exist vv 0 path g ie direct path lead v v 0 v set node input graph g reachabl let st g r defin follow 1 u u contain rule fl u u 0 x edg u u 0 g edg r contain rule 2 node contain rule fl u ffl ffl 3 addit r contain rule clearli work tape logarithm size suffici ture machin construct st furthermor g contain vv 0 path rule 3 never appli convers vv 0 path given sequenc e 1 target node e j rule 1 3 deriv st st mean st contain pair full binari tree height consequ os st k 1 delta prove os st exponenti sinc k constant final consid gener case go make use dexptim complet result seidl determinist topdown finit tree automaton determinist topdown tree transduc ta sigma sigma gamma r everi flf rule r form flf x ousli comput relat ta partial ident seidl 14 show dexptimehard decid whether domta 1 tree automata ta ta n given input let ta assum without loss gener set state pairwis disjoint let given follow compon symbol f state suppos new one r 0 contain rule clearli td determinist domta 1 impli comput tree transduct empti otherwis choos arbitrari tree tree 1 deriv complet binari tree height 1 f ffl thu output size td exponenti complet proof theorem corollari 47 set topdown tree transduc whose output size polynomi bound complement whose output size expo nential famou result immerman szelepscenyi 10 15 state nl close complement fact hold determinist class like dexptim anyway polynomi output size problem ie determin whether os td polynomi bound turn thu nl respect dexptim 53 corollari polynomi output size problem nl total topdown tree transduc dexptim gener one pi 6 bottomup tree transduc section output size bottomup tree transduc consid mistak claim conclus 3 result section 5 true also bottomup tree transduc fact hold neither total gener case assum nl 6 p 6 dexptim bottomup tree transduc copi subtre process individu differ state copi take place copi subtre process result consider easier empti problem make possibl appli construct similar one proof lemma 35 use polynomi instead exponenti time hand result bottomup tree transduct may depend delet subtre like copi delet take place process subtre mean intuit delet larg subtre simul effect nontot output size consequ exponenti output size problem bottomup tree transduc becom easier restrict total bottomup tree transduc main result section state problem pcomplet case let us first recal definit bottomup tree transduc 61 definit bottomup tree transduc bottomup tree transduc tupl definit topdown tree transduc finit set rewrit rule set final state bottomup tree transduct comput bu denot bu well set pair bu flt bu denot rewrit relat r pi topdown case assum without loss gener variabl lefthand side rule read left right alway x appropri k 2 n thu everi rule bottomup tree transduc form f fl 1 x 1 state tree sigma 0 l l 2 n contain everi variabl x l exactli x bottomup tree transduc definit determinist r contain one rule whose righthand side f fl 1 x 1 gamma similarli bu total least one rule whose righthand side f fl 1 x 1 output size bu given function os bu defin exactli case topdown tree transduc similarli definit exponenti output size problem carri bottomup case obviou way call state fl bottomup tree transduc tree 2 sigma 2 sigma 0 bu flt follow problem call use use instanc bottomup tree transduc state fl 2 gamma question fl use state follow lemma state use pcomplet rather obviou reformul fact empti problem contextfre string languag pcomplet 11 corollari 11 use wellknown relationship contextfre grammar finit tree automata one hand finit tree automata bottomup tree transduc cf definit finit tree automata proof theorem 52 sake complet explicit proof nevertheless ad 62 lemma state use pcomplet hold problem restrict total determinist bottomup tree transduc whose output signatur fffl 0 g proof proof similar proof 11 corollari 11 let bu gamma order decid whether tree 2 sigma bu flt appli follow standard techniqu comput 0 obvious done polynomi time follow straightforward induct fl use remain prove phard restrict variant 11 corollari 9 follow problem pcomplet finit set binari oper delta given multipl tabl subset 0 element 2 decid whether closur 0 delta ie whether element smallest superset 0 0 b delta c obviou way everi tree 2 sigma seen express delta constant 0 construct deriv bu fl b ffl b valu express particular fl use 2 0 requir furthermor bu comput logarithm space easi convert multipl tabl delta r complet proof similar topdown case conveni simplifi given bottomup tree transduc way righthand side contain exactli one output symbol let theta 0 set bottomup tree transduc everi righthand side rule r element gammah x 63 lemma everi bottomup tree transduc bu one construct bottomup tree transduc bu 0 2 theta 0 constant 2 n os bu na os bu 0 n 2 n construct carri logarithm space proof simpli replac everi rule f fl 1 x 1 r argument proof lemma 33 satisfi claim inequ furthermor obvious done logarithm space show turn bottomup tree transduc total top stringtotre transduc use construct similar one proof lemma 35 64 lemma everi bottomup tree transduc bu 2 theta 0 one construct total stringtotre transduc st 2 theta constant 2 n os bu nn 2 os st n max1 os bu delta n n 2 n construct carri polynomi time proof let 62 set use state determin polynomi time obvious remain state rule appear delet without affect comput transduct therefor follow assum without loss gener gamma contain use state base assumpt let st mon sigma new state r defin follow 1 everi rule f fl 1 x 1 r everi 2 k contain rule flf number time x occur among x contain rule form f fl 1 x 1 r 1 contain rule flf x h order account total 2 everi rule flf contain rule fl 0 f rule fl 0 f gg remaind proof simplifi variant reason proof lemma 35 claim 1 constant 2 n follow hold everi state everi deriv fl st 2 th tree bu proof let 0 smallest natur number everi tree size 0 bu flt tree 2 th defin maximum rank symbol sigma proceed induct length deriv fl st h claim hold induct step let deriv st st jt jg induct hypothesi exist tree 0 bu tree th satisfi jt 0 jg construct r contain rule f fl 1 x 1 time among x defin j 2 k n fig comput similar correspond one proof lemma 35 verifi inequ js 0 j delta jsj furthermor deriv bu bu occur p time among 0 thu get claim second claim let everi tree 2 sigma pathss mon sigma defin follow g furthermor everi state everi tree arbitrari fix tree 0 2 th maximum width fl 0 st 0 notic tree exist st total 2 everi deriv bu flt hold proof induct length deriv deriv length 1 assert trivial case consid deriv bu bu assum tion occur p time among contain rule flf consequ wd fl f 0 0 particular yield claim claim 1 2 prove inequ lemma seen follow rule r 2 st yield st state use claim 1 latter impli exist pair bu jtj thu os st st n os bu delta n prove os st n max1 os bu delta n inequ proof lemma 35 impli exist pair st show os bu nn 2 os st n n 2 n easi prove main result section 65 theorem exponenti output size problem bottomup tree transduc pcomplet hold total determinist bottomup tree transduc proof lemma 63 lemma 64 theorem 52 exponenti output size problem bottomup tree transduc p remain prove p hard total determinist case done reduc problem state use exponenti output size problem class tree transduc lemma 62 suffic consid total determinist bottomup tree transduc gamma state fl 2 gamma show construct logarithm space total determinist bottomup tree transduc bu 0 os bu 0 exponenti fl use state bu let bu clearli bu 0 total determinist construct perform logarithm space order verifi requir equival let bu flffl 2 sigma defin f deriv f bu 0 bu 0 flt everi 2 n full binari tree g ffl height 1 thu output size bu 0 exponenti convers fl use bu clear rule f never appli deriv bu 0 therefor deriv hold output symbol occur remain rule thu os bu 0 exponenti finish proof use lemma 63 64 corollari 47 extend bottomup tree transduc thu sinc p close complement corollari similar corollari 53 obtain 66 corollari polynomi output size problem bottomup tree transduc p pi 7 conclus shown paper exponenti output size problem nl complet total topdown tree transduc dexptimecomplet gener one pcomplet bottomup tree transduc intuit reason huge complex gap two topdown variant gener case solv problem requir solv empti problem topdown tree transduct sever direct futur research could interest complex exponenti output size problem composit topdown bottomup tree transduct gener class tree transduc like eg macro tree transduc 7 seem interest open problem anoth point mention introduct everi k 2 n one construct topdown tree transduct whose output size bound polynomi degre k polynomi degre k gamma 1 fact corollari 47 output size topdown tree transduc either bound polynomi exponenti macro tree transduc engelfriet maneth 6 show decid whether output size linearli bound thu may interest search effici algorithm determin given topdown even macro tree transduc smallest natur number k os 2 k provid k exist final natur class nontot topdown tree transduc exponenti output size problem least solvabl polynomi space acknowledg thank joost engelfriet told find complet result 11 point relat work 1 well helmut seidl anonym refere care read manuscript help list suggest improv r translat context free complex exponenti output size problem topdown tree transduc open question recent result tree transduc tree languag three hierarchi transduc character decid mso defin macro tree transduct macro tree transduc zoltan fulop tree languag nondeterminist space close complement complet problem determinist polynomi time comput complex mathemat system theori haskel overload dexptimecomplet method forc enumer nondeterminist automata gener 2 sequenti machin map there lot finit automata theori would thought tree automata inform survey tr method forc enumer nondeterminist automata nondeterminist space close complement haskel overload dexptimecomplet tree languag syntaxdirect semant character decid msodefin macro tree transduct exponenti output size topdown tree transduc ctr frank drew joost engelfriet branch synchron grammar nest tabl journal comput system scienc v68 n3 p611656 may 2004