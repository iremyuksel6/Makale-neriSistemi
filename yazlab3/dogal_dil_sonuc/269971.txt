make graph reduc control node split sever compil optim data flow analysi exploit instructionlevel parallel ilp loop transform memori disambigu requir program reduc control flow graph howev program satisfi properti new method transform irreduc control flow graph reduc control flow graph call control node split cn present cn duplic node control flow graph obtain reduc control flow graph cn result minimum number split minimum number duplic sinc comput time find optim split sequenc larg heurist develop result heurist close optimum straightforward applic node split result averag code size increas 235 per procedur benchmark program cn heurist limit increas 3 impact total code size complet program 136 straightforward applic node split howev cn use heurist averag growth code size complet program dramat reduc 02 b introduct current comput architectur improv obtain exploit instruct level parallel ilp ilp made possibl due higher transistor densiti allow duplic function unit data path exploit ilp consist map ilp applic onto ilp target architectur effici possibl map use long instruct word vliw superscalar architectur latter use workstat architectur may execut multipl oper per cycl effici usag requir compil fill instruct oper effici possibl process call schedul problem statement order find suffici ilp justifi cost multipl function unit data path schedul larger scope singl basic block time basic block sequenc consecut statement flow control enter begin leav alway end sever schedul scope found go beyond basic block level 1 gener scope current use call region 2 set basic block correspond bodi natur loop sinc loop nest region also nest like natur loop region singl entri point loop header may multipl exit 2 1 speedup 40 report extend schedul scope region problem region schedul requir loop control flow graph singl entri point flow graph call reduc flow graph fortun control flow graph reduc nevertheless problem irreduc flow graph ignor exploit benefit region schedul irreduc control flow graph convert reduc control flow graph exploit ilp also requir effici memori disambigu accomplish nest loop must determin sinc irreduc flow graph nest loop clear memori disambigu techniqu directli appli loop exploit benefit memori disambigu irreduc control flow graph convert reduc control flow graph well anoth pleasant properti reduc control flow graph fact data flow analysi essenti part compil done effici 3 relat work problem convert irreduc flow graph reduc flow graph tackl frontend backend compil 4 5 method normal control flow graph program frontend given method rewrit intermedi program normal form normal irreduc flow graph convert reduc one make graph reduc code duplic result larger code size sinc frontend unawar precis number machin instruct need translat piec code difficult minim growth code size anoth approach convert irreduc flow graph backend advantag select machinecod duplic one take result code size account solut solv problem backend given 6 7 8 9 solut given cock miller 6 9 time complex tri minim result code size method describ hecht et al 7 8 even ineffici sens minim code size requir less analysi paper new method convert irreduc flow graph backend given effici term result code size paper overview section 2 reduc irreduc flow graph defin method detect irreduc flow graph discuss principl node split convers method describ hecht et al straightforward applic node split given section 3 approach control node split cn describ section 4 known convers method convert irreduc flow graph without minim number copi control node split possibl minim number copi unfortun method requir much cpu time therefor develop heurist reduc cpu time still perform close optimum heurist algorithm control node split present result appli cn sever benchmark given section 5 final conclus given section 6 irreduc flow graph control flow program describ control flow graph control flow graph consist node edg node repres sequenc oper basic block edg repres flow control definit 21 control flow graph program tripl n e finit direct graph n collect node e collect edg initi node 2 n path everi node graph figur 1 show exampl control flow graph node initi node c e f c e f b figur 1 reduc control flow graph b graph state introduct find suffici ilp requir input reduc flow graph mani definit reduc flow graph propos one adopt given 8 base partit edg control flow graph g two disjoint set 1 set back edg consist edg whose head domin tail 2 set forward edg fe consist edg back edg thu node u flow graph domin node v everi path initi node flow graph v goe u domin relat figur 1 node domin node node domin node except node node c domin node c e f node domin node e f therefor fg definit reduc flow graph definit 22 flow graph g reduc flow graph acycl everi node n 2 n reach initi node control flow graph figur 1 reduc sinc acycl flow graph figur 2 howev irreduc set back edg empti neither node node b domin fe equal fs acycl definit 22 deriv control flow graph g irreduc graph contain least one loop loop call irreduc loop remov irreduc loop must b figur 2 basic irreduc control flow graph detect first sever method one use interv analysi 10 11 method use hechtullman t1t2 analysi 12 3 method base two transform t2 transform illustr figur 3 defin definit 23 let control flow graph let u 2 n remov edg u u 2 e selfloop edg exist deriv graph becom g short g 1u t1u u figur 3 definit 24 let control flow graph let node v 6 singl predecessor u transform consumpt node v node u successor edg node v becom successor edg node u origin successor edg node u preserv except edg node v set successor node v deriv graph g short g 2v definit 25 graph result repeatedli appli transform possibl order flow graph flow graph result applic t1 t2 possibl call limit flow graph transform denot 7 proven limit flow graph uniqu independ order transform appli theorem 26 flow graph reduc repeatedli appli transform particular order flow graph reduc singl node proof theorem found 12 exampl applic transform given figur 4 flow graph figur 1 reduc singl node conclud flow graph reduc f c c t2c t2a t1a c e f e c f t2d t2e c f e f c t1c figur 4 exampl applic appli transform result flow graph consist multipl node graph irr ducibl transform t1 t2 detect irreduc also detect node caus irreduc exampl irreduc graph given figur 5 theorem 26 follow altern defin irreduc corollari 27 flow graph irreduc limit flow graph singl node 1 anoth definit intuit flow graph irreduc least one loop multipl loop entri 12 b c b c b c b c figur 5 exampl extens basic irreduc control flow graph figur 2 3 flow graph transform control flow graph occur irreduc graph transform techniqu use obtain reduc control flow graph past method given solv problem 6 7 8 method convert irreduc control flow graph base techniqu call node split section 31 techniqu reduc irreduc flow graph describ section 32 show node split appli straightforwardli reduc irreduc graph 31 node split node split techniqu convert graph g 1 equival graph g 2 assign label node graph label node x denot label duplic node creat new node label equival relat two flow graph deriv hecht 7 given definit 31 path flow graph defin labelsp sequenc label correspond path labelsp two flow graph g 1 g 2 equival path p g 1 path q g 2 labelsp convers accord definit two flow graph figur 6 equival note node labela node split defin 32 node split transform graph g graph g node n 2 n multipl predecessor p split incom edg p n duplic n n made one incom edg p outgo edg n n 0 defin n successor node n transform denot g 1 split node n 2 n principl node split illustr figur 6 node graph g 1 split note node n split limit graph correspond node n origin graph must split remov irreduc theorem 33 equival relat two graph preserv transform g 1 b b sa figur simpl exampl appli node split node proof show node split transform graph g 1 equival split graph g 2 assum graph g 1 node v n1 predecessor u 0 successor w k shown figur 7a set labelsp path p graph g denot label g label notat path graph g 1 figur 7a describ k0 flabel label v label w k g b figur 7 two equival graph node split b node split node v split n copi name v split graph g 2 result set path graph g 2 k0 flabel label v graph given figur 7b sinc label v label v everi path g 2 exist also g 1 convers lead conclus graph g 1 g 2 equival sinc figur 7 split node arbitrari number incom outgo edg may gener conclud split node graph result equival graph use reason clear equival relat transit split finit number node either origin graph equival graph result graph equival origin graph 2 name node split decept suggest node split differ part fact node duplic 32 uncontrol node split node split transform techniqu use convert irreduc control flow graph reduc control flow graph hecht 7 adopt theorem 34 theorem 34 let denot split node let denot graph reduct transform eg control flow graph transform singl node transform repres regular express st proof theorem given 7 hecht et al describ straightforward applic node split reduc irreduc control flow graph method select node split limit graph node multipl predecessor select node split sever ident copi one enter edg approach advantag rather simpl disadvantag select node split make graph reduc figur 8a see node b c candid node split figur 8b node split number node reduc applic two t2 transform graph still irreduc split node neither make graph reduc see figur 8c split node b c convert graph reduc control flow graph see figur 8d although method ineffici node split transform irreduc control flow graph eventu reduc one consequ ineffici node split number duplic becom unnecessarili larg 4 present control node split problem exist method result code size convert irreduc graph grow uncontrol control node split cn control amount copi result smaller growth code size cn restrict set candid node split first introduc necessari terminolog definit 41 loop flow graph path n immedi successor n k set node contain loop call loopset figur 8a fa bg fb cg fa b cg loopset definit 42 immedi domin node u idu last domin path initi node graph u exclud node u b c origin irreduc graph b split node c split node split node b figur 8 exampl node split figur 1 node domin node b c e f immedi domin node b c definit 43 share extern domin set sedset subset loopset l properti element share immedi domin immedi domin part loopset l sedset loopset l defin definit 44 maxim share extern domin set msedset k defin sedset k maxim 6 9 sedset k ae definit say msedset proper subset anoth sedset figur 5a multipl sedset identifi like fa bg fb cg fa b cg one msedset fa b cg definit 45 node sedset flow graph classifi three set ffl common node cn node domin sedset reachabl sedset domin ffl reachabl common node rc node domin sedset reachabl sed domin ffl normal node nn node sedset classifi one class node domin sedset initi graph figur 9a identifi msedset fa bg c dg node c element set nn node b element set rc edg c b present node b would element set cn note loop b c sedset theorem 46 sedsetl one node correspond loop l singl header reduc proof theorem deriv 7 exampl sedset one node graph figur 4 transform section 41 descript cn given treat method minim number node split section 42 give method minim amount copi number copi equal number split split creat everi enter edg copi node n enter edg one split creat copi speed process minim amount copi heurist given algorithm implement heurist given section 43 41 control node split node irreduc limit graph except initi node graph possibl candid node split sinc least two predecessor howev split node effici see section 32 cn minim number split accomplish two restrict made set candid node restrict 1 node element sedset candid split 2 node element rc candid split first restrict prevent split node sedset split node ineffici unnecessari exampl split shown figur figur 8b sedset figur 8b fb cg second restrict complic impact restrict illustr figur 9 figur show two differ sequenc node split initi graph figur graph appli figur 9a three split need figur 9b two figur 9a node b split node howev element set rc second restrict prevent split sequenc one figur 9a node split restrict altern eventu result singl node seen easili everi time node element sedset split reduc transform number node involv sedset decreas one sinc consid flow graph finit number node singl node eventu remain b c c node split sequenc three node b node split sequenc two node c b c b figur 9 graph two differ split graph theorem 47 minimum number split need reduc msedset k node given proof everi time node split appli number node msedset decreas one everi predecessor node split duplic made mean everi duplic one predecessor duplic reduc t2 transform result msedset one node less origin msedset reduc complet msedset node one msedset must split one node left result k1 split 2 theorem 48 minimum number split need convert irreduc graph n msedset reduc graph given split total number split k number node msedset proof proof consist multipl part first relat lemma proven lemma 49 msedset disjoint two msedset share node proof node share two msedset node must two differ immedi domina tor conflict howev definit immedi domin given 42 2 sinc msedset disjoint number split individu msedset ad howev split node result merg msedset result hold anymor therefor prove cn merg msedset merg msedset lead less split lemma 410 split node part msedset rc result merg msedset proof first shall prove split node element rc merg msedset afterward prove split node element cn nn merg msedset split rc node merg two msedset consid graph figur 10 suppos subgraph g 1 g 2 msedset node subgraph form join loop possibl x figur 10 merg two msedset go g 1 g 2 viceversa reason subgraph form singl msedset fact differ immedi domin split node rc case node x appli complet graph immedi domin subgraph g 1 becom also immedi domin subgraph g 2 sinc subgraph add singl loop share immedi domin msedset merg hold also gener case x domin reachabl n msedset split node rc merg msedset two type node left candid split node set nn cn split node element set nn merg msedset node edg go msedset therefor split node affect edg one msedset anoth therefor split never result merg msedset split node element set cn merg msedset node form loop msedset domin split node node msedset get immedi domin loop msedset therefor merg lemma 411 reduc two merg msedset result split reduc graph reduc msedset separ proof suppos sedset 1 consist x node sedset 2 node merg cost one split sinc rc node must split reduc result sedset x split total number split x gamma 1y reduc two sedset separ result split one split less split need merg sedset 2 combin lemma 410 411 justifi restrict prevent split node element rc lemma 412 exist alway node irreduc graph part msedset element rc proof node msedset element rc node must domin least two node node domin domin node also element msedset rc graph therefor must infinit number node sinc consid graph finit number node must node part msedset element sinc msedset disjoint algorithm alway find node split without merg msed set result equat 1 hold 2 exampl 413 figur 9 msedset fa bg fc dg identifi two node result minim number split need reduc graph 42 minim amount copi previou section saw algorithm minim number split result minimum number copi instruct basic block follow quantiti minim denot q q n mean quantiti node n qg quantiti graph g defin purpos cn minim qg g transform g singl node use sequenc split formal q g two condit must satisfi achiev minimum 1 freedom select node split must big possibl notic number split also minim prevent split node domin anoth msedset prevent split node element rc cn disadvantag lose freedom select node loss freedom illustr figur 11 suppos node contain number b c figur 11 graph common node set rc instruct want minim total result code size mean would like copi less instruct possibl number copi instruct prevent split node element rc cn q prevent split node element rc number copi instruct min q number instruct node b less node number copi instruct less latter case thu keep set candid node big possibl pay one would like minim amount copi 2 sequenc split node must chosen optim exist multipl split sequenc solv irreduc graph tree build discov figur 12 show flow graph tree possibl split sequenc node tree indic mani copi introduc split b c 2b c c ba cb ab c bc figur 12 irreduc graph copi tree edg give split sequenc number copi found follow path root leaf ad quantiti node suppos node contain number instruct want minim total result code size mean would like copi less instruct possibl choos 6 differ split sequenc 5 differ number copi minimum number copi instruct minq problem pick split sequenc minim number copi instruct theorem 414 minim result qg irreduc graph convert reduc graph requir minimum number split g singl node total reduc graph short split produc g minim proof suppos node limit flow graph except initi node candid split node msedset node element rc also candid split node one categori result number split greater minim number split prove split node alway result qg greater one obtain exclud node proven minimum number split requir order minim qg ffl split node msedset result minimum qg seen previou section split node msedset make graph reduc sinc split node decreas number node msedset mean msedset still need number split ffl split node element rc result minimum qg g sag ag g sa ga saga sa ga split node set rc b split node set rc figur 13 influenc number copi split rc node consid graph figur 13 figur subgraph g least one msedset otherwis graph would irreduc figur 13a show reduct graph case split rc node allow 13b split node allow node g reduc subgraph g notat sa node mean node consum copi node result quantiti node sum quantiti node see result total quantiti split sequenc figur 13a qsqaqg result total quantiti reduc graph figur 13b qs2qaqg without loss gener conclud split node rc never lead minimum total quantiti 2 one easili see node msedset larger tree number possibl split sequenc increas take much comput time comput possibl therefor heurist construct pick node n split smallest h n defin result heurist compar best possibl split sequenc given section 5 43 algorithm method describ previou section detect irreduc control flow graph convert reduc control flow graph section algorithm method given algorithm consist three part 1 t1 t2 transform 2 select candid node 3 split node algorithm 41 control node split input control flow graph procedur reduc control flow graph procedur 1 copi flow graph basic block flow graph g node 2 appli repeatedli t1t2 transform g 3 g one node select 5 split candid node appli repeatedli t1t2 transform g algorithm 41 expect input control flow graph basic block structur flow graph copi flow graph node 1 two differ flow graph flow graph basic block flow graph node mean initi everi node repres basic block everi duplic introduc split flow graph node also perform flow graph basic block graph copi t2 transform appli till graph node chang 2 graph node reduc singl node graph reduc split need howev remain multipl node node split must appli first node split select 4 done algorithm 42 discuss later select node split 5 defin definit 32 graph basic block correspond basic block copi also split t1 t2 transform appli graph node 6 still one node left process start algorithm termin graph node reduc singl node thu graph basic block convert reduc flow graph algorithm transform node split quit straightforward given algorithm 42 select node split initi everi node candid node reject candid fulfil restrict 3 discuss subsect 41 node fulfil restrict heurist calcul 4 equat 1 node smallest heurist select split goal experi measur qualiti control node split sens minim amount copi experi four method node split use optim node split on method comput best possibl node split sequenc respect quantiti minim number basic block number instruct algorithm howev algorithm 42 node select input control flow graph node node split 2 node n 3 n sedset n rc calcul valu hn return candid node requir lot comput time sever day hp735 workstat uncontrol node split ucn straightforward applic node split restrict made set node candid split control node split cn node split restrict discuss section 41 control node split heurist cnsh method cn heurist use select node set candid node algorithm appli select group benchmark benchmark procedur irreduc control flow graph obtain real world program a68 bison expand gawk gs gzip sed tr program compil gcc compil port risc architectur 2 amount copi two differ quantiti consid tabl 1 number copi basic block list tabl 2 number copi instruct report result method ucn cn cnsh averag possibl split sequenc first column tabl 1 2 list procedur name program name parenthes second column give number basic block instruct procedur algorithm appli column give number copi result algorithm absolut number copi given percentag indic growth quantiti respect origin quantiti given result on method conclud node split lead excess number copi furthermor conclud cn outperform ucn ucn lead enorm amount copi averag percentag growth basic block 2417 code size 2355 cn perform better growth 262 basic block 301 number instruct still big gap optim case use heurist control node split perform close optimum averag growth basic block method cnsh on respect 31 30 growth use risc like move architectur move project 13 1 research gener applic specif processor asp mean transport trigger architectur tta tabl 1 number copi basic block atof output programbison 14 2 14 97 69 97 69 20 14 copi definitionbison 119 2 2 4170 350 277 23 20 2 copi guardbison 190 4 2 22735 1197 1334 70 40 2 copi actionbison next fileexpand 17 1 6 50 29 50 29 10 6 compil patterngawk 787 1 0 12027 153 475 6 10 0 gs copi blockgzip 17 2 12 25 15 25 15 20 12 compil programs 145 1 1 801 55 600 41 10 1 search 2sed 486 20 4 13287 273 500 10 210 4 squeez filtertr 33 8 2 163 49 155 47 80 24 total 2692 82 30 65053 2417 7041 262 83 31 code size method 29 compar result on cnsh lead conclus cnsh perform close optimum experi one procedur small differ result tabl 1 2 show substanti improv use cnsh question impact code expans use simpl method like ucn code size complet program impact small bother except theoret aspect tabl 3 4 effect complet code expans shown procedur benchmark irreduc control flow graph convert procedur reduc control flow graph tabl 3 show impact basic block tabl 4 impact code size list first column tabl list program name second column list total number basic block instruct remain column list increas basic block instruct method seen tabl impact node split substanti term number basic block instruct see ucn averag increas basic block 154 instruct 136 use ucn even result code size increas 80 program bison use control node split increas smaller quit accept cnsh result expect smallest increas quantiti result show import clever transform irreduc control flow graph 6 conclus method given transform irreduc control flow graph reduc control flow graph give us opportun exploit ilp larger scope singl basic block program method base node split achiev minimum number split set possibl candid node limit node specif properti sinc split node result minimum result code size algorithm use prevent uncontrol growth code size comput time determin optimum split sequenc larg heurist develop tabl 2 number copi instruct instruct on ucn cn cnsh atof output programbison 59 9 15 415 70 415 70 90 15 copi copi guardbison 880 copi actionbison 858 9 1 29614 345 1225 14 90 1 next fileexpand compil patterngawk 2746 1 0 41069 150 2185 8 10 0 gs lzwd read bufg 228 62 27 950 42 950 42 620 27 copi blockgzip 88 4 5 75 9 75 9 40 5 compil programs 693 2 0 3914 56 2675 39 20 0 search 2sed 1857 91 5 48037 259 2275 12 930 5 squeez filtertr 119 22 18 570 48 555 47 220 18 total 11588 335 29 272917 2355 34841 301 337 29 method heurist call control node split heurist method appli set procedur contain irreduc control flow graph result compar result method method uncontrol node split control node split experi follow uncontrol node split lead enorm number copi averag growth code size per procedur 2355 control node split perform better 301 still big gap optim case observ averag number copi use control node split heurist close optimum averag growth code size per procedur method 29 also look impact total code size benchmark contain procedur irreduc control flow graph method use analysi per procedur use cnsh impact total code size small 02 averag impact ucn howev surprisingli larg averag code size growth 136 maximum bison 80 tabl 3 increas basic block per program program basic block on ucn cn cnsh bison 4441 14 0 35017 79 2228 5 140 0 expand 1226 1 0 50 0 50 0 10 0 gs 16514 sed 3823 21 1 14088 37 1100 3 220 1 tr 1554 8 1 163 1 155 1 80 1 total 43116 108 03 66312 154 7541 17 1090 03 tabl 4 increas instruct per program instruct on ucn cn cnsh bison 19689 63 0 158584 80 9838 5 630 0 expand gs 85824 210 0 21697 3 18041 2 2100 0 sed 17489 93 1 51951 30 4950 3 950 1 tr total 205073 452 02 278840 136 36954 18 4540 02 r global instruct schedul superscalar machin elimin algorithm data flow analysi tame control flow structur approach elimin goto statement controlflow normal algorithm complex analysi techniqu optim comput program flow analysi comput program certain graphtheoret properti program basi program optim program data flow analysi procedur flow graph reduc tr compil principl techniqu tool elimin algorithm data flow analysi global instruct schedul superscalar machin controlflow normal algorithm complex elimin algorithm bidirect data flow problem use edg placement new framework exhaust increment data flow analysi use dj graph loop use dj graph fast usual linear algorithm global flow analysi fast algorithm solv path problem program data flow analysi procedur microprocessor architectur flow analysi comput program transporttrigg versu operationtrigg ctr hansaem yun jihong kim soomook moon time optim softwar pipelin loop control flow intern journal parallel program v31 n5 p339391 octob sebastian unger frank mueller handl irreduc loop optim node split versu djgraph acm transact program languag system topla v24 n4 p299333 juli 2002 fubo zhang erik h dholland use hammock graph structur program ieee transact softwar engin v30 n4 p231245 april 2004 reinhard von hanxleden ken kennedi balanc code placement framework acm transact program languag system topla v22 n5 p816860 sept 2000