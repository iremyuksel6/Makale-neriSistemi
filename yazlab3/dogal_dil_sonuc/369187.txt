optim sequenc hybrid round sequenc hybrid sbh method reconstruct sequenc small finit alphabet collect probe substr substr queri arrang array sbh chip combinatori method use construct sequenc collect probe technolog constraint limit number substr queri place singl sbh chip develop idea margar skiena propos algorithm use seri small sbh chip sequenc long string number probe use match inform theoret lower bound constant factor b introduct consid follow problem let alphabet letter given string drawn uniformli random n abil ask queri type x substr minimum set question one ask high probabl one reconstruct problem abstract problem occur sequenc dna molecul dna strand seen sequenc drawn four letter alphabet nucleotid fa c g tg sequenc hybrid sbh bain smith 1988 drmanac et al 1989 lysov et al 1998 propos altern tradit gilbertsang method sequenc gel electrophoresi survey chetverin cramer 1994 pevzner lipshutz 1994 give overview technolog algorithm aspect method method appli complementari watsoncrick base pair dna molecul given singl strand dna molecul hybrid complement strand sbh base use chip fabric use photolithograph techniqu activ area chip structur matrix region assign specic oligonucleotid biochem attach chip surfac solut uoresc tag target dna fragment expos chip fragment hybrid complementari fragment chip hybrid fragment identi use uoresc detector hybrid lack thereof determin whether fragment substr target string formul assum hybrid chip give us answer ternari queri whether string occur occur occur classic sequenc chip design cm contain singl strand oligonucleotid xed length pevzner algorithm pevzner 1989 reconstruct use classic sequenc chip interpret result sequenc experi subgraph debruijn graph eulerian path correspond possibl sequenc reconstruct therefor uniqu unless eulerian path uniqu exampl found show order uniqu reconstruct member n use classic sequenc chip cm need greater nsee skiena sundaram 1995 pevzner et al 1991 show experiment classic c8 chip contain 65536 oligonucleotid suce reconstruct 200 nucleotid sequenc 94 100 case dyer et al 1994 arratia et al 1996 shown independ cm eectiv random string length n need chosen greater 2 log n word constant probabl reconstruct string length n drawn uniformli random n use classic hybrid chip chip must contain least substr compar inform theoret lower bound number ternari queri need distinguish n element n varieti dierent method suggest overcom neg result classic sbh chip use assumpt univers dna base synthes preparata et al preparata et al 1999 preparata upfal 2000 give scheme size chip optim ie broud et al 1994 suggest gener posit inform along hybrid inform psbh psbh analyz algorithm hannenh et al hannenh et al 1996 show nphard gener problem give ecient algorithm posit inform constant model analyz bendor et al bendor et al 1999 drmanac et al 1989 suggest sequenc larg sequenc obtain spectra mani overlap fragment model analyz algorithm arratia et al 1996 give bound probabl uniqu reconstruct shamir tsur 2001 recent improv analysi arratia et al 1996 furthermor gave algorithm case fals neg error occur hybrid sequenc hybrid round interact sequenc hybrid rst consid margar skiena 1995 assumpt sequenc queri done adapt result one hybrid round known new chip construct origin paper margar skiena give number upper lower bound number round need depend number probe allow round among result algorithm reconstruct sequenc high probabl use olog n chip contain queri main result paper improv result paper written isbh skiena sundaram 1995 show singl queri could ask round nround necessari 1n round sucient string reconstruct kruglyak kruglyak 1998 gave algorithm worst case perform guarante show olog n round sucient queri place chip round follow theorem main result paper theorem 11 high probabl string drawn uniformli random n reconstruct sequenti use seven hybrid chip contain substr queri notic result optim number queri inform theoret sens constant multipl algorithm proce follow manner initi step ask substr queri correspond classic sbh chip construct debruijn graph way suggest pevzner proceed ask target queri order unravel string main result paper mathemat although may eventu practic relev sequenc chip similar classic chip alreadi product hyseq inc hold sever patent procedur drmanac crkvenjakov 1993 chip use success denovo sequenc drmanac et al 1993 sequenc ing sequenc unknown given mani organ sequenc anoth problem practic import resequenc hybrid drmanac et al 1989 peer shamir 2000 problem templat sequenc known goal sequenc determin specic mutat variant sequenc machin produc oligonucleotid array use inkjet printer technolog pioneer blanchard et al 1996 current manufactur agil technolog technolog may prove particularli use interact sequenc hybrid review dierent technolog dna array manufactur see blanchard 1998 schena 1999 relev technolog includ aymetrix type array lockhart et al 1996 fodor et al 1991 southern array maker develop oxford gene technolog southern 1996 note technolog constraint need consid practic implement method develop paper particular realist case fals posit neg error occur experi need consid organ paper follow next section give overview previou work motiv algorithm give simpli version section 3 give complet algorithm verifi correct section 4 prove complex result section 5 demonstr comput experi ctg figur 1 debruijngraph construct substr length 3 agc gct tgc ctg gca cat one occur motiv basic algorithm 21 debruijn graph section review debruijn graph construct rst consid pevzner unknown target string given answer ternari queri string r length whether r occur construct associ edgelabel digraph follow manner vertex set consist edg x 1 2g case edg label 1 x 1 occur 2 x 1 occur follow call debruijn graph figur 1 show construct debruijn graph also label node node x label 0 outedg label 1 one inedg one outedg label 1 label 2 otherwis let x denot label nodeedg x note uniqu path substr x k 1 name path start x 1 end x k m2 x travers edg x x 1g denot path px refer path correspond x special case k 1 refer nodeedg correspond x pevzner show correspond eulerian path graph dene eulerian path graph walk travers edg label 1 exactli edg label 2 least twice graph figur 1 tell origin string agctgcat gc gc gca gc gca gcat gc gca figur 2 exampl map px ctg figur 3 debruijngraph construct substr length 3 agc gct cgc gcg tgc ctg gca cat one occur debruijn graph may howev one eulerian path case construct string ambigu see figur 3 22 simpli algorithm algorithm proce construct debruijn graph substr xed length use inform graph construct set substr queri enabl us determin substr length number larger iter process notic probabl path increas ie attempt elong string correspond node debruijn graph motiv algorithm let us look ambigu elong process notic node x debruijn graph label 1 string correspond outedg occur elong string correspond inedg x henc unambigu determin append last charact string correspond outedg exampl graph tagt know string catagt occur howev node x one outedg need pair inedg outedg atac figur 4 node two outedg graph figur 4 tell two string cataca catacg gacaca gacacg occur one determin substr length six would ask substr queri string central question remaind paper determin condit number queri gener way larg edg graph label 1 would uniqu elong determin elong string catac k charact would sucient determin whether catac elong cataca catacg determin elong ataca atacg charact howev catac elong catacg atacg occur two time atacg two elong length k 1 determin elong catac see determin elong particular edg e k charact sucient determin path e either 1 length k 2 shorter end edg multipl one motiv denit cluster collect node edg label 2 eulerian path pass node edg label 2 determin string biguou set cluster graph set ambigu part graph denit 21 cluster contain x clx maxim connect subgraph contain x node edg task determin thought determin eulerian path start node end node notic intern node edg label 1 uniqu occurr therefor uniqu elong assum know node start node end node reconstruct determin path start node edg label 1 determin continu eulerian path edg uniqu elong either anoth edg label 1 end node motiv follow algorithm reconstruct let c posit constant q set queri place dna chip algorithm 1 step 1 classic sbh chip ne ask queri q construct step 2 resolv ambigu let c c choos node x c let c clx c let q set string 1g step 3 reconstruct debruijn graph answer queri q 23 potenti pitfal let us look complic may face analysi algorithm cycl debruijn graph determin whether given string pass cycl past add queri possibl string may caus us ask larg number queri cycl exampl figur 5 loop aaa edg aaa aac label 2 determin graph aaaa figur 5 exampl cluster along edg cluster node edg label 2 two string taaaca taaact taaaaca taaaact caaaca caaact caaaaca caaaact occur algorithm add queri taaaa caaaa taaaca taaact caaaca taaaca aaaaca aaaact edg aaaa occur graph rst determin whether taaaa caaaa occur determin occurr taaaaca taaaact caaaaca taaaact string aaaaca aaaact occur cluster contain cycl number queri gener algorithm grow number inedg time number outedg cluster cluster contain cycl may abl determin often given path travers cycl contain multipl cycl hold true one number queri gener algorithm may therefor grow exponenti number cycl cluster notic occurr string correspond node graph highli correl occurr string correspond neighbor interdepend make algorithm dicult analyz complex cluster requir larg number queri reason probabl occur averag number queri gener algorithm may fact larg modi algorithm modifi previou algorithm make limit number queri initi given node graph use two round queri may henc abl determin show high probabl seven round sucient use follow modic step 2 notic also modi version doesnt assum prior knowledg start end node add queri start node cluster termin node let k time let q set string ask queri q construct 31 correct algorithm let us clarifi statement theorem 11 denit 31 say event occur high probabl whp occur probabl 1 o1 n 1 lemma 31 number substr queri gener algorithm satisfi condit theorem 11 optim inform theoret sens constant multipl proof n string length n high probabl sequenc string must abl distinguish string 3 possibl answer ternari queri n algorithm gener o1 queri verifi algorithm correct ie whp reconstruct lemma 32 singl iter step 2 0 allow us construct b appli step 2 0 whp reconstruct proof substr x length add queri possibl elong either length k 0 x string multipl one case elong x determin uniqu elong b follow result arratia et al 1996 dyer et al 1994 whp debruijn graph random 2 n 4 complex analysi proceed estim expect number queri iter main goal section prove follow lemma lemma 41 expect number queri q gener singl iter step 2 0 start dene normal node section 41 show queri gener origin normal node form tree section 42 bound number tree section 43 consid relationship tree substr section 44 summar upper bound expect number queri gener origin normal string section 45 show rare node normal henc prove lemma 41 final section 46 show concentr expect number queri 41 normal substr denit 41 everi node x 2 dene subgraph l x edg vertex set set edg vertic reachabl x path x 1 1g say x l x normal l x tree contain end substr p maxim map 1 l x occur disjointli notic denit normal refer substr ie node normal depend string exampl figur 5 l taa graph shown except node caa edg caaa l taa normal sinc contain cycl figur 6 show laac 42 count number tree bound expect number queri q whose initi string x l x normal notic case algorithm step 2 0 gener one queri initi string x everi node l x x 1 ie collect fy substr relat aaca aca act figur exampl figur 5 consid laac normal form aacaaact denot string normal form aacaact sinc two string overlap children also notic denit 41 l x normal contain cycl must therefor tree denit 42 say ari tree node children b ltree b branch node node one child singl child node l leav children node consid order make distinct two children node base order count expect number queri whose initi string x count number dierent b ltree section 43 estim probabl l x tree lemma 42 number distinct b ltree proof number tree b branch node l leav 1k1 sinc less number ari tree size k see knuth 1968 ex 234411 insert intern nonbranch node tree subdivid one exist edg tree ad new singl child root node choic put intern node done ik 1 way outedg intern node chosen way 43 tree string estim probabl l x take form tree multipli number queri gener l x take form avoid signic overcount number queri initi string x count number queri termin leaf node queri initi string x termin intern node count estim number queri gener l x take form one subtre dene partial order tree partial order ensur count queri intern node well denit 43 subtre 0 label tree incub subtre node v either none children v occur 0 note denit children given node must remov time rephras descend 0 seri incub oper children given node appear oper purpos proof import thing note node leaf node incub subtre follow observ immedi denit 41 normal denit 43 lemma 43 given collect c node normal l x predecessor z exist disjoint substr correspond node c particular collect leav incub subtre l x collect relat tree l x substr follow definit give minim requir occurr string correspond node l x denit 44 say collect c string string decomposit tree string correspond edg occur substr c string correspond edg incid root leav occur twice substr c string requir label tree dene label e root edg edg branch node leaf otherwis 2 e le e b le show upper bound probabl l x take form four step first give algorithm return particular type string decomposit bound number possibl string decomposit gener algorithm xed tree go bound probabl contain disjointli given string decomposit final show l x normal take form incub subtre contain disjointli substr form one string decomposit gener algorithm let us x node x x given b xed integ b l furthermor let us dene map subgraph complet debruijn graph name root node x let us name node graph follow notic denit b ltree node children make distinct two base preden order children therefor talk k th child node k number 1 possibl greater number xs children z k th child node name 1 edg 1 k th letter alphabet follow algorithm gener string decomposit algorithm 2 label use string requir label def 44 preorder node initi c empti collect 9 e le 0 let v lowest order node posit label outedg e choos v nonleaf choos e one outedg v append charact correspond e add collect c return c rst upper bound number string decomposit gener algorithm lemma 44 number possibl string decomposit gener algorithm 2 bound r 2i1 number intern nonbranch node r dene denit 44 proof let us count number choic made algorithm let v branch node k sum label vs outedg algorithm 2 arriv k time v whenev v chosen outer loop one vs outedg label get decreas one sinc inedg v label two arriv twice v inner loop rst time arriv v inner loop outedg v posit label one decreas second time arriv v inner loop may choos edg chosen last time arriv v outer loop choic edg travers time choic edg travers number choic clearli less arriv node singl child choic edg travers next number string decomposit therefor b set branch node inequ veri note label outedg node one child alway two except case root one child upper bound probabl string decomposit lemma 45 c collect string gener algorithm 2 probabl string c occur disjointli substr upper bound l r proof let set string lemma 43 jdj l origin chosen string length 1 furthermor append least r extra charact note probabl string length j occur n probabl string occur bound x2d jxj l x2d 1jxj l r relat l x string lemma 46 incub subtre normal l x contain disjointli one collect gener algorithm 2 proof base actual string show algorithm 2 made construct collect disjoint substr denit normal incub subtre l x l x normal e edg label k algorithm 2 must contain least k disjoint substr correspond e outer loop algorithm 2 henc alway choos substr disjoint previous chosen let correspond inner loop make choic e base next charact j1 onward ie j1 k e chosen kth child v sinc l x normal end string occur l x choic child henc alway well dene sinc incub subtre l x choic never return edg termin leaf node 44 number normal queri combin result lemma 42 44 45 give follow lemma lemma 47 probabl l x contain b ltree incub subtre l i1 l lemma 48 let larg enough e 1 expect size set queri qn ad q correspond normal string x bound ne proof estim expect number queri multipli number node x probabl l x b incub subtre number leav l sum b notic l b 1 get expect number queri q multipli number node sum possibl ks number queri ad tree b multipli probabl tree possibl ks number way choos initi node x ejqn 1x ne second inequ follow seri algebra manipul note k e k second equal well known ident geometr seri rst equal less well known observ dierenti ident geometr seri k time slomson 1991 shown queri gener node x graph l x normal 45 remain case show unlik l x normal use fact maximum number queri gener algorithm initi string correspond given node graph bound let us introduc terminolog denit 45 1 say string 2 core string correspond node node string substr x occur substr node string l x ie x k 0 case l x normal end occur l x l x cycl string decomposit l x consist string nondisjoint end occur l x x number queri contain string correspond end substr henc bound 2 depth l x bound k contain cycl period cycl must also bound k 0 1 core x must therefor period k occur node string l x core x period less k call x lowperiod core string simplifi present also consid string period period less 1log ne lowperiod core string extens node string x appear disjointli core x occur twice start posit j ji jj mk 0 1 1 length node string current iter step condit may therefor rewritten ji jj olog n happen say core x selfrepetit count expect number queri q consid four case first count expect number queri stem string lowperiod core expect number elong string selfrepetit core given core lowperiod remaind string normal termin string occur l x count number queri q origin low period core string number node string core period k determin degre freedom outsid core k 0 1 plu degre freedom insid core k therefor k 0 k1 number extens lowperiod core node string henc 1log ne 1log nek1 1 look number queri string origin node string whose core selfrepetit lowperiod expect number core selfrepetit lowperiod number place rst core start number place second core start rst core bound n olog n 1log ne log n expect number string selfrepetit core henc bound 7 log n expect number queri ad q case henc bound 9 use lemma 48 shown lemma 41 expect number queri gener step 2 0 bound ne 46 concentr expect use azuma inequ see alon spencer 1992 show high probabl step 2 0 linear number queri lemma 49 high probabl queri ad q iter step 2 0 proof view sequenc n independ random trial one charact want bound number queri may ad remov q chang one charact chang one charact may eect ne 5 log n string denot length node string current iter step 2 0 seen rst choos posit charact chang queri string note length queri string c charact chang let r m2 r charact immedi preced follow c q queri string aect charact chang length q path q correspond must pass one node correspond substr length 1 contain c particular charact chang occur jth posit q j 1 q charact posit charact posit charact rst posit charact charact case string aect azuma equal 5 log n 2 put complet proof comput result choic k 0 1log ne previou section done eas present may chosen slightli larger decreas number round test practic method implement variant algorithm present stringent algorithm analyz closer origin algorithm step 2 variant limit length queri largest l total number queri round limit instead limit length xed k 0 word step 2 modi line let q set string v l chosen larg possibl ask queri q tabl 1 show number sbh chip use base pair gener randomli number queri round signicantli lower number round guarante worstcas perform guarante algorithm see initi use classic sbh chip contain oligonucleotid size dlog 4 ne 1 nish sequenc dna less 4n extra queri use singl chip exampl tabl 2 show number sbh chip use sequenc arbitrarili chosen viru sequenc one exampl algorithm sequenc dna use classic chip contain string length log extra round 4n queri 6 acknowledg author would like rravi magnu halldorsson dan iel f gudbjartsson anonym refere review paper alan friez support part nsf grant ccr9818411 bjarni v halldorsson support merck comput biolog chemistri program graduat fellowship merck compani foundat r probabilist method poisson process approxim sequenc repeat novel method nucleic acid sequenc determin complex posit sequenc hybrid paterson synthet dna array oligonucleotid array new concept possibl dna sequn determin hybrid strategi ecien larg scale sequenc probabl uniqu solut sequenc hybrid posit sequenc hybrid art comput program fundament algo rithm multistag sequenc hybrid express monitor hybrid highdens oligonucleotid array spectrum align ecient resequenc hybrid toward dnasequenc hybridiza tion improv chip sequenc hybrid journal biomolecular structur dynam optim reconstruct sequenc probe dna microarray larg scale sequenc hybrid reconstruct string substr journal comput biolog dna chip analyz sequenc hybrid oligonucleotid larg scale tr art comput program volum 1 3rd ed sequencingbyhybrid informationtheori bound toward dna sequenc chip reconstruct string substr round ctr steven skiena sagi snir restrict sbh ambigu via restrict enzym discret appli mathemat v155 n67 p857867 april 2007 eran halperin shay halperin tzvika hartman ron shamir handl long target error sequenc hybrid proceed sixth annual intern confer comput biolog p176185 april 1821 2002 washington dc usa