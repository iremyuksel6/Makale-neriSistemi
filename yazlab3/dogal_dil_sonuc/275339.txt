compon base design multitoler system abstractth concept multitoler abstract problem system depend provid basi improv design depend system abstract sourc undepend system repres class fault correspond abil system deal undepend sourc repres type toler multitoler thu refer abil system toler multipl faultclass possibl differ way paper present compon base method design multitoler two type compon employ method name detector corrector theori detector corrector interferencefre composit intoler program develop enabl stepwis addit compon provid toler new faultclass preserv toler previous ad faultclass illustr method design fulli distribut multitoler program token ring b introduct depend increasingli relev systemlevel requir encompass abil system deliv servic desir manner spite occurr fault secur intrus safeti hazard configur chang load variat etc achiev abil difficult essenti engin system sake one depend properti say avail presenc fault often interfer anoth desir depend properti say secur presenc intrus paper effect reason multipl depend properti introduc concept multitoler sourc undepend treat class fault depend properti treat type toler thu multitoler refer abil system toler multipl class fault possibl differ way although mani exampl multitoler system practic 1 gamma 3 exist grow bodi research present instanc multitoler system 4 gamma 9 awar previou work consid systemat design multitoler toward redress defici present paper formal method design multitoler system deal difficulti interfer multipl type toler method base use compon specif multitoler system design use method consist intoler system set compon one desir type toler thu method reduc complex design design compon correctli ad intoler system moreov enabl reason type toler interfer differ type toler level compon oppos involv whole system method reduc complex ad multipl compon intoler system ad compon stepwis fashion word method consid fault class intoler system subject fix total order say f1 fn compon ad intoler system toler f1 desir manner result system augment anoth compon toler f2 desir manner toler f1 preserv process ad new toler preserv old toler repeat n faultclass account follow final system multitoler respect f1 fn compon use method built two build block name detector corrector occur albeit implicitli faulttoler system intuit detector detect whether predic satisfi system state corrector detect whether predic satisfi system state also correct system state order satisfi predic whenev predic satisfi detector use ensur step system safe respect problem specif corrector use ensur system eventu reach state problem specif resatisfi thu paper also abl show compon built detector suffici design failsaf toler program compon built corrector suffici design nonmask toler program compon built detector corrector suffici design mask toler program formal defin term shortli rest paper organ follow section 2 give formal definit program problem specif fault faulttoler section 3 4 defin detector corrector discuss role design faulttoler system illustr design hierarch effici section 5 present theori noninterfer compos detector corrector intoler program section 6 defin multitoler present formal method design multitoler section 7 illustr method design multitoler token ring program final discuss issu rais methodolog section 8 make conclud remark section 9 preliminari section give formal definit program problem specif fault fault toler formal program standard one specif adapt alpern schneider 9 fault faulttoler adapt earlier work first author moham gouda 10 except portion failsaf toler new program program set variabl finit set action variabl predefin nonempti domain action uniqu name form guard action boolean express program variabl statement action execut atom instantan updat zero program variabl notat conveni write action restrict anoth action use notat hname defin action hname 0 whose guard obtain restrict guard action hnamei hguard 0 whose statement ident statement action hnamei oper speak hname 0 execut guard hnamei guard hguard 0 true likewis conveni write program restrict anoth program use notat defin program consist set action hguardi ac action ac hprogrami let p program definit state state p defin valu variabl p chosen predefin domain variabl definit state predic state predic p boolean express variabl p note state predic may character set state boolean express state predic true definit enabl action p enabl state iff guard state predic true state definit comput comput p fair maxim sequenc state j j 0 j obtain state j gamma1 execut action p enabl state j gamma1 fair sequenc mean action p continu enabl along state sequenc eventu chosen execut maxim sequenc mean sequenc finit guard action p fals final state ie sequenc extend execut enabl action final state problem specif problem specif set sequenc state suffix close fusion close suffix closur set mean state sequenc oe set suffix oe fusion closur set mean state sequenc hff x fli hfi x ffii set state sequenc hff x ffii hfi x fli ff fi finit prefix state sequenc fl ffi suffix state sequenc x program state note state sequenc problem specif may finit infinit follow alpern schneider 9 shown problem specif intersect safeti specif suffix close fusion close live specif defin next definit safeti safeti specif set state sequenc meet follow condit state sequenc oe set exist prefix ff oe state sequenc fi fffi set fffi denot concaten ff fi definit live live specif set state sequenc meet follow condit finit state sequenc ff exist state sequenc fi fffi set defin exampl problem specif name gener pair closur converg let r state predic definit gener pair gener pair fsg frg set state sequenc j j 0 true j r true j1 definit closur closur set state sequenc true j k k j true k definit converg converg r set state sequenc intersect r true exist k k r true k note fsg converg program correct respect problem specif let spec problem specif definit satisfi p satisfi spec iff comput p start state true spec definit violat p violat spec iff case p satisfi spec exist comput p start state true spec conveni reason program satisfi special case problem specif introduc follow notat abbrevi definit gener hoaretripl fsg p frg iff p satisfi gener pair fsg frg true definit close p close p iff p satisfi true note trivial true state predic true fals close p definit converg p converg r p iff p satisfi converg r true inform speak prove correct p respect spec involv show p satisfi spec state predic cours use predic fals sinc problem specif suffix close may without loss gener restrict attent prove p satisfi problem specif close state predic call state predic invari p invari enabl proof program correct eschew oper argument long subsequ state thu methodolog advantag definit invari invari p spec iff close p p satisfi spec notat remark henceforth whenev problem specif clear context omit thu invari p abbrevi invari p spec one way calcul invari p character set state reachabl execut p start design initi state experi show howev eas proof program correct one may prefer use invari p properli includ reachabl set state key reason includ initi state definit program techniqu design invari articul dijkstra 11 use notion auxiliari variabl gri 12 use heurist state predic balloon shrink techniqu mechan calcul invari discuss alpern schneider 13 fault fault program subject systemat repres action whose execut perturb program state emphas represent possibl notwithstand type fault stuckat crash failstop omiss time perform byzantin natur fault perman transient intermitt abil program observ effect fault detect undetect definit faultclass faultclass p set action variabl p let state predic invari p f faultclass p definit preserv action ac preserv state predic iff execut ac state true result state true f span p iff close p action f preserv thu state invari p true f span p also true also like also close p moreov action f execut state true result state also one true follow comput p start state true boundari state space p beyond state p may perturb occurr action f notat remark henceforth ambigu abbrevi phrase action f preserv close f whenev program p clear context omit thu invari abbrevi invari p f faultclass abbrevi f faultclass p faulttoler readi defin mean program p invari toler faultclass f definit toler p f toler iff exist state predic satisfi follow three condit ffl state true also true word ffl start state true action p f execut result state also one true word close p action f preserv ffl start state true everi comput p alon eventu reach state true word sinc close p converg p definit may understood follow state predic f span p boundari state space p beyond state p may perturb occurr fault f fault f continu occur state p remain within boundari fault f stop occur p converg boundari stricter boundari state space invari true import note may multipl state predic p meet three requir multipl state predic captur potenti differ type faulttoler p exploit multipl section 6 order defin multitoler type faulttoler classifi three type faulttoler program exhibit name mask nonmask failsaf toler use definit f toler inform speak classif base upon extent program satisfi problem specif presenc fault three mask strictest type toler presenc fault program alway satisfi safeti specif execut p execut action f yield comput safeti live specif p ie comput problem specif p nonmask less strict mask presenc fault program need satisfi safeti specif fault stop occur program eventu resum satisfi safeti live specif ie comput suffix problem specif failsaf also less strict mask presenc fault program alway satisfi safeti specif fault stop occur program need resum satisfi live specif ie comput safeti specif necessarili live specif p formal three type toler may express term definit f toler follow definit mask toler p mask toler f iff p f toler close f word fault f occur state true p continu state true definit nonmask toler p nonmask toler f iff p f toler close f word fault f occur state true p may perturb state violat howev p recov state true definit failsaf toler p failsaf toler f iff exist state predic r p f toler r r close p f p satisfi safeti specif problem specif r word fault f occur state true p may perturb state r true latter case subsequ execut p yield comput safeti specif p necessarili live specif notat sequel whenev faultclass f invari clear context omit thu mask toler abbrevi mask toler f detector section defin first two build block suffici design faulttoler program name detector also present properti detector show construct hierarch effici manner discuss role design faulttoler mention introduct intuit detector program detect whether given state predic true current system state implement detector abound practic wellknown exampl includ compar error detect code consist checker watchdog program snooper alarm snapshot procedur accept test except condit z state predic program u state predic close say z detect x u iff follow three condit hold ffl safe state u true z true x also true word u ffl progress start state u x true everi comput either reach state z true state x fals ffl stabil start state u z true falsifi z also falsifi x word fu zg fz xg safe condit impli detector never let predic z wit detect predic x incorrectli execut state u true progress condit impli comput start state u true x true continu eventu detect x truthifi z stabil condit impli z truthifi continu true unless x falsifi remark detect predic x close definit detect relat reduc one given chandi misra 14 consid gener definit accommod case occur instanc nonmask toler x denot someth bad happen case x suppos close sinc subsequ correct end remark sequel implicitli assum specif detector dn z detect x u respect zn detect xn dn un also implicitli assum u un close respect dn properti detect relat reflex antisymmetr transit first two argument lemma 30 let x z state predic u state predic close follow statement hold detect x u ffl z detect x u x detect z u u ffl z detect u detect x u z detect x u lemma 31 let v state predic u v close follow statement hold ffl z detect x u z detect x uv ffl z detect x u v x zv detect x u ffl z detect x u z z detect xv u composit regard construct detector case detect predic x wit atom ie execut one action detector program detect predic give composit small detector yield larg detector hierarch effici manner particular given two detector d1 d2 compos two way parallel ii sequenc parallel composit detector parallel composit d1 d2 denot d1d2 d1 d2 execut interleav fashion formal parallel composit d1 d2 union variabl action program d1 d2 observ commut d1d2d3 distribut g theorem 32 let z1 detect x1 d1 u z2 detect x2 d2 u variabl d1 d2 mutual exclus z1z2 detect x1x2 d1d2 u proof safe condit d1d2 follow trivial safe d1 d2 progress condit consid two case comput d1d2 falsifi x1 x2 ii comput d1d2 never falsifi x1 x2 first case progress satisfi trivial second case eventu z1 truthifi stabil d1 z1 continu true execut d1 moreov sinc variabl d1 d2 disjoint z1 continu true d2 likewis z2 eventu truthifi continu true thu progress satisfi final stabil condit satisfi sinc z1z2 falsifi x1 x2 violat d1d2 sinc d1 d2 perform detect concurr time requir detect x1x2 maximum time taken detect x1 detect x2 assum unit measur time allow d1 d2 attempt execut action also space complex d1d2 sum space complex d1 d2 sinc state space d1d2 union state space d1 d2 sequenti composit detector sequenti composit d1 d2 denot d1 d2 d2 execut d1 complet detect ie wit predic z1 true formal sequenti composit d1 d2 program whose set variabl union variabl d1 d2 whose set action union action d1 z1d2 postul axiom leftassoci d1 d2 observ commut distribut d1 distribut g d1 suppos variabl d1 d2 mutual exclus case start state x1x2 true continu d1 eventu truthifi z1 z1 truthifi action d2 execut action eventu truthifi z2 sinc z2 truthifi z1 henc x1 x2 true also follow u assum u theorem 33 let z1 detect x1 d1 u z2 detect x2 d2 ux1 variabl d1 d2 mutual exclus u z2 detect x1x2 d1 d2 u d1 d2 time respect space taken detect x1x2 sum time respect space taken detect x1 detect x2 extra time taken d1 d2 compar d1d2 warrant case wit predic z2 wit atom z1z2 exampl memori access let us consid simpl memori access program obtain valu store given address cf figur 1 program subject two faultclass first consist protect fault caus given address corrupt fall outsid valid address space second consist page fault remov address valu memori toler first faultclass detector d1 use page tabl tbl detect whether address addr valid x1 toler second faultclass anoth detector d2 use memori mem detect whether given address memori x2 d2 mem addr figur 1 memori access formal detector follow simplic assum tbl set valid address mem set object form haddr vali thu may observ ffl z1 detect x1 d1 u1 1 ffl z2 detect x2 d2 u1 x1 2 note appropri choic initi state u1 would one z1 z2 fals note also u1 z1 truthifi x1 true z2 truthifi x1 x2 true detect x1x2 may compos d1 d2 sequenti d1 would first detect x1 d2 would detect x2 theorem 33 1 2 get ffl z2 detect x1 x2 d1 d2 u1 3 applic design faulttoler detector suffic ensur program satisfi safeti specif see recal safeti specif essenti rule certain finit prefix program comput consid prefix comput rule safeti specif execut program action start prefix violat safeti specif iff elong prefix rule safeti specif word program action ac exist set comput prefix execut ac violat safeti specif follow exist detect state predic execut ac state state predic true violat safeti specif fusion closur safeti specif suffic state predic character set state state st yield upon execut ac successor state st 0 state sequenc safeti specif st st 0 occur consecut order detector ad program program action ac detect predic ac wit program action restrict execut correspond wit predic true result program satisfi safeti specif design failsaf toler f need ensur upon start state true execut p presenc f alway yield comput safeti specif p follow detector suffic design failsaf toler likewis design mask toler f need ensur upon start state true execut p presenc f never violat safeti specif execut p execut action f alway yield comput safeti live specif p ie comput problem specif p fusion closur problem specif follow comput p safeti specif suffix problem specif problem specif regard safeti suffic detector ad p regard live suffic corrector ad p discuss next section detector also play role design nonmask toler may use detect whether program perturb state invari fals discuss next section detector systemat compos corrector restor program state invari true section discuss second set build block name corrector manner analog discuss detector mention introduct intuit corrector detector also correct program state whenev detect detect predic fals current system state implement corrector also abound practic wellknown exampl includ voter error correct code reset procedur rollback recoveri rollforward recoveri constraint resatisfact except handler altern procedur recoveri block z state predic program c u close c say z correct x c u iff follow four condit hold ffl safe state u true z true x also true word u ffl converg start state u true everi comput c eventu reach state x true subsequ x continu true thereaft word u converg x c start state u x true everi comput c either reach state z true state x fals ffl stabil start state u z true c falsifi z also falsifi x word fu zg c fz xg definit follow z correct x c u z detect x c u also follow u x close c cf converg consequ start state u x true everi comput c reach state z true cf progress moreov u z close c cf stabil remark wit predic z ident correct predic x definit correct relat reduc one given arora gouda 10 consid gener definit accommod case occur instanc mask toler wit predic z check atom correct predic x end remark properti correct relat antisymmetr transit first two argument lemma 40 let x z state predic c u state predic close c follow statement hold ffl z correct x c u x correct z c u u ffl z correct c u correct x c u z correct x c u lemma 41 let v state predic u v close c follow statement hold ffl z correct x c u z correct x c u v ffl z correct x c u v x zv correct x c u composit analog detect predic wit atom exist case correct predic x correct atom ie execut one step action corrector correct predic construct larg corrector small corrector detector parallel composit corrector parallel composit two corrector c1 c2 denot c1c2 union variabl action program c1 c2 theorem 42 let z1 correct x1 c1 u z2 correct x2 c2 u variabl c1 c2 mutual exclus z1z2 correct x1x2 c1c2 u time taken c1c2 correct x1x2 maximum time taken correct x1 correct x2 space taken correspond sum sequenti composit corrector sequenti composit corrector c1 c2 denot c1 c2 program whose set variabl union variabl c1 c2 whose set action union action c1 z1 c2 theorem 43 let z1 correct x1 c1 u z2 correct x2 c2 u x1 variabl c1 c2 mutual exclus u z2 correct x1x2 c1 c2 u time respect space taken c1 c2 correct x1x2 sum time respect space taken correct x1 correct x2 mention previou section one way design corrector x sequenti composit detector corrector detector first detect whether x true use wit corrector establish x theorem 44 let z detect x u z x correct x c u z 0 x close fu zg c fz xg x correct x z c u c atom ie c satisfi progress converg one step follow corollari hold corollari 45 let z detect x u z x correct x c u z 0 x close c atom x correct x c u anoth way design corrector x sequenti composit corrector detector corrector first satisfi correct predic x detector satisfi desir wit predic z theorem 46 let x correct x c u z detect x u x close z correct x x c u atom follow corollari hold corollari 47 let x correct x c u z detect x u x close c atom z correct x c u exampl memori access continu given address valid memori object form haddr gammai ad memori omit detail object obtain eg disk remot memori network thu corrector c formal specifi follow addr d2 c figur 2 memori access thu may observ ffl x2 correct x2 c true 4 ffl x2 correct x2 c u1 5 ffl x2 correct x2 c u1 x1 6 detector d2 wit valu address memori corrector c execut henc compos c d2 sequenti corollari 47 2 6 ffl z2 correct x2 c d2 u1 x1 7 moreov detector d1 wit address valid either corrector c detector d2 execut henc compos d1 c d2 sequenti recal section 3 z1 detect x1 d1 u1 also x1 close d1 henc d1 start state satisfi u1 x1 eventu satisfi z1 follow z1 correct x1 d1 u1 x1 therefor theorem 43 9 ffl z2 correct x1 x2 d1 c d2 u1 x1 8 applic design faulttoler corrector suffic ensur comput program suffix problem specif see observ correct predic corrector chosen invari program corrector ensur program eventu reach state invari true henceforth program comput problem specif design nonmask toler f invari need ensur upon start state true execut p execut action f alway yield comput suffix problem specif follow corrector whose correct predic invari suffic design nonmask toler likewis design mask toler f need ensur upon start state true execut p presenc f never violat safeti specif execut p execut action f alway yield comput problem specif p latter guarante suffic corrector ad p former suffic detector ad p discuss previou section 5 composit detectorcorrector compon program section discuss detectorcorrector compon correctli ad program result program satisfi specif compon far possibl proof preserv simpler explicitli prove specif satisfi result program achiev composit proof show program interfer compon ie program compon execut concurr violat specif compon composit proof interferencefreedom receiv substanti attent formal method commun 15gamma19 last two decad draw effort identifi sever simpl suffici condit ensur program p compos detector respect corrector q safeti specif q viz safe stabil live specif viz progress converg violat suffici condit satisfi safeti specif detector demonstr p interfer safe stabil straightforward suffici condit action p subset action q occur instanc program act detector anoth straightforward condit variabl p q disjoint gener condit p read write variabl q case p said superpos q suffici condit satisfi live specif detector three condit given also suffic demonstr p interfer progress q provid action p q execut fairli yet anoth condit satisfi progress q requir q atom ie q achiev progress one step follow even p q execut concurr progress q satisfi altern requir p execut progress q achiev follow p interfer progress q likewis requir p termin eventu follow p termin execut q isol satisfi progress gener requir exist variant function f whose rang wellfound set execut action p q reduc valu f progress q achiev follow even q execut concurr p progress q satisfi suffici condit outlin formal state tabl 1 suffici condit case corrector similar follow theorem let z detect x q u let u close p theorem 50 superposit q read write variabl written p read variabl written q z detect x qp u theorem 51 contain action p subset q z detect x qp u theorem 52 atom fu zg p fz xg q atom z detect x qp u theorem 53 order execut fu zg p fz xg z detect x q p u theorem 54 termin fu zg p fz xg u converg v pq z detect x v pq u theorem 55 variant function fu 0f kg q f0f z detect x qp u tabl suffici condit interferencefreedom discuss address prove program interfer compon compon interfer program standard composit techniqu suffic purpos practic detector snapshot procedur watchdog program snooper program typic read write state program ad thu detector interfer program likewis corrector reset rollback recoveri forward recoveri procedur typic restrict execut state invari hand fals thu corrector interfer program exampl memori access continu consid intoler program p memori access assum address valid current present memori eas exposit let p access one memori locat instead multipl locat thu p follow p interfer specif corrector d1 c d2 suffic p execut z2 wit predic d1 c d2 satisfi henc d1 c d2 p compos sequenc analogu theorem 53 case corrector p interfer d1 c d2 ffl z2 correct x1 x2 d1 c d2 p u1 x1 6 design multitoler section first defin multitoler present method composit stepwis design multitoler program let p program invari f1fn n faultclass l1 l2 ln type toler ie mask nonmask failsaf say p multitoler f1fn iff faultclass f j 1j n p ljtoler f j definit may understood follow presenc fault class f j p perturb state f jspan predic j true note exist potenti differ faultspan faultclass fault f j stop occur subsequ execut p alway yield comput problem specif prescrib type toler lj exampl lj failsaf comput p start state j true safeti specif exampl memori access continu observ memori access program d1 c d2 p discuss section 5 multitoler class protect fault page fault failsaf toler former mask toler latter particular presenc page fault alway obtain correct data memori presenc protect fault obtain data valu composit stepwis design method outlin introduct method start faultintoler program stepwis manner consid faultclass fix total order say f1fn first step intoler program augment detector andor corrector compon l1toler f 1 result program augment detectorcorrector compon second step l2toler f2 l1toler f1 preserv nth step lntoler fn ad preserv l1lngamma1toler f1fngamma1 multitoler program design thu structur shown figur 3 detector andor corrector fn faultintoler program detector andor corrector f1 detector andor corrector f2 figur 3 structur multitoler program design use method first step let p intoler program invari calcul f 1span p detector corrector compon design satisfi l1toler f 1 discuss section 3 4 suffic add detector design failsaf toler f 1 corrector design nonmask toler f 1 detector corrector design mask toler f 1 toler program nonmask program failsaf corrector detector corrector intoler program mask toler program detector toler figur 4 compon suffic design variou toler note detector corrector ad p also subject f henc toler f necessari mask toler f specif suffic detector ad design failsaf toler failsaf toler f detector satisfi live specif presenc f result program made satisfi live specif p presenc f likewis suffic corrector ad design nonmask toler nonmask toler f long comput corrector suffix safeti live specif comput result program made suffix safeti live specif p lastli expect suffic detector corrector ad design mask toler mask toler f see figur 5 practic detector corrector ad p often possess desir toler f trivial one way design toler f analog addit detector corrector anoth way design self toler without use detector corrector compon exemplifi selfcheck selfstabil inher faulttoler design toler program nonmask compon toler program intoler program failsaf mask toler program nonmask mask compon figur 5 toler requir compon addit detector andor corrector compon p remain show result program p1 compon interfer p p interfer compon note p1 may contain variabl action p henc invari faultspan p1 may differ p therefor let s1 invari p1 t1 f 1span p1 s1 show follow 1 absenc f 1 ie state s1 true compon interfer p ie comput p problem specif even execut concurr new compon 2 presenc f 1 ie state t1 true p interfer compon ie comput compon compon specif sens prescrib type toler even execut concurr p addit detector corrector may simplifi use stepwis instanc design mask toler may first augment program detector augment result failsaf toler program corrector altern may first augment program corrector augment result nonmask toler program detector see figur 6 reason space refer interest reader 20 formal detail twostag approach design mask tolerance000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111toler mask toler program intoler program corrector detector program corrector program detector failsaf nonmask toler figur two approach stepwis design mask toler second step step add l2toler f2 preserv l1toler f 1 add l2 toler f 2 first step add new detector corrector compon p1 account possibl interfer execut ad compon p1 specif let s2 invari result program p2 t21 f 1span p2 s2 t22 denot f 2span p2 s2 show follow 1 absenc f1 f 2 ie state s2 true newli ad compon interfer p1 ie comput p1 problem specif even execut concurr new compon 2 presenc f 2 ie state t22 true p1 interfer new com ponent ie comput new compon new compon specif sens prescrib type toler even execut concurr p1 3 presenc f 1 ie state t21 true newli ad compon interfer l1toler p1 f 1 ie comput p1 specif l1toler f 1 even p1 execut concurr new compon remain step remain step design add toler f3fn procedur second step gener accordingli 7 case studi multitoler design token ring recal mutual exclus problem multipl process may access critic section provid time one process access critic section moreov process wait forev access critic section assum process leav critic section finit time mutual exclus readili achiev circul token among process let process enter critic section token token ring program particular process organ ring token circul along ring fix direct case studi design multitoler token ring program program mask toler number k fault corrupt state process detect toler continu sens k state corrupt occur correct state within thetak time thu quantit uniqu measur toler provid fk fk fault class caus k state corrupt process detect corrupt state process mean corrupt state detect process action inadvert access state state immedi corrupt may howev lost purpos irrelev caus corrupt ie whether due loss messag duplic messag time fault crash subsequ restart process etc proceed follow first describ simpl token ring program intoler detect state corrupt add detector corrector achiev mask toler fault corrupt state one process progress add detector corrector achiev mask toler faultclass corrupt process state k k 1 time 71 faultintoler binari token ring process 0n organ ring token circul along ring process j token successor j 1 section gamma modulo n1 process j maintain binari variabl xj process j j 6 n token iff xj differ successor xj 1 process n token iff xn successor x0 program tr consist two action process j formal action follow invari consid state process j token state sinc process token x valu process 0j ident x valu process j1n ident let x denot string binari valu x0 x1 xn x satisfi regular express 0 l 1 n1gammal 1 l 0 n1gammal denot sequenc length n1 consist zero follow one one follow zero thu invari program tr 72 ad toler 1 state corrupt base assumpt state corrupt detect introduc special valu process j detect state ie valu xj corrupt reset xj readili design mask toler singl corrupt state process j ensur valu xj eventu correct longer ii interim process particular j1 inadvert get token result corrupt xj add corrector process j correct xj valu either 0 1 corrector j j 6 0 copi xj gamma 1 corrector corrector action j statement action tr j merg corrector tr action ii add detector process detect predic action wit predic detector case detect predic use restrict action program tr j henc action tr j execut result execut action tr alway safe ie action inadvert gener token augment program ptr fault action state xj corrupt xj set henc fault action proof interferencefreedom start state tr true presenc fault set x valu process string x alway satisfi regular express 0 l 1 n1gammal 1 l 0 n1gammal thu invari ptr sptr consid detector j detect wit predic xj gamma 1 6 sinc detect relat trivial reflex first two argument follow ptr word detector interf action consid corrector j correct wit predic xj 6 sinc program action ident corrector action theorem 51 corrector action interf action tr also sinc detector action detector process j interfer corrector j moreov sinc one x valu set xj thu corrector j enabl wit predic detector j true henc corrector j interf detector j consid program action tr safeti follow safeti detector describ progress follow progress corrector ensur start state sptr true process state corrupt everi comput ptr reach state tr true progress detector ensur action tr indefinit block execut observ proof mutual interferencefreedom illustr reprov correct tr new invari observ also state process j corrupt within theta1 time corrector j correct state j 73 ad toler 2n state corrupt proof noninterfer program ptr gener show ptr also mask toler faultclass twice corrupt process state gener selfevid case state corrupt separ time first one correct second one occur case state corrupt occur concurr say process j k need show corrector j k truthifi interfer action program let us consid two subcas j k nonneighbor ii j k neighbor first subcas j k correct xj xk predecessor jgamma1 kgamma1 respect execut equival parallel composit corrector j k theorem 42 ptr reach state xj xk second subcas let j predessor k j correct xj predecessor truthifi xj 6 termin sinc corrector j read variabl written corrector k thu analogu theorem 50 case corrector corrector j interf corrector k xj 6 truthifi corrector k correct xk predecessor j theorem 44 corrector k interf corrector j sinc corrector j k interfer follow program reach state xj xk fact long number fault n exist least one process j xj 6 ptr ensur state j eventu caus j1 correct state xj correct continu process x valu set henc ptr toler n fault time requir converg tr thetak k number fault 74 ad toler n state corrupt unfortun n fault occur program ptr deadlock iff reach state x valu process mask toler faultclass corrupt state process n time corrector need detect whether state process correct program state x valu process say 0 equal 0 1 sinc x valu process access simultan corrector detect sequenti manner whether x valu process let detector ad purpos process j denot dj sequenti compos detector detect whether x valu process corrupt dn design dj add valu domain xj dn detect xn equal set xn likewis dj detect xj equal set xj note sinc dj part sequenti composit restrict execut j1 complet detect ie xj1 equal follow j complet detect x valu process jn corrupt particular d0 complet detect x valu process corrupt henc x0 set suffic corrector reset x0 0 ensur corrector execut process inadvert get token result corrupt xj add detector restrict action ptr j1 execut state xj 6 true action program ftr consist five action process j like ptr first two action ftr1 ftr2 pass token j j1 restrict trivial detector execut xj gamma1 neither action ftr3 dn let process n chang xn action ftr4 dj j n action ftr5 corrector action process 0 let process correct x0 0 formal action follow invari start state sptr true detector chang trail valu x thu ftr may reach state x satisfi regular express 1 l 0 subsequ state corrupt may perturb x form 1 l 0 n1gammalgammam 0 l 1 n1gammalgammam sinc action preserv last predic invari ftr 0 proof interferencefreedom design ftr ad corrector action ftr3 gamma 5 program ptr ensur j xj corrupt ie correct predic corrector v corrector form dn dngamma1 d0 c0 dj atom detector process j c0 atom corrector process 0 detect predic dn v wit predic x0 show detector isol satisfi specif observ 1 xn detect dn sftr 2 sftr 1 2 theorem 33 xn gamma1 detect use argument x0 detect dn observ sftr converg v dn violat execut eventu truthifi x0 execut c0 truthifi v thu v correct v dn corrector interf action ftr1 ftr2 follow fact ftr1 ftr2 interfer dj c0 use theorem 52 program ftr also ad detector process j detect xjgamma1 6 describ 1 fault case detector interfer action interf action final consid action program ptr safeti follow safeti detector describ also start state sftr program reach state x valu process corrupt start state program ptr eventu program reach state tr truthifi ie action ptr perman block thu progress action follow theorem 70 program ftr mask toler invari sftr faultclass fk k 1 fk detect corrupt process state k time moreov sftr converg tr ftr within thetak time remark emphas program ftr mask toler faultclass fk invari sftr tr thu presenc fault fk sftr continu true although tr may violat process j j n token iff xj differ xj1 neither xj xj1 corrupt process n token iff xn x0 neither xn x0 corrupt thu state sftr true one process token also start state eventu program reach state tr true start state process get token thu start state sftr comput ftr problem specif token ring section address issu method design multitoler rais also discuss motiv design decis made work formal concept multitoler use abstract closur converg abstract use formal multitoler advantag use closur converg principl one formul concept multitoler use abstract closur converg point john rushbi 21 approach formul faulttoler classifi two specif approach calcul approach specif approach system regard composit sever subsystem standard specif one failur specif system faulttoler satisfi standard specif compon one failur specif compon depart standard specif one exampl approach due herlihi wing 22 thu formul grace degrad special case multitoler calcul approach set comput permiss presenc fault calcul system said faulttoler set satisfi specif system accept degrad version approach calcul sinc comput set state potenti reachabl presenc fault faultspan approach may use formul design multitoler awar formal method design multitoler use moreov experi structur impos abstract closur converg proven benefici sever way 1 enabl us discov role detector corrector design toler properti cf section 3 4 2 yield simpl theorem compos toler action underli action interferencefre manner cf section 5 6 3 facilit design novel complex distribut program whose toler exceed compar program design otherwis 5 10 20 23 24 25 repres fault state perturb represent readili handl transient fault also handl perman fault intermitt fault detect fault undetect fault inde repres state perturb token ring case studi illustr use state perturb variou class transient fault extend version paper 24 present case studi treebas mutual exclus illustr analog represent perman fault detect undetect fault worth point repres perman intermitt fault byzantin fault failstop repair fault may requir introduct auxiliari variabl 5 10 exampl repres byzantin fault affect process j may introduc auxiliari boolean variabl byzj true iff j byzantin j byzantin execut normal action otherwis execut abnorm action byzantin fault occur byzj truthifi thu permit j execut abnorm action similarli repres failstop repair fault affect process j may introduc auxiliari boolean variabl downj true iff j failstop action j restrict execut downj fals failstop fault occur downj truthifi thu prevent j execut action repair occur downj falsifi assum problem specif suffix close fusion close assumpt exploit design method assumpt restrict applic method use assumpt three place 1 suffix closur problem specif impli exist invari state predic 2 fusion closur problem specif impli exist correct state predic 3 suffix closur fusion closur problem specif impli correspond safeti specif fusion close turn impli exist detect state predic assumpt restrict follow sens let l set state sequenc suffix close andor fusion close let p program shown ad histori variabl variabl p exist problem specif l 0 follow condit hold comput p start state initi state predic true l iff p satisfi l 0 state predic thu languag problem specif restrict would method consid faultclass oneatatim compar method consid altogeth sens oneatatim altogeth method equival program design one method also design method justifi inform let us consid program p design use altogeth method toler faultclass f 1 f 2 fn program p also design use oneatatim method follow let p1 subprogram p toler f 1 program design first stage oneatatim method likewis let p2 subprogram p toler f1 f 2 program design second stage oneatatim method p design complet argument equival remain observ program design oneatatim nstage method trivial design altogeth method term softwar engin practic howev two method would exhibit differ toward identifi differ address three issu structur program design use two method ii complex use iii complex program design use first issu stepwis method may yield program better structur exemplifi hierarch token ring program consist three layer basic program transmit token corrector case least one process corrupt corrector case process corrupt second issu sinc consid one faultclass time complex step less complex altogeth program exampl token ring program first handl case state process corrupt handl case state process corrupt thu step simpler case would need consid case simultan third issu possibl consid faultclass time may yield program whose complex sens optim respect faultclass wherea oneat atim approach may yield program optim faultclass suggest two consider use method one order faultclass consid chosen care principl program design one order design order practic differ order may yield differ program complex program may differ two choos design toler particular faultclass lookahead may warrant impact design choic design toler remain faultclass composit method affect tradeoff depend properti method make possibl reason tradeoff local ie focus attent compon correspond depend properti oppos global ie consid entir program thu method facilit reason tradeoff depend properti moreov expect desir depend properti imposs cosatisfi follow exist compon ad program compli interferencefreedom requir method composit design method compar exist method design faulttoler program composit design method rich sens subsum variou exist faulttoler design method replic checkpoint recoveri schneider state machin approach except handl randel recoveri block interest reader refer 20 24 detail discuss properti replic agreement order design interferencefre composit within method faultclass deriv method use difficult character fault system subject deriv faultclass applic specif begin identif fault program may subject fault formal character use state perturb mention auxiliari variabl may introduc formal desir type toler fault specifi final fault group possibl overlap faultclass base characterist fault correspond type toler difficult character fault applic user method oblig guess larg enough faultclass would accommod possibl fault often reason design choos weak model selfstabil state may perturb arbitrarili byzantin failur program may behav arbitrarili 9 conclud remark futur work paper formal notion multitoler abstract varieti problem de pendabl worthwhil point multitoler relat applic well one reason grace degrad respect progress increas faultclass anoth guarante differ qualiti servic qo respect differ user requir traffic third one reason adapt system respect differ mode environ behavior also present simpl composit method design multitoler program ad detector corrector compon provid desir type toler addit multipl compon intoler program made tractabl ad toler fault class one time avoid reprov correct program everi step provid theori ensur mutual interferencefreedom composit detector corrector intoler program knowledg first formal method design multitoler program method effect design quantit well qualit toler exampl quantit toler present token ring protocol recov upto k fault time exampl qualit toler refer interest reader design multitoler program barrier comput repetit byzantin agreement mutual exclus tree mainten leader elect boundedspac distribut reset termin detect 23 appli design method practic current develop siefast simul implement environ enabl stepwis implement valid multitoler distribut program also studi mechan synthesi multitoler concurr program acknowledg indebt anonym refere detail construct comment earlier version paper significantli improv present thank also lauri dillon help review process r reliabl comput system design evalu att case galileo case foundat faulttoler comput superstabilz protocol dynam distribut system maxim flow rout highli safe selfstabil mutual exclus algorithm defin live closur converg foundat faulttoler comput disciplin program scienc program prove boolean combin determinist properti parallel program design foundat exist refin map proof techniqu commun sequenti process stepwis refin parallel program proof network process axiomat proof techniqu parallel program design mask faulttoler via nonmask faulttoler critic system properti survey taxonomi specifi grace degrad multitoler distribut reset multitoler design constraint satisfact basi design nonmask faulttoler multitoler barrier synchron composit design multitoler repetit byzantin agreement tr ctr anil hanumantharaya purnendu sinha anjali agarw componentbas design composit verif faulttoler multimedia commun protocol realtim imag v9 n6 p401422 decemb orna raz mari shaw approach preserv suffici correct open resourc coalit proceed 10th intern workshop softwar specif design p159 novemb 0507 2000 anish arora sandeep kulkarni murat demirba resett vector clock proceed nineteenth annual acm symposium principl distribut comput p269278 juli 1619 2000 portland oregon unit state anish arora sandeep kulkarni murat demirba resett vector clock journal parallel distribut comput v66 n2 p221237 februari 2006 paul c atti anish arora e allen emerson synthesi faulttoler concurr program acm transact program languag system topla v26 n1 p125185 januari 2004 robyn r lutz softwar engin safeti roadmap proceed confer futur softwar engin p213226 june 0411 2000 limerick ireland anish arora marvin theimer model toler incorrect softwar journal high speed network v14 n2 p109134 april 2005 ile yen farokh b bastani david j taylor design multiinvari data structur robust share access multiprocessor system ieee transact softwar engin v27 n3 p193207 march 2001 anish arora paul c atti e allen emerson synthesi faulttoler concurr program proceed seventeenth annual acm symposium principl distribut comput p173182 june 28juli 02 1998 puerto vallarta mexico axel van lamsweerd emmanuel letier handl obstacl goalori requir engin ieee transact softwar engin v26 n10 p9781005 octob 2000 vina ermagan junichi mizutani kentaro oguchi david weir toward modelbas failuremanag automot softwar proceed 4th intern workshop softwar engin automot system p8 may 2026 2007 felix c grtner fundament faulttoler distribut comput asynchron environ acm comput survey csur v31 n1 p126 march 1999 anish arora sandeep kulkarni design mask faulttoler via nonmask faulttoler ieee transact softwar engin v24 n6 p435450 june 1998