protocolcentr approach onthefli race detect abstractw present design evalu new dataracedetect techniqu techniqu execut runtim rather postmortem handl unmodifi sharedmemori applic run top cvm softwar distribut share memori system assum explicit associ synchron share data requir neither compil support program sourc instead use binari code rewrit instrument instruct may access share memori novel aspect system abl use inform underli memori system implement order reduc number comparison made runtim present experiment evalu techniqu use system look data race five common sharedmemori program quantifi effect sever optim basic techniqu data flow analysi instrument batch runtim code modif instrument inlin system correctli found race three five program includ two standard benchmark suit slowdown debug techniqu averag less 25 applic b introduct despit potenti save time effort datarac detect techniqu yet accept tool builder parallel distribut system part problem sure restrict domain mechan oper ie parallel compil compil support usual deem necessari racedetect gener npcomplet 19 paper present design evalu onthefli racedetect techniqu explicitli parallel sharedmemori applic techniqu applic share memori program written lazyreleaseconsist lrc 11 see section 31 memori model work differ previou work 3 4 7 9 18 17 datarac detect perform onthefli without compil support common dynam system address problem detect data race occur given execut gener problem detect race allow program semant 19 25 earlier work 21 introduc approach demonstr use less complex singlewrit protocol paper extend earlier work use advanc multiwrit protocol seri optim basic techniqu find data race run applic modifi version coher virtual memori cvm 13 14 softwar distribut share memori dsm system dsm support abstract share memori parallel applic run cpu connect generalpurpos interconnect network workstat distribut memori machin like ibm sp2 key intuit work follow lrc implement alreadi maintain enough order inform make constanttim determin whether two access concurr addit lrc inform track individu share access binari instrument run simpl racedetect algorithm exist global synchron point last task made much easier precis synchron order inform maintain lrc system automat gener global synchron point longrun applic none origin use techniqu check data race implement five common parallel applic system correctli found race three waternsquar spatial splash2 27 benchmark suit data race constitut real bug bug report splash author fix current version race could affect correct unlik occur platform splash origin intend barn hand modifi local order elimin unnecessari synchron race introduc modif affect correct applic sinc overhead still potenti exponenti describ varieti techniqu greatli reduc number comparison need made portion racedetect procedur largest theoret complex turn third fourthmost expens compon overal overhead specif show static elimin 99 load store instruct potenti race particip ii elimin 80 potenti comparison runtim use lrc order inform iii averag slowdown use techniqu current less 28 applic could reduc even support inlin instrument code overhead still high system use time low enough use tradit debug techniqu insuffici even part standard debug toolbox parallel program problem definit paraphras adv 1 terminolog defin data race detect system defin happenedbefore1 partial order denot hb1 share access synchron acquir releas follow 1 b ordinari share memori access releas acquir processor occur b program order b 2 releas processor p 1 b correspond acquir processor p 2 b lock acquir correspond releas interven acquir releas lock barrier acquir correspond releas acquir departur releas arriv instanc barrier 3 hb1 c hb1 given definit 1 defin data race follow share access b constitut data race 1 b access word share data least one write 2 neither hb1 true approxim notion actual data race defin netzer 20 common implement system without compil support make claim detect data race allow semant program feasibl race discuss netzer 20 program run complet system without data race guarante subsequ execut free data race well howev detect race occur given execut figur 1 show two possibl execut code process access share variabl x synchron synchron variabl l access pair w 1 execut left constitut data race semant enforc order lock acquisit execut might instead happen shown 1b case r 1 x order respect w 1 x two therefor constitut race note data race caus incorrect result gener correct result gener even execut right r 1 complet w 1 issu order system distinguish access figur 1 system must abl detect understand semant synchron use program practic requir mean program must use systemprovid synchron synchron implement top share memori abstract invis system could result spuriou race warn howev requir stricter underli dsm system program must use systemvis synchron order run releaseconsist system datarac detect system impos addit consist synchron constraint 3 lazi releas consist data race b figur 1 order access lock l nondeterminist either b possibl order event order given data race releaseacquir sequenc pair conflict access b race r 1 x w 1 x 31 lazi releas consist lazi releas consist 11 variant eager releas consist erc 8 relax memori consist allow effect share memori access delay select synchron access occur simplifi matter somewhat share memori access label either ordinari synchron access latter categori divid acquir releas access acquir releas may thought convent synchron oper lock synchron mechan map model well essenti erc requir ordinari share memori access perform next releas processor erc implement delay effect share memori access long meet constraint lrc protocol processor delay perform modif remot subsequ acquir processor modif perform processor perform acquir central intuit lrc compet access share locat correct program separ synchron defer coher oper synchron acquir consist inform piggyback exist synchron messag lrc divid execut process interv identifi interv index figur 2 show execut two processor two interv second interv p 1 exampl denot oe 2 1 time process execut releas acquir new interv begin current interv index increment relat interv differ process happensbefore1 partial order similar defin share access 1 interv singl processor total order program order 2 interv oe oe j begin acquir correspond releas conclud interv oe wy 2 repli sync request figur 2 share data x 1 x 2 assum page 1 2 coloc anoth page pagebas comparison concurr interv would flag concurr interv pair oe 1 1 oe 2 contain possibl conflict refer common page comparison associ bitmap would reveal former fals share latter true race rx 1 oe 2 1 wx 1 oe 2 3 transit closur lrc protocol append consist inform synchron messag inform consist structur describ interv seen releas togeth enough inform reconstruct hb1 order visibl interv exampl messag grant lock p 2 figur 2 contain inform interv seen p 1 time releas yet seen p 2 ie oe 1 1 system also record fact oe 1hb1 discuss lock barrier paper notion synchron acquir releas easili map synchron model well 32 datarac detect lrc system intuit data race pair access interven synchron least one access write figur 2 read x 1 p 1 write x 1 p 2 constitut data race interv oe 2 1 oe 2 concurr order detect data race gener requir compar share access everi share access lrc system system base hb1 partial order limit comparison access pair concurr interv exampl interv pair oe 1 2 figur 2 concurr check order determin data race form access interv perform wordlevel comparison first verifi page access two interv overlap exampl assum 1 2 figur 2 resid page comparison page access concurr 1 oe 1 would reveal access overlap page ie page contain 1 2 would therefor need perform bitmap comparison order determin access constitut fals share true share ie data race case answer would fals share access distinct locat howev p 2 first write z variabl complet differ page comparison page access two interv would reveal overlap bitmap comparison would perform even though interv concurr implement 41 system chang implement racedetect system top cvm 13 14 softwar dsm support multipl protocol consist model like commerci avail system treadmark 12 cvm written entir userlevel librari run unixlik system unlik treadmark cvm creat specif platform protocol experiment system written c opaqu interfac strictli enforc differ function unit system whenev possibl base system provid set class implement gener protocol lightweight thread network commun latter function consist effici endtoend protocol built top udp new share memori protocol creat deriv class base page protocol class method differ base classs method need defin deriv class underli system call protocol hook page fault synchron io event take place sinc mani method inlin result system abl perform within percent sever optim system treadmark run similar protocol cvm also design take advantag gener synchron interfac well use multithread latenc toler detect mechan base cvm multiwriterlrc protocol protocol propag modif form diff runlength encod modif singl page 12 diff creat wordbyword comparison current content page copi page save modif made made three modif basic cvm implement ad instrument collect read access inform ii ad list page read read notic messag type alreadi carri analog inform page written iii potenti add extra messag round barrier order retriev wordlevel access inform necessari 42 instrument use atom 26 coderewrit instrument share access call analysi routin atom allow execut binari analyz modifi use atom identifi instrument load store may access share memori although atom current avail dec alpha system port current underway intel x86 architectur moreov tool provid similar support architectur becom common exampl eel 16 sparc mip shade 5 sparc etch 22 x86 base instrument consist procedur call analysi routin check instruct access share memori routin set bit correspond accesss page posit page order indic page word access analysi routin consist includ 10 instruct save regist restor regist stack actual call analysi routin togeth instruct save regist outsid call consum 7 8 instruct small number addit instruct need batch runtim code modif optim inform page access togeth bitmap place known locat bitmap comparison barrier arriv barrier releas interv comparison bitmap request bitmap figur 3 barrier algorithm follow step 1 read write notic sent barrier master 2 barrier master identifi concurr interv overlap page access list 3 bitmap request overlap page step 2 comparison use identifi data race dot line indic event occur share detect step 2 cvm use execut applic data structur includ bitmap static alloc order reduc runtim cost share memori bitmap alloc fix memori locat order decreas cost instrument code 43 algorithm overal procedur detect data race illustr figur 3 follow 1 use atom instrument share load store applic binari problem lie determin refer share base case simpli instrument refer use stack pointer global variabl pointer 1 regist load one valu current basic block also skip librari refer know inspect applic make librari call modifi share memori absenc guarante contrari easili instrument noncvm librari well instrument would affect slowdown applic spend time librari initi section 45 describ sever extens basic techniqu either elimin memori access candid instrument decreas cost result instrument 2 synchron messag base cvm protocol carri consist inform form interv structur interv structur contain one write notic enumer page written interv cvm augment interv structur also carri read notic list page read interv assum share data alloc dynam interv structur also contain version vector identifi logic time associ interv permit check concurr 3 worker process lrc system append interv structur togeth consist inform barrier arriv messag barrier therefor barrier master complet current inform interv entir system inform suffici barrier master local determin set pair concurr interv although algorithm must potenti compar version vector interv given processor version vector interv everi processor exploit synchron program order allow mani comparison omit 4 pair concurr interv read write notic check overlap data race might exist page either written two concurr interv read one interv written interv pair togeth list overlap page place check list step 5 6 perform check list nonempti ie datarac fals share see figur 3 5 barrier releas messag augment carri request bitmap correspond access cover check list read write notic correspond bitmap describ precis word page access interv henc pair concurr interv four bitmap read write interv might need order detect race bitmap return barrier master interv pair check list 6 barrier master compar bitmap overlap page concurr interv singl bitmap comparison constant time process depend page size case readwrit writewrit overlap algorithm determin data race exist print address offend race current use simpl interv comparison algorithm find pair concurr interv primarili major system overhead elsewher upper bound number interv per processor pair comparison algorithm must compar oi 2 maximum number interv singl processor sinc last barrier howev algorithm need examin interv creat last barrier epoch barrier epoch interv time two success barrier definit interv separ interv previou epoch synchron therefor order respect sinc interv potenti need compar everi interv anoth process current epoch total comparison time per barrier bound number process maximum number interv process current epoch practic howev number comparison usual quit small applic use barrier one interv per process per barrier epoch one interv per barrier creat addit peertop synchron exclus lock howev peertop synchron also impos order interv synchron process exampl lock releas subsequ acquir order interv prior releas respect subsequ acquir sinc order pair interv definit concurr act creat interv also remov mani interv pair consider data race henc program mani interv barrier usual also order constraint reduc number concurr interv note techniqu requir frequent barrier accommod longrun barrierfre applic forc global synchron occur system buffer fill 44 exampl illustr use techniqu exampl base figur 2 figur 2 show portion execut two process togeth synchron memori access memori access static identifi nonshar shown data item x 1 x 2 locat page 1 2 anoth assum barrier occur immedi access figur event figur correspond singl barrier epoch barrier arriv messag p 1 p 2 therefor contain inform four interv oe 1 2 interv structur oe 1 2 contain singl write notic oe 2 contain two read notic read x 1 x 2 repres singl read notic locat page upon arriv process second barrier six possibl interv pair elimin oe 1 1 2 program order oe 1 2 synchron order final oe 1 2 elimin interv access page common leav oe 2 2 oe 2 2 possibl caus race fals share follow use notat oe j rx refer read bitmap page x interv oe j similar notat write barrier releas messag includ request bitmap oe 2 1 ry oe 1 2 wy order judg first pair oe 2 2 wx second pair comparison oe 2 1 ry oe 1 2 wy reveal fals share interv access differ data item happen locat page contrast comparison oe 2 show data race exist x 1 access interv one access write 45 optim section describ three enhanc basic techniqu 451 dataflow analysi use limit form iter interprocedur regist dataflow analysi order identifi addit nonshar memori access techniqu consist creat dataflow graph associ incom outgo set regist basic block regist set defin regist known pointer share memori iter analysi outgo set defin incom set minu regist load block incom set redefin intersect incom set previou iter outgo set preced block procedur continu incom regist set stabil valu left regist incom regist set known pointer share space memori access use regist need instrument made two main assumpt first simplifi interprocedur analysi exploit fact function argument usual pass regist track paramet pass manner entail track order stack access caller calle block conserv assum paramet pass method might name pointer share data second assum function call regist pointer call complic data flow analysi destin call identifi static system could easili modifi disabl dataflow optim call detect 452 batch call instrument routin batch combin access check multipl instruct singl procedur call implement three differ type batch access within singl basic block ffl batch access memori locat refer type either load store ffl batch access memori locat differ refer type ffl batch access consecut memori locat refer type largest perform improv provid first method ie batch access memori locat refer type instrument first access elimin care data access care mani time access duplic load store memori locat might occur within basic block regist pressur alias exampl latter case pair load one regist sandwich around store anoth regist compil static analysi gener way determin whether load store access distinct locat memori henc second load left basic block batch method less use instrument elimin howev instrument remain less costli without batch second third method avoid procedur call consolid instrument multipl access singl routin result instrument also need check whether share valid even access consecut memori locat assum share nonshar region locat contigu address space instrument gener second method addit advantag abl use bitmap offset calcul access 453 runtim code modif use selfmodifi code remov instrument instruct turn refer privat data memori refer instrument consist check distinguish privat share refer code record access refer share memori runtim code modif overwrit instrument noop instruct instruct refer privat data advantag subsequ execut instrument instruct delay cost execut noop instruct rather cost execut instrument code includ addit memori refer modifyingcod runtim requir text segment writabl unprotect entir text segment begin applic execut use atom routin obtain size applic instrument text segment repli sync request figur 4 singl diff describ modif page x oe 1 2 oe 2 2 lazi dif primari complic caus separ data instruct cach use data store overwrit instrument code new instruct seen data system stall writeback data cach problem remain even new instruct written memori stale copi might remain instruct cach solv problem issu special pal imb alpha instruct make cach coher second complic naiv overwrit entir instrument call insid call caus stack becom corrupt get around problem mere save indic affect instrument call delet rather perform delet immedi instrument call actual delet code subsequ synchron point techniqu applic assum memori access instruct exclus refer either privat share data modifi system detect instruct access share nonshar data runtim inform anecdot provid guarante behavior run nonetheless techniqu use appli caution use modifi version cvm detect instruct access share nonshar data two applic elimin offend instruct manual clone 6 routin contain 454 diff one optim exploit use diff captur write behavior diff summari chang made singl page interv creat compar current copi page twin copi save modif begun henc diff seemingli inform write bitmap use diff could allow us dispens instrument write access howev diff creat lazili mean share write might assign wrong portion processs execut exampl consid process figur 4 assum x 1 x 2 page lazi diff creation mean diff describ p 2 first write immedi creat end interv oe 1 problem subsequ write x 1 fold diff associ earlier interv merg violat consist guarante lrc system requir applic free data race howev merg caus system incorrectli believ datarac exist oe 1 1 oe 1 anoth disadvantag approach use diff would slightli weaken race detect techniqu diff contain modif share data locat overwritten valu appear diff even app input set sync memori interv slowdown interv bitmap msg use use ohead barn barrier 32768 1 242 4 47 11 spatial 512 mol 5 iter lock barrier 824 water 512 mol 5 iter lock barrier 344 84 318 5 19 31 tabl 1 applic characterist though use might constitut race perform evalu perform prototyp search data race five common sharedmemori applic barn barneshut algorithm splash2 27 benchmark suit fft fast fourier transform sor jacobi relax water molecular dynam simul splash2 suit spatial problem water differ algorithm also splash2 optim reduc synchron applic run decstat four 275 mhz alpha processor connect 155 mbit atm perform number measur datarac free applic ie first detect identifi remov datarac water barn spatial measur number shown tabl 1 summar applic input runtim characterist memori size size share data segment interv barrier averag number interv creat barrier number interv comparison potenti proport squar number interv metric give approxim idea worstcas cost run comparison algorithm roughli speak new interv creat synchron acquir henc barrieronli applic singl interv per barrier epoch slowdown runtim slowdown applic withoutani optim describ section 45 compar uninstru version applic run unalt version cvm first iter applic time interest steadyst behavior longrun applic howev slowdown would even smaller first iter count five applic nonoptim execut time slow averag factor 38 number compar quit favor even system exploit extens compil analysi 17 7 last three column discuss section 52 figur 5 break applic slowdown five categori without optim describ section 45 cvm mod overhead ad modif cvm primarili set data structur necessari proper datarac detect addit bandwidth use read write notic bitmap describ overhead extra barrier round requir retriev bitmap togeth cost bitmap comparison interv refer time spent use interv comparison algorithm identifi concurr interv pair barn fft sor spatial water slowdown cvm mod bitmap access check proc call orig figur 5 breakdown overhead unoptim instrument techniqu overlap page access access time spent insid instrument procedur call determin whether access share memori set proper bit proc call procedur call overhead instrument base version atom current inlin instrument procedur call insert exist code section 55 describ perform impact experiment version atom inlin instrument orig refer origin run time access check time domin overhead two applic slow sor spatial neither applic signific fals share frequent synchron therefor interv creation opportun run interv comparison algorithm barn highest proport overhead spent interv comparison algorithm reason process determin whether given pair interv access page expens barn process access signific fraction entir share address space interv current represent read write notic list page effici larg number page overhead could reduc chang represent bitmap interv mani notic follow subsect describ overhead detail 51 instrument cost instrument load store could potenti involv data race instrument consist procedur call analysi routin henc add proc call access check overhead sum column figur 5 see instrument account averag 646 total racedetect overhead overhead reduc instrument fewer instruct goal difficult share privat data access use address mode sometim even share base regist howev elimin stack access check use stack pointer base regist fact share data system dynam alloc allow us elimin instruct access data base regist point start staticallyalloc data segment final instrument instruct share librari none applic pass segment pointer app load store instruct stack static librari cvm inst barn 558 320 118057 15759 933 fft 308 207 118057 15759 358 spatial 758 506 118057 15782 1043 water 613 503 118057 15759 940 tabl 2 categor memori access instruct inst show number instruct actual instrument librari case major scientif program data race detect import howev easili instrument dirti librari function necessari tabl break load store instruct categori abl static distinguish base case ie without optim appli first five column show number load store instrument access stack staticallyalloc data librari routin includ cvm sixth column show remaind instruct could elimin therefor possibl datarac particip use atom instrument access procedur call access check routin execut whenev instruct execut averag abl static determin 99 load store applic nonshar data exampl fft binari contain 134993 load store instruct 118057 instruct librari 308 instruct access data stack pointer henc refer stack data anoth 15759 cvm system final 207 instruct access data global pointer regist point base static alloc global memori elimin instruct well sinc cvm alloc share memori dynam entir binari remain 358 memori access instruct could possibl refer share memori henc might part data race nonetheless section 53 show major runtim call analysi routin privat share data 52 cost comparison algorithm comparison algorithm three task first set concurr interv pair must found second list must reduc interv pair access least one page common eg one interv read notic page x interv write notic page x pair concurr interv exhibit unsynchron share howev share may either fals share ie load store page x refer differ locat x data race true share load store refer least one common locat page x data race column label interv use tabl 1 show percentag interv involv least one concurr interv pair number rang zero sor unsynchron share true fals 86 spatial larg amount true fals share note number possibl interv pair quadrat respect number interv even stage elimin 14 interv spatial may elimin much higher percentag interv pair column label bitmap use show averag 27 bitmap must retriev constitu processor order identifi data race distinguish fals true share page access list concurr interv overlap case fals share actual data race percentag interv bitmap involv comparison fairli small note howev effect bitmap interv comparison barn although absolut amount overhead ad comparison larg larger rel rest overhead applic also seem dispar util interv bitmap barn 4 interv use 47 bitmap use impli major share page access small number interv probabl one two phase timestep loop mani phase fact exactli case version barn work done forc posit comput phase separ barrier howev processor access bodi phase set bodi access differ processor disjoint henc true share processor across barrier comput sinc bodi assign processor iter scatter throughout address space larg amount fals share occur barrier serv doubl effect fals share split interv half caus bitmap request twice page instead note barrier remov without slight reorgan code synchron updat scalar global variabl test interpret result implement reorgan remov barrier effect reduc interv bitmap overhead half reduc overal overhead approxim 30 final column tabl 1 show amount addit data need race detect techniqu compar uninstru system 53 effect optim tabl 3 show effect optim number instruct actual instrument opt refer base case optim df dataflow batch selfexplanatori code mod refer dynam code modif includ three dfbatch includ show synergi dataflow batch absenc code modif code modif actual increas number instrument site fft water clone last three column tabl 3 show number time abl appli batch method 23 repres combin two three instruct type consecut address repres combin instruct type address final mix combin instruct address differ access type number impli batch applic applic complex data structur access pattern app instrument instruct batch opt data flow batch code mod dfbatch 23 mix barn 933 854 730 933 655 655 63 26 76 spatial 1043 844 904 1043 725 725 water 940 776 747 1156 604 733 39 38 58 tabl 3 static instrument statist app million instrument instruct flow batch code mod dfbatch barn 4358 4150 4343 885 4135 870 fft 58 53 58 15 53 15 spatial 1083 395 882 285 221 200 water 1249 518 1050 216 326 75 tabl 4 dynam optim statist tabl 4 show effect optim number instrument instruct execut runtim although data flow analysi batch togeth elimin 298 229 local refer instrument barn fft respect account 51 88 instrument refer runtim hand 305 instrumentationsand 358 water instrumentationsar elimin yet eliminationof instrument account 800 739 runtim refer respect clearli effect optim heavili applicationdepend figur 6 show effect optim overal slowdown applic averag slowdown three optim appli 28 improv 26 fft lowest overhead 22 figur 6 also includ bar inlin optim discuss section 55 54 cost cvm modif figur 5 show almost 158 overhead come cvm mod modif made cvm system order support racedetect algorithm overhead consist cost set addit data structur datarac detect cost addit bandwidth consum read notic last column tabl 1 show bandwidth overhead ad read addit write notic synchron messag individu read write notic size typic least five time mani read write read notic consum proport larger amount space write notic addit write notic need even notic longer creat lazili even though diff still barn fft sor spatial water slowdown base data flow batch code mod inlin allinlin figur 6 optim bandwidth overhead water quit larg finegrain synchron mean mani interv notic creat contrast primari cost spatial fals share quit preval lead larg number bitmap request inlin verifi assumpt procedur call access check overhead significantli reduc inlin use unreleas version atom call xatom inlin read write access check implement decreas cost inlin code fragment use regist live analysi identifi dead regist dead regist use whenev possibl avoid spill content regist need instrument code tabl 5 show effect inlin overal perform rel base case optim column label runtim show effect percentag overal run time overhead show quantiti percentag instrument overhead static column show percent inlin instruct elimin regist live analysi mostli load store instruct dynam show correspond dynam quantiti elimin instruct use major memori access instruct henc rel expens improv roughli correl procedur call overhead shown figur 5 averag 137 total overhead caus procedur call howev inlin also elimin access check overhead live analysi reduc regist spillag particularli import case sor overhead access check import question answer effect optim combin inlin inlin certainli decreas potenti techniqu work decreas cost number access check howev still effect combin inlin remain overhead still signific runtim code modif particular would still use inlin effect total number instruct instrument howev code modif mechan would probabl need chang slightli order address fact insert instrument longer byte insert uncondit branch end app improv regist live runtim overhead static dynam barn 150 285 217 355 fft 138 235 168 158 spatial 13 19 135 73 water 140 257 178 244 tabl 5 inlin instrument code might effect overwrit inlin instrument larg number noop instruct 6 discuss 61 refer identif system current print share segment address togeth interv index detect race condit combin symbol tabl inform use identifi exact variabl synchron context identifi specif instruct involv race difficult requir retain program counter inform share access inform avail runtim scheme would requir save program counter share access futur barrier analysi phase determin access involv race storag requir would gener prohibit would also add runtim overhead second approach use conflict address correspond barrier epoch initi run program input second run second run program counter inform gather access conflict address origin barrier epoch determin involv data race runtim overhead storag requir therebi drastic reduc data race must occur second run exactli first happen applic gener race 20 ie synchron order determinist case water applic found data race solut modifi cvm save synchron order inform first run enforc order second run done work execut replay treadmark similar dsm approach reconstruct lamport timestamp rolt 23 techniqu keep track minim order inform save initi run enforc exactli interleav share access synchron second run second run complet address trace save postmortem analysi although author discuss race detect detail advantag approach initi run incur minim overhead ensur trace mechan perturb normal interleav share access rolt approach complementari techniqu describ paper system could augment includ initi synchronizationtrac phase allow us elimin perturb parallel comput second ie racerefer identif phase current use share page variabl involv datarac initi run target page save program counter identif run 62 global synchron interv comparison algorithm run global synchron oper ie barrier applic input set studi use barrier frequent enough otherwis synchron infrequ enough number interv compar barrier quit manag nonetheless certainli exist applic global synchron frequent enough keep number interv comparison small number ideal system would abl increment discard data race without global cooper mechan would increas complex underli consist protocol 10 global synchron either use use often enough exploit cvm routin allow global state consolid synchron current mechan use cvm garbag collect consist inform longrun barrierfre program 63 accuraci adv 2 discuss three potenti problem accuraci race detect scheme concert weak memori system system support memori model lazi releas consist first whether return data race first data race 18 2 first race essenti caus affect prior race determin whether given race affect effect consist decid whether oper race preced via hb1 oper race question system current report data race howev could easili captur approxim first race turn report race access occur via hb1 access data race second problem accuraci dynam racedetect algorithm reliabl inform presenc race race condit could caus wild access random memori locat potenti corrupt interv order inform access bitmap problem exist dynam racedetect algorithm expect occur infrequ final accuraci problem identifi adv system attempt minim space overhead buffer limit trace inform possibl result race remain undetect system discard trace inform check race henc suffer limit 64 limit expect techniqu applic larg class applic applic test suit rang sor bandwidthlimit water synchron modifi data fine granular applic stress differ portion racedetect techniqu raw cost access instrument sor complex cost deal larg number interv water furthermor applic except sor modifi order reduc fals share multiwrit lrc toler fals share much better protocol applic tune lrc tend fals share remov water spatial barn larg amount fals share nonetheless methodolog clearli applic situat chaotic algorithm exampl toler race mean elimin synchron improv perform fals posit caus toler race obscur unintend race render class applic illsuit techniqu similarli protocolspecif optim techniqu may caus spuriou race report earlier version barn barrier enforc antidepend barrier remov version barn applic still correct lrc delay propag consist inform data howev antidepend flag system data race interfer normal oper techniqu techniqu discuss paper necessarili limit lrc system applic approach essenti use exist synchronizationord inform reduc number comparison made runtim inform could easili collect distribut system memori model put appropri wrapper around synchron call append small amount addit inform synchron messag multiprocessor could support use wrapper append small amount data synchron state applic rest techniqu straightforward 65 perform enhanc perform underli protocol could improv use write instrument creat diff rather use twin page comparison method investig option complex integr mechan runtim code modif exampl would nontrivi compil techniqu could use expos opportun batch loop unrol trace schedul would particularli effect applic sor applic largest overhead applic testb final interv comparison algorithm could improv significantli overhead ad comparison algorithm rel small applic better worstcas bound would desir product system one promis approach use hierarch comparison algorithm exampl two process creat larg number interv exclus pairwis synchron number interv compar process could reduc first aggreg interv creat isol use aggreg compar interv process 7 relat work great deal publish work area data race detect howev prior work dealt applic system special domain bitmap use track share access 7 know languag independ implement onthefli datarac detect explicitlyparallel sharedmemori program previous 21 describ perform preliminari form racedetect scheme ran top cvm singlewrit lrc protocol 14 paper describ perform racedetect scheme top cvm multiwrit protocol protocol challeng target usual outperform singlewrit protocol significantli make difficult hide racedetect overhead addit work describ paper includ sever optim basic system ie batch dataflow analysi runtim code modif inlin work close relat work alreadi allud section 63 techniqu describ implement adv et al 2 author describ postmortem techniqu creat trace log contain synchron event inform allow rel execut order deriv comput event comput event correspond roughli cvm interv comput event also read write attribut analog read page list bitmap describ share access interv trace file use offlin perform essenti oper system differ minimallymodifi system leverag lrc memori model order abstract synchron order inform onthefli therefor abl perform analysi onthefli well away trace log postmortem analysi much overhead work execut replay treadmark could use implement racedetect scheme approach reconstruct lamport timestamp rolt 23 techniqu similar techniqu describ section 61 identifi instruct involv race minim order inform save initi run use enforc exactli interleav share access synchron second run second run complet address trace save postmortem analysi although author discuss race detect detail advantag approach initi run incur minim overhead ensur trace mechan perturb normal interleav share access rolt approach complementari techniqu describ paper primari thrust work use underli consist mechan prune enough inform onthefli postmortem analysi necessari techniqu could use improv perform second phase rolt approach similarli system could augment includ initi synchronizationtrac phase allow us reduc perturb parallel comput recent work eras 25 use verif lock disciplin detect race multithread program eras main advantag detect race actual occur instrument execut howev guarante racefre behavior datarac found return fals posit furthermor system support distribut execut final overhead eras approach order magnitud higher work detect datarac detect nondistribut multithread program also done recplay 24 recordreplay system multithread program work similar rolt approach discuss appli multithread program work use happensbefor relat reconstruct replay execut initi run second run perform access check conclus paper present design perform new methodolog detect data race explicitlyparallel sharedmemori program techniqu abstract synchron order consist inform alreadi maintain multiplewrit lazyreleaseconsist dsm system abl use inform elimin access comparison perform entir datarac detect onthefli use system analyz five sharedmemori program find data race three two data race standard benchmark program bug primari cost datarac detect system track share data access abl significantli reduc cost use three optim techniqu regist dataflow analysi batch inlin nonetheless major runtim call librari nonshar access therefor use runtim codemodif dynam rewrit instrument order elimin access check instruct access nonshar data combin optim except inlin abl reduc averag slowdown applic approxim 28 12 one applic expect combin inlin optim would reduc slowdown even implement describ specif lrc gener approach system exploit synchron order elimin major share access without explicit comparison finegrain comparison made onlywher coarsegrain comparison fail rule data race approach could use system support program model use wrapper around synchron access track synchron order believ util techniqu combin gener approach present help datarac detect becom wide use r unifi formal four sharedmemori model detect data race weak memori system debug fortran share memori machin race frontier reproduc data race parallel program debug fast instructionset simul execut profil methodolog procedur clone empir comparison monitor algorithm access anomali detect memori consist event order scalabl sharedmemori multiprocessor parallel program debug onthefli anomali detect distribut share memori use lazi releas consist lazi releas consist softwar distribut share memori treadmark distribut share memori standard workstat oper system coher virtual machin rel import concurr writer weak consist model make multiprocessor comput correctli execut multiprocess program improv accuraci data race detect complex event order sharedmemori parallel program execut race condit onlin datarac detect via coher guarante instrument optim win32intel execut use etch execut replay treadmark work progress onthefli data race detector recplay dynam data race detector multithread program atom system buildingcustom program analysi tool splash2 program character methodolog consider tr ctr edith schonberg onthefli detect access anomali acm sigplan notic v39 n4 april 2004 milo prvulov josep torrella reenact use threadlevel specul mechan debug data race multithread code acm sigarch comput architectur news v31 n2 may min xu rastislav bodk mark hill serializ violat detector sharedmemori server program acm sigplan notic v40 n6 june 2005 chen ding xipeng shen kirk kelsey chri tice ruke huang chengliang zhang softwar behavior orient parallel acm sigplan notic v42 n6 june 2007 bohuslav krena zdenek letko rachel tzoref shmuel ur tom vojnar heal data race onthefli proceed 2007 acm workshop parallel distribut system test debug juli 0909 2007 london unit kingdom sudarshan srinivasan srikanth kandula christoph r andrew yuanyuan zhou flashback lightweight extens rollback determinist replay softwar debug proceed usenix annual technic confer 2004 usenix annual technic confer p33 june 27juli 02 2004 boston