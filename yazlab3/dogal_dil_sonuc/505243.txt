optim minimum span tree algorithm establish algorithm complex minimum span tree problem equal decisiontre complex specif present determinist algorithm find minimum span tree graph n vertic edg run time otmn minimum number edgeweight comparison need determin solut algorithm quit simpl implement pointer machinealthough time bound optim exact function describ known present current best bound known om mn certain natur invers ackermann functioneven assumpt superlinear show input graph select gnm algorithm run linear time high probabl regardless n permut edg weight analysi use new martingal gnm similar edgeexposur martingal gnp b introduct minimum span tree mst problem studi much centuri yet despit appar simplic problem still fulli understood graham hell gh85 give excel survey result earliest known algorithm boruvka bor26 invent fibonacci heap central algorithm ft87 ggst86 chazel chaz97 present mst algorithm base soft heap chaz98 complex ommn log n certain invers ackermann function recent chazel chaz00 modi algorithm chaz97 bring run time om n later independ work similar algorithm run time present petti pet99 give altern exposit om n result tightest time bound mst problem date though known optim updat version utc technic report tr9917 includ perform analysi random graph new refer part work support texa advanc research program grant 003658 00291999 seth petti also support mcd fellowship algorithm mention work pointer machin tar79 restrict edg weight may subject binari comparison power model assum mst comput optim fredman willard fw90 show unitcost ram bitrepresent edg weight may manipul mst comput linear time karger et al kkt95 present random mst algorithm run linear time high probabl even edg weight subject comparison still unknown whether power model necessari comput mst linear time howev paper give determinist comparisonbas mst algorithm run pointer machin ot n time n number edgeweight comparison need determin mst graph edg n vertic addit show algorithm run linear time vast major graph regardless densiti permut edg weight natur algorithm exact run time known might seem paradox rst sourc algorithm optim mysteri run time use precomput mst decis tree whose exact depth unknown nonetheless provabl optim trivial lower bound algorithm best upper bound ommn due chazel chaz00 point precomput optim decis tree increas constant factor hidden bigoh notat result nonuniform algorithm optim mst algorithm contrast complexitytheoret result optim veric algorithm problem use construct optim algorithm problem jo97 though asymptot optim construct hide astronom constant factor prove noth relationship algorithm complex decisiontre complex see section 8 discuss relat issu next section review wellknown mst result use algorithm section 3 prove key lemma give procedur partit graph mst respect manner section 4 give overview optim algorithm discuss structur use precomput decisiontre mst problem section 5 give algorithm proof optim section 6 show algorithm may modi run pointer machin section 7 show algorithm run lineartim whp input graph select random section 8 9 discuss relat problem algorithm open question actual complex mst preliminari input undirect graph e edg assign distinct realvalu weight minimum span forest msf problem ask span acycl subgraph g least total weight paper assum conveni input graph connect sinc otherwis nd connect compon linear time solv problem connect compon thu msf problem ident minimum span tree problem wellknown one identifi edg provabl msf use cut properti edg provabl msf use cycl properti cut properti state lightest edg cross partit vertex set two part must belong msf cycl properti state heaviest edg cycl graph msf 21 boruvka step earliest known msf algorithm due boruvka bor26 algorithm quit simpl proce sequenc stage stage execut boruvka step graph g identi set f consist minimumweight edg incid vertex g add edg msf sinc must msf cut properti form graph input next stage gnf graph obtain contract connect compon form f comput perform linear time sinc number vertic reduc least factor two run time algorithm om log n n number vertic edg input graph optim algorithm use procedur call boruvka2g f g 0 procedur execut two boruvka step input graph g return contract graph g 0 well set edg f identi msf two step 22 dijsktrajarnkprim algorithm anoth earli msf algorithm run om log n time one jarnk jar30 rediscov dijkstra dij59 prim prim57 refer algorithm djp algorithm brie djp algorithm grow tree initi consist arbitrari vertex one edg time choos next edg follow simpl criterion augment minimum weight edg x x 2 62 cut properti edg msf lemma 21 let tree form execut number step djp algorithm let e f two arbitrari edg exactli one endpoint let g maximum weight edg path e f g heavier e f proof let p path connect e f assum contrari g heaviest edg p fe fg consid moment g select djp let p 0 portion p present tree exactli two edg p p elig chosen djp algorithm moment one edg g edg p choic g must lighter g edg either e f assumpt must lighter g case g could chosen next djp algorithm contradict 2 23 dens case algorithm algorithm present ft87 ggst86 chaz97 chaz00 pet99 nd msf graph linear time graph sucient dens ie sucient larg edgetovertex ratio purpos sucient dens mean 3 n n number vertic graph algorithm run linear time densiti procedur densecaseg f take input nnode graph g return msf f g linear time graph densiti 263 3 n optim algorithm call densecas graph deriv nnode medg graph contract vertic number vertic reduc factor n number edg contract graph straightforward see densecas run om n time graph 24 soft heap main data structur use algorithm soft heap chaz98 soft heap kind prioriti queue give us optim tradeo accuraci speed support follow oper makeheap return empti soft heap insert x insert item x heap findmin return item smallest key heap delet x heap creat new heap contain union item store 1 2 destroy 1 2 process oper take constant amort time except insert take olog 1 save time soft heap allow item group togeth treat though singl key item adopt largest key item group corrupt item new key dier origin key thu origin key item return findmin ie item group minimum key key uncorrupt item heap guarante n insert oper n corrupt item heap follow result shown chaz98 lemma 22 fix paramet 0 12 begin prior data consid mix sequenc oper includ n insert soft heap amort complex oper constant except insert take olog1 time n item corrupt given time 3 key lemma procedur 31 robust contract lemma well known tree msf edg contract singl vertex maintain invari msf contract graph plu give msf graph contract algorithm nd tree msf edg corrupt graph edg weight increas due use soft heap lemma given show use inform obtain contract certain corrupt tree particular construct use number step dijkstrajarnikprim djp algorithm idea similar use chazel 1997 algorithm chaz97 explicitli recent algorithm petti pet99 chazel chaz00 state lemma need notat preliminari concept let v g eg vertex edg set g n cardin respect let gweight edg weight graph g g may omit impli context follow denit c subgraph g denot g graph deriv g rais weight edg arbitrari amount edg said corrupt let mc set edg exactli one endpoint c let gnc denot graph obtain contract connect compon induc c ie replac connect compon singl vertex reassign edg endpoint appropri dene subgraph c g djpcontract execut djp algorithm g number step suitabl start vertex c tree result span tree c lemma 31 let set edg graph g c subgraph g djpcontract wrt g msf g subset msf c msf gnc mc mc proof edg c msfc heaviest edg cycl c sinc cycl exist g well edg msfg need show edg gnc msfgnc mc also msfg henc need show edg h msf h msf g let e heaviest edg cycl h ie e 2 h msf h involv vertex deriv contract c exist g well e 62 msf g otherwis form path p g whose end point say x c let end edg p x w includ corrupt edg one end point c gweight edg g mweight let span tree c deriv djp algorithm q path connect x g heaviest edg q notic p q form cycl choic e must heavier x w z lemma 21 heavier x w z heavier g mweight g upper bound gweight edg q wrt gweight e heaviest edg cycl p q msf g 2 32 partit procedur algorithm use partit procedur given procedur nd djp contract subgraph c edg progress corrupt soft heap let mc contain corrupt edg one endpoint c time complet subgraph c djpcontract wrt graph deriv g sever round contract edg delet c nish contract incid corrupt edg discard appli lemma 31 repeatedli see c built msf g subset msf partit procedur shown figur 1 argument appear semicolon input other output set edg cfc set subgraph g edg appear one mc initi partit set everi vertex live object convert vertex dead signifi part compon c maxsiz vertic part conglomer maxsiz vertic conglomer connect compon graph intuit conglomer collect c link common vertic scheme grow compon similar one given ft87 grow c one time accord djp algorithm except use soft heap compon done grow reach maxsiz vertic attach exist compon clearli compon reach maxsiz vertic link partitiong vertic initi live live vertex increment live vertex creat soft heap consist vs edg use vertic v live jv j maxsiz repeat find delet minweight edg x soft heap live insert ys edg soft heap vertic v dead corrupt edg one endpoint v dismantl soft heap let c fc z subgraph g induc v z exit figur 1 partit procedur conglomer least maxsiz vertic henc vertic design dead upon complet compon c discard set corrupt edg one endpoint c run time partit domin heap oper depend edg insert soft heap twice endpoint extract charg cost dismantl heap insert oper creat henc total run time om log 1 number discard edg bound number insert scale thu jm j 2m thu lemma 32 given graph g 0 1 2 paramet maxsiz partit nd edgedisjoint subgraph b jv c j maxsiz c conglomer p 2 jemj 2 jegj 4 overview optim algorithm overview optim msf algorithm rst stage nd djpcontract subgraph c associ set edg consist corrupt edg one endpoint c second stage nd msf f c msf f 0 contract graph gn 31 msf whole graph contain within note point identi edg msf origin graph g third stage nd msf edg via boruvka step recurs graph deriv contract edg execut rst stage use partit procedur describ previou section execut second stage optim decis tree essenti hardwir algorithm design comput msf graph use optim number edgeweight comparison gener decis tree much larger size problem solv nding optim one time consum aord cost build decis tree guarante one extrem small time make conglomer form c sucient larg msf f 0 contract graph found linear time use densecas algorithm final third stage reduct vertic due boruvka step reduct edg due applic lemma 31 optim algorithm vertic edg reduc constant factor thu result recurs applic algorithm graph geometr decreas size 41 decis tree msf decis tree root tree edgeweight comparison associ intern node eg weightx weightw z intern node exactli two children one repres comparison true fals leav tree list edg span tree msf decis tree said correct edgeweight comparison encount path root leaf uniqu identifi span tree leaf msf decis tree said optim correct exist correct decis tree lesser depth let us bound time need nd optim decis tree graph r vertic brute forc search fewer 2 r 2 graph graph must check possibl decis tree bound depth r 2 r 4 possibl intern node r 2 r 2 o1 decis tree check determin decis tree correct gener possibl permut edg weight solv msf problem given graph simultan check permut decis tree first put permut root move left right child depend truth falsiti edgeweight comparison wrt permut repeat step permut reach leaf leaf permut share leaf agre msf decis tree correct process take longer r decis tree set allow us precomput optim decis tree time observ highlevel algorithm gave section 4 maximum size compon c sucient small compon organ rel small number group isomorph compon ignor edg weight group use singl precomput optim decis tree determin msf compon group optim algorithm use procedur decisiontreeg f take input collect graph g r vertic return minimum span forest f use precomput decis tree 5 algorithm discuss optim msf algorithm follow first precomput optim decis tree graph log 3 n vertic next divid input graph subgraph discard set corrupt edg mc c complet use decis tree found earlier comput msf f c contract connect compon span f ie conglomer singl vertex result graph n log 3 n vertic sinc conglomer least log 3 n vertic lemma 32 henc use densecas algorithm comput msf f 0 time linear point lemma 31 msf contain edg set f graph appli two boruvka step reduc number vertic factor four comput recurs algorithm given use soft heap partit procedur precomput optim decis tree graph log 3 n 0 vertic n 0 number vertic origin input graph r log 3 jv gj partitiong g apart recurs call use decis tree comput perform opti malmsf clearli linear sinc partit take om log 1 owe reduct vertic call densecas also take linear time 8 number edg pass nal recurs call m4 give geometr reduct number edg sinc msf algorithm better linear time bottleneck must lie use decis tree optim construct concret let n run time optimalmsf let n optim number comparison need graph n vertic edg let g optim number comparison need specic graph g recurr relat given base case note graph recurs call connect input graph connect henc base case graph edg one vertex 0 1 equal constant straightforward see n om recurr give om one also show n ot n mani natur function includ n howev show result hold matter function describ n need establish result decis tree complex msf problem next section 51 result msf decis tree section establish result msf decis tree allow us establish main result optimalmsf run ot n time proposit 51 n m2 proposit 52 xed proposit 51 obvious true sinc everi edg particip comparison determin inclus exclus msf proposit 52 hold sinc add isol vertic graph obvious aect msf number necessari comparison state properti use lemma 54 55 properti 53 structur g dictat edgedisjoint subgraph g compon return partit seen graph denit 53 sinc everi simpl cycl graph must contain exactli one c see consid simpl cycl let largest index c contain edg cycl sinc c share one vertex contain edg proof follow lemma found pr99b lemma 54 properti 53 hold g exist optim msf decis tree g make comparison form e f e 2 c proof consid subset p permut edg weight e 2 c hold weight weightf permut p two use properti readili veri first number intercompon comparison shed light rel weight edg compon second span forest compon msf compon permut p consid optim decis tree g let 0 subtre contain leav reach permut p intercompon comparison node must one child rst properti msf leaf deduc use intracompon comparison second properti 0 must determin msf compon correctli thu properti 53 must determin msf graph g correctli henc contract 0 correct decis tree 00 replac onechild node child 2 lemma 55 properti 53 hold g proof given optim decis tree c construct decis tree g replac leaf 1 2 gener replac leaf i1 label leaf last tree union label origin tree along path clearli height tree sum height henc g need prove optim decis tree g height less sum height let optim decis tree g intercompon comparison guarante lemma 54 show transform canon decis tree 0 g height 0 comparison c preced comparison c i1 subgraph 0 contain comparison within c consist collect isomorph tree establish desir result sinc 0 must contain path concaten longest path optim decis tree c rst prove result case two compon c 1 c 2 assum induct subtre root vertic certain depth transform desir structur c 1 comparison occur c 2 comparison subtre c 2 within subtre root depth isomorph trivial case equal height consid node v depth 1 comparison node c 1 comparison c 2 subtre descend node must comput set leav c 2 henc subtre root v convert desir format simpli replac c 2 subtre one minimum depth note two dierent c 2 subtre c 2 subtre descend left right child v must isomorph comparison v c 2 comparison know c 1 subtre root left child x right child must comput set leav c 1 henc pick c 1 subtre smaller height wlog let root x replac v x togeth c 1 subtre root x copi comparison node v leaf posit c 1 subtre copi place one isomorph copi c 2 subtre descend x left subtre c 2 subtre descend right subtre subtre root x depth 1 desir form comput result increas height tree henc induct convert canon decis tree greater height assum induct result hold k 1 2 compon result easili extend k compon note group rst k 1 compon c 0 1 let c k c 0 method transform canon tree c k comparison appear leaf subtre strip c k subtre canon tree induct assumpt perform transform remain k 1 compon 2 corollari 56 let c compon form partit routin appli graph g let g edg n vertic corollari 57 n solv recurr relat run time optimalmsf given previou section corollari 56 corollari 57 proposit 51 52 c n sucient larg c complet induct give us desir theorem theorem 58 let n decisiontre complex msf problem graph edg n node algorithm optimalmsf comput msf graph edg n vertic determinist ot n time 6 avoid pointer arithmet precis speci requir underli machin model upon examina tion algorithm seem requir full power random access machin ram bit manipul use arithmet limit increment oper howev procedur decisiontre implement obviou manner requir use tabl lookup thu random access memori section describ altern method handl decis tree run pointer machin tar79 model allow random access memori method similar describ b98 ensur time overhead perform tabl lookup call decisiontre linear size current input decisiontre pointer machin distinguish pointer data type oper allow pointer assign comparison equal dereferenc memori organ record hold constant number pointer normal data word integ oat etc given pointer particular record refer pointer data word record constant time nonpoint data usual array logic arithmet binari comparison oper allow rst describ represent decis tree decis tree associ gener graph edg weight decis tree determin mst permut edg weight gener graph intern node decis tree four pointer rst two point edg gener graph compar second two point left right child node leaf list edg span tree gener graph sinc decis tree pointerbas structur construct precomput decis tree enumer check possibl without use tabl lookup describ represent gener graph vertic gener graph number order integ start 1 represent consist list vertic order start 1 follow adjac list vertex start vertex 1 gener graph pointer root decis tree recal precomput decis tree gener graph log 3 n 0 vertic n 0 number vertic input graph whose msf need nd gener graph gener store lexicograph sort order note represen tation sort order gener graph appear nondecreas order number vertic graph use decis tree actual graph must isomorph gener graph decis tree must associ edg actual graph counterpart gener graph thu comparison edg weight gener graph substitut correspond weight actual graph constant time random access machin encod possibl graph singl machin word say adjac matrix index gener graph array accord represent thu given graph nd associ decis tree constant time pointer machin howev convert bit vector integ pointer specic disallow describ method identifi gener graph c ecient assum c speci adjac list represent edg x pointer occurr x ys adjac list edg also pointer record contain weight let n number edg vertic rewrit c form gener graph call numer represent let c p vertic note p r assign vertic number 1 p order list adjac list represent rewrit edg pair number indic endpoint edg retain pointer weight separ numer represent chang format graph follow instead list number rang 1r repres graph list pointer initi link list r bucket label 1 r numer represent number j appear replac pointer j th bucket transform graph pointer represent travers rst list vertic list edg order travers list bucket simultan replac vertex entri rst vertex entri edg pointer correspond bucket thu edg x also appear x appear ptrx ptri x employ twin pointer replac remain x equival pointer clearli transform perform om time sum size perform lexicograph sort ahu74 sequenc c order group togeth isomorph compon represent replac bucket index perform tradit lexicograph sort access bucket pointer place element henc run time pointerbas lexicograph sort length th vector decisiontre call graph size r olog 3 n sum size graph om henc radix sort perform om final march sort list c sort list gener graph match appropri need travers initi sequenc sort gener graph contain o2 r 2 entri order match graph take time om 7 perform random graph even assum mst superlinear complex show algorithm run linear time nearli graph regardless edg weight improv upon expect lineartim result karp tarjan kt80 depend edg weight chosen randomli result may also contrast random algorithm karger et al kkt95 shown run om time whp proof depend permut edg weight random bit chosen graph topolog fact none earlier publish mst algorithm appear properti run linear time whp random graph edgeweight use analysi section suitabl soupedup version earlier algorithm ft87 ggst86 chaz00 may obtain high probabl result analysi hing observ spars random graph whp subgraph construct partit routin miniscul number edg excess number span forst edg subgraph mst graph comput linear time henc comput optim decis tree take linear time graph throughout section denot n theorem 71 mst graph found linear time probabl e graph drawn g nm graph drawn g np 1 2 hold regardless permut edg weight next section describ edgeaddit martingal g nm model section 72 use martingal azuma inequ prove part 1 theorem 71 part 2 shown follow part 1 71 edgeaddit martingal consid g nm random graph model graph n label vertic edg equal like analyt purpos select random graph begin n vertic ad one edg time er61 let x random edg st x graph made rst edg g 0 graph n vertic edg martingal sequenc random variabl prove g graphtheoret function martingal lemma 72 sequenc martingal g graph theoret function g 0 edgefre graph n vertic g deriv g 1 ad random edg g 1 g 1 g given g 1 xed call sequenc prove martingal lemma 72 edgeaddit martingal contrast edgeexposur martingal g np recal wellknown azuma inequ see eg as92 theorem 73 azumaa inequ let ym martingal jy let 0 arbitrari prji facilit applic azuma inequ edgeaddit martingal establish follow lemma lemma 74 consid sequenc prove martingal lemma 72 let g graphtheoret function jgg gg 0 j 1 pair graph g g 0 form averag rang possibl outcom given g g 1 respect identifi outcom equals disjoint set outcom x cover outcom x may regard averag set averag set correspond outcom p x establish set averag dier gg p 1 lemma follow correspond follow let outcom x correspond set consist outcom x j rang edg appear g 1 x outcom i1 q p associ set sinc graph dier one edg clearli hold well averag outcom q p associ set 2 72 analysi dene excess subgraph h jehj jf hj f h span forest h let fg maximum excess graph made intracompon edg set compon rang possibl set return partit procedur recal size compon key observ lead lineartim result pass optim algorithm denit run linear time fg mmn see note bound fg hold reduc total number intracompon edg 2m linear time use log boruvka step clearli mst result graph determin om time show graph randomli chosen g nm fg mmn high probabl show lemma 74 appli graphtheoret function f appli azuma inequ obtain desir result lemma 75 let two graph set label vertic dier one edg jfg fg 0 j 1 proof suppos wlog fg fg 0 1 could appli optim set compon g g 0 everi intracompon edg g remain intracompon edg except possibl e reduc excess one contradict possibl e 0 may becom intracompon edg help argument 2 lemma proof notic simpli imposs intracompon edg assum upper bound f e g 0 expect number indic st edg x complet cycl length k g 1 sinc edg caus f increas must satis criterion probabl x complet cycl length k bound number cycl probabl exist graph n nm recal n either case f g chosen g nm prfg e proof appli azuma inequ prjf e gm set give lemma note lemma 76 f insignic 2 readi prove theorem 71 proof examin rst log k pass optim algorithm sinc remain pass certainli take om time lemma 77 assur us rst pass run linear time whp howev topolog graph examin later pass depend edg weight assum boruvka step contract part graph constant rate easili enforc partit graph one pass algorithm correspond partit origin graph compon size less k c xed c use k c place k aect lemma 76 give theorem g nm part 1 g np note probabl pn 2 edg exponenti pn 2 henc probabl algorithm fail run linear time domin bound part 1for spars case n theorem 71 part 1 hold probabl 1 1n cherno bound part 2 hold probabl 1 e n intrigu aspect algorithm know precis determinist run time although prove within constant factor optim result natur obtain past sensit analysi minimum span tree drt92 convex matrix search lar90 also problem triangul convex polygon observ drt92 altern lineartim algorithm could obtain use optim decis tree small subproblem howev earlier algorithm make use decis tree straightforward way algorithm present note section 41 construct optim decis tree take sublinear time thu import observ use decis tree result larg constant factor run time construct optim decis tree perform straightforward bruteforc search henc result algorithm uniform mention introduct optim algorithm construct prob lem given optim veric algorithm problem jo97 construct produc algorithm enumer program machin model execut increment whenev one program halt verier check output correct use lineartim mst veric algorithm drt92 k97 b98 construct yield optim mst algorithm howev unsatisfactori sever reason asid truli astronom constant factor roughli exponenti size optim program algorithm optim respect particular machin model say tm ram pointer machin result contrast robust tie algorithm complex mst decisiontre complex limit factor machin model alway case algorithm complex decisiontre complex asymptot equival fact one easili concoct simpl problem nphard nevertheless polynomialdepth decisiontre eg nd lightest edg hamiltonian path see gks93 pr01 section 8 two sortingtyp problem whose decisiontre complex algorithm complex provabl diverg 9 conclus present determinist msf algorithm provabl optim algorithm run pointer machin graph n vertic edg run time ot n n decisiontre complex msf problem nnode medg graph also random graph algorithm run linear time high probabl possibl edgeweight although exact run time algorithm known shown time bound depend number edgeweight comparison need determin msf data structur issu determin worstcas complex algorithm main open question remain msf problem howev subtler open question given optim uniform algorithm msf problem optim uniform algorithm use precomput decis tree similar techniqu gener problem precomput necessari one may wish studi issu simpler set say msf veric problem pointer machin still n factor separ best pointer machin algorithm use precomput decis tree b98 one tar79b one may also ask parallel complex msf problem resolv recent random worktim complex pr99 determinist time complex chl99 msf problem erew pram open question remain obtain determinist worktim optim parallel msf algorithm parallel optim algorithm straightforward although handl decis tree present problem parallel context still need method identifi contract compon parallel base case algorithm perform linear work graphdens log 3 n exist sequenti algorithm suitabl base case one ft87 also easili paralleliz r design analysi comput algorithm probabilist method faster determinist algorithm minimum span tree minimum span tree algorithm inverseackermann type complex parallel time complex undirect connect minimum span tree note two problem connexion graph fibonacci heap use improv network optim algorithm histori minimum span tree problem optim random algorithm local sort set maxima comput complex program perspect random lineartim algorithm nd minimum span tree linear expectedtim algorithm connect problem simpler minimum span tree veri optim algorithm unknown time complex convex matrix search random timework optim parallel algorithm nding minimum span forest proceedingsproc optim minimum span tree algorithm comput undirect shortest path comparison addit find minimum span tree om shortest connect network gener class algorithm requir nonlinear time maintain disjoint set applic path compress balanc tree tr effici algorithm find minimum span tree undirect direct graph fibonacci heap use improv network optim algorithm optim algorithm unknown time complex convex matrix search verif sensit analysi minimum span tree linear time optim random algorithm local sort setmaxima transdichotom algorithm minimum span tree shortest path random lineartim algorithm find minimum span tree comput complex lineartim pointermachin algorithm least common ancestor mst verif domin applic path compress balanc tree soft heap minimum span tree algorithm inverseackermann type complex concurr thread optim parallel minimum span tree algorithm comput shortest path comparison addit minim random minimum span tree parallel connect set maxima algorithm design analysi comput algorithm random timework optim parallel algorithm find minimum span forest faster determinist algorithm minimum span tree find minimum span tree om alphamn time ctr jess cerquid ramon lpez mntara tan classifi base decompos distribut machin learn v59 n3 p323354 june 2005 artur czumaj christian sohler estim weight metric minimum span tree sublineartim proceed thirtysixth annual acm symposium theori comput june 1316 2004 chicago il usa tzuchiang chiang chienhung liu yuehmin huang nearoptim multicast scheme mobil ad hoc network use hybrid genet algorithm expert system applic intern journal v33 n3 p734742 octob 2007 seth petti new approach allpair shortest path realweight graph theoret comput scienc v312 n1 p4774 26 januari 2004 ran mendelson robert e tarjan mikkel thorup uri zwick meld prioriti queue acm transact algorithm talg v2 n4 p535556 octob 2006 amo korman shay kutten distribut verif minimum span tree proceed twentyfifth annual acm symposium principl distribut comput juli 2326 2006 denver colorado usa