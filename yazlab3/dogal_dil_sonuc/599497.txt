analysi optim activ databas introduc new formal semant activ databas reli transact rewrit techniqu userdefin transact view sequenc atom databas updat form semant atom unit translat mean activ rule induc one transact embodi activ rule semant either immedi defer rule semant confluenc equival optim formal investig character solid framework natur extend known model relat databas transact b introduct activ databas base rule allow us specifi action taken system automat certain event occur condit met wide recogn activ rule provid power mechan manag sever import databas activ eg constraint mainten view materi 6 7 reason larg use modern databas applic extens studi last year 2 4 5 9 12 14 21 22 23 howev variou approach activ rule execut gener specifi inform naturallanguag descript follow often number rule increas activ rule process becom quickli complex unpredict even rel small rule set 23 goal paper provid formal approach activ rule process reli method rewrit user defin transact reflect behavior set activ rule show known result transact equival extend framework preanalyz properti transact rule start introduc simpl transact languag base well known model relat databas 1 transact view collect basic updat oper form semant unit quit gener activ rule languag whose comput model setori like 23 differ approach 22 consid two differ execut model activ rule immedi defer delay 8 14 former tempor decoupl event condit action part latter tempor decoupl event part one side condit action part side defin context rewrit process take input user defin transact set activ rule produc new transact 0 embodi activ rule semant sens explicitli includ addit updat due activ process defer modal new transact origin one augment induc action wherea immedi modal new transact interleav origin updat action defin activ rule follow execut new transact passiv environ correspond execut origin transact within activ environ defin given rule approach consid rewrit techniqu 11 22 usual appli restrict context formal con vers believ formal simpl approach improv understand sever activ concept make easier show result said execut model transact extend relat transact model extens investig 1 reason choic twofold firstli wish use well known framework formal set solid transact execut model secondli wish take full advantag result alreadi avail transact equival optim 1 13 way abl formal investig static sever interest properti activ rule process ing first check whether two transact equival activ databas due result transact equival also abl provid result confluenc final optim issu address final remark note approach activ rule process requir specif runtim support simpler implement other built scratch 10 remaind paper organ follow section 2 detail overview relat databas system confluenceoptim transact rewrit loop check figur 1 compon approach approach present use sever practic exampl section 3 defin basic framework section 4 5 introduc systemat way notion activ databas rewrit transact techniqu respect properti equival investig section 6 studi sever result activ rule process deriv section 7 final section 8 draw conclus overview approach section inform present approach describ figur 1 basic idea express activ rule process four step comput given user defin transact set activ rule p first step check whether p present kind recurs time present simpl character address issu detail present paper second step take p transform transact induc one embodi semant rule p gener step sever transact gener differ induc transact take account fact updat origin transact may trigger sever rule time correspond action execut differ order yield differ result third step confluenc optim issu activ rule process investig analyz transact comput second step done extend known techniqu test equival databas transact 1 13 last step accord result analysi one transact final submit relat databas manag system point two import aspect approach firstli reli formal basi allow us deriv solid result secondli rewrit confluenceoptim step done static without access underli databas therefor perform effici compil time said consid immedi defer activ rule execut model immedi modal reflect intuit rule process soon trigger defer modal suggest rule evalu execut end origin transact 14 thu two differ rewrit procedur given specif consid user defin transact sequenc updat transact transform immedi modal induc one denot sequenc updat comput immedi reaction updat respect set activ rule p reaction deriv match updat u event part activ rule clearli obtain updat trigger rule henc reaction comput recurs note sever transact obtain way note immedi modal induc transact interleav user defin updat rule action defer modal induc transact form henc reaction defer postpon end user transact induc updat trigger rule reaction origin updat recurs comput use immedi modal give number practic exampl clarifi discuss follow activ rule react updat personnel databas compos two relat empnamednames depdnamemgr rule express gener languag refer specif system whose intend mean evid inde rule easili express practic activ rule languag r1 delet dep delet emp dnameddnam r2 insert new emp namenewenam dnamenewednam r3 insert new emp newes 50k insert dep valu dnamenewednam mgrnewenam intuit first rule state depart delet employe work depart must remov cascad delet second one serv enforc constraint employe work one depart state employe tupl say johntoy40k insert relat emp old tupl john associ depart differ toy must delet final last rule state insert employe salari greater 50k elig manag depart work accord tupl name depart new employe insert relat dep provid follow simpl user defin transact first toy depart remov employe ad depart salari 60k insert emp valu namebilldnametoysal60k inspect given activ rule easili realiz run time first updat t1 trigger rule r1 wherea second updat trigger rule r2 r3 therefor immedi modal t1 rewritten compil time follow transact t1i denot immedi modal unfold t1 respect activ rule new transact prefix denot induc updat insert emp valu namebilldnametoysal60k insert dep valu dnametoynamebil obtain transact describ behavior transact t1 take account activ rule immedi modal note anoth possibl translat last two updat switch second updat origin transact trigger two rule time name r2 r3 therefor two possibl execut order effect rule follow gener user defin transact actual induc set transact one goal paper show mani case possibl static check whether transact equival induc transact equival state activ program confluent respect transact t1 case execut one obtain transact implement expect behavior user defin transact within activ framework note assum presenc partial order rule framework easili extend take account let us turn attent defer execut model assum want move employe john toy book depart implement mean follow transact t2 insert emp valu namejohndnamebooksal50k inspect transact rule static decid first updat t2 trigger rule r3 sinc condit satisfi salari new employe greater 50k thu rewrit transact take account activ rule defer modal follow possibl translat t2d denot defer modal effect rule postpon end transact execut transact observ fact second updat discard without alter overal effect transact sinc effect includ effect third updat show optim perform induc transact transact implement expect behavior follow contrast user defin transact updat induc transact independ updat inde induc other fact consequ execut semant induc transact assum instanc runtim execut updat u induc transact null effect databas exampl condit hold effect invalid subsequ updat reason updat induc directli indirectli u execut well interpret need defin new transact semant take account inducerinduc relationship among updat clearli techniqu achiev confluenc optim must take account fact clarifi point consid transform transact t1 defer modal accord previou discuss rewrit process gener follow transact insert emp valu namebilldnametoysal60k insert dep valu dnametoynamebil howev easi see third updat invalid effect second one follow last two updat transact t1d induc updat must execut run time rewrit transact t1 defer modal simplifi follow thu need develop specif techniqu check equival optim induc transact done extend alreadi exist framework equival optim relat databas rest paper devot formal character issu discuss section 3 model transact notion transact use paper base model relat transact introduc abiteboul vianu 1 inform transact mean sequenc basic updat oper name insert delet tupl view semant unit specif restrict attent import class domainbas transact select tupl involv inspect individu valu tupl differ model describ 1 also allow comparison predic 31 preliminari let u finit set symbol call attribut 2 u let doma infinit set constant call domain usual use notat indic singl attribut singleton fag also indic union attribut set thereof mean juxtaposit name moreov assum technic reason domain disjoint total order relat scheme object rx r name relat x subset u databas scheme u collect relat scheme fr 1 x distinct relat name union x u tupl v set attribut x function x union domain 2 x va doma relat relat scheme rx finit set tupl x databas instanc databas scheme function rx 2 srx relat rx denot tupx set tupl set attribut x inst set databas instanc databas scheme throughout rest paper alway refer fix databas scheme set attribut u 32 condit let x set attribut attribut x atom condit x express form 1 ac c 2 doma comparison predic 6 2 2 mean symbol gamma1 1 evid 2 gamma1 c 2 equival c 2 reason allow form atom condit clarifi shortli definit 31 condit complex condit simpli condit set attribut x finit set atom condit x tupl v x satisfi atom condit ac condit c satisfi everi atom condit occur c assum condit alway satisfi contain atom condit alway fals eg 2 c 2 doma atom condit mutual exclus eg condit c set attribut x uniqu identifi set tupl x satisfi condit set call target c definit 32 target condit target condit c set attribut x denot targc set tupl fv 2 tupx j v satisfi cg note targc empti c satisfi say condit specifi complet tupl 33 transact let us first introduc basic updat oper definit 33 insert insert relat scheme r j express form r j c c condit x j specifi complet tupl effect insert r j c map eff r j c inst inst defin r definit 34 delet delet relat scheme r j express form gammar j c c condit x j effect delet gammar j c map eff gammar j c inst inst defin r updat relat scheme insert delet note sake simplic consid modifi oper actual similarli 1 modif accommod framework complex notat would increas dramat updat oper gener execut within transact collect data manipul oper view semant atom unit definit 35 user transact user transact finit sequenc updat effect transact composit effect updat contain map eff exampl 31 sql transact describ section 2 easili express use notat introduc instanc transact t1 page 6 express follow two user transact equival alway produc result appli databas instanc effect definit 36 equival user transact two user transact 1 2 equival denot case eff 1 34 normal transact accord 1 describ character section transact satisfi properti call normal form transact syntact distinct updat disjoint target therefor interfer conveni form sinc simplifi result algorithm moreov make easier specif reaction activ rule updat involv transact also show transact brought special form mean preprocess phase call normal oper perform polynomi time definit 37 normal form transact normal form pair updat u u j relat condit c c j c 6 c j case targc follow result easili follow definit state transact normal form 1 two updat differ target target empti intersect 2 two updat target condit lemma 31 transact normal form 1 target pair updat either ident disjoint 2 condit pair updat target syntact equal proof 1 assum way contradict transact normal form two updat u u j condit c c j targc target u u j differ c 6 c j definit 37 impli target disjoint contradict 2 assum transact normal form two updat target differ condit definit transact normal form impli target inde disjoint contradict 2 transact transform equival transact normal form split target condit suffici mani target end introduc number axiom call split axiom use transform transact equival transact normal form intuit axiom show 1 transform transact equival transact contain atom condit form axiom sa2sa4 2 transform transact way possibl interfer pair updat two form avoid axiom sa5 sa6 1 axiom sa1 sa7 use order appli other specif former show gener condit compos singleton variou attribut latter show add condit attribut condit mention definit 38 split axiom follow axiom call split axiom c condit x 2 x cj denot set atom condit c 1 clearli one possibl way enforc normal form g g c atom condit cg cg cg c element doma c 1 follow result easili prove lemma 32 split axiom sound proof let us consid instanc axiom sa2 let let easi see definit 34 35 eff similar consider appli axiom 2 show axiom practic use normal transact let us first introduc properti condit use algorithm follow properti 31 let c condit x z set attribut c finit set constant attribut 2 x z 1 cja form g c 2 doma c split algorithm use normal transact report figur 2 follow result theorem 31 let transact c set constant appear z set attribut mention 1 algorithm split termin c z gener transact split polynomi time 2 2 split 3 split normal form 2 hereinaft polynomi time mean time polynomi respect length transact algorithm split input transact set constant c set attribut z output new transact split begin updat u r whose condit satisfi properti 31 set attribut x z set constant c transact obtain split u accord split axiom gammafupd unsatisfi conditionsg end figur 2 algorithm split proof 1 assum contain one updat structur split axiom iter loop algorithm split jt moreov algorithm tri enforc properti 31 allow updat atom condit form follow number differ form atom condit i1 take execut algorithm bound 2 correspond number order pair k symbol atom condit form 2 plu cardin c atom condit form c sinc updat split respect constant follow everi jt j bound ju j number complex condit univers u attribut form differ atom condit thu sequenc strictli increas bound therefor algorithm termin contain multipl updat split algorithm appli separ updat result concaten obtain split follow algorithm split termin transact gener output transact polynomi time 2 part easili shown basi lemma 32 induct number transform appli algorithm split 3 way contradict assum split normal form pair updat set attribut x syntact differ condit say c whose target disjoint let attribut x condit 1 properti 31 output algorithm split c j c j j form two possibl case c j form form target would disjoint b c j form 2 c form 2 c case least one two condit satisfi condit 2 properti 31 contradict split output algorithm split 2 exampl 32 let domain integ consid transact transact normal form sinc tupl target two updat contain appli algorithm split obtain 1 2 axiom algorithm termin second step output normal form let us consid transact normal form note 0 satisfi properti 31 sinc first updat even mention attribut b appli algorithm split obtain 1 0 algorithm termin first step output 0 1 inde normal form 4 activ databas section introduc formal notion activ rule program consid simpl form activ rule howev captur consider portion rule describ literatur implement system particular 19 consid core sever concret activ rule languag whose rule execut specifi inform descript shown framework possibl describ main featur languag 41 activ rule program repres activ rule use notat introduc express transact allow us easili describ way updat activ rule interact specif event condit part rule describ updat wherea action part describ transact accord definit section 33 differ variabl use place constant variabl use describ bind pass event condit action rule 3 simplic exampl write 1 thu let us fix set symbol call variabl call gener updat updat condit variabl occur place constant gener transact transact compos gener updat activ rule defin follow definit 41 activ rule activ rule form 1 u e gener updat case insert condit necessarili specifi complet tupl 2 gener transact variabl occur also occur u e left hand side right hand side rule also call event part action part respect definit 42 activ databas activ program p set activ rule activ databas pair p databas instanc p activ program note event part activ rule allow us specifi updat trigger rule condit met effect execut rule 23 intuit semant rule follow updat u match u e execut databas perform transact use bind match u u e exampl 41 activ rule describ section 2 page 5 easili express use notat introduc said one import point tempor relationship execut compon rule event action tempor decoupl defer execut model wherea immedi execut model tempor decoupl approach semant activ databas respect transact given term execut new transact induc defin section 5 along definit rewrit techniqu 42 trigger rule describ updat activ rule interact first introduc preliminari notion let union domain attribut u v set variabl substitut oe function v v ident constant match atom condit defin follow ground atom condit ca atom condit without variabl match gener atom condit c 0 attribut either 1 c 0 contain variabl substitut oe call bind 2 c 0 ground least one tupl v x v satisfi ca c 0 targca let c 1 ground condit c 2 gener condit set attribut x say attribut 2 x occur c 1 j match c 2 j composit bind variou atom condit form bind c 1 c 2 easi show two condit match match uniqu renam variabl definit 43 trigger let updat r activ rule u e say u u e perform type oper relat 2 c match c e updat u trigger rule r u e oe bind say u induc sequenc updat oet rule r note condit variabl activ rule see definit 41 ground updat alway induc ground updat exampl 42 updat empnamebilldnametoysal60k trigger follow activ rule bind associ bill variabl n toy variabl note sal60k match sal50k follow updat induc updat depdnametoymgrbil 5 transact transform section present algorithm transform user defin transact induc one embodi activ rule behavior consid immedi defer case 51 transact transform figur 3 report recurs algorithm comput reaction singl updat algorithm symbol ffl denot concaten oper sequenc note gener differ output gener algorithm depend order trigger rule select first step loop clearli algorithm gener way possibl reaction updat gener moreov accord sever approach describ literatur algorithm modifi first step loop order take account partial order rule unfortun algorithm guarante termin possibl input sinc kind recurs occur activ program howev syntact restrict given algorithm reaction guarante termin result follow base construct special graph g p describ relationship rule p construct graph base notion unif updat gener notion match follow algorithm reaction input updat u activ program p set constant c set attribut z output sequenc p updat induc directli indirectli u p begin trigger trigger ug trigger u p empti pick rule r trigger u p let oe bind u u e u ffl end figur 3 algorithm reaction say two gener updat u 1 u 2 possibl contain variabl unifi ground substitut oe call unifi targoeu 1 graph g p node repres rule p edg rule r updat unifi u 0 e lemma 51 graph g p acycl algorithm reaction guarante termin p updat u k proof algorithm reaction perform recurs call updat oeu u updat occur action part trigger rule r oe match caus trigger call caus turn trigger set rule rule number recurs call algorithm reaction let rule trigger oeu definit 43 mean substitut oe 0 target oeu oe 0 e nonempti intersect sinc assum rule differ variabl oe ffi oe 0 unifi r r 0 therefor two rule p caus recurs call edg r r 0 g p sinc g p acycl follow number recurs call alway finit algorithm termin 2 hereinaft consid activ program p graph g p acycl inde less restrict condit given achiev termin also algorithm modifi order take account presenc kind recurs discuss issu elsewher 18 readi present notion induc transact definit 51 induc transact let user defin transact p activ program c set constant includ constant occur constant occur p z set attribut includ attribut mention attribut mention p output algorithm c z consid follow transact say induc p immedi defer modal respect actual follow refer induc transact without make explicit refer modal transact transform comput sinc variou result hold independ aspect induc transact follow properti hold lemma 52 let user defin transact p activ program transact induc p normal form comput polynomi time proof definit 51 updat occur transact 0 induc split use algorithm split either preprocess step execut algorithm reaction respect set constant set attribut includ occur therefor theorem 31 0 normal form let us consid complex construct 0 hypothesi acycl graph g p easili follow one execut algorithm reaction requir worst case number recurs call equal jp j number rule p bound jp j 2 moreov call algorithm reaction involv one execut algorithm split requir polynomi time theorem 31 number concaten oper bound maximum number updat occur action part rule p follow algorithm reaction requir polynomi time sinc algorithm use updat occur origin transact induc transact comput polynomi time 2 point given user defin transact activ program may sever differ induc transact depend possibl differ output algorithm reaction even number induc transact alway finit may larg howev number reduc check instanc certain one obvious equival eg certain rule trivial commut problem effici gener induc transact manag beyond goal paper address elsewher 18 52 semant induc transact said section 2 induc updat induc transact execut 1 induc updat effect execut 2 invalid afterward new notion effect transact need defin accord call new semant activ effect induc transact sinc take account relationship induc updat induc one due activ rule relationship known alway made explicit gener induc transact sever way instanc mean label techniqu describ 18 let u updat databas instanc say effect u visibl also let transact 1 j n denot tj j transact compos first j compon definit 52 activ effect activ effect eff ff induc transact map eff ff inst inst recurs defin follow induc updat u effect u visibl eff ff final readi defin semant transact respect activ databas definit 53 effect transact activ databas potenti effect user transact activ databas p coincid eff ff 0 0 transact induc p 6 equival activ databas mani interest problem systemat studi formal framework defin among equival optim confluenc activ databas section shall consid equival show properti decid polynomi time 61 equival induc transact transact equival extens investig relat model 1 13 major result studi concern decid whether two transact equival transform transact equival less expens one unfortun result directli use within framework differ semant defin transact let us introduc new definit equival refer induc transact definit 61 equival induc transact two induc transact 1 2 equival denot 1 ff 2 case eff ff algorithm summari input induc transact output summari sigma begin u induc u embed sigma sigma els case u end figur 4 algorithm summari present simpl method test equival induc transact actu alli method work transact normal form base represent behavior transact call summari annot condit follow syntax hr ci r relat c complex condit summari induc transact pair set annot condit gener summari algorithm report figur 4 algorithm make use follow notion given summari sigma say updat u condit c embed sigma either summari sigma describ succinct way behavior induc transact specif let n cardin sigma sigma gamma respect consid transact b defin follow hr ci 2 updat gammarc one first n posit hr ci updat rc one posit actual sinc sigma sigma gamma set sever differ way build b howev sinc transact obtain alway delet follow insert nonact effect alway thu order updat occur b immateri consid determinist construct follow lemma 61 eff ff proof proof proce induct length n basi sinc case easi see definit 52 eff ff regard induct step assum eff ff definit 52 instanc updat u j execut eff ff tj j gamma1 induc updat u occur tj j gamma1 visibl eff ff condit induct hypothesi u visibl also eff b construct simpli impli u occur b tj j gamma1 mean u embed execut algorithm summari annot condit correspond u j includ sigma j therefor u j occur b j j follow instanc u j effect execut eff ff activ effect semant u j occur b tj j eff ff tj complet induct part theorem 61 let 1 2 two induc transact set constant set attribut 1 ff 2 sigma 1 proof let sigma 1 assum without loss gener b lemma 61 eff ff let eff ff instanc relat scheme rx let v tupl srx v 62 eff ff 1 srx clearli also v 62 eff ff 2 srx consid transact b updat u updat u induc transact set constant set attribut therefor concaten 1 2 transact normal form sinc non empti intersect lemma 31 follow thu annot condit hr c 1 occur sigma gamma consider appli insert follow 2 interest aspect point notion activ effect induc transact inde gener notion effect userdefin transact impli character equival also hold ordinari transact passiv environ 62 equival user transact notion equival user transact natur extend activ environ sinc seen transact potenti produc differ result activ databas depend differ induc transact gener assum two transact equival abl produc alway result databas instanc definit 62 equival transact activ framework two user transact 1 2 equival respect activ program p transact 0 induc 1 p transact 0 induc 2 p 0 2 vice versa result section state follow result theorem 62 equival two user transact activ framework decid polynomi time proof given user transact lemma 52 construct transact induc polynomi time number transact induc singl updat activ program p bound constant depend size p specif bound denot cardin p number transact induc bound k theta jtj definit 62 equival two user transact 1 2 requir test equival pair transact induc 1 2 respect number test bound k 2 theta jt 1 j theta jt 2 j theorem 61 equival two induc transact requir 1 construct summari mean algorithm summari requir time linear respect length transact bound jtj theta jp j 2 2 test equal two summari requir time proport jt 1 j theta jt 2 j theta jp j 4 follow equival 1 2 decid polynomi time 2 63 axiomat transact equival close section present two simpl intuit axiom prove equival induc transact provid much insight relationship updat induc transact sinc axiom show transact manipul without alter overal effect call manipul axiom also show axiom suggest way optim effici transact activ environ order present axiom need introduc preliminari notion first use notat inducedu denot updat induc directli indirectli updat u induc transact moreov say two updat collid relat scheme condit ident final introduc notion valid updat transact syntact counterpart notion visibl recurs defin follow updat u induc transact valid 1 induc 2 induc directli updat u j preced u valid updat u k u j collid u j definit 63 manipul axiom follow axiom call manipul axiom involv induc transact 1 2 eventu empti subtransact switch axiom 1 u u j collid 2 u valid updat 3 u j collid updat u k occur 1 u merg axiom 1 u u j collid 2 u j valid updat 3 0 updat inducedu intuit axiom ma1 state updat u u j collid u j invalid effect updat induc u switch instead axiom ma2 state u collid u j execut equival execut u j provid 1 updat induc directli indirectli execut well 2 updat induc directli indirectli howev execut happen u j induc u lemma 62 manipul axiom sound 1 man 2 impli 1 ff 2 proof let us first consid ma1 sinc u u j collid u invalid u j execut latter first moreov definit 52 switch effect execut u depend updat occur 1 u j collid updat induc u switch execut u still depend updat occur 1 final switch effect execut u j depend updat occur 1 u therefor u j induc u switch effect execut u j still depend updat occur 1 hand u j induc u problem aris sinc u valid u j execut anyway follow given condit activ effect coincid activ effect let us consid ma2 sinc u u j collid u j valid u j invalid u therefor u delet without alter effect transact moreov sinc u invalid u j effect visibl execut 2 updat induc directli indirectli u delet 2 except induc also u j case u j induc u given condit activ effect coincid activ effect theorem 63 sound complet set axiom prove equival induc transact proof lemma 62 sound prove complet axiom consid two induc transact 1 2 1 ff 2 use manipul axiom transform transact two new transact 0 delet perform insert done two step first one updat transact collid anoth updat delet second one delet move front transact insert first step perform use manipul axiom follow start second updat iter updat transact move forward use axiom ma1 updat preced one current consider collid updat delet use axiom ma2 easi show work alway done first step pair updat transact collid second step easili move delet front transact use axiom ma1 sinc axiom sound lemma 62 2 0 also sinc pair updat 0 collid easili follow 0 sinc 0 theorem 61 sigma 0 sigma 0 construct b coincid permut delet permut insert follow b 1 transform b use repeatli axiom ma2 sum man 0 man man 2 2 7 analysi activ rule process basi result transact equival deriv section number result import properti activ databas 71 confluenc confluenc strong properti applic may actual need weaker notion 2 propos two notion confluenc former weaker latter sinc refer specif transact howev notion nice character turn practic import definit 71 weak confluenc activ program p confluent respect user transact transact induc p equival definit 72 strong confluenc activ program p strongli confluent confluent respect user transact follow result show practic method test weak confluenc theorem 71 weak confluenc decid test polynomi time proof given user transact lemma 52 construct transact induc polynomi time definit 71 confluenc respect p requir test equival pair transact induc number test done bound squar maximum number transact induc k 2 theta jtj 2 k constant depend size p see proof theorem 62 sinc theorem 61 test equival two induc transact requir polynomi time follow confluenc respect p also perform polynomi time 2 introduc anoth interest notion confluenc independ specif transact let p activ program c set constant occur p r u e rule p denot u r set updat obtain r follow atom condit ca u e involv variabl x let set interv 2 constant c 2 ca c 2 sinc ca finit psi actual finit partit doma let k set constant contain one element whichev everi note sinc psi finit partit doma ka alway finit set u r contain possibl updat obtain appli u e substitut attribut occur u e map variabl u e occur ca constant ka intuit set u r contain repres trigger updat rule r specifi differ way rule r trigger updat definit 73 local confluenc activ program p local confluent rule confluent respect updat u r activ program p local confluent confluent everi rule p note theorem 71 follow check local confluenc activ program polynomi time follow result state local confluenc although restrict desir properti activ program theorem 72 activ program local confluent strongli confluent proof let user transact normal form respect set constant occur p set attribut mention p note restrict hypothesi sinc theorem 31 transact transform transact satisfi properti use algorithm split proof proce show updat u trigger rule r 2 p sequenc updat induc u map constant 1 u 2 u r 2 u induc sequenc updat 0 0 specif map defin follow atom condit ca occur u ident constant ka map constant c 62 ka constant c 0 2 ka belong interv contain c clearli u 2 ka moreov definit 43 trigger algorithm split easi show induct number step algorithm reaction sequenc updat gener algorithm start u algorithm abl gener sequenc start u definit local confluenc sequenc updat induc u equival easili follow sequenc updat induc u also equival thu p confluent respect sequenc updat induc updat easili shown given transact partit sequenc adjac updat confluent respect confluent respect therefor definit 51 induc transact follow independ modal transact p confluent respect p strongli confluent 2 possibl show local confluenc impli strong confluenc convers true gener even weak confluenc activ program local confluent confluent respect certain transact notion local confluenc give us suffici condit confluenc check effici let p activ program p conf set rule p local confluent note set deriv one definit time follow character weak confluenc simpli requir updat transact one test match event part rule p corollari 71 let p activ program user defin transact p confluent respect updat trigger rule p conf proof p conf inde strongli confluent program therefor theorem 72 confluent respect p conf respect p 2 72 optim major object research provid tool optim induc transac tion particularli import sinc approach optim techniqu induc transact yield method optim overal activ activ rule process accord 1 two type optim criteria transact consid first relat syntact aspect eg length complex updat transact wherea second relat oper criteria number atom updat perform transact criteria formal investig section let us first introduc preliminari notion let p partit tupl space partit set tupl v 2 tupx everi rx scheme say transact base p condit c occur updat targc 2 p accord implement assum delet oper complex insert oper denot u order may invalid certain implement updat howev chang order affect result follow definit 74 transact base p syntact optim everi transact 0 base p equival exist permut given transact denot nopt map inst theta associ instanc pair number tupl insert number tupl delet moreov denot order relat theta defin follow k ratio cost insert oper cost delet oper intuit order relat take account number updat oper togeth prefer attribut insert delet definit 75 transact base p oper optim everi transact base p equival instanc 2 inst note definit refer possibl pair equival transact rather transact base partit tupl space howev conveni form sinc possibl show transact base partit syntact oper optim attain simultan gener definit 76 transact optim oper syntact optim let us consid manipul axiom introduc previou section defini tion 63 easi see one applic merg axiom yield strictli simpler transact wherea switch axiom affect complex translat howev use order appli merg axiom simpl observ lead method optim induc transact intuit method consist appli number time switch axiom follow applic algorithm optim input induc transact output new transact opt begin repeat collid updat u j j preced u i1 transact obtain delet u j updat inducedu j els updat examin end figur 5 algorithm optim merg axiom modif perform method effect implement simpl way mean algorithm figur 5 recal inducedu denot induc transact updat induc directli indirectli updat u follow theorem confirm algorithm alway termin polynomi time produc optim transact theorem 73 let induc transact 1 algorithm optim termin gener transact opt polynomi time 2 opt ff 3 opt optim proof 1 algorithm simpli involv iter updat requir worst case time linear length transact note howev step involv reduct averag execut algorithm even effici 2 part prove show step loop algorithm new transact i1 equat transact previou step obtain number applic switch axiom move close u follow one applic merg axiom show note algorithm elimin collis updat soon encount iter updat transact impli step sequenc updat 1 preced updat u consider pair updat collid updat valid therefor step freeli use switch axiom 1 see definit 63 particular updat u j 1 collid u move u j close u appli merg axiom thu obtain exactli transact i1 lemma 62 follow ff termin opt ff 3 first note consequ shown part 2 opt pair updat collid assum way contradict opt syntact optim let 0 transact base partit p equival opt less updat oper opt accord order impli updat u opt condit c visibl eff ff opt instanc must updat u 0 condit c 0 0 therefor sinc opt updat 0 least updat u x opt visibl possibl u x invalid anoth updat opt opt normal form obtain delet updat transact normal form lemma 31 impli two updat opt collid contradict assum way contradict opt oper optim let 0 transact base partit p equival opt nopt 0 opt instanc 2 inst impli opt either perform two time insertiondelet tupl tupl first insert delet delet insert opt normal lemma 31 possibl two updat opt collid contradict 2 conclus present formal techniqu allow us reduc sever import case activ rule process passiv transact execut specif user defin transact translat new transact embodi expect rule semant immedi defer execut modal shown mani problem easier understand investig point view tackl formal set natur extend alreadi establish framework relat transact fact turn sever import result deriv transact passiv environ taken across activ one firstli abl formal investig transact equival framework activ databas secondli result transact equival use check interest practic use notion confluenc final optim issu address believ approach activ rule process suitabl interest investig practic point view studi effici way gener keep induc transact context implement method top commerci relat dbm 18 theoret point view believ variou result extend sever way take account gener framework final rewrit techniqu appli data model one base object 16 r equival optim relat transact static analysi techniqu predict behavior activ databas rule model activ objectori databas automat gener product rule integr maintenanac chimera model languag activ dood sy tem deriv product rule constraint mainten deriv product rule increment view mainten structur approach definit semant activ databas ode activ databas constraint trigger design implement chimera activ rule languag combin theori practic integr control declar approach specif transact modif subsystem rule process activ databas system simplif rule complet axiomat relat updat transact architectur activ data base manag system activ databas paradigm enhanc comput environ ment rewrit techniqu implement activ object system rewrit techniqu analysi optim activ databas transact transform approach activ rule process framework specif activ rule languag semant implement larg product system dbm environ concept algorithm integr rule system databas system rule tr equival optim relat transact architectur activ databas manag system theori rule trigger system deriv product rule constraint mainten setori product rule relat databas system rule procedur cach view data base system simplif rule complet axiomat relat updat transact rule process activ databas system termin confluenc rule execut automat gener product rule integr mainten static analysi techniqu predict behavior activ databas rule structur approach definit semant activ databas logicbas integr activ deduct databas design implement chimera activ rule languag activ rule analysi optimis rock myampersandamp roll deduct objectori databas foundat databas integr rule system databas system refin trigger graph transact transform approach activ rule process rewrit techniqu analysi optim activ databas express complex activ databas ode activ databas deriv product rule increment view mainten implement languag specifi activ databas execut model algebra approach rule analysi expert databas system use delta relat optim condit evalu activ databas investig termin activ databas system express rule languag rewrit techniqu implement activ object system framework specif activ rule languag semant combin theori practic integr control termin analysi activ databas ctr burcin bostankorpeoglu adnan yazici fuzzi petri net model intellig databas data knowledg engin v62 n2 p219247 august 2007