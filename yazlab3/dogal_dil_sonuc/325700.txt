framework combin analysi verif present gener framework combin program verif program analysi framework enhanc program analysi take advantag user assert enhanc program verif assert refin use automat program analysi enhanc gener produc better way reason program use verif techniqu alon analysi techniqu alon importantli combin better simpli run verif analysi isol combin result last step word framework explor synergist interact verif analysi paper start represent program user assert given analyz program framework describ induc algorithm exploit assert analyz produc gener accur analysi import featur flexibl number assert use anywher open employ arbitrari analyz modular reason condit correct assert increment tune accuracyeffici tradeoff b introduct abstract 9 success method abstract interpret abstract domain construct given finit set predic program variabl intuit easili though necessarili effici comput within travers method program control flow structur recent success predic abstract enhanc process discoveri copyright notic appear abstract domain gener known cegar counterex ampl guid abstract refin one major disadvantag predic abstract true mani realiz abstract interpret principl process abstract perform everi step travers phase inde survey section 19 state abstract often defin small part program abstract modelcheck often overapproxim gener easi optim somewhat perform abstract eg sever consecut asign may compress abstract perform accord one composit assign blast system 11 systemat way anoth disadvantag aris partli abstract descript limit fix number variabl adhoc method would composit exampl 2 requir elabor extens predic abstract essenti consid second set variabl call symbol constant order describ behaviour function languag predic abstrac tion provid limit form composition paper present gener proof method program reason base predic abstract process abstract intermitt approxim perform select program point restrict abstract perform even though termin issu usual restrict choic key advantag abstract domain requir ensur converg algorithm minim b cost perform abstract inter mittent reduc exampl reason execut x one need know final assign also consid prove follow program snippet 1 n textbook hoarestyl loop invari loop 2i proposit predic abstract would howev suffic one fact need know hold two increment c thu gener proper loop invari use could propag inform exactli main challeng exact propag reason requir strongestpostcondit oper associ arbitrarili long program fragment essenti mean deal constraint unbound number variabl describ state start end program fragment hand advantag term effici howev signific less predic need abstract domain also less frequent execut abstract oper import addit featur proof method composit repres proof hoarestyl tripl given program fragment relat input valu variabl output valu repres formula gener formula must contain auxiliari variabl addit program vari abl gener imposs repres project formula use predefin set vari abl equival possibl perform quantifi elimin consequ order unrestrict composit proof necessari deal unbound number variabl latter part paper introduc technolog constraint logic program clp basi effici implement briefli advantag clp handl term contain anonyn primari variabl constraint variabl also arbitrari number auxiliari variabl b effici repres project term c handl backtrack summari show method provid flexibl combin abstract hoarestyl reason predic transform loopinvari composi tional practic implement feasibl 11 relat work import categori tool use program verif technolog develop within framework java model languag jml project jml allow specifi java method pre postcondit class invari exampl program verif tool jack 4 escjava2 7 krakatoa 15 tool employ weakest preconditionstrongest postcondit calculi gener proof oblig reflect whether given postcondit class invari hold end method whenev correspond precondit valid procedur entri point result proof oblig subsequ discharg theorem prover simplifi 7 coq 3 pv 17 hol light 10 system perform exact propag depend userprovid loop invari oppos abstract domain recent emerg system base abstract interpret particular predic abstract exampl blast 11 slam 1 magic 5 murphi 8 amongst other abstract interpret central system employ techniqu automat determin abstract domain need given assert techniqu call cegar see eg descript 6 base iter refin abstract domain failur abstract domain previou iter system perform exact propag systemat way 2 preliminari apart program counter k whose valu program point let n system variabl domain respect paper shall use two exampl domain integ integ array assum number system variabl larger number variabl requir program fragment procedur definit 1 state transit system state simpli state form kd 1 n pc program point 1 n valu system variabl transit pair state follow defin languag firstord mula let v denot infinit set variabl type 1 n let denot set func tor p denot set constraint symbol term either constant 0ari functor form term primit constraint form ft 1 f mari constraint symbol term constraint construct primit constraint use logic connect usual manner constraint write x denot possibl refer variabl x write x denot existenti closur away x substitut map simultan replac variabl term constraint ex pression e term constraint write eq denot result appli q e special kind substitut renam map variabl given sequenc say correspond variabl anoth given sequenc say write denot map anoth special kind substitut ground map variabl express valu respect domain thu effect appli ground substitut q express e obtain set eq ground instanc q write denot set possibl ground e 3 constraint transit system key concept program fragment p oper sequenc anonym variabl correspond system variabl variou point comput p particular consid two sequenc n anonym variabl denot system valu execut p target point p respect typic alway target point termin point p proof oblig assert form 1 constraint said variabl possibl includ new variabl like hoaretripl state p execut state satisfi state target point satisfi 1 note unlik hoaretripl p may nontermin 1 may refer state point reach infinit often formal exampl let one system variabl x let p 0 x let target point 1 mean p successor function x similarli p perpetu program 0 true x 1 target point truepx state 1x point 1 satisfi zx show amongst thing pariti x alway remain unchang proof method accomod concurr program fix number process n process shall use program point sequenc n program point th program point one come th process next repres program fragment p transit system execut symbol follow definit serv two main purpos first high level represent oper semant p fact repres exact trace semant p second execut specif assert check definit 2 constraint transit system constraint transit p formula k k 1 variabl program point x x 1 sequenc variabl repres system even5 even5 figur 1 even count process 1 true process 2 true figur 2 two process bakeri figur 3 ct two process bakeri state constraint x possibl addit auxiliari variabl constraint transit system ct p finit set constraint transit p consid exampl program section 1 call even figur 1 contain ct even consid anoth exampl bakeri algorithm two process figur 2 ct program call bak given figur 3 note use first second argument term bub denot program point first second process respect clearli variabl constraint transit may renam freeli scope local transit thu say constraint transit variant anoth one ident renam subsitut perform may simplifi constraint transit renam one variabl x express provid ground constraint tran sition exampl may simpli state last constraint transit figur 3 replac variabl 1 origin transit 0 formul program transit familiar literatur purpos defin set transi tion new howev use ct defin symbol transit sequenc thereon notion proof similar logic program use term goal deonot liter subject unfold process order infer logic consequ definit 3 goal queri goal ct k program point sequenc variabl system state constraint variabl x possibl addit variabl variabl x call primari variabl goal addit variabl call auxiliari variabl goal thu goal like conclus constraint transit say goal start goal k start program point similarli goal target goal k target program point run start goal tantamount ask question valu x satisfi lead goal target point idea success reduc one goal anoth result goal target point inspect result next defin mean ct prove goal definit 4 proof step sequenc tree let ct p let xy goal proof step g obtain via variant pk transit ct variabl fresh result goal g form 1 provid constraint 1 satisfi proof sequenc finit infinit sequenc proof step proof tree defin proof sequenc obviou way tree complet everi intern node repres goal g succeed node repres everi goal obtain proof step g figur 5 proof tree even count program consid ct figur 1 wish prove fact one proof sequenc start goal equival even0 10 proof sequenc shown figur 5 note counterrepres last goal variabl c 2 valu 2 hereaft shall consid program ct synonym given program p say x start variabl p denot x variabl first constraint transit p definit 5 assert let p program start variabl x let constraint let x denot sequenc variabl repres system state appear p repres target valu system assert p wrt x form particular k start program point may abbervi assert use notat intuit clear mean assert hold execut everi instanc q pk lead target state properti 1 violat exampl could prove assert understood final variabl c correspond start variabl c note last occurr n assert mean compar c initi final valu n though exampl two fact state essenti properti proof sequenc theorem 1 let ct p start point k target x x 1 sequenc variabl figur 4 proof tree 2process bakeri algorithm partial shown system state assert hold goal form pk appear proof sequenc goal pk x follow hold theorem provid basi search method remain provid mean ensur termin search toward end next defin concept subsumpt coinduct allow success termin proof sequenc howev gener insuffici next section present version abstract whose purpos transform proof sequenc applic termin criteria subsumpt coinduct 31 subsumpt consid finit complet proof tree start goal goal g tree subsum differ path tree contain goal g g principl simpli memoiz one may termin expans proof sequenc construct proof tree encount subsum goal 32 coinduct principl within one proof sequenc proof oblig associ final goal may assum proof oblig ancestor goal alreadi met formal explain principl coinduct see eg appendix b 16 importantli simpl form coinduct requir base case wellfound order shall simpli demonstr principl exampl suppos transit p0x p0x wish prove assert p0x evenx x differ x final valu even consid deriv step may use latter goal fact earlier goal satisfi assert may reduc obligaton latter goal simpl matter infer whether formula hold gener practic applic coinduct test larg equival test one goal simpli instanc anoth 33 compostion intuit clear sinc proof oblig relat start final valu program equival obey assumeguarante paradigm 18 proof method sequenti composit thu omit formal treatment ct program directli invok program instead next section provid simpl exampl 4 abstract literatur predic abstract abstract descript special data structur monomi abstract oper serv propag structur though small program fragment contigu group assign test obtain anoth struc ture strength method simplic use finit set predic fix number program variabl basi abstract descript choos follow method howev abstract descript shall distinguish data structur abstract descript goal goal definit 6 abstract abstract appli goal specifi program point pca sequenc variabl vara correspond subset system variabl final finit set constraint preda vara call predic let abstract g goal pk xy x denot subsequ x correspond system variabl vara let x denot remain subsequ x without lose gener assum x 1 initi subsequ x x abstract ag g z sequenc fresh variabl renam 2 finit set constraint exampl let first variabl abstract neg nonneg valu let g p0 x 1 x 2 x 3 x 1 abstract ag goal form p0 zx 2 x 3 x simplifi p0 zx 2 x 3 x note orgin goal ground instanc p0 1 1n n abstract goal instanc p0 m1n n nonneg note second variabl x 2 abstract even though tightli constrain first variabl x 1 note valu x 3 unchang abstract would allow constraint x 3 exampl goal contain constraint propag lemma 1 let abstract g goal critic point abstract goal format goal thu abstract goal express power regular goal yet contain notion abstract suffici produc finitest effect facilit abil reason unbound number variabl consid bubbl program ct figur 7 8 simplifi skeleton bubbl sort algorithm without array consid subprogram correspond start point 2 whose target point 6 consid inner loop suppos follow assert alreadi proven bub2 j n subprogram increment n preserv n j consid proof sequenc goal bub0 j nn 0 want prove program point 8 n2 proof tree depict figur 6 proof show combin use intermitt abstract composit proof point abstract goal bub2 use predic i2 call abstract set variabl henc variabl correspond respect system variabl 1 n1 3 j ni1 figur 7 program bubbl bub0 j n bub1 bub1 j n bub8 j n n1 bub1 j n bub2 j n n1 bub2 j n bub3 bub3 j n bub6 j n j n 1 bub3 j n bub4 j n j n 1 bub4 j n bub5 bub5 j n bub6 j n j n 1 bub5 j n bub4 j n j n 1 bub6 j n bub7 bub7 j n bub8 j n n1 bub7 j n bub2 j n n1 figur 8 ct bubbl renam fresh variabl 2 2 mean variabl j n retain origin valu perform abstract reus proof inner loop immedi move program point 6 increment updat j unknown valu howev n retain origin valu 2 result intermitt abstract obtain coinduct proof b 5 whole algorithm summar proof method assert suppos start program point p k start variabl p x consid start goal pk increment build search tree path tree construct far lead goal g g either subsum coinduct consid path close ie expand g goal abstract defin replac g ag g target goal constraint primari variabl x 1 g satisfi yq q renam target variabl coinduct use satisfi satisfi proof composit intermitt abstract bub0 j nn 0 figur 6 composit proof theorem 2 algorithm appli assert asert hold 6 clp technolog almost immedi ct implement clp given ct p build clp program follow way everi transit form k use clp rule claus pk ing constraint domain clp implement hand b everi termin program point k use clp fact pk number anonym variabl number variabl x see later key implement challeng clp system increment satisfi problem roughli state problem success determin monoton increas sequenc constraint interpret conjunct satisfi 61 exact propag clphard inform demonstr increment satisfi problem reduc problem analyz straight line path program consid constraint form linear diophantin equat ie multivari polynomi integ without loss gener assum constraint written form integ suppos alreadi sequenc constraint correspond path program control flow suppos add new constraint one variabl say new add assign x z new variabl creat correspond remain variabl x z either new correspond variabl x z howev xy z new add statement program variabl correspond x z respect hereaft pursu branch statement similarli suppos new constraint form correspond possibl new x new simpli add assign x n x newli creat correspond x otherwis add statement path pursu branch statement clearli exact analysi path construct lead success travers requir increment solv constraint sequenc 0 n 62 key element clp system clp system attempt find answer initi goal g search valid substitut variabl depthfirst search use path search tree fact involv solv increment satisfi problem along way unsatisfi constraint hand would entail backtrack key issu clp increment satisfi problem mention standard approach follow given sequenc constraint 0 determin satisfi repres fact solv form essenti mean new constraint i1 encount solv form effici combin i1 order determin satisfi new conjunct constraint method essenti requir represent project set constraint onto certain variabl con sider exampl set x assum new constraint would involv variabl x happen vastli ten desir represent x project problem well studi clp system 13 system clpr 14 exampl variou adapt fouriermotzkin algorithm implement project herbrand linear arithmet constraint final mention anoth import optim clp tail recurs techniqu use space procedur call stack recurs call amongst bebefit techniqu allow potenti unbound number recurs call tail recurs particurli relev context recurs call aris ct program often tailrecurs clpr system use implement prototyp engin handl constraint auxiliari variabl effici use techniqu 7 experi perform two kind experi first set perform exact propag look compar abstract run blast system exact run system result present section 71 second set experi present section 72 compar intermitt predic abstract normal predic abstract blast system use pentium 4 28 ghz system 512 mbram run gnulinux 2422 71 exact run start experi show concret execut potenti less costli abstract execut simpli compar time concret execut use clpbase implement predic abstractionbas model checker also run simpl loop program whose c code shown figur 9 first blast gener 100 predic requir rerun blast provid predic blast took 2206 second explor state space machin without abstract verif engin took second comparison spin model checker 12 execut program written promela less second consid synthet program consist initi assign x 0 follow 1000 increment x object prove 1000 end consid also anoth version program contain singl loop increment counter x 1000 time input two program program verifi without use abstract escjava 2 well result shown tabl 1 verifi escjava 2 run x initi 0 initi hope forc symbol execut tabl 1 show verifi run faster nonloop version howev notic slowdown int main int i0 j x0 i7 j7 x j error figur 9 program loop time second clp tabl escjava 2 nonloop 245 247 989 968 loop 2205 2195 100 100 tabl 1 time comparison escjava 2 loop version implement caus fact implement coinduct tabl subsumpt check done base similar program point therefor program point insid loop visit ith time 1 subsumpt check perform result total 500000 subsumpt check loop program comparison nonloop version requir 1000 subsumpt check howev implement current prototyp stage tabl mechan implement effici way loop version escjava 2 employ weakest precondit propag calculu sinc program small straightforward invari loop condit comput fast tabl also show almost differ x initi 0 72 experi use abstract next show exampl demonstr intermitt approach requir fewer predic let us consid second loop program written c shown figur 10 program postcondit proven provid invari xi i50 exactli first statement loop bodi outer loop specifi abstract domain follow predic xi i50 respect negat xi i50 program point verifi use inform proof process finish less 001 second provid abstract domain verif process finish 2034 sec ond intermitt predic abstract requir fewer predic also run program blast provid predic xi i50 blast would auto int main int i0 j x0 i50 j10 x j xi x error figur 10 second program loop true figur 11 bakeri algorithm peudocod process matic also consid negat blast finish 133 second addit also produc 23 predic refin run predic given blast finish 028 second also tri proof method version bakeri mutual exclus algorithm need abstract sinc bakeri algorithm infinitest program pseudocod process shown figur 11 would like verifi mutual exclus two process critic section program point 2 time version bakeri algorithm concurr program asynchron composit process encod sequenti program nondeterminist choic first encod algorithm 2 3 4 process blast nondeterminist choic implement blast use special variabl blast nondet nondeterminist valu show blast code 2process bakeri algorithm figur 12 within code use program point annot pc consid comment notic program point concurr version encod use integ variabl pc1 pc2 translat blast sequenti version algorithm 2 3 4 process ct version shown figur 13 also correspond clp code input prototyp verifi experi attempt verifi mutual exclus properti two process critic section time perform 3 set run consist run 2 3 4 process 3 set use basic set predic x 0 x 0 pc 0 pc 1 int main 0 int pc10 pc20 unsign int x10 x20 1 1 2 pc11 pc21 3 abstract point 1 4 pc10 pc20 5 abstract point 2 els pc12 pc22 6 error 7 blast nondet 8 pc10 els pc11 els pc12 els 12 pc20 els pc21 els pc22 figur 12 sequenti 2process bakeri n number process also negat set 1 use predic abstract everi state full predic set use prototyp system perform ordinari predic abstract abstract everi state encount search addit basic predic also requir predic shown tabl 2 negat avoid produc spuriou counterexampl set 2 intermitt predic abstract full predic set second set use intermitt abstract techniqu prototyp implement abstract process pc 1 hold figur 12 abstract point mark comment abstract point 1 set predic use predic use first experi otherwis spuriou counterexampl gener set 3 intermitt predic abstract reduc predic set third set also use intermitt abstract techniqu tabl clp system abstract whenev n1 process program point 0 2process sequenti version condit either pc10 pc20 bak3 pc1 pc2x1x2 bak4 pc1 pc2x1x2 bak5 pc1 pc2x1x2 bak7 pc1 pc2x1x2 2 bak6 pc1 pc2x1x2 bak7 pc1 pc2x1x2 bak7 pc1 pc2x1x2 bak8 pc1 pc2x1x2 bak7 pc1 pc2x1x2 bak12 pc1 pc2x1x2 2 2 2 2 figur 13 ct sequenti 2process bakeri bakery2 x1x2 bakery3 x1x2 x1x3 x2x3 bakery4 x1x2 x1x3 x1x4 x2x3 x2x4 x3x4 tabl 2 addit predic time second clp tabl blast bakery3 083 014 009 238 bakery4 13111 885 502 7847 tabl 3 time comparison blast mark comment astract point 2 figur 12 bakeri algorithm n process need basic predic negat without addit predic shown tabl 2 also compar result blast suppli set predic use first second set blast blast specifi negat explicitli interestingli 4process bakeri algortihm blast requir even predic avoid refin x1x31 x2x31 x1x21 1x4 x1x3 x2x3 x1x2 suspect due fact precis predic abstractionbas statespac travers depend power underli theorem prover blast gener addit predic need prerun run blast use sinc run blast refin lazi abstract techniqu 11 effect blast use suppli predic repres abstract state problem use intermitt abstract clp tabl also markedli faster full predic abstract clp blast show time result tabl 3 smallest record time 3 run first set blast run abstract everi visit state time differ second third set show perform abstract everi visit state expens third set show gain second understand intricaci system acknowledg thank ranjit jhala help blast r automat predic abstract c program polymorph predic abstract coq proof assist refer manualvers v6 java applet correct developerori approach modular verif softwar compon c escjava2 unit escjava jml experi predic abstract construct abstract state graph infinit system pv hol light tutori introduct lazi ab straction spin model checker primer refer manual project clpr clpr krakatoa tool certif javajavacard program annot jml principl program analysi pv prototyp verif system proof techniqu relyguarante properti model check program tr constraint logic program method logic prove program base program analysi modern compil implement ml simplif cooper decis procedur abstract interpret systemat design program analysi framework flexibl approach interprocedur data flow analysi program recurs data structur prove safeti properti integr static analysi theorem prove abstract program analysi use mix term set constraint experi theorem prove model check protocol verif power techniqu automat gener invari verifi invari use theorem prove pv