new tile techniqu improv cach tempor local tile wellknown loop transform improv tempor local nest loop current compil algorithm tile limit loop perfectli nest transform trivial way perfect nest paper present number program transform enabl tile class nontrivi imperfectlynest loop cach local improv defin program model loop develop compil algorithm tile propos adopt oddeven variabl duplic break anti output depend without unduli increas workingset size adopt specul execut enabl tile loop may termin prematur due eg converg test iter algorithm implement techniqu research compil panorama initi experi sever benchmark program perform sgi workstat base mip r5k r10k processor overal transform program run faster 9 164 b introduct due widen gap processor memori speed import effici use cach wide recogn loop tile combin stripmin loop interchang wellknown loop transform use increas work sponsor part nation scienc foundat grant ccr950254 mip9610379 purdu research foundat appear acm sigplan pldi99 copyright c fl1999 associ comput machineri inc permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page intial screen document copyright compon work own other acm must honor abstract credit permit copi otherwis republish post server redistribut list requir prior specif permiss andor fee request permiss public dept acm inc fax 1 212 8690481 permissionsacmorg reus cach data 25 varieti loop transform revers skew also propos enabl loop tile 23 current tile techniqu gener limit perfectlynest loop loop except innermost one perfect nest contain exactli one inner loop next level loop nest contain simpl statement two loop header shown figur 1 transform perfect nest simpli move statement guard appropri insert condit insid inner loop 23 assum inner loop iter least unfortun mani imperfectlynest loop numer program trivial one figur 1 loop may contain sever inner loop level exampl jacobi program kernel shown figur 2a two separ loop nest within outmost loop certain case techniqu peelandfus 13 transform nontrivi imperfectlynest loop perfectli nest one may becom amen tile unfortun techniqu exploit tempor local within iter outer loop eg loop jacobi code paper tloop call timestep loop rel littl tempor reus exploit cach data reus across differ time step current tile techniqu also difficulti prematur loop exit caus converg test iter numer algorithm paper present number program transform overcom aforement difficulti tile make two main contribut ffl defin class nontrivi imperfectlynest loop present algorithm legal profit tile separ loop perfectlynest timestep loop case jacobi tempor reus thu exploit across differ time step ffl present scheme permit tile loop prematur exit specul execut iter timestep loop exit condit test iter rollback statement insert insur correct program result case exit condit turn true techniqu introduc paper particularli suitabl iter stencil comput matrix element updat base valu neighbor element comput often perform solv partial differenti equat geometr model imag process ing data depend inform requir autom propos techniqu gather exist compil analys implement propos techniqu within panorama compil order evalu effect appli techniqu one wellknown numer comput kernel jacobi two applic program tomcatv swim industri spec95 benchmark 20 overal program transform improv execut speed 9 164 sgi sequenti workstat statement statement end statement 3 end statement end end transform b transform figur 1 trivial imperfect loop nest transform perfect loop nest paper consid uniprocessor comput memori hierarchi includ cach memori one level assum one cach larg enough store small number column consid array whole array secondari cach typic modern workstat satisfi assumpt techniqu introduc paper aim improv data reus cach rest paper organ follow section 2 defin class imperfectlynest loop present tile scheme legal tile loop also present criteria determin whether tile scheme profit discuss techniqu improv profit tile scheme loop preprocess section 3 present scheme specul execut allow tile timestep loop contain prematur exit section 4 present experiment result discuss relat work section 5 conclud section 6 tile imperfectlynest loop section first use jacobi exampl give basic idea tile scheme imperfectli nest loop defin class loop handl scheme present scheme legal tile imperfectlynest loop criteria determin whether tile end end end end end jocobi kernel code b stencil illustr jacobi code j2 j2 j2 j2 j2 j2 flow depend backward direct along j1 j2 flow depend straight forward direct along j1 j2 antidepend backward direct along j1 j2 antidepend straight forward direct along j1 j2 output depend backward direct along j1 j2 output depend straight forward direct along j1 j2 c iter subspac depend figur 2 code comput stencil depend iter subspac jacobi kernel profit discuss techniqu improv profit tile scheme addit loop transform analyz complex compil algorithm briefli discuss extens 21 basic idea iter numer algorithm array element usual access repeatedli differ time step number array element larg cach overflow requir array element fetch repeatedli cach everi time step use loop tile work time step finish execut move next time step oper array element recent refer enc avoid cach overflow unfinish time step continu later moment consid jacobi kernel shown figur 2a converg test remov simplifi illustr plot iter subspac j1 j2 loop shown figur 2c within iter complet execut j1 j2 loop requir access nearli 2 theta n gamma 1 2 distinct array element suffici larg n cach overflow result cach miss next itera tion avoid overflow partit iter subspac tile mark staircas line figur 2c execut order topleft bottomright properli chosen tile size make number memori locat access tile fit cach reorder execut sequenc legal satisfi origin data depend figur 2b show jacobi comput stencil figur 2c show subset data depend edg iter point indic flow anti output depend adopt valuebas definit flow depend 25 flow depend exist statement s1 statement s2 latter may use valu written former adopt tradit definit anti output depend 11 antidepend exist s1 s2 former read memori locat overwritten latter output depend exist s1 s2 s2 may overwrit memori written s1 one similarli defin depend two variabl refer two loop iter two program segment 25 key scheme tile imperfectlynest loop find uniform tile slope flow depend carri satisfi find offset tile inner loop flow depend within also satisfi tile shape result guarante flow depend exist laterexecut tile earlierexecut tile anti output depend exist laterexecut tile earlierexecut one elimin techniqu call oddeven duplic array unlik full array expan sion oddeven duplic unduli increas workingset size defeat local figur 2c edg node n1 n2 drawn solid j loop index valu n1 greater drawn dot otherwis j stand either j1 j2 solid edg affect legal tile shape one see solid flow depend edg within tile solid antidepend edg may cross two neighbor tile howev shown section 23 latter remov oddeven duplic exist solid output depend edg jacobi 22 class imperfectlynest loop gener program model present figur 3a loop bodi contain jloop 1 j loop may contain arbitrari program construct without loss gener loop assum step 1 requir loop j take form lower upper bound respect l u invari b nonneg known constant make present clean itmax assum even number requir read refer get valu either alway iter end end end modt 2eq1 end end end end end end program model b oddeven array duplic modt 2eq1 end end end end end end end c tile figur 3 step tile imperfect loop nest alway previou iter henc flow depend distanc either 0 1 loop level commonli true applic focu use iter algorithm exist compil techniqu array privat determin whether condit flow depend satisfi see 5 list refer jacobi code figur 2 read refer alway get valu previou iter except give distanc 1 read refer l alway get valu iter make distanc 0 figur 3a assum b alway get valu previou iter simplic exposit paper consid tile j loop 1 even though may contain inner loop techniqu propos howev extend includ loop within j loop briefli discuss section 26 tth iter potenti reus slope t1th iter loop ji loop ji figur 4 portion tile illustr reus 23 algorithm tile imperfect loop nest given loop nest program model goal transform form shown figur 3c term 23 jj call tile control loop j tile loop conv nienc call loop timestep loop j loop tile size nstep term figur 2c nstep number grid point tile j1j2 direct slope number grid point tile shift left tindex increas 1 figur 4 illustr two instanc loop j show shape portion tile potenti tempor reus across iter proport valu nstep gamma slope figur 5 show main step tile tech niqu rest subsect present compil algorithm implement step 231 construct subgraph minimum legal slope constrain data depend distanc exist extens studi problem comput data depend distanc pair array refer respect common enclos loop 25 distanc constant symbol analysi perform deriv bound distanc valu 3 16 7 current literatur depend distanc usual defin respect loop contain depend refer program model would appli loop slightli extend definit also includ j loop program model suppos exist depend iter 1 j 1 iter k say depend distanc vector specif say distanc respect j loop j 2 neg say exist backward depend wrt j exist work distancecomput cite readili use comput lower bound upper bound distanc defin refer differ j loop construct depend subgraph 11 loop nest node repres statement within one j loop edg repres flow anti output depend multipl edg may exist one node anoth edg mark ffl construct depend subgraph ffl calcul minimum slope ffl select maximum legal tile size test profit ffl perform array duplic ffl gener tile code figur 5 main step tile loop nest distanc vector dt dj dt distanc wrt dj lower bound estim possibl neg distanc wrt j loop dt valu group three class 0 1 valu greater 1 differenti differ dt valu greater 1 denot g1 equal recal program model flow depend distanc respect loop 0 1 henc possibl anti output depend distanc wrt j neg let dj 0 jacobi exampl figur 2 depend subgraph shown figur 6a s1 statement comput l s2 one comput easi illustr figur 6a draw one edg repres type data depend flow anti output one vertex anoth mark possibl depend distanc vector sinc loop iter must execut lexicograph order flow depend edg depend subgraph whose vertic must distanc vector 0 0 1 dj anti output depend edg must distanc vector 0 0 1 dj g1 dj group anti output depend edg sourc target dj valu delet one edg minimum dt valu tile shape determin remain depend edg also satisfi delet one furthermor condens node depend subgraph belong j loop singl node result new graph defin simplifi graph filter depend inform unimport tile scheme thu improv effici graph travers techniqu definit 2 jloop distanc subgraph g l graph deriv depend subgraph gd given loop nest conform program model 1 node j g l repres j loop given loop nest 2 flow depend edg gd distanc vector dt dj n1 loop j i1 n2 loop j i2 j i1 j i2 differ node g l add edg g l j i1 j i2 distanc vector dt dj otherwis j i1 j i2 dt j2 b antidepend flow depend depend figur depend jloop distanc subgraph jacobi equal 1 add edg j i1 j i2 distanc vector dt dj 3 everi two node n1 gd exist anti depend n1 n1 loop j i1 n2 loop j i2 consid antidepend edg n1 group antidepend edg edg belong group dj valu b group take minimum dt valu denot mindt add edg j i1 j i2 distanc vector mindt 4 process output depend gd way step 3note step 3b g l instead mindt dj although treatment potenti produc overconserv tile shape expect case jacobi depend distanc subgraph figur 6a jloop distanc subgraph deriv shown figur 6b 232 calcul minimum slope follow algorithm perform loop tile base jloop distanc subgraph first algorithm comput minimum legal tile slope slope offset j loop bound within tile algorithm 1 comput minimum legal tile slope offset input loop nest conform program model jloop distanc subgraph g l output slope minimum legal slope tile offset node g l procedur ffl step comput offset everi node g l 1 temporarili remov anti output depend edg edg 1 2 node g l without successor 3 node g l assign offset valu go 6 otherwis continu 4 4 find node u g l whose successor assign offset valu edg annot 5 go back 3 6 put edg remov step a1 back g l offsetuju v node g l flow depend edg 1 gfor jacobi code figur 2a step a1 exist one edg j1 j2 distanc vector 0 0 initi offsetj2 0 offsetj1 mean need adjust loop bound either j1 j2 within iter step b sinc exist two flow depend edg j2 j1 233 select tile size definit 3 defin wsetx maximum work set size singl iter transform code figur 3c singl iter transform code loop bound j depend combin jj wsetx take maximum work set produc jjt combin sinc code yet transform compil stage estim wsetx memcount repres number differ memori locat access x iter loop j estim give upperbound wsetx memcount estim array data flow analysi merg array region access j loop bodi 5 next determin size tile object maxim tile size order maxim data reus within tile prevent anti output depend cross backward one tile boundari tile wide work set size exce effect cach size 22 algorithm 2 profit test tile size deter minat input loop nest conform program model jloop distanc subgraph g l slope valu comput algorithm 1 given cach size cs ff effectivecach factor 1 22 output tile size nstep tile profit logic valu profit procedur 1 hold 1 go step 2 otherwis return procedur 2 comput goto step 3 3 nstep slope return procedur otherwis goto step 4 4 let ju v node g l u v anti output depend edg node g l u v anti output depend edg 1g nstep otherwis guarante overlap iter point least one j loop adjac iter ie hold least one j loop step 2 guarante work set fit effect cach accord figur 4 make nstep larg enough allow potenti tempor reus across iter step 4 prevent anti output depend cross backward one tile boundari jacobi jloop distanc subgraph figur 6b exist two anti depend edg respect recal offsetj1 exist antidepend edg two output depend edg 234 array duplic next algorithm determin whether particular anti output depend need remov duplic algorithm 3 oddeven duplic input loop nest conform program model jloop distanc subgraph g l data flow upwardexposur inform output loop nest oddeven array duplic insert shown figur 3b procedur theta cs call effect cach size determin variou system factor recommend comput vendor base empir local measur chose experi ffl step everi anti output depend distanc vector check see whether need oddeven array dupli cation procedur return otherwis continu step b ffl step b duplic loop bodi insert ifstat one copi loop bodi becom branch copi els branch branch execut odd iter els branch even iter respect ffl step c anti output depend distanc vector condit b step hold identifi array say contribut depend declar copi ffl step assum origin array c new copi write refer branch chang referenc array name c read refer valu odd iter chang c ffl step e insert proper initi statement new copi array region initi newli declar array upwardlyexpos entri second iterationin worst case array could duplic jacobi jloop distanc subgraph figur 6b antidepend j1 j2 make necessari duplic array region upwardli expos entri second iter initi valu copi duplic 235 tile code gener base calcul slope nstep offset loop transform perform algorithm 3 follow algorithm calcul loop bound tile j loop modifi loop new jj loop figur 3c also form loop bodi tile j loop algorithm 4 tile code gener input 1 jloop distanc subgraph g l 2 slope calcul algorithm 1 nstep calcul algorithm 2 3 loop nest updat algorithm 3 form shown figur 3b output tile loop nest procedur end end end end figur 7 tile j loop ffl everi j loop whose current loop bound respect replac whole loop bodi code segment shown figur 7b offsetj repres origin j loop bodi except loop index variabl j replac k bodyk offsetj loop bodi replac code segment shown figur 7a ffl lower bound jj loop tile loop nest mg upper bound jj loop mg lower bound new loop maxmin fd upper bound new loop c itmaxth proof correct algorithm 4 sketch appendix figur 8 show jacobi code transform algorithm 4 note sinc offsetj1 loop bodi figur 7a appli loop im prove shown figur 9 loop fusion 14 25 forward substitut 2 assum array l dead exit whole loop nest improv known techniqu discuss detail paper 24 techniqu improv profit number compil techniqu appli given loop nest shorten backward depend distanc wrt j loop henc increas profit present two algorithm paper first one deal problem incompat j loop take exampl figur 10a exist flow depend j2 j1 henc 1 say loop j1 j2 incompat indic appear differ dimens array hand say loop j1 i2 compat end end modt 2eq1 end end end end end end end end end end end figur 8 jacobi kernel transform tile oddeven duplic modt 2eq1 end end end end end end figur 9 tile jacobi kernel improv simpl loop fusion forward substitut indic appear array dimens loop j2 i2 permut shown figur 10b flow depend i2 j1 distanc vector 1 0 make loop nest profit tile similarli loop i1 said compat loop j2 loop i1 loop j1 permut shown figur 10c howev cachelin spatial local suffer due columnmajor memori alloc array need transpos 1 8 order restor spatial local formal definit compat given definit 4 program model figur 3a suppos j loop contain inner loop i1 i2 perfectli nest within j outmost one innermost one denot j i0 compat set 1tupl 1 c nonneg integ c appear dimens ardo end end end end end end end end end end end end end end end b c figur 10 exampl illustr compat set ray 3 type equal row column indic appear first second dimens call compat set rowcompat column compat set respect 2dimension array rowassoci columnassoci row compat columncompat set least one loop index variabl ic set appear first second dimens refer 2 follow algorithm check see combin array transpos 1 8 loop permut 25 produc loop nest profit tile although exist exponenti number possibl combin permut j loop array transpos small number need consid practic algorithm 5 loop permut array transpos improv profit input 1 loop nest lp conform program model 2 comset compat set lp 3 boolean array outmost allow 1 array perm1 mg outmost allow uv indic whether loop iuv becom outmost loop within loop legal permut outmost allow legal permut vector output transform loop nest algorithm succe restor origin loop nest algorithm abort procedur profit permut unlik exist element cs c1 array transpos array rowassoci cs outmost allow ic perform permut specifi permic appli algorithm return transform loop nest undo permut array transpos perform end abort 2 jacobi code figur 2a two compat set 0 0 column 1 1 row figur 10a compat set 01column call permut loop i2 loop j2 outmost allow 21 true compat set 10row call transpos array permut i1 j1 outmost allowed11 true next show known loop transform call circular loop skew 25 use enhanc profit tile techniqu exampl suppos code skeleton figur 11a wrap around comput stencil typic pde circular boundari condit iter subspac shown figur 11b assum within time step 1 jth iter loop j2 flowdepend j gamma 1th jth j iter j1 first iter loop j2 flowdepend first second last iter j1 3 last iter loop j2 flowdepend n gamma 1th nth first iter j1 assum flow depend j2 j1 distanc vector j loop free loopcarri depend reduc slope 1 follow chang j2 iter order 1 2 also chang j1 iter order 1 2 transform elimin backward depend result follow algorithm formal circular loop skew cl techniqu profit enhanc circularli skew bound everi j loop shorten backward distanc call procedur find cl paramet elimin backward depend whose distanc less given loop nest lp find cl paramet return ffi skew amount everi j loop adjac iter also mark fi 1 node j jloop distanc subgraph g l fi initi skew amount j algorithm 6 circular loop skew shorten backward depend input loop nest lp conform program model except j loop index form l u invari jloop distanc subgraph g l real cach size cs effect cach size factor ff everi loop assum free loopcarri depend output transform loop nest success procedur calcul csg end end end j2 j2 end end end j2 j2 b c figur 11 sampl exampl transform algorithm origin loop nest skeleton b simplifi iter space graph transform c transform loop nest skeleton simplifi iter space graph transform code procedur find cl paramet present appendix b j loop assum lower upper loop bound j l u respect chang loop bound assign j begin j loop bodi end appli algorithm 2 transform loop nest return transform loop nest els abort figur 11c show transform code figur 11a appli algorithm 6 figur 11d show correspond iter subspac suppos procedur find cl paramet perform follow 1 initi remov edg l 3 j1 sinc predecessor noth 4 j2 increment fi 2 1 backward depend distanc restor edg back g l 6 process edg 25 complex analysi construct jloop distanc subgraph requir inform array dataflow depend distanc worst case requir exponenti time comput howev practic inform obtain effici implement scheme see 5 25 list refer algorithm 2 domin workingset comput requir array region union oper oper simpler construct jloop distanc subgraph given jloop distanc subgraph g l v e algorithm 1 take ojv algorithm 3 find array duplic need ojv time renam refer take time proport loop bodi size algorithm 4 take time multipli loop bodi size algorithm 5 theoret take loop bodi size small practic algorithm 6 procedur find cl paramet worstcas time ojv jjej 2 26 discuss techniqu extend tile inner loop within j loop take one loop level j exampl extens j loop perfectli nest inner loop lower bound upper bound u 0 invari j invari c known nonneg constant follow chang made previou definit algorithm need extend distanc vector tripl dt dj di instead pair dt dj definit 2 extend edg g l mark new distanc vector algorithm 1 comput slopej slopei j loop loop respect also need annot g l offset j offset j loop respect algorithm 2 comput nstepj nstepi j loop respect definit 3 extend defin wsetxi x nstepj nstepi new algorithm 2 check see whether wsetnstepj fnstep g true increas nstepj max fx j wsetx nstepi ff csg ffl algorithm 3 duplic condit b true either j algorithm 4 need gener correct loop bound ii addit jj j 3 tile specul execut numer program use iter method often exist converg test may caus maximum iter count reach enabl tile algorithm present present algorithm partit maximum iter count end end goto next end end next extend program model chunk plu exit condit iter end end next b code iter chunk initi b execut tile chunk econdeqtru go rollback copi aor odd copi c backup copi b accumeqitmax goto next end end go next roolback restor backup copi b execut origin loop nest figur 12a next c tile specul code figur 12 tile specul execut chunk exit condit test execut chunk iter instead one iter tile individu chunk case overshoot iter execut roll back specul code statement must insert guard potenti except overflow dividedbyzero possibl except detect execut roll back latest checkpoint model defin section 22 henc extend includ loop exit test shown figur 12a exit condit refer variabl defin either within iter outsid loop sourc carri flow depend follow algorithm implement idea algorithm 7 tile specul execut input loop nest conform program model shown figur 12a output tile loop nest procedur ffl step estim chunk size lmax ffl step b block loop figur 12a chunk size lmax shown figur 12b ffl step c tile chunk use algorithm 4 ffl step transform loop nest one shown figur 12c array referenc exit condit renam similar renam algorithm 3in transform code everi array sourc carri flow depend creat backup copi b ident copi initi variabl accum accumul total iter execut far everi iter outmost loop execut tile program lmax step condit rollback check execut must rollback valu store b restor comput resum begin accum1th iter latest checkpoint otherwis odd copi c copi backup copi b execut reach itmaxth iter outmost loop termin tradeoff overshoot cost checkpoint overhead perform gain tile reason follow let origin execut time per time step let flmax speedup per time step due tile account checkpoint overhead amort lmax time step assum origin take step converg sinc incur penalti lmax iter rollback occur tile specul gain perform total current use formula e equal estim time step per tile given tile size nstep futur work one certainli experi formula instanc lmax may vari distinct comput stage section 4 see gain cach tempor reus outweigh loss due checkpoint overshoot 4 experiment evalu implement techniqu panorama compil 5 appli algorithm one wellknown numer kernel jacobi converg test two spec95 benchmark tomcatv swim run two sgi uniprocessor workstat one base mip r5k processor base mip r10k r5k processor 32kb 2way data cach 512kb 2way unifi l2 cach r10k processor also 32kb 2way l1 data cach 2mb 2way unifi l2 cach moreov mip r10k perform outoford instruct ex ecut provid data prefetch instruct permit multipl pend cach miss nativ compil mipspro f77 compil experi origin code peelandfus code turn o3 switch enabl number loop transform includ interchang fusion fission tile code gener techniqu o2 o3 deliv nearli perform show o2 result origin tomcatv swim program fail profit test appli algorithm 5 6 two program take gener step shown figur 5 algorithm 5 find tomcatv made profit tile loop permut array transpos algorithm 6 find swim made profit circular loop skew algorithm 7 appli jacobi tomcatv swim program exit condit timestep loop jacobi code also optim forward substitut figur 9 jacobi program fix itmax 100 vari input matrix size arbitrarili base algorithm 2 nstep deriv 10 9 7 respect 1279 r5kbase workstat matrix size r10kbase workstat nstep deriv 44 37 30 respect tabl 1 show perform result origin program peelandfus program tile algorithm 4 mark tile w array dup although base tile techniqu array dupli cate shown figur 8 array l elimin forward substitut figur 9 give increas memori usag peelandfus scheme manual appli method present lrw 12 tss 6 choos tile size real cach size effect cach size 22 best four scheme give shortest execut time chosen evalu peelandfus tabl 1 tile oddeven duplic alway perform better peel andfus improv perform 70 84 r5k 159 164 r10k origin code tomcatv program among 7 nbyn array tomcatv two array duplic increas memori usag 29 nstep equal 5 21 r5k r10kbase workstat respect refer input data tomcatv alway run maximum time step ie 750 order measur potenti overhead rollback alter converg test trigger rollback comparison differ converg test result differ number iter execut untransform transform program execut time differ version tomcatv r5k shown tabl 2 iter orig mean number tabl 2 execut time second tomcatv r5k variou converg test iter orig itertran exec time orig time speedup 43 199 204 175 207 118 731 736 593 717 128 tabl 3 execut timein second swim test exec time speedup exec time speedup orig prog 32685 100 625 100 tran prog 21501 152 573 109 iter execut untransform code iter tran mean number iter execut transform code roll back chunk size lmax 5 base heurist rollback happen alway incur penalti lmax iter howev except case converg fast still get steadi speedup 128 rollback loop bound 750 reach speedup 169 r10k origin program execut 366 second transform program take 288 second speedup 127 converg test alter perform comparison similar r5k also run tomcatv peelandfus transform code take 649 306 second r5k r10k achiev speedup 113 119 respect origin program swim program duplic swim nstep equal 5 22 r5k r10k respect perform result shown tabl 3 orig prog stand origin program tran prog repres transform program r5k smaller l2 cach therefor smaller result less overlap iter point adjac iter within tile thu yield lower speedup peelandfus appli directli swim due long backward depend distanc r10k addit execut time also measur secondari cach miss use perfex librari base r10k perform counter tabl 4 show result ls stand number dynam loadstor instruct sm number miss secondari cach mr secondari cach miss ratio jacobi even checkpoint number dynam loadstor instruct reduc due forward substitut tabl 1 execut time second differ version jacobi differ scheme matrix size r5k matrix size r10k origin time 46 68 102 2443 4465 5293 peelandfus time 37 50 82 1708 2723 3576 tile w array dup time 25 38 believ differ number loadstor instruct origin code peelandfus code due slightli memori optim opportun nativ compil peelandfus tomcatv number loadstor instruct increas techniqu due period checkpoint swim ad number loadstor instruct expans array make program conform program model five case secondari cach miss rate dramat reduc gain tempor local across iter overcom loss memori instruct thu improv overal perform experi appli intervari pad similar scheme 18 tile swim pad reduc cach set conflict henc improv speedup 108 152 also appli intervari pad three origin program without notic perform gain cach overflow origin program domin perform 5 relat work kodukula et al propos data shackl 9 block array base data flow analysi form new loop nest comput block block although tackl certain imperfectlynest loop method appli stencil comput handl work updat one block destroy boundari data necessari adjac block manjikian et al present peelandfus 13 method partial fuse adjac loop within loop tile fuse loop exploit local within loop iter algorithm 1 bear similar peelfactor comput consid depend within iter consid depend across iter kodukula pingali propos matrixbas framework repres transform imperfectlynest loop 10 includ permut revers skew scale align distribut jam work appli tile strout et al discuss minimum storag requir allow flexibl loop schedul tile 21 method deal imperfectli nest loop handl work collard propos method specul execut whileloop parallel machin 4 object increas parallel process util tile loop better memori perform uniprocessor use quit differ algorithm pugh et al present method handl exit condit iter applic parallel environ 17 work collard pugh et al present interest idea handl loop exit condi tion may incorpor futur work mccalpin wonnacott develop scheme call time skew adopt valuebas flow analysi optim memori local 15 method first perform full array expans forward sub stitut recompress expand array preserv data depend method handl subset imperfectlynest loop repres program model 6 conclus futur work paper present new techniqu tile nontrivi imperfectlynest loop handl class imperfectlynest loop seem quit gener scientif comput develop two algorithm shorten backward depend distanc improv profit also extend program model handl exit condit common iter algorithm implement techniqu fortran sourcetosourc compil panorama 5 preliminari experiment result show transform program run faster 9 164 optim nativ compil work open sever interest subject futur work import one includ applic idea specul execut localityenhanc techniqu studi effect aggress localityenhanc algorithm effect cach size acknowledg thank chauwen tseng care review paper final r data comput transform multiprocessor compil transform highperform comput ing symbol rang propa gation experi effici array data flow analysi array privat tile size select use cach organ data layout symbol depend analysi high perform parallel compil matrixbas approach global local optim problem transform imperfectli nest loop structur comput comput cach perform optim block algorithm fusion loop parallel local improv data local loop transform time skew valuebas approach optim memori local iti practic algorithm exact array depend analysi exploit monoton converg function parallel program elimin conflict miss high perform architectur standard perform evalu corpor combin loop transform consid cach schedul improv local parallel nest loop data local optim algorithm high perform compil parallel comput tr cach perform optim block algorithm data local optim algorithm practic algorithm exact array depend analysi improv local parallel nest loop instructionlevel parallel process compil transform highperform comput tile size select use cach organ data layout improv data local loop transform exploit monoton converg function parallel program combin loop transform consid cach schedul fusion loop parallel local multilevel block experi effici array data flow analysi array privat elimin conflict miss high perform architectur scheduleindepend storag map loop transform imperfectli nest loop structur comput comput symbol rang propag matrixbas approach global local optim problem ctr claudia leopold optim tempor local stencil code proceed 2002 acm symposium appli comput march 1114 2002 madrid spain nawaaz ahm nikolay mateev keshav pingali synthes transform local enhanc imperfectlynest loop nest intern journal parallel program v29 n5 p493544 octob 2001 shoaib kamil kaushik datta samuel william leonid olik john shalf katherin yelick implicit explicit optim stencil comput proceed 2006 workshop memori system perform correct octob 2222 2006 san jose california david wonnacott achiev scalabl local time skew intern journal parallel program v30 n3 p181221 june 2002 roger espasa federico ardanaz joel emer stephen felix julio gago roger gramunt isaac hernandez toni juan geoff lowney matthew mattina andr seznec tarantula vector extens alpha architectur acm sigarch comput architectur news v30 n2 may 2002 guohua jin john mellorcrummey experi tune smg98 semicoarsen multigrid benchmark base hypr librari proceed 16th intern confer supercomput june 2226 2002 new york new york usa jingl xue wentong cai timeminim tile rise larger zero parallel comput v28 n6 p915939 june 2002 j hu kandemir n vijaykrishnan j irwin analyz data reus cach reconfigur acm transact embed comput system tec v4 n4 p851876 novemb 2005 guohua jin john mellorcrummey robert fowler increas tempor local skew recurs block proceed 2001 acmiee confer supercomput cdrom p4343 novemb 1016 2001 denver colorado steve carr soner nder case workingsetbas memori hierarchi proceed 2nd confer comput frontier may 0406 2005 ischia itali nawaaz ahm nikolay mateev keshav pingali synthes transform local enhanc imperfectlynest loop nest proceed 14th intern confer supercomput p141152 may 0811 2000 santa fe new mexico unit state indupraka kodukula keshav pingali datacentr transform local enhanc intern journal parallel program v29 n3 p319364 june 2001 nawaaz ahm nikolay mateev keshav pingali tile imperfectlynest loop nest proceed 2000 acmiee confer supercomput cdrom p31e novemb 0410 2000 dalla texa unit state gabriel rivera chauwen tseng local optim multilevel cach proceed 1999 acmiee confer supercomput cdrom p2e novemb 1419 1999 portland oregon unit state qing yi vikram adv ken kennedi transform loop recurs multilevel memori hierarchi acm sigplan notic v35 n5 p169181 may 2000 naraig manjikian tarek abdelrahman exploit wavefront parallel largescal sharedmemori multiprocessor ieee transact parallel distribut system v12 n3 p259271 march 2001 yonghong song rong xu cheng wang zhiyuan li data local enhanc memori reduct proceed 15th intern confer supercomput p5064 june 2001 sorrento itali kristof beyl erik h dholland intermedi execut code key find refactor improv tempor data local proceed 3rd confer comput frontier may 0305 2006 ischia itali ya kalinov l lastovetski n ledovskikh posypkin compil vector statement c languag architectur multilevel memori hierarchi program comput softwar v27 n3 p111122 mayjun 2001 sriram krishnamoorthi muthu baskaran uday bondhugula j ramanujam atana rountev p sadayappan effect automat parallel stencil comput acm sigplan notic v42 n6 june 2007 jonathan weinberg michael mccracken erich strohmaier allan snave quantifi local memori access pattern hpc applic proceed 2005 acmiee confer supercomput p50 novemb 1218 2005 gabriel rivera chauwen tseng tile optim 3d scientif comput proceed 2000 acmiee confer supercomput cdrom p32e novemb 0410 2000 dalla texa unit state charli hu alan cox willi zwaenepoel improv finegrain irregular sharedmemori benchmark data reorder proceed 2000 acmiee confer supercomput cdrom p33e novemb 0410 2000 dalla texa unit state michel mill strout larri carter jeann ferrant barbara kreaseck spars tile stationari iter method intern journal high perform comput applic v18 n1 p95113 februari 2004 chunghs hsu ulrich kremer quantit analysi tile size select algorithm journal supercomput v27 n3 p279294 march 2004 martha mercaldi steven swanson andrew petersen andrew putnam andrew schwerin mark oskin susan j egger instruct schedul tile dataflow architectur acm sigop oper system review v40 n5 decemb 2006 karin hgstedt larri carter jeann ferrant parallel execut time tile loop ieee transact parallel distribut system v14 n3 p307321 march venkata k pingali salli mckee wilson c hseih john b carter comput regroup restructur program tempor data cach local proceed 16th intern confer supercomput june 2226 2002 new york new york usa chen ding maksim orlovich potenti comput regroup improv local proceed 2004 acmiee confer supercomput p13 novemb 0612 2004 swarup kumar sahoo sriram krishnamoorthi rajkiran panuganti p sadayappan integr loop optim data local enhanc tensor contract express proceed 2005 acmiee confer supercomput p13 novemb 1218 2005 venkata k pingali salli mckee wilson c hsieh john b carter restructur comput tempor data cach local intern journal parallel program v31 n4 p305338 august abdelhame badawi aneesh aggarw donald yeung chauwen tseng evalu impact memori system perform softwar prefetch local optim proceed 15th intern confer supercomput p486500 june 2001 sorrento itali cociorva j w wilkin c lam g baumgartn j ramanujam p sadayappan loop optim class memoryconstrain comput proceed 15th intern confer supercomput p103113 june 2001 sorrento itali jingl xue xavier vera effici accur analyt model wholeprogram data cach behavior ieee transact comput v53 n5 p547566 may 2004 sandhya krishnan sriram krishnamoorthi gerald baumgartn chichung lam j ramanujam p sadayappan venkatesh choppella effici synthesi outofcor algorithm use nonlinear optim solver journal parallel distribut comput v66 n5 p659673 may 2006 zhiyuan li yonghong song automat tile iter stencil loop acm transact program languag system topla v26 n6 p9751028 novemb 2004 chen ding ken kennedi improv effect bandwidth compil enhanc global cach reus journal parallel distribut comput v64 n1 p108134 januari 2004