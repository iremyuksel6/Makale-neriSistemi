local failur distribut synchron abstractth faulttoler distribut algorithm investig asynchron messag pass system undetect process failur two specif synchron problem consid dine philosoph problem binari committe coordin problem abstract bound doorway introduc gener mechan achiev individu progress good failur local use build block optim faulttoler algorithm construct two problem b introduct abil toler failur import design requir comput system gener distribut system particular detect failur becom difficult system investig effect failur distribut synchron problem requir cooper set independ process specif problem studi assum underli undirect graph defin neighborhood process interprocess commun messagepass possibl neighbor process goal design solut effect failur process confin immedi neighborhood word interest solut process shield effect nonloc failur assum failstop model failur undetect fail process indistinguish process slow choos problem dine philosoph committe coordin repres class distribut synchron problem dine philosoph problem gener mutual exclus problem use solv mani synchron problem committe coordin problem occur languag csp 4 ada 1 base synchron messag commun use failur local 6 measur degre fault toler failur local algorithm denot size neighborhood get affect failur thu algorithm failur local process failur within distanc underli graph execut failur occur word process continu meet specifi safeti progress properti main contribut paper present tight lower bound failur local solut dine philosoph committe coordin problem achiev present lower bound design solut achiev part optim algorithm also introduc idea bound doorway doorway interest properti coupl algorithm ensur absenc global starvat doorway ensur absenc local starvat without ad failur local algorithm contrast kind doorway 6 13 add failur local underli algorithm rest paper organ follow section 2 present relev back ground section 3 introduc idea bound doorway section 4 solv dine philosoph problem optim failur local section 5 solv committe coordin problem optim failur local brief discuss appear section 6 appendix contain proof theorem use main bodi paper relev background local distribut comput studi mani author 2 14 19 20 linial 14 consid problem comput function requir global commun comput function process start local data comput inform exchang neighbor process final process termin return valu function said comput local 2 comput time less diamet network function includ find maxim independ set 2 11 14 15 comput node edg color network 2 10 paper investig local distribut synchron problem requir process termin return result particular concentr dine philosoph problem 8 16 committe coordin problem 5 dine philosoph problem consist set process set resourc model conflict graph process map node conflict graph resourc map edg mani solut dine philosoph problem appear literatur 3 5 6 16 20 styer peterson 20 perhap first consid issu local problem measur local algorithm length longest wait chain process may form system formal idea wait chain notion failur local dine philosoph problem failur local algorithm defin smallest number process failur within distanc conflict graph free starvat algorithm obtain styer peterson achiev failur local 3 recent consid problem achiev good failur local conjunct problem achiev good respons time good messag complex 6 present solut achiev failur local 4 maintain quadrat degre conflict graph respons time quadrat messag complex paper also contain algorithm achiev failur local 3 howev question best achiev failur local remain open committe coordin problem consist set interact committe set process problem initi aros rendezvousbas commun languag like csp ada 1 4 subset process need exchang inform synchron manner conflict graph construct problem map interact node place edg interact share common process concentr binari version problem everi interact two member binari gener version problem solv mani research 4 5 6 12 18 19 sistla 19 call solut problem real time complex independ size commun network also investig format wait chain use deriv lower bound respons time defin failur local solut committe coordin problem smallest number continu readi interact failur within distanc conflict graph eventu commit recent present solut committe coordin problem failur local 2 6 question optim failur local remain open 3 bound doorway solut problem requir absenc local starvat often compos two part 6 13 20 first part satisfi requir problem except ensur absenc global starvat ie deadlock second part solut usual call doorway translat absenc global starvat underli solut absenc local starvat ie progress respect process composit solut word doorway take program f ensur absenc global starvat produc composit program consist f local starvat occur variou kind doorway defin use literatur basic kind call firstcomefirstserv doorway defin use lamport 13 context mutual exclus problem doorway consist finit sequenc nonwait statement enforc firstcomefirstserv behavior though use share variabl system doorway use messag base system doorway would consist wait statement order enforc firstcomefirstserv behavior variant doorway use styer peterson solv dine philosoph problem messag base model similar 20 scheme neighbor process execut p oper common semaphor implement pass messag enter doorway v oper exit doorway two kind doorway call singl doorway doubl doorway introduc 6 order avoid unbound overtak doorway requir process outsid doorway wait process insid doorway increas failur local composit solut least one paper introduc new kind doorway increas failur local underli comput doorway refer bound doorway implement dynam assign set distinct id process id distinct use resolv conflict occur execut algorithm assum underli solut resolv conflict favor process smaller id doorway algorithm process made progress select neighbor higher id perform id exchang exchang result neighbor smaller id ie higher prioriti id exchang involv send exchg messag select neighbor wait acknowledg return broadcast new id process process receiv exchg messag agre exchang id lead smaller id process current particip anoth exchang process maintain queue neighbor choos candid process id exchang scan queue process higher id exchang need neighbor lower id order ensur fair process chosen place end queue exchang id thu process make progress infinit often neighbor starv eventu higher id consequ lower prioriti neighbor allow neighbor make progress avoid starvat 4 dine philosoph problem 41 problem descript problem consist number process may one three state think hungri eat predic think denot process think predic hungri eat defin similarli initi everi process think think process becom hungri need access resourc adjoin edg process stay hungri allow eat dine philosoph algorithm process access resourc eat period assum finit eat process transit think state dine philosoph algorithm satisfi two requir mutual exclus requir neighbor process eat time starvat requir everi hungri process eventu get chanc eat process may fail time comput failur process model auxiliari predic fail predic initi fals set true failur process true remain true forev assum failstop mode failur failur process undetect particular impli predic fail use code algorithm predic howev use proof correct state earlier measur faulttoler algorithm failur local formal failur local algorithm defin smallest number process failur within distanc conflict graph free starvat requir failur effect safeti properti mutual exclus algorithm exampl consid conflict graph 7 process shown figur 1 failur local algorithm 1 failur effect progress process outsid immedi neighborhood fail process word failur process 1 starv process 23 4 failur process 4 starv process 1235 6 algorithm failur local 2 failur process 1 starv process 7 viceversa figur 1 exampl conflict graph 42 imposs result easi see failur local 0 ie failur process starv process unachiev process may fail eat mean immedi neighbor unawar failur may starv follow theorem state failur local 1 also unachiev theorem 1 exist solut dine philosoph problem failur local 1 proof suppos exist solut failur local one consid problem instanc 3 process neighbor j k neighbor consid follow execut histori none process fail initi process think process becom hungri first sinc think process may remain think forev exist futur state start eat j k still think assum eat j k becom hungri possibl process undetect eat therefor order ensur failur local one process k allow eat thu exist futur state k eat j hungri suppos finish eat becom hungri argument exist futur state k remain eat j remain hungri start eat let process stop eat becom hungri lead us back state exist earlier histori process eat process j k hungri note process j remain hungri intermedi state scenario may repeat continu give us desir contradict process j remain hungri forev though none neighbor fail 2 initi main procedur ack process n order wait ack pend wait allfork allfork alllowfork releas releasehigh forev figur 2 algorithm process 43 optim algorithm construct optim algorithm failur local 2 algorithm consist two part bound doorway discuss section 3 scheme ensur mutual exclus absenc global starvat mutual exclus ensur associ fork edg maintain invari eat process neighbor fork order ensur absenc global starvat conflict request fork resolv favor process smaller id sinc may lead format long wait chain turn result poor failur local process break long chain select releas fork howev process smallest id releas fork ensur absenc global starvat id exchang mechan due bound doorway ensur continu hungri process eventu smaller id compet neighbor abl eat composit algorithm thu also ensur freedom local starvat algorithm shown figur 2 3 process set n defin neighbor given process j 2 n refer process j high neighbor process refer process low neighbor process j similarli fork process refer high fork process low fork process j process use number local variabl refer id process variabl id ij refer id process j known process boolean fork ij true iff fork process j process initi fork process smaller id presenc process insid bound doorway indic variabl ack variabl fals iff process execut code bound doorway ie exchang id neighbor queue q use order select next process receiv messag hrequesti j id ij pend receiv messag hrequesti j id ij pend releasehighfork fi receiv messag hfork flagi j request ij f lag pend alllowfork requesthighfork lag receiv messag hexchg idi j ack send hexchgy id j k 2 n send hnewid idi k od alllowfork hungri requesthighfork fi els send hexchgnoi j fi receiv messag hexchgy idi j k 2 n send hnewid idi k od ack true receiv messag hexchgnoi j ack true receiv messag hnewididi j procedur requestfork j 2 n send hrequest j request ij true fi od procedur requesthighfork j 2 n send hrequest j request ij true fi od procedur releasefork j 2 pend od releasefork procedur releasehighfork j 2 pend od releasehighfork procedur releaseid ack send hexchg id j fi procedur sendforkj pend pend send hfork truei j request ij true els send hfork falsei j fi figur 3 algorithm process continu exchang id initi ack true q set arbitrari order process n request ij true iff process sent outstand fork request process j set pend contain fork request yet servic process becom hungri attempt collect miss fork send request messag procedur requestfork neighbor process receiv request fork decid whether go releas fork request j depend state rel order id id ij fork releas process think collect low fork condit captur predic releasehigh fork releas along captur high fork order avoid format long wait chain process think collect fork condit captur predic releas note procedur sendfork process releas fork hungri inform request process set flag fork true fork releas request process id request save set pend futur consider recept fork complet collect low fork process request miss high fork made call procedur requesthighfork otherwis fork receiv high fork true flag fork return sender process gather fork transit eat state enter critic section upon exit critic section set state think releas fork pend execut bound doorway code ie procedur releaseid order exchang id procedur process first invok function next choos next process higher id queue q process exist id return move end queue otherwis special valu null return implement function straightforward shown function next return nonnul valu j ack set fals exchg messag sent process j upon receiv messag process j particip id exchang iff outsid doorway indic ack true id exchang lower id case process j send exchgy messag also inform neighbor new id otherwis process j respond exchgno messag process upon receiv posit acknowledg process j process complet id exchang process inform neighbor new id neg acknowledg receiv exchang carri either case ack set true next iter state transit begin 44 proof correct use tempor oper 2 3 17 follow proof briefli 2p mean formula p hold state histori begin current state 3p mean formula p hold futur state histori begin current state follow two lemma prove appendix lemma 1 nonfail process starv eventu everi neighbor j order id id j becom fix formal 22fail lemma 2 nonfail process starv eventu low neighbor j either fail remain noneat forev id ji 22fail fail j eat j construct wait graph w starv nonfail process follow process w ffl process j w appli lemma 2 add neighbor k w fail k hold ffl repeat process ad w inform graph w includ process starv nonfail process reachabl chain decreas id process w follow lemma prove appendix lemma 3 process j w low neighbor k j eventu fork j k either remain j forev remain k forev formal ii base lemma prove follow theorem failur local algorithm theorem 2 process starv fail process distanc 2 proof sake contradict assum process starv process within distanc 2 fail lemma 3 neighbor j process eventu either hold forev two case consid either eventu process hold low fork forev eventu process miss low fork forev former case process send request necessari high neighbor collect high fork sinc process fail eventu releas fork thu process eventu collect fork start eat contradict assumpt process starv second case let j low neighbor hold fork process forev sinc process j hold high fork must collect low fork consequ process j start collect miss high fork sinc process within distanc 2 fail process within distanc 1 j fail impli process j abl collect high fork start eat eventu process j finish eat releas fork process contradict assumpt fork share process j stay process j forev 2 5 committe coordin problem 51 problem descript problem consist set process set interact process predetermin set interact may particip interact predetermin set process cooper execut process may particip interact physic close commun directli process may one three state idl readi commit predic idl denot process idl predic readi commit defin similarli initi process idl time time process becom readi take part interact associ remain readi one interact commit similar process interact may also one three state idl readi commit interact readi execut process associ readi interact commit state process particip commit perform interact idl otherwis execut interact interact process associ interact state commit commit interact eventu termin point interact process becom idl say two interact conflict share common process base conflict relat interact defin conflict graph follow repres interact node place edg two node correspond interact conflict mention earlier state transit process occur order idl readi commit back idl state transit interact similar except fact interact may transit state idl directli state readi two neighbor interact may readi time commit one chang state idl time interact commit assum finit solut committe coordin problem satisfi two safeti requir synchron mutual exclus one progress requir weak interact fair synchron requir commit interact start readi mutual exclus requir two interact share common process commit simultan weak interact fair requir interact continu readi eventu commit dine philosoph problem process may fail time comput model auxiliari predic fail say interact fail process belong fail failur local algorithm defin smallest number interact long interact within distanc conflict graph fail requir weak interact fair satisfi failur impact requir synchron mutual exclus safeti properti 52 imposs result follow theorem show effect failur process limit interact particip theorem 3 exist solut committe coordin problem achiev failur local 0 proof proof reduct wellknown result imposs distribut consensu one faulti process 9 assum exist algorithm achiev failur local 0 word algorithm supposedli ensur long process interact readi fail interact one neighbor commit eventu use algorithm solv distribut consensu problem three process consensu problem everi process initi valu nonfail process agre common valu one initi valu case three process consid form three interact fi jg j fj kg k fk ig devis mechan commit interact eg impli consensu reach initi valu correspond process case everi process first broadcast initi valu process becom readi particip interact member requir synchron mutual exclus weak interact fair underli committe coordin algorithm commit exactli one interact j k process particip commit interact broadcast ident third process final process agre initi valu process correspond commit interact sinc process broadcast initi valu becom readi valu correspond commit interact avail process sinc one process fail least one interact readi commit assum failur local underli committe coordin algorithm least one interact commit therefor least one process abl broadcast ident commit interact result nonfail process agre common valu one initi valu 2 initi main procedur ack process n order wait ack pend wakeupneighbor wait commit hperform state releaseid forev figur 4 algorithm process 53 optim algorithm construct optim algorithm failur local 1 binari version problem dine philosoph problem use bound doorway process exchang id anoth piec code ensur two safeti properti global progress everi interact process smaller id design manag respons commit interact process may possibl manag sever interact base upon rel order id process process set n defin set process particip common interact process process becom readi attempt commit interact manag invok procedur requestcommit execut procedur process send request messag process j fi jg interact manag process process j receiv request repli ye messag readi sent ye messag anoth manag otherwis save set pend j local variabl set true iff process j sent ye messag manag upon receiv ye messag process j process commit interact fi jg provid still readi respond ye messag manag otherwis manag respond releas messag process j receiv releas messag process j inform neighbor manag retransmit request messag send wakeup messag process pend j receiv wakeup messag process j process tri commit correspond interact complet algorithm shown figur 4 5 local variabl id ack dine philosoph algorithm implement bound doorway ie procedur releaseid also previou solut receiv messag hrequesti j readi send hyesi j els pend receiv messag hyesi j send hcommiti j state els send hreleasei j fi request ij receiv messag hreleasei j wakeupneighbor requestcommit receiv messag hwakeupi j request ij readi send hrequesti j request ij true fi receiv messag hexchg idi j ack id send hexchgy id j k 2 n send hnewid idi ki od els send hexchgnoi j fi receiv messag hcommiti j state commit receiv messag hexchgy idi j k 2 n send hnewid idi ki od ack receiv messag hexchgno idi j ack receiv messag hnewididi j procedur requestcommit j 2 n bound send hrequesti j request ij true fi od requestcommit procedur wakeupneighbor j 2 pend send hwakeupi j od pend wakeupneighbor procedur releaseid ack send hexchg id j fi figur 5 algorithm process continu 54 proof correct follow two lemma prove manner similar lemma 1 lemma 2 lemma 4 nonfail process remain readi forev eventu everi neighbor j order id id j becom fix formal 22fail lemma 5 nonfail process remain readi forev eventu low neighbor either fail remain noncommit forev formal 22fail fail j construct wait graph w nonfail process readi forev follow process w ffl process j w appli lemma 5 add neighbor k w hold ffl repeat process ad w inform graph w includ process nonfail process readi forev reachabl chain decreas id process w follow lemma prove appendix lemma 6 process j w eventu bound j becom stabl formal base lemma prove follow theorem failur local algorithm theorem 4 interact remain readi forev either interact conflict fail proof sake contradict assum interact remain readi forev interact conflict fail let j two process lemma 4 assum without loss gener belong w lemma 6 eventu bound bound j becom fix bound j becom fix true sinc neighbor interact fail process j eventu send ye messag nonfail process process eventu respond commit releas messag former case process j becom nonreadi latter case bound j reset fals possibl assumpt therefor must case bound j fix fals eventu similarli shown bound fix fals eventu algorithm process j send request messag process time bound j reset fals consid request messag sent process j becom fix fals process respond messag either ye wakeup messag former case process j becom nonreadi latter case process j retransmit request messag former possibl process j remain continu readi therefor process j send request messag process infinit often sinc bound eventu fix fals process eventu respond ye messag thu commit interact contradict assumpt remain readi forev 2 6 conclud remark paper prove failur local one achiev dine philosoph problem imposs result essenti base absenc global inform total asynchron distribut system subsequ present algorithm optim failur local two algorithm base idea bound doorway process exchang id neighbor upon make progress consid committe coordin problem show failur local 0 unachiev problem proof base reduct problem distribut consensu final present optim algorithm binari version problem base idea bound doorway gener case committe coordin problem solv reduct dine philosoph problem 5 use optim algorithm present result solut committe coordin problem failur local two open question whether failur local one achiev problem r refer manual ada program languag network decomposit local distribut comput dine philosoph algorithm polynomi respons time effect implement gener inputoutput construct csp parallel program design foundat effici fault toler algorithm resourc alloc distribut system adapt algorithm mutual exclus problem hierarch order sequenti process imposs distribut consensu one faulti process parallel ffi fast parallel algorithm maxim independ set problem algorithm nparti synchron use token mutual exclus problem part ii distribut algorithm global solut local data simpl parallel algorithm maxim independ set problem fast alloc nearbi resourc distribut system cook tempor proof system pet languag new effici implement multiprocess synchron distribut algorithm ensur fair interprocess commun improv algorithm distribut resourc alloc tr ctr hagit attiya eyal dagan improv implement binari univers oper journal acm jacm v48 n5 p10131037 septemb 2001 yehuda afek michael merritt gadi taubenfeld dan touitou disentangl multiobject oper extend abstract proceed sixteenth annual acm symposium principl distribut comput p111120 august 2124 1997 santa barbara california unit state