industri strength theorem prover logic base common lisp abstractacl2 reimplement extend version boyer moor nqthm kaufmann pcnqthm intend larg scale verif project paper deal primarili scale nqthm logic industri strength program languagenam larg applic subset common lispwhil preserv use total function within logic make possibl run formal model effici keep logic simpl enumer mani import featur acl2 briefli summar two industri applic model motorola cap digit signal process chip proof correct kernel float point divis algorithm amd5k86 microprocessor advanc micro devic inc b introduct formal verif use mathemat techniqu verifi properti system descript work report perform author employ comput logic inc matt kaufmann motorola lakewood po box 6000 md f52 austin z j moor depart comput scienc univers texa austin austin receiv oct 25 1996 revis mar 31 1997 recommend accept c heitmey sr faulk inform obtain reprint articl pleas send email transsecomputerorg refer ieeec log number 1048920 particular style formal verif shown consider promis recent year use generalpurpos autom reason system model system prove properti everi reason system requir consider assist user make import system provid conveni way user interact one stateoftheart generalpurpos autom reason system acl2 comput logic applic common lisp number autom reason system exist discuss subsect 11 paper describ acl2 offer user conveni industrialstrength use begin section 2 histori acl2 project next section 3 describ logic support acl2 design conveni specif verif section 4 discuss guard connect acl2 effici execut common lisp provid power specif capabl illustr role guard section 5 section 6 discuss import featur acl2 section 7 present two industri applic conclud section 8 11 brief comparison theorem prover mention mani autom reason system besid acl2 ancestor although beyond scope paper survey field provid descript system say word order provid context work activ research continu autom reason number area incomplet list case give one two repres system certainli area contain consider overlap ffl prover provid strong support specif comput system see ffl ctl model checker 29 11 ffl geometri prover 13 ffl firstord prover 28 ffl classic mathemat 21 41 construct mathemat 15 16 ffl prover symbol comput engin 14 ffl metatheoret system 34 prover first categori distinguish conveni offer specifi comput system case could made prover first categori capabl categori convers prover categori could place one first categori may subdivid follow ffl higherord tacticbas prover eg hol 20 ffl higherord heavilyautom prover eg pv 18 ffl firstord heavilyautom prover eg acl2 nqthm ffl prover integr program verif system eg neverev 17 space permit detail comparison bill young paper 42 special issu compar pv acl2 particular exampl acl2 ancestr sy tem nqthm compar nuprl 3 extrem difficult compar two generalpurpos theorem prover least part experienc user dramat affect system behavior proper formul problem said system cite support logic power acl2 hand acl2 theorem prover encourag relianc user system automat aspect user happi essenti quantifierfre firstord logic believ acl2 offer overal conveni type reason requir model prove properti digit comput system addit sophist infer engin provid acl2 provid extrem effici evalu allow formal model often serv simul system describ turn provid immedi proofindepend payoff eg requir test code develop addit reason acl2 conveni broadli lump proof engin consider discuss section 6 see url httpwwwformalstanfordeducltar arsdbhtml data base autom reason system includ brief descript link home page system mention mani 2 histori acl2 direct descend boyermoor sy tem nqthm 8 9 interact enhanc pc nqthm 23 see 7 introduct two ancestr system includ reason larg set refer accomplish use system particular success describ 4 5 10 22 32 26 36 38 tutori introduct system may found 24 like nqthm acl2 support lisplik firstord quantifierfre mathemat logic base recurs defin total function experi earlier system support claim logic suffici express permit one address deep mathemat problem realist verif project fact nqthm logic execut also import asset use model hardwar softwar system model execut mean corrobor accuraci consid exampl 2 nqthm model mc68020 corrobor fabric chip run 30000 test vector nqthm model largest formal verif project done far carri nqthm cite explicitli cli short stack 4 design fabric fm9001 microprocessor 22 verif berkeley c string librari top mc68020 microprocessor 10 formal model project collect sever hundr page long involv mani function despit success nqthm design kind largescal project sever inadequaci import inadequaci nqthm lack theorem prove power would quickli settl everi question put one could proceed effici alway look better proof techniqu eg 33 know build significantli power automat theorem prover nqthm logic 2 therefor scale nqthm focus engin issu decid good first step would adopt logic applic subset commonli use program languag therebi gain access mani effici execut platform model written logic mani program develop ie model environ chose common lisp express effici familiar properli formul common lisp execut speed compar c three guid tenet acl2 project 1 conform compliant common lisp implement 2 add noth logic violat understand user input submit directli common lisp compil execut environ suitabl acl2specif macro function acl2 kernel defin 3 use acl2 implement languag acl2 system third tenet akin recod nqthm nqthm logic task believ would produc unaccept slow perform program acl2 system acl2 emphas word significantli acl2 theorem prover fact power nqthm mani way see section 6 repeatedli forc us extend subset could accept effici code sever iter system built current system consist 5 megabyt applic sourc code includ document first version system written summer fall 1989 boyer moor time went boyer involv decreas kaufmann increas eventu boyer decid longer consid coauthor acl2 use model verif project within comput logic inc cli sever year releas first public version acl2 septemb 1995 see url httpwwwclicom 3 acl2 logic definit common lisp use work 39 40 also close studi 35 acl2 logic firstord quantifierfre logic total recurs function provid mathemat induct ordin ffl 0 two extens principl one recurs definit one encapsul sketch logic 31 syntax syntax acl2 common lisp formal acl2 term either variabl symbol quot constant applic nari function symbol lambda express f n term written f 1 n illustr syntax primit constant formal syntax extend facil defin constant symbol macro 32 rule infer rule infer nqthm name proposit calculu equal togeth instanti mathemat induct ffl 0 two extens prin cipl recurs definit encapsul also pro vide discuss subsect 36 33 axiom primit data type follow primit data type axiomat ffl acl2 number number consist ration complex number ration compon exampl numer constant 5 227 ffl charact object acl2 support 256 distinct charact includ common lisp standard char acter charact constant newlin space ffl string acl2 support string charact eg string constant arithmet overflow ffl symbol common lisp provid sophist class object call symbol constant logic speak symbol constant object contain two string packag name constant packag mc68020 name exec written mc68020execbi con vention one packag alway select cur rent name need written thu mc68020 current packag symbol may simpli written exec packag may import symbol packag al though acl2 import must done time packag defin mc68020exec import stringlib packag stringlibexec fact symbol mc68020exec ffl list acl2 support arbitrari order pair acl2 object eg list constant x mc68020x hello 1 227 34 axiom defin primit function symbol essenti common lisp function data type axiomat defin function macro acl2 common lisp function mean program specifi 39 40 applic ii depend state implicit paramet data type acl2 iii complet specifi unambigu hostindepend manner approxim 170 function axiomat common lisp function partial defin possibl input acl2 function total roughli speak logic function given name acl2 complet common lisp function name obtain ad arbitrari natur valu argument outsid intend domain common lisp function acl2 requir everi acl2 function symbol guard may thought predic formal function describ intend domain guard entir extralog involv axiom defin function discuss role guard explain relat acl2 common lisp 35 axiom addit common lisp applic common lisp add four import new featur introduc new function symbol appropri axiom ffl add new multiplevalu function call return primit syntact restrict similar common lisp primit multiplevaluebind valu primitivesrequir functionalway return number valu call context ex pect appropri number valu restrict allow multiplevalu function implement effici common lisp least case gnu common lisp logic speak vector multipl valu return function list valu implement effici list actual construct ffl add explicit notion state allow acl2 programm accept input caus output putoutput function common lisp acl2 applic depend implicit notion current state acl2 state ntupl contain among thing file system open inputoutput channel file primit inputoutput function axiomat take state explicit paramet return new state explicit result usual one sever result syntact check languag ensur state singlethread ie function take state argument call function return new state new state precis final descend must return give rise welldefin notion current state suppli toplevel call statedepend acl2 function state return call becom definit next current state restrict execut statedepend function need actual construct new state ntupl liter modifi underli common lisp state ffl add fast applic array impl ment behind scene common lisp array manner alway return valu accord axiom oper effici provid certain program disciplin follow name use singlethread way recent updat version array use syntact enforc disciplin failur follow simpli lead ineffici cor rect execut warn messag ffl add fast applic properti list manner similar array 36 extens principl final acl2 two extens principl definit encapsul preserv consist extend logic 25 inde standard model number list alway extend includ newli introduc function symbol inconsist thu caus user add new axiom directli rather via extens principl encapsul principl allow user introduc new function symbol constrain axiom certain properti consist ensur requir user exhibit wit function satisfi constraint set function symbol constrain wit use establish consist irrelev axiom new function state constraint theorem prove constrain function theorem instanti higherord way deriv analog result function satisfi constraint made possibl deriv rule infer call function instanti 6 name encapsul stem way principl implement encapsul command essenti wrapper around admiss sequenc definit theorem wrapper allow one mark certain definit theorem local local definit theorem export wrapper nonloc one export within local context establish encapsul constrain function local defin wit constraint nonloc theorem function outsid encapsul function symbol undefin theorem appear consist axiom implement make encapsul use even new function symbol introduc allow larg proof structur see section 6 definit principl ensur consist requir proof defin function termin done nqthm identif ordin measur formal decreas recurs 8 show nqthm ensur one one settheoret function satisfi recurs definit proof carri acl2 case appropri treatment nonuniqu constrain function use definit form acl2 function definit common defun f acl2 extend common lisp declar permit specif guard express g x 1 x n well permit option specif ordin measur hint addit syntact restrict put bodi ensur common lisp version f execut effici accord claim make roughli speak enforc syntact notion current state singl thread restrict use variabl name state ensur multipl valu use appropri syntact restrict met requir termin theorem prove axiom f x1 ad new axiom observ axiom ad independ guard 4 relat acl2 common guard role logic howev crucial relat logic common lisp implicit guard common lisp allow great effi cienci implement common lisp exampl gnu common lisp perform compil code gener arithmet list process function compar handcod c arithmet pointer manipul except execut effici wide varieti platform combin clear applic semant use properli one great attract base acl2 logic common lisp consid exampl primit function car page 411 40 say argument car must con nil page 6 learn place state soandso must must may case error state requir met page 5 learn error mean valid common lisp program caus situat occur situat occur effect result complet undefin common lisp implement requir detect error thu implement function car may assum actual con nil suitabl represent data implement car simpli fetch content memori locat actual store check necessari cours car appli 7 result unpredict possibl damag runtim imag usual implement depend aspect lisp make difficult debug compil lisp code also rais problem direct embed applic common lisp logic situat far wors mere know valu car 7 know valu object logic car 7 might exampl wors still know car function form equal car 7 car 7 instanc axiom equal x x might sometim evalu nil common lisp first car 7 might return 0 second might return 1 acl2 solv problem axiomat car x total function return nil outsid intend main describ guard consp x equal x nil claim axiom describ common lisp car argument car satisfi guard acl2 provid gener mean verifi situat obtain evalu given express contain car read rest section reader may wish consid possibl approach could carri program languag 3 although program commerci avail mainstream languag c check certain kind error believ util match capabl make arbitrari semant check static describ acl2 perhap analog approach c would present opportun integr formal verif mainstream softwar develop practic lessen need dynam errorcheck 41 gold function symbol term make precis relat acl2 common lisp defin two interrel notion function gold term gold hypothesi hypothesi given implicitli true hypothesi roughli speak function symbol gold guard true guard subroutin encount evalu true argument ffl acl2 logic primit function symbol gold ffl defin function f guard g bodi b gold everi function symbol mention g gold term g gold everi function symbol besid f mention b gold term b gold g ffl variabl quot constant gold term ffl term b c gold h gold h b gold h c gold h ffl term f 1 f guard v formal f gold h provid gold 3 thank one refere pose question h impli h g 1 theorem formula must prove call guard conjectur subterm question sometim say function term common lisp compliant synonym say gold call process check whether function symbol term gold guard check guard verif 42 stori relat logic common lisp claim function symbol acl2 gold gold theorem prove everi execut function compliant common lisp produc answer consist theorem provid argument function satisfi guard resourc error eg stack overflow occur less precis gold acl2 theorem describ behavior common lisp claim made precis follow present claim restrict set simplic suppos f function symbol one argument defin certifi book eg file admiss acl2 definit theorem guard f f gold equal f x necessarili gold theorem acl2 prove book consid common lisp compliant 40 acl2 kernel load load book lisp let x common lisp object also object acl2 applic lisp f x return els caus resourc error eg stack overflow memori exhaust essenc proof claim observ f x evalu logic sound logic comput step exercis function symbol outsid guard domain f gold sinc logic common lisp agre insid guard domain common lisp comput f x return also less restrict altern formul thm gold theorem certifi book acl2 instanc thm evalu nonnil compliant common lisp acl2 kernel book load 43 guard effici one obviou implic stori one formal model prove common lisp compliant one wish evalu gold applic model one ignor acl2 theorem prover altogeth load model compliant common lisp contain acl2 kernel directli execut model obtain result consist axiom exampl one might build gold simul microprocessor highlevel languag provid user via standalon common lisp engin acl2 theorem prover need present less obviou use claim made insid acl2 theorem prover cours theorem prove uncommon ground subexpress aris certain instanti lemma case split enumer main base case induct etc like nqthm acl2 interpret evalu ground express acl2 complet common lisp primit built runtim type check done interpret eg determin valu axiom car appli constant interpret determin whether consp either use lisp car return default valu nil interpret call userdefin function requir recurs evalu typecheck bodi repeatedli acl2 evalu call gold function symbol use direct common lisp comput guard evalu nqthm acl2 interpret implement defin compil auxiliari common lisp function runtim type check gold acl2 function gener compil acl2 type check thu interpret approach gold shortcircuit enjoy benefit compil effici differ acl2 avoid runtim type check certain subexpress make substanti differ industrials model summari one import increment effect prove acl2 function symbol gold subsequ applic function effici comput 44 guard specif devic guard may also use type specif gold function welltyp howev guard much express convent type arbitrari term logic cours acl2 type check decid reason relat work see 1 one attach restrict guard one function prove function gold one obtain assur function exercis intend domain precis one gain knowledg comput valu provabl equal function applic weaken logic system equal function applic bodi condit guard true nqthm provid assur mechan 5 exampl section illustr point made guard 51 admit definit consid problem concaten two list defin function app follow defun app x declar xarg measur x guard truelistp x equal x nil con car x app cdr x ignor declar moment observ function termin x nil otherwis cdr x recurs intent x alway true list ie con tree whose rightmost branch termin nil function appli 7 8 common lisp result would unpredict 76nil recur cdr 7 8 cdr 7 undefin common lisp replac equal x nil test atom x sensibl know x con cdr lisp programm tend use test effici type check 4 equival provid x true list declar guard truelistp x make clear intend domain logic speak must admit function reason logic speak guard irrelev must show measur argument decreas recurs matter x use suitabl measur x suppli user declar x defin elsewher 0 x nil otherwis one greater length rightmost branch x easi show measur decreas recurs ie cdr x x6nil intuit recurs termin acl2 cdr complet return nil noncons recurs hit atom bottom rightmost branch stop atom nil otherwis goe one step cdring atom produc termin nil function admit axiom axiom app x equal x nil con car x app cdr x ad note axiom mention guard 4 equal test symbol done singl address comparison requir memori refer type check 52 theorem prove surpris theorem theorem surprisingappcal equal app 7 con nil 8 return surpris exampl later also prove use power uncondit equal state app associ theorem associativityofapp equal app app b c app app b c proof take advantag fact car cdr return nil noncon argument number guard app infect definit app limit applic true list app would uncondit associ identifi suffici condit difficult sinc appear first argument call app conjectur must true list order use definit app call similarli b must true list app b also first argument call app use definit app call system must abl establish either third hypothesi proof hypothes app b true list short guard function infect definit axiom theorem inherit complex composit weaken encumb hypothes weaken theorem rais problem three way ffl harder user state accur ffl often harder prove induct induct hypothesi weaken ffl harder use subsequ one must reliev hypothes point made 27 decis guard affect definit axiom thu far reach effect fact guard play logic role earlier version acl2 driven return nqthm paradigm total function complex guard introduc industrialstrength proof effort particularli cap project describ later 53 complianc return app exampl next ask relationship common lisp prove app gold ie common lisp compliant everi function use definit except app gold primit bodi evalu everi guard encount true guard app true initi latter condit expand follow three subroutin bodi app nontrivi guard car cdr recurs call app definit gold theorem must prove call subroutin bodi app particular call must prove guard app togeth test lead call impli guard call prove app gold therefor suffic observ x nonnil true list x must con cdr true list extralog natur guard brought home observ could defin anoth function say xapp analog app contain guard ie guard two function provabl equiva lent app common lisp compliant xapp guard conjectur prove know app common lisp compliant stori tell us call app satisfi guard execut accord axiom acl2 put anoth way wish determin valu axiom app b b constant simpli execut express common lisp provid true list thu user wish execut formal model concret data satisfi guard run model common lisp provid model prove compliant furthermor guard gold term suitabl data determin common lisp evalu also 54 gold theorem theorem gold function app surpris result equal app 7 con nil 8 know everi compliant common lisp evalu true theorem gold guard app violat 7 noth infer common lisp via claim common lisp may caus sever troubl command evalu app 7 8 associ result app expect app uncondit associ common lisp answer theorem gold howev follow theorem gold 5 theorem goldassociativityofapp impli truelistp equal app app b c app app b c 5 impli thought lazi ie impli p q read p q given proper treatment definit gold cours must prove theorem proof trivial given uncondit associ result must also verifi gold ie guard everi call satisfi argument call context call two truelistp hypothes true guard three call app first argument variabl symbol guard requir variabl question b appropri truelistp guard condit trivial given hypothes final guard condit app app b c gener interest guard condit app b true list b 55 separ concern note acl2 treatment guard separ con cern theorem prove simplic nqthm tradit acl2 make function total complet primit arbitrari natur default valu function introduc logic without address question whether compliant common lisp properti prove without concern oneself question whether guard satisfi often allow properti simpli state allow data base rule less restrict power easili appli nevertheless nongold function evalu axiom nqthm effici system acl2 function defin logic properti prove one move question common lisp complianc either gain execut effici acl2 set standalon common lisp gain type assur effici gain increment guard verif core subroutin outli checker preprocessor postprocessor typic involv big system prove certain function gold one stop settl correspond effici type assur one prove key properti prove also gold recal exampl one carri follow sequenc step ffl admit app function ffl prove uncondit associ ffl prove gold ie common lisp compliant welltyp ffl trivial prove restrict version associ ffl prove restrict version associ gold common lisp compliant version acl2 predat version 18 guard part definit equat issu often intertwin imposs address separ make littl differ set simpl app associ make great deal differ model involv thousand function properti 6 proof engin argu acl2 industri strength main argument improv effici nqthm virtu execut common lisp special consider effici execut oper involv array properti list state also indic express kind typecorrect gain guard verif yet capabl separ logic proper proof needlessli hinder beloww consid strength acl2 besid effici program languag robust gener featur maintain proof support 61 robust notion industri strength robust tool put consider effort make program bulletproof handl user error gracious appropri messag interfac consist provid abil submit definit theorem well abil execut applic lisp code effici 62 usabl yet anoth notion industri strength tool support featur crucial get job done partial list featur offer acl2 ffl extens onlin document may read termin well text way hypertext emac info html ffl support undo back given command well undo undo ffl notion book allow independ develop inclus librari definit theorem book share underli implement encapsul form within mark local author book reader book see nonloc definit theorem possibl complex environ necessari certifi book need export reader environ book hierarch may includ book local otherwis reader may includ mani independ develop book creat environ author book instal theori invari help reader manag environ creat multipl book author book document definit theorem book book inclus updat onlin document within consist check done book includ book carri certif help commun versioncontrol ffl program mode allow definit execut function without proof burden impos without risk unsound introduc prover know pro gram mode function ffl realist collect data type includ string complex ration number support reason data eg fulli integr linear arithmet decis procedur ration extens capabl control prover see ffl common lisp macro eas program specif without clutter collect function one need reason ffl mani use program primit includ effici use multipl valu array properti list file io ffl common lisp packag support distinct name space mutual recurs definit support 63 maintain also found applic style program amen mainten fix bug implement enhanc moreov subset common lisp acl2 support suffici code lowest level system need implement primit believ common lisp program applic perhap even perform io fact acl2 program nearli 64 proof support nqthm pcnqthm proof signific theorem acl2 tend requir seriou effort part user prove appropri support lemma primarili store use condit rewrit rule howev acl2 offer mani way user control proof engin ffl nqthm proof commentari english assist user debug fail proof ffl pcnqthm interact loop proof discoveri extens macro access full power theorem prover ffl capabl appli hint individu subgoal ffl proof tree display show evolv structur proof real time also make conveni inspect fail proof effici handl proposit logic normal claus gener much effici nqthm also facil integr order binari decis diagram rewrit ing ffl function instanti facil give acl2 like nqthm conveni higherord logic without sacrif simplic first order logic ffl breakrewrit facil sophist nqthm prover far know allow prooftim debug rewrit stack ffl theori mechan make easi manipul set rule especi turn also check desir invari set rule ffl forc mechan give prover permiss defer check hypothes specifi rule end main proof ffl support varieti type rule 17 includ type support nqthm includ condit rewrit rule may use replac equal equal may also work respect userdefin equival relat linear arithmet rule togeth mechan creat rule certain simpl order standard lessthan order ration compound recogn forward chain type prescript equival congru enc builtin claus rule effici automat use certain fact improv meta lemma facil allow lemma condit ie hypothes rule use outsid simplifierrewrit elimin gener thu claim acl2 industri strength effici consist robust interfac array gener featur eas mainten flexibl theorem prover 7 industri applic cours ultim test whether tool indu trial strength must whether use job interest industri first two import applic acl2 support claim task ap plicat summar discuss detail 12 31 also detail time manpow resourc spent compon task 71 motorola cap digit signal processor bishop brock cli work collabor mo torola inc produc execut formal acl2 specif motorola cap 19 digit signal processor design motorola execut 1024 point complex fft 131 microsecond everi welldefin behavior cap model includ pipelin io interrupt breakpoint trap exclud hard soft reset sequenc cap much complex processor recent subject formal model name fm90001 22 mc68020 10 aamp5 30 principl cap singl instruct simultan modifi well 100 regist brock acl2 model cap bitaccur cycleaccur run faster motorola spw model furthermor acl2 use reason cap model acl2 comput symbol effect complic instruct second acl2 brock prove suitabl condit model cap equival simpler pipelinefre model perhap import aspect cap work acl2 possibl prove correct program complex instruct set mechan analysi cap microcod program perhap way assur program certain properti brock use acl2 verifi microcod produc motorola assembl sever applic program includ fir filter peak find algorithm use adder array chain compar work discuss 12 follow approach use nqthm mc68020 10 brock configur acl2 make easi symbol execut cap microcod program data specifi mechan prove total correct microcod program consid ere possibl often less labor intens use cap model acl2 prove weaker properti mi crocod error occur believ microcod engin cap specifi acl2 applic program mechan verifi subsequ microcod applic done rou tine routin mean technic detail symbol execut particular microcod manag acl2 effort verif task domin consider specif behavior given program anoth import aspect acl2 cap model execut cap program faster motorola spw model make conveni debug tool two reason speed one code somewhat higher level spw model ie arithmet model arithmet common lisp simul combin logic brock use strict guard ensur model type correct regist contain data appropri size address legal object use cap machin state appropri form etc function cap model prove gold thu acl2 cap model compil faith execut directli common lisp 72 amd5k 86 floatingpoint divis anoth test industri applic acl2 collabor tom lynch advanc micro devic inc formal mechan prove correct microcod kernel float point divisionop erat use amd5k 86 microprocessor amd first pentiumclass processor particular 31 prove p doubl extend precis floatingpoint number 6 0 mode round mode specifi round style target format precis n 64 result algorithm pd round accord mode explain detail 31 algorithm use tabl obtain 8bit approxim reciproc two iter effici comput variat newtonraphson iter use refin approxim rel error less 2 gamma28 approxim use comput four floatingpoint number whose sum suffici close pd round accord mode result round pd instead algorithm implement microcod comput use float point oper direct round prove algorithm work specifi develop acl2 much floatingpoint folk lore also formal algorithm acl2 use acl2 check fairli deep mathemat proof necessari step proof show everi intermedi result fit floatingpoint resourc alloc amd industri strength aspect acl2 use proof fact acl2 execut impor tant proof two applic newtonraphson iter produc suffici accur answer gener away particular tabl use amd defin predic recogn tabl contain suffici accur 8bit approxim prove newtonraphson step start tabl correct answer produc predic execut given concret tabl common lisp determin evalu whether satisfi predic thu appli result actual amd tabl acl2 mere execut predic amd tabl aspect acl2 crucial proof encapsul macro book use encapsul macro abl conveni configur acl2 temporarili deriv key step proof without impos proof strategi key step use book abl partit respons variou part proof among collabor assembl final result subsequ proof floatingpoint divis microcod david russinoff use acl2 prove correct amd5k 86 floatingpoint squar root microcod 37 8 conclus acl2 reimplement extend version boyer moor nqthm kaufmann pcnqthm intend larg scale verif project acl2 logic extens larg applic subset common lispsup port practic collect data type singl thread state io multiplevalu function array properti list care design notion guard acl2 allow eleg express proof theorem logic without mani encumbr typelik hy pothes time allow function logic relat common lisp way allow extrem effici comput furthermor design allow clear separ problem admiss logic definit proof simpli state properti typecorrect common lisp complianc effici execut design allow increment achiev goal via proof allow user focu effort import aspect project acl2 provid widevarieti featur supportiveof industri strength goal includ rug extens document implement mani conveni featur construct model develop structur proof good maintain final demonstr acl2 use tackl problem import industri acknowledg especi initi stage acl2 develop quit possibl acl2 would never creat also especi grate bishop brock provid valuabl feedback base heavi use acl2 mani month bill young improv contribut tutori materi document art flatau noah friedman laura lawless contribut technic aspect document provid use feedback also acknowledg contribut bill bevier alessandro cimatti rich cohen john cowl warren hunt jun sawada bill schel ter mike smith final grate util provid gnu emac particular richard stallman provid texinfo patch assist build documen tation also thank anonym refere paper provid mani valuabl suggest paper extend version paper acl2 industri strength version nqthm appear proceed eleventh annual confer comput assur compass96 ieee comput societi press pp 2334 june 1996 work report support part comput logic inc advanc research project agenc arpa order d245 contract n66001 95c8634 arpa order 7406 offic naval search contract n0001494c0193 view conclus contain document author interpret repres offici polici either express impli comput logic inc unit state govern r strong static type check function common lisp model valid test boyermoor prover nuprl experiment comparison special issu system verif machin check proof design faulttoler circuit function instanti first order logic boyermoor theorem prover interact enhanc computationallog comput logic handbook autom correct proof machin code program commerci microprocessor acl2 theorem commerci microprocessor mechan geometri theorem prov ing theorem prover mathematica implement mathemat nuprl proof develop system coq proof assist eve overview architectur complex arithmet processor com municationsign process introduct hol theorem prove environ higherord logic imp interact mathemat proof system user manual interact enhanc boyermoor theorem prover interact boyermoor theorem prover tutori studi use arithmeticgeometr mean theorem ramsey theorem boyermoor logic type harmless otter 30 refer manual guid symbol model check formal verif aamp5 microprocessor case studi industri use formal method mechan check proof correct kernel amd5k86 float point divis algorithm formal model asynchronouscom munic use mechan verifi biphas mark protocol introductionto obdd algorithm atp commun isabel gener theorem prover draft propos american nation standard inform system program languag common lisp mechan proof quadrat reciproc mechan check proof correct amd5k 86 floatingpoint squar root microcod compar verif system interact consist acl2 tr ctr michael lowri daniel dvorak analyt verif flight softwar ieee intellig system v13 n5 p4549 septemb 1998 georg avrunin stephen f siegel andrew r siegel finitest verif high perform comput proceed second intern workshop softwar engin high perform comput system applic may 1515 2005 st loui missouri sean w smith vernon austel trust trust hardwar toward formal model programm secur coprocessor proceed 3rd confer usenix workshop electron commerc p88 august 31septemb 03 1998 boston massachusett josiah dykstra softwar verif valid destini parallel approach autom theorem prove crossroad v8 n3 p2327 spring 2002 zaher andrau karem sakallah automat abstract verif verilog model proceed 41st annual confer design autom june 0711 2004 san diego ca usa j strother moor mechan check proof multiprocessor result via uniprocessor view formal method system design v14 n2 p213228 march 1999 young compar verif system interact consist acl2 ieee transact softwar engin v23 n4 p214223 april 1997 stephen mccamant greg morrisett evalu sfi cisc architectur proceed 15th confer usenix secur symposium p1515 juli 31august ruben gamboa correct fast fourier transform structur proof acl2 formal method system design v20 n1 p91106 januari 2002 matt kaufmann j strother moor structur theori develop mechan logic journal autom reason v26 n2 p161203 februari 2001 zaher andrau mark h liffiton karem sakallah refin strategi verif method base datapath abstract proceed 2006 confer asia south pacif design autom januari 2427 2006 yokohama japan j strother moor toward mechan check theori comput acl2 project logicbas artifici intellig kluwer academ publish norwel 2000 matthew wild david greve david hardin effici simul formal processor model formal method system design v18 n3 p233248 may 2001 alessandro armando silvio ranis constraint contextu rewrit journal symbol comput v36 n12 p193216 juli paolo bientinesi john gunnel margaret e myer enriqu quintanaort robert van de geijn scienc deriv dens linear algebra algorithm acm transact mathemat softwar tom v31 n1 p126 march 2005 andrew ireland alan bundi automat verif function accumul paramet journal function program v9 n2 p225245 march 1999 jeremi w nimmer michael ernst automat gener program specif acm sigsoft softwar engin note v27 n4 juli 2002 j strother moor thoma w lynch matt kaufmann mechan check proof amd5k86tm floatingpoint divis program ieee transact comput v47 n9 p913926 septemb 1998 ramesh bharadwaj constanc l heitmey model check complet requir specif use abstract autom softwar engin v6 n1 p3768 januari 1999 jack minker introduct logicbas artifici intellig logicbas artifici intellig kluwer academ publish norwel 2000