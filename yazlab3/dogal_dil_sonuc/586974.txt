simpl confluent persist caten list consid problem maintain persist list subject concaten insert delet end updat persist data structur nondestructiveeach oper produc new list incorpor chang keep intact list list appli although gener techniqu exist make data structur persist techniqu fail structur subject oper caten combin two version paper develop simpl implement persist doubleend queue dequ caten support dequ oper constant amort time implement function allow memoiz b introduct last fteen year consider develop persist data structur current version also older one avail access partial persist updat full per sistenc particular driscol sarnak sleator tarjan 5 develop ecient gener method make pointerbas data structur partial fulli persist dietz 3 develop ecient gener method make arraybas structur fulli persist gener method support updat appli singl version structur time accommod oper combin two dierent version structur set union list caten driscol sleator tarjan 4 coin term con uentli persist fulli persist structur support combin oper altern way obtain persist use pure function program take extrem strict view pure function disallow lazi evalu memoiz techniqu listbas data structur design pure function program amount use lisp function con car cdr pure function data structur automat persist inde con uentli persist simpl import problem data structur design make issu con uent persist concret implement persist doubleend queue dequ caten seri paper 2 4 culmin work kaplan tarjan 11 10 develop con uentli persist implement dequ caten worstcas constant time space bound dequ oper includ caten kaplantarjan data structur precursor obtain con uent persist pure function depart comput scienc tel aviv univers tel aviv 69978 israel haimkmathtauacil depart comput scienc columbia univers new york ny 10027 research carnegi mellon univers support advanc research project agenc csto titl fox project advanc languag system softwar arpa order c533 issu escen contract f1962895c0050 cokasakicscolumbiaedu z depart comput scienc princeton univers princeton nj 08544 intertrust technolog corpor sunnyval ca 94086 research princeton univers partial support nsf grant ccr9626862 retcsprincetonedu one care persist pure function program unnecessarili restrict particular okasaki 14 15 16 observ use lazi evalu combin memoiz lead ecient function pure function sens data structur con uentli persist order analyz structur okasaki develop novel kind debitbas amort use techniqu weaken time bound worstcas amort abl consider simplifi kaplantarjan data structur particular elimin complic skeleton encod tree extens redund digit number system paper explor problem simplifi kaplantarjan result obtain con uentli persist implement dequ caten constant amort time bound per oper structur substanti simpler origin kaplantarjan structur even simpler okasaki caten dequ wherea okasaki requir ecient persist dequ without caten build block structur entir selfcontain furthermor analysi use standard creditbas approach give two altern close relat implement method rst use memoiz second save small constant factor time space use extens memoiz express replac equival express remaind paper consist section section 2 introduc terminolog concept section 3 illustr approach develop persist implement dequ without caten section 4 extend approach handl stack caten section 5 develop solut dequ caten conclud section 6 remark open problem extend abstract work appear 9 2 preliminari object studi list 11 10 allow follow oper list return new list contain singl element x return new list form ad element x front list l popl return pair whose rst compon rst element list l whose second compon list contain second last element l return new list form ad element x back list l return pair whose rst compon list contain last element l whose second compon last element l catenatel r return new list form caten l r l rst seek implement oper specic subset persist list oper allow previous construct list list time discuss variou form persist see 5 stack list push pop allow queue list inject pop allow stequ stackend queue list push pop inject allow final dequ doubleend queue list four oper push pop inject eject allow four structur may may allow caten caten allow push inject becom redund sinc special case caten sometim conveni treat separ oper easier implement gener caten say data structur pure function built manipul use lisp function car con cdr structur consist set immut node either atom node contain two pointer node cycl pointer node use build structur actual contain xed number eld reduc structur two eld per node ad addit node straightforward variou node structur repres list obtain result extend pure function allow memoiz function evalu node second time function evalu node valu simpli retriev previou comput construct constant number memoiz function one two implement memoiz node point result appli memoiz function initi pointer unden rst function evalu ll appropri pointer indic result subsequ evalu mere follow pointer result take time also consid use substanti extens pure function allow oper replac node structur anoth node repres list replac perform imper set replac eld node instanc lisp use replaca replacd replac view gener memoiz structur node replac twice mean structur implement writeonc memori easi convert algorithm overwrit eld xed constant number time writeonc algorithm constantfactor loss ecienc use overwrit instead memoiz save small constant factor run time storag space slightli simpli amort analysi perform amort analysi use standard potentialbas framework assign congur data structur total node current exist potenti dene amort cost oper actual cost plu net increas potenti caus perform oper applic potenti empti structur zero potenti alway nonneg follow sequenc oper start empti structur total actual cost oper bound sum amort cost see survey paper 17 complet discuss amort analysi 3 noncaten dequ section describ implement persist noncaten dequ constant amort time bound per oper structur base analog kaplantarjan structur 11 10 much simpler result present illustr techniqu amort analysi persist data structur end section comment relat structur propos previous exist solut 31 represent subsequ section say data structur set store element represent recurs built boundeds dequ call buer contain three ele 4 h kaplan c okasaki r e tarjen ment buer two kind prex sux nonempti dequ repres order tripl consist prex denot prd possibl empti child dequ order pair denot cd sux denot sfd pair consist two element child dequ cd nonempti repres way dene set descend dequ standard waynam c 0 exist order element dequ dene recurs one consist order tripl buer pair child dequ thu order element dequ rst element prd element pair cd nalli element sfd gener represent dequ uniqueth sequenc element may repres tripl dier size prex sux well content represent descend dequ whenev refer dequ actual mean particular represent one clear context pointer represent represent obviou one node repres dequ contain pointer prd cd sfd note pointer structur essenti link list descend sinc c contain pointer c i1 32 oper implement dequ oper straightforward except maintain size bound buer specic push dequ easi unless prex size three pop dequ easi unless prex empti symmetr statement hold inject eject deal buer ow ow proactiv fashion rst xing buer oper perform violat size bound actual oper detail follow dene buer green contain one two element red contain zero three dene two memoiz function dequ gp construct represent list green prex gs construct represent list green sux appli gp gs respect list whose prex sux red made green specic gp prex empti child dequ must nonempti symmetr gs give implement push pop gp implement inject eject gs symmetr denot dequ prex p child dequ c sux p c mention section 2 implement memoiz gp gs node point node result appli gp gs initi pointer unden prd empti cd let nonempti let x return pair x p ce sfe otherwis ce must empti let x return pair x z three element prd let p prex contain x let c prd empti cd let x prex contain x follow return p 33 analysi amort analysi method reli memoiz gp gs call node repres dequ secondari return call gp gs primari otherwis secondari node construct call gpx gsx respect way access later via anoth call gpx gsx respect secondari node return result push pop inject eject oper mean gp gs call primari node devid node repres dequ three state node rr buer red gr exactli one buer red gg buer green subdivid rr gr state rr node rr0 neither gp gs appli rr1 exactli one gp gs appli rr2 gp gs appli gr node gr0 neither gp gs appli gr1 otherwis discuss everi secondari node gr0 gg dene rr0 rr1 gr0 number primari node state rr0 rr1 gr0 respect dene potenti collect node repres dequ 4rr0 call push either termin result call gp turn call push similarli call pop either termin result call gp turn call pop charg o1 time spent call gp exclus inner call push pop push pop call gp call push result sequenc recurs call push via call gp bottommost termin rest nontermin nontermin push one follow eect convert primari rr0 node rr1 creat new primari gr0 node result push new secondari gr0 node result call gp convert primari rr1 node rr2 creat new primari gr0 node new secondari gr0 node convert primari gr0 node gr1 creat new primari gg node new secondari gg node case total potenti drop one pay time need push exclud recurs call termin push take o1 time creat o1 new node increas potenti o1 conclud push take o1 amort time analog argument appli pop inject eject give us follow theorem theorem 31 oper push pop inject eject dene take o1 amort time 34 implement use overwrit memoiz implement describ primari rr node give rise two secondari gr node repres list primari gr node give rise secondari gg node repres list redund represent exist simultan gr represent howev domin rr represent perform dequ op erat gg represent domin gr represent allow us improv ecienc implement use overwrit place memo izat gp call node overwrit content node result gp comput similarli gs one represent list exist time evolv rr gr gg via one two altern path depend whether gp gs call rst node need three eld prex child dequ sux instead two extra gp gs use overwrit save constant factor run time storag space also simpli amort analysi follow dene rr gr number node state rr gr respect secondari node dene potenti collect node 3rr gr nontermin push one follow eect convert rr 6 h kaplan c okasaki r e tarjen node gr creat new gr node convert gr node gg creat new gg node either case reduc potenti one pay o1 time requir push exclud recurs call termin push take o1 time increas potenti o1 conclud push take o1 amort time similar argument appli pop inject eject 35 relat work structur describ base kaplantarjan structur 10 section 4 simpli three way first skeleton structur sequenc descend stack kaplantarjan structur skeleton must partit stack stack order support worstcas constanttim oper via redund binari count mechan second recurs chang structur make node green onesid instead twosid origin structur stackofstack mechan requir coordin keep side structur relat state third maximum buer size reduc three special case stequ maximum size sux reduc two special case queue prex sux reduc maximum size two altern much older approach use increment recopi obtain persist dequ worstcas constanttim oper see 7 discuss approach increment recopi approach yield arguabl simpler structur one present structur gener allow caten one know implement ecient use increment recopi also structur extend support access insert delet posit away end list olog amort time appli idea 12 4 caten stequ section show extend idea support caten specic describ data structur caten stequ achiev o1 amort time bound push pop inject caten data structur base recurs decomposit list section 5 10 pointer structur need much simpler 10 analysi amort follow framework outlin section 2 use section 3 41 represent structur similar structur section 3 slightli dierent denit compon part section 3 use buer two kind prex sux prex contain two six element sux contain one three element nonempti stequ repres either sux sfd order tripl consist prex prd child stequ cd pair sux sfd contrast section 3 pair dene order pair contain prex possibl empti stequ pair observ denit add addit kind recurs pair store stequ structur section 3 extra kind recurs allow ecient caten order element stequ one consist order tripl buer pair stequ within pair child stequ section 3 mani dierent represent stequ contain given list element speak stequ mean particular represent pointer structur represent straightforward tripl repres node contain three pointer prex child stequ sux pair repres node contain two pointer prex stequ 42 oper implement stequ oper much like implement noncaten dequ oper present section 32 call prex red contain either two six element green otherwis call sux red contain three element green otherwis prex suxonli stequ consid color sux dene two memoiz function gp gs produc greenprex greensux represent stequ respect call correspond buer red made green dene push pop inject call gp gs necessari obtain green buer denit repres stequ prex child stequ c sux p c case 1 stequ repres tripl case 2 stequ repres sux creat prex p contain x rst two element sfd creat sux contain last element sfd return p otherwis creat sux push x onto sfd return case 1 stequ repres tripl case 2 stequ repres sux creat sux contain x return sfd otherwis creat sux inject x sfd return case 1 1 2 repres tripl first caten buer sfd 1 prd 2 obtain p calcul c 0 follow jpj 5 let c 9 creat two new prex p 0 contain rst four element p p 00 contain remain element let c either case return case 2 1 2 repres sux push inject element suxonli stequ onebyon stequ note push caten produc valid stequ even second argument stequ prex length one although stequ normal allow may exist transient pop everi stequ immedi pass push caten discard howev order dene pop gp gs oper dene n aivepop oper simpli pop stequ argument without make sure result valid stequ repres tripl let x return consist sux let x pair x case 1 stequ repres sux jprdj 2 return n aivepopd case 2 stequ repres tripl x rst element prd second jsfdj 3 push onto sfd form 8 h kaplan c okasaki r e tarjen return x otherwis jsfdj 3 form p rst two element sfd form last element sfd return x p case 3 stequ repres tripl creat two new prex p p 0 split prd equal two let c cd 6 proceed follow inspect rst pair p 0 cd jpj 4 0 empti let p 0 inspect p case 1 p contain least four element pop rst two element p form inject two element prd obtain p 0 let c return case 2 p contain three element push two element prd onto p obtain p 0 let c nonempti c return stequ repres tripl contain rst two element sfd last element sfd let c return 43 analysi analysi method similar analysi section 33 dene primari secondari node node state potenti function exactli section 33 potenti function 4rr0 rr0 rr1 gr0 number primari node state rr0 rr1 gr0 respect section 33 charg o1 cost call gp gs exclud cost recurs call push pop inject push pop inject call gp gs amort cost push inject o1 argument ident use analyz push section 33 oper caten call push inject constant number time creat singl new node amort cost also o1 analyz pop assum call pop recur depth k via interven call gp argument analog push rst k 1 call pay decreas potenti one termin call pop result call either push caten o1 amort cost follow overal amort cost pop o1 give us follow theorem theorem 41 oper push pop inject caten dene take o1 amort time improv time space ecienc stequ data structur constant factor use overwrit place memoiz exactli describ section 34 also simplifi amort analysi exactli describ section 34 44 relat work structur present section analog kaplantarjan structur 10 section 5 structur 8 section 7 simpli follow first buer constantbound size wherea structur 10 section 5 use noncaten stequ buer structur 8 section 7 use noncaten stack buer buer turn must repres section 3 paper use one method mention contrast structur present section entir self contain second skeleton present structur stack instead stack stack 10 8 third chang use make buer green appli onesid needdriven way 10 8 repair must made simultan side structur care chosen locat okasaki 14 devis dierent somewhat simpler implement con uentli persist caten stequ also achiev o1 amort bound per oper solut obtain ecienc implicitli use form path revers 18 addit lazi evalu memoiz structur extend doubleend case shall see next section whether okasaki structur extend case open problem 5 caten dequ section show extend idea support list oper specic describ data structur caten dequ achiev o1 amort time bound push pop inject eject caten structur base upon analog structur okasaki 16 simpli use constants buer 51 represent use three kind buer prex middl sux nonempti dequ repres either sux sfd 5tupl consist prex prd left dequ tripl ldd middl mdd right dequ tripl rdd sux sfd tripl consist rst middl buer dequ tripl last middl buer one two middl buer tripl must nonempti tripl contain nonempti dequ middl must nonempti buer tripl prex sux 5tupl contain three six element sux suxonli represent contain one eight element middl 5tupl contain exactli two element nonempti middl buer tripl contain two three element order element dequ one consist order 5tupl buer tripl recurs dequ pointer structur straightforward node repres 5tupl tripl contain one pointer eld 52 oper call prex sux 5tupl red contain either three six element green otherwis call sux suxonli represent red contain eight element green otherwis prex suxonli dequ consid color sux introduc two memoiz function function gp gs section 32 42 produc greenprex greensux represent dequ respect call correspond buer red made green give implement push pop gp caten implement inject eject gs symmetr push pop gp respect denot dequ prex p left dequ l middl right dequ r sux p l case 1 dequ repres 5tupl otherwis let case 2 dequ repres sux sfd 8 return suxonli dequ sux pushx sfd otherwis push x onto sfd form nine element creat new prex p rst four middl next two sux last three return p section 42 implement pop use n aivepop case 1 dequ repres sux jprdj 3 return n aivepopd case 2 case 3 x rst element prd creat new sux contain element prd mdd sfd except x return pair consist x dequ repres otherwis form p prd pop x inject rst element mdd 0 mdd pop rst element inject rst element sfd form sfd pop rst element return x creat two new prex p p 0 p contain rst four element jprdj p 0 last two return p pushp proceed follow case 1 ldd 6 inspect rst tripl ldd either rst nonempti middl buer contain 3 element contain nonempti dequ let assum x nonempti consist one nonempti middl buer appli appropri one folow two subcas case 11 3 form x 0 x p prd pop rst element x inject prd return case 12 2 inject element x prd form p 0 empti return p l mdd rdd sfd otherwis 0 nonempti let l case 2 inspect rst tripl rdd either rst nonempti middl buer contain 3 element contain nonempti dequ let assum x nonempti consist one nonempti middl buer appli appropri one follow two subcas case 21 x 0 prd x pop element inject prd form p pop element inject rst element x form 0 pop rst element x form x 0 return case 22 2 inject two element mdd prd form p let empti r return case 1 1 2 repres 5tupl let rst element prd 2 let x last element sfd 1 creat new middl contain x follow partit element sfd 1 fxg two buer 0 1 1 contain two three element order 00 possibl empti let ld 0 ld 00 otherwis let ld 00 ld 0 1 similarli partit element prd 1 fyg two prex contain two three element order possibl empti let rd 0 2 return prd 1 ld 00 case 2 1 2 repres sux push inject element suxonli dequ onebyon dequ 53 analysi analyz structur use denit potenti function section 33 43 amort cost push inject caten pop o1 argument analog section 43 amort cost eject o1 argument symmetr pop thu obtain follow theorem theorem 51 oper push pop inject eject caten dene take o1 amort time section 34 43 improv time space constant factor simplifi analysi use overwrit place memoiz overwrit prefer implement unless one use function program languag support memoiz easili allow overwrit 54 relat work structur present section analog structur 16 chapter 11 8 section 9 simpli follow first buer constant size wherea 16 8 noncaten dequ second skeleton present structur binari tree instead tree extens redund digit number system 8 also amort analysi use standard potenti function method 17 rather complic debit mechan use 16 anoth relat structur 10 section 5 repres pure function realtim dequ pair tripl rather 5tupl otherwis similar simpler structur 8 section 9 straightforward modifi structur present use pair tripl rather 5tupl 6 result open question univers element dequ construct total order extend structur describ support addit heap order base order specic support addit oper nding minimum element dequ delet preserv constant amort time bound everi oper includ nding minimum mere store buer dequ pair tripl minimum element relat work see 1 2 6 13 also support ip oper dequ ip oper revers linear order element dequ ith front becom ith back viceversa noncaten dequ section 3 implement ip maintain revers bit ip ip oper revers bit set push becom inject pop becom eject inject becom push eject becom pop support caten well ip use revers bit level must also symmetr denit section 5 allow dequ repres prex extend variou oper handl possibl interpret revers bit cumul dequ x dequ insid x regard revers odd number revers bit set 1 along path actual pointer structur node node x perform caten revers bit either two dequ 1 push bit ip bit dequ x 0 ip bit dequ x point swap appropri buer dequ prex sux exchang role left dequ right dequ order element prex sux revers well pushdown revers bit assembl new dequ overwrit old one devis altern implement caten dequ size prex sux 3 5 instead 3 6 memoiz pop eject oper avoid creat new structur green prex sux respect repres origin dequ perform pop eject respect use complic potenti function one use earlier section show implement run o1 amort time per oper one direct futur research nd way simplifi structur fur ther specic consid follow altern represent caten de que use singl recurs subdequ rather two subdequ nonempti dequ repres tripl consist prex prd possibl empti child dequ tripl cd sux sfd tripl consist nonempti prex dequ tripl nonempti sux nonempti prex sux buer tripl oper push pop inject eject implement similar implement section 5 major dierenc implement caten structur requir call pop specic let 1 2 two dequ caten caten pop cd 1 obtain tripl p new dequ c inject c sfd 1 obtain 00 push p 00 prd 2 nal result prex prd 1 child dequ c 0 sux sfd 2 open question whether algorithm run constant amort time per oper constant upper lower bound buer size anoth research direct design con uentli persist represent sort list access updat posit either end take olog time caten take o1 time best structur far develop problem doubli logarithm caten time 12 pure function time bound worstcas acknowledg thank michael goldwass detail read paper jason hartlin discuss led implement use memoiz r data structur bootstrap con uentli persist dequ via data structur boot strap fulli persist array fulli persist list caten make data structur persist dequ heap order list phd thesi simpl con uentli persist caten list ex tend abstract optim ram implement caten min doubleend queue amort comput complex worst case analysi set union algorithm tr ctr amo fiat haim kaplan make data structur confluent persist journal algorithm v48 n1 p1658 august georg lagogianni yanni panagi spyro siouta athanasio tsakalidi survey persist data structur proceed 9th wsea intern confer comput p16 juli 1416 2005 athen greec