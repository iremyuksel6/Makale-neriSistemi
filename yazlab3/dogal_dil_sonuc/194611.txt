tight bound oblivi chain chain problem defin follow given valu chain problem appear subproblem mani context known algorithm solv chain problem crcw pram oalphan time alphan invers ackerman function slowli grow function author studi class algorithm call oblivi algorithm problem simpl oblivi chain algorithm run oalphan time present importantli optim algorithm demonstr show match lower bound oblivi algorithm use n processor first step toward lower bound chain algorithm also provid show chain algorithm run two step must use superlinear number processor proof use prefix graph weak superconcentr interest connect two demonstr idea use obtain improv bound size prefix graph b introduct consid follow problem call chain given valu 1 ig defin output view pointer chain 1s link list chain problem natur problem consid context databas retreiv oper record satisfi particular predic correspond input bit valu 1 chain 1s correspond make link list record futur process apart appear subproblem mani context studi 16 17 parallel integ sort 2 14 parallel merg integ drawn restrict domain 3 parallel subset compact 18 1316 circuit comput threshold function 15 exampl easi solv problem time use one processor use processor fast parallel algorithm exist run time close constant reason simplic open question theoret interest 3 1617 whether constant time parallel algorithm exist berkman vishkin 4 independ ragd 16 given parallel algorithm solv chain problem offn time use n processor ffn invers ackerman function slowli grow function use algorithm similar chain algorithm berkman vishkin 5 give algorithm achiev bound problem lowestcommonancestor problem parenthesi match problem studi oblivi algorithm chain problem inform oblivi algorithm one pattern memori access depend n size problem specif input class algorithm interest algorithm berkman vishkin ragd modifi oblivi present simpl oblivi algorithm chain run offn time perform bound previous known algorithm algorithm simpl make use previous known graph structur importantli show class oblivi algorithm optim prove oblivi chain algorithm use n processor time sinc known algorithm chain made oblivi give evid superconst lower bound chain algorithm chandra fortun lipton 7 show circuit bound depth prefixcarri problem requir superlinear size impli superconst lower bound depth circuit linear size essenti show circuit must structur special type graph call prefix graph prove upper lower bound size prefix graph bound depth 6 7 demonstr connect prefix graph anoth famili graph call superconcentr 11 use idea present simpl proof improv lower bound 7 show construct 6 optim dolevdwork pippeng wigderson 11 show lower bound weak superconcentr bound depth lower bound oblivi chain algorithm obtain interpret algorithm graph use techniqu 11 analyz properti worth note chain algorithm whose graph weak superconcentr henc lower bound 11 use directli provid first step toward prove lower bound algorithm show chain algorithm termin 2 step requir superlinear number processor time submiss paper conjectur techniqu develop paper would use prove lower bound algorithm inde case techniqu use recent extend prove lower bound chain algorithm 9 model comput use paper concurrentread concurrentwrit parallel random access machin crcw pram common model crcw pram processor simultan write memori cell must write valu power prioriti model processor associ prioriti sever processor simultan write memori cell highest prioriti processor succe shown prioriti model strictli stronger common model 1 show consid oblivi algorithm model equival common machin extra memori thu throughout paper algorithm describ run common model lower bound prove prioriti model oblivi comput pram input algorithm chain consist valu n size problem n bit call input vector repres problem step processor comput base action far memori address access content write write step oblivi algorithm mean one address access fix input vector ie depend valu n howev whether processor perform action may depend input vector exampl fifth write step p 1 write alway write c 15 may may write depend input vector definit oblivi algorithm coincid call semioblivi 10 conveni model comput oblivi algorithm graph given algorithm input size n direct graph g defin follow vertic g group level suppos algorithm solv chain problem k step graph g consist 2k vertic number 0 2k even level vertex cell memori access algorithm vertic form c 2j 0 j k call cell vertic cell odd level vertex processor vertic form p 2j call processor vertic processor thu k level processor vertic cell vertic edg g defin follow input vector step j input vector step j initi bit input vector assum cell final output valu correspond bit assum cell shall refer vertic 0 x vertic 2k let p number processor use number cell access comput 2kp two kind edg graph adjac processor vertex other sinc processor vertex degre 4 former 4kp number cell access comput k cell vertic graph one even level thu total number cell vertic graph 2k 2 p sinc cell vertex adjac two latter type edg 2k 2 p edg henc number edg graph certainli upperbound 6k 2 p given input vector length n shall associ cell vertex content processor vertex state content associ c 2j content cell c step j j 1st readwrit step comput input state associ state processor p read step j 1th readwrit step comput time comput action processor depend sole state processor start fix initi state partial input one b 2 f0 1 lambdag input vector denot set input consist b partial input b cell vertex c 2j defin content x 2 xb g similarli processor vertex state e x 2 xb g say cell processor vertex x j fix partial input b j sb x j j 1 21 oblivi common simul oblivi prioriti consid follow problem call leftmoston problem given input 1g fich ragd wigderson 12 show leftmoston problem solv o1 time common use n processor n memori cell algorithm made oblivi shall use fact prove follow lemma 21 consid oblivi algorithm run prioriti pram p processor memori cell k step oblivi algorithm solv problem common pram p processor memori cell ok step proof suffic show one write step oblivi prioriti algorithm simul oblivi common machin o1 step suppos prioriti machin write r cell denot set processor may write c fix set note processor may choos write suffici common machin find highest prioriti processor choos write done solv leftmoston problem size j j use j j cell processor o1 time space bound follow fact henceforth shall refer prioriti algorithm lemma algorithm run common time bound note gener true one step prioriti algorithm simul common algorithm o1 step boppana 1 give exampl problem solv o1 time prioriti logn loglog n time common 3 upper bound ackerman function defin follow function f let f 1 ne k 1 function k invers kth level ackerman function ie k ng 1 behav like log n 2 like log n defin jg berkman vishkin 4 3 independ ragd 16 given algorithm solv chain problem prioriti ck step use ni k n processor c constant 2 algorithm one construct algorithm use processor take offn time give simpl oblivi algorithm solv problem 2k step prioriti use ni k n processor though perform bound feel algorithm easier understand prefix graph size n direct acycl graph n vertic call input vertic n vertic 1 yn outdegre 0 call output vertic depth prefix graph length longest path input output prefix graph follow properti direct path x j say prefix graph level vertic partit level number 0 everi edg level vertex level vertex 1 call edg level edg prefix graph contigu vertex v input v reachabl form x possibl construct 6 level contigu prefix graph size n depth 2k 8i 1 2k number level edg ni k n restricteddomain prefixmaxima problem defin follow given input 1 ig show solv problem use prefix graph initi set valu vertex propag valu tail head vertic level select largest valu propag easi see valu vertex reachabl x j g thu valu theorem 31 8k 1 oblivi prioriti pram algorithm use ni k n processor solv chain problem 2k step show oblivi prioriti pram algorithm simul comput level contigu prefix graph g label edg g follow let fx r j r 2 jg set input vertic reach vertex tail edg e label e j design memori cell mv correspond vertex v g step alloc processor pe level edg g two edg f label labelf pf higher prioriti pe alloc easi e edg v w pe read valu mv valu 0 pe noth otherwis write valu mw easi show valu mw maxfa r j w reachabl x r g solv chain problem input 1 first 1 n simpli solv restricteddomain prefixmaxima problem valu mx input state bound follow bound prefix graph 2 31 weak superconcentr prefix graph 7 prove prefix graph depth 2k edg improv lower bound show construct optim weak superconcentr direct acycl graph n vertic vertic outdegre 0 properti 8k exist vertex disjoint path fx fy j1 jk g depth weak superconcentr length longest direct path prove 11 weak superconcentr depth edg theorem 32 prefix graph depth 2k requir omegagamma ni k n edg show everi prefix graph weak superconcentr let x input output vertic prefix graph g 8k exist path x vertex disjoint 9p q 1 path jp x q jq common vertex path x q contradict 2 4 use function properti follow 11 defin tree k l l 1 k l leav depth k edg label power 2 outdegre root l outdegre everi vertex label edg come vertex parent describ construct k l start root edg vertic k l creat certain order think vertic given depth arrang left right order creation rule govern label edg depth label first edg creat 1 label jth edg creat twice maximum product label path start j gamma 1th edg creat end leaf initi root vertex v depth less k number children v creat far less label edg v parent less l v root creat new child v label connect edg per rule move new child number children creat far equal label edg v parent move parent v v root alreadi l children construct complet vertex depth k ie leaf simpli move back parent recal definit ackerman function previou section appendix shown maximum product label path k l root leaf suffici larg let h set leav label edg path root h order follow inequ hold 1 6 similar inequ prove 11 8 includ proof appendix shall prove other fact let v non leaf node tree k l let w next node right level let c label edg v w parent respect let e label edg v rightmost child v easili seen e 2 c e 2 c lemma 41 let c 1 c k label path root leaf 1 jhj leav tree left right lemma clearli hold path h 1 label 1 assum lemma hold path hm shall show hold path hm1 path hm hm1 diverg level call level r c 1 c r common level let c r1 c k r1 k remain label path hm hm1 respect note c r2 c k label rightmost children fact c j1 2 c j 1 induct hypothesi 8j 1 j1 sinc r1 c r1 c r c 2 r1 c r 2 j1 complet proof 2 lemma 42 function 0 k follow hold let l posit integ let consid set path root leaf properti set vertic pass level j k respect 2 vertic j left right consid path leftmost leaf among set consid path path pass v 1 let label path c j log label edg vertex right v 1 least done assum c j log lemma 41 1 log sinc c 1 c k c j c k log label edg vertex right v 1 fact 3 2 2y log log 2 2 corollari 41 inequ 7 0 k 0 k proof v vertex level j k l let c 1 v c j v label path root v order lemma 42 hand sinc label success edg level increas least factor two log edg level label exce 2 5 lower bound consid follow fact theorem 31 show obtain oblivi chain algorithm whose graph defin section 2 prefix graph theorem 32 everi prefix graph weak super concentr lower bound weak superconcentr known 11 given fact tempt conjectur graph everi oblivi chain algorithm prefix graph therebi directli obtain lower bound howev chain algorithm whose graph weak su perconcentr exampl consid algorithm first two step processor p 1 read x 1 x 2 without write anywher next two step p 1 write valu x 1 x 2 cell z 1 z 2 respect chain problem solv input z processor ever read cell x 1 x 2 graph comput path x 1 must pass vertex henc never vertex disjoint thu graph weak superconcentr simpl exampl gener necessari therefor care analyz structur graph chain algorithm prove prioriti algorithm solv chain problem n processor suffic prove follow theorem 51 n suffici larg oblivi prioriti algorithm solv chain problem size n k step processor graph algorithm termin k readwrit step let input output vertic g let h set leav k l defin previou section pick u random subset n pick element n independ probabl ph consid partial input fix valu input vertic g indic b vertex v g let f v denot indegre v let v j denot set vertic level 2j 0 j k call vertex consid high degre vertex c 2j fix b let p highest prioriti processor write c 2j input consist b ie set variabl p write c step j state p affect input vertic reach p 2j gamma 1 modifi b input vertex set input consist new b p fix valu c 2j c 2j fix b sinc p overrid processor write processor write c 2j modifi b set 0 variabl reach c c 2j call oper fix vertex carri follow two step procedur g j start 1 go k gamma 1 fix highdegre vertic v j start 1 go n set input vertic valu reach lowdegre vertic valu 1 except x claim end procedur undefin input vertic fix except possibl one see suppos one input vertex undefin set 1 except leftmost undefin input vertex x let partial input c let x j first input vertex right x valu 1 clearli x j exist set step b x reach lowdegre vertic howev two input consist c vertic reachabl x low degre vertic differ valu sinc high degre vertic fix henc state j remain fix input error write eab expect number input bit set process argument eab ej u 1 obtain upper bound e ab note fix highdegre vertic v thu variabl affect content v undefin variabl reach v lowdegre vertic henc v enumb input set fix enumb undefin input reach v low degre vertic actual fix fix state highest prioriti processor p write v processor write fix v 0 vertex repres memori cell v previou time step number input fix number input reach either two lowdegre vertic ie 2c j highdegre vertex v minimum two quantiti ie v 1 expect number bit set sum expect number bit set fix high degre vertex ie ea enumb bit set g thu ea upper bound eb expect number input set step b let j output vertex let reach j lowdegre vertic 2 u 6 jg j j process j step b pi 2 u j 2 u sinc event 2 u j 2 u independ pi 2 u j 2 u henc e number input set process j step b eb sum output vertic expect eb clearli multipli side c k h sum h 2 h interchang order summat get g let zv g notic v j disjoint union zv j w v j use observ rewrit get simplifi observ sum indegre cell vertic bound number edg number cell vertic bound 2k 2 p ie separ bound term lh call ii iii respect written sum two term separ vertic degre greater k1 n other thu use inequ 7b bound first term 7a c bound second find use 5 c simplifi ii get term iii estim use 4 c yield rh equat 1 estim use 6 3 give rh n k ngamma 2n thu rewrit equat 1 simplifi yield 6 nonoblivi lower bound techniqu use lower bound oblivi algorithm may extend nonoblivi algorithm conjectur similar lower bound algorithm abl prove case 2 although follow theorem may prove use comput similar use oblivi case use simpler comput hope illumin associ graph gab nonoblivi algorithm partial input b g ab level vertic 1 edg defin vector consist b step j vector consist b step j cell c note case edg cell vertic cell vertic v vertex gab defin sb v theorem 61 prioriti pram algorithm solv chain problem 2 step requires8 nlog n 1 processor 2 number processor use suppos termin 2 step gab consist 5 level number 04 vertic let e set edg level level gab easili seen partial input b j e b1 j p j e b2 j 2p level 2 vertex indegre ig j j z 0 consid highest prioriti processor p edg v state processor depend one input bit set input bit p write v let b partial input defin clearli j sb v fix manner fix vertic 0 let c partial input obtain procedur number bit set c 0 sinc fix vertex 0 involv set one bit level 2 vertic g ac fix written less 0 processor 2 state differ thing written vertex two valu processor may write case processor write two valu initi contain henc 8v j sc v processor read vertex 2i 0 differ valu written number state processor bound product twoie output vertic g ac suppos bit set c defin l bit c l j c undefin may final valu one l l j ml j1 sinc minim show r l j ml j1 e 2 e c4 edg p 3 c 4 let ge number differ valu p write c input consist c output vertex 4 let e set edg 4 number differ valu written 4 bound number valu differ processor write via edg e plu number valu case processor write henc sc 4 e2ey processor p 3 total number difer valu write edg lead bound c p 3 4i 0 sum quantiti processor give upper bound number difer valu written via edg e c4 thu equat 4 get j sc r l j ml j1 final equat 3 get sinc r n 2i0log n2 yield conclus open problem shown oblivi chain n processor thetaffn time leav open question whether o1 time nonoblivi algorithm exist recent chaudhuri radhakrishnan 9 settl question show omegagamma ffn lower bound chain algorithm use processor use random better perform may achiev situat raman 17 gave random algorithm run o1 time number 1s input larg conjectur arbitrari input constanttim chain possibl even use random acknowledg grate ravi boppana introduc work 6 11 mani help discuss indebt jaikumar radhakrishnan simpl proof upper bound innumer insight comment r optim separ concurr write parallel machin improv determinist parallel integ sort triplylogarithm parallel algorithm recurs startre parallel data structur recurs startre parallel data structur unbound fanin circuit associ function lower bound constant depth circuit prefix problem tight bound chain problem complex parallel prefix problem small domain upper lower time bound parallel random access machin without simultan write superconcentr gener gener connector limit depth simul among concurrentwrit model parallel comput count pack parallel integ sort parallel hash perfect hash graph entropi circuit complex parallel simplic compact chain power collis random parallel algorithm chain integ sort subset select parallel tr