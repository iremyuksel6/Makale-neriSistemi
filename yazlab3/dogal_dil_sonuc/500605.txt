learn onevari pattern languag effici averag parallel ask queri pattern finit string constant variabl symbol langaug gener pattern set string constant symbol obtain pattern substitut nonempti string variabl studi learnabl onevari pattern languag limit respect updat time need comput new singl hypothesi expect total learn time taken converg correct hypothesi result follow first design consist setdriven learner use concept descript pattern achiev updat time on2logn n size input sampl best previous known algorithm comput descript onevari pattern requir time on4logn cf angluin j comput system sci 21 1 1980 4662 second give parallel version algorithm requir time ologn on3logn processor erewpram third use modifi version sequenti algorithm subroutin devis learn algorithm onevari pattern whose expect total learn time ol2logl provid sampl string drawn target languag accord probabl distribut expect string length l probabl distribut must string equal length equal probabl arbitrari otherwis thu establish first algorithm learn onevari pattern languag expect total learn time provabl differ updat time constant factor final show algorithm descript onevari pattern use learn onevari pattern polynomi number superset queri respect onevari pattern queri languag b introduct pattern string constant symbol variabl symbol languag gener pattern set string obtain substitut string constant variabl cf 1 pattern languag variat thereof wide investig cf eg 17 18 19 continu interest pattern languag mani reason among learnabl full version paper avail technic report cf 4 limit pattern languag text cf 1 2 moreov learnabl pattern languag interest respect potenti applic cf eg 19 given effici becom central issu howev defin appropri measur effici learn limit difficult problem cf 16 variou author studi effici learn term updat time need comput new singl guess realli count applic overal time need learner converg ie total learn time one show total learn time unbound worstcas thu studi expect total learn time purpos motiv shortli summar known regard pattern languag learn output descript pattern hypothes cf 1 result learn algorithm consist setdriven learner setdriven iff output depend rang input cf eg 20 22 gener consist setdriven consider limit learn capabl cf eg 14 22 polynomi time algorithm comput descript pattern known henc alreadi updat time practic infeas moreov find descript pattern maximum possibl length npcomplet cf 1 thu unlik polynomialtim algorithm comput descript pattern maximum possibl length therefor natur ask whether effici pattern learner benefit concept descript pattern special case eg regular pattern noncross pattern union k regular pattern languag k priori fix studi case descript pattern polynomialtim comput cf eg 19 thu learner achiev polynomi updat time noth known expect total learn time anoth restrict obtain priori bound number k differ variabl occur pattern kvariabl pattern open polynomialtim algorithm comput descript kvariabl pattern fix k 1 cf 9 12 hand kvariabl pattern paclearn respect union kvariabl pattern hypothesi space cf 11 lang wiehagen 13 provid learner lwa pattern languag may output inconsist guess lwa achiev polynomi updat time setdriven cf 21 even iter thu beat angluin 1 algorithm respect space complex lwa expect total learn time exponenti number differ variabl occur target pattern cf 21 moreov point converg lwa definit depend appear suffici mani shortest string target lan guag algorithm mention least correspond correct proof depend thu follow problem aris natur exist effici pattern languag learner benefit concept descript pattern therebi depend present suffici mani shortest string target languag still achiev expect total learn time polynomi bound expect string length provid complet affirm answer studi special case onevari pattern believ case natur choic sinc nontrivi may exponenti mani consist pattern given sampl sinc first case polynomi time algorithm comput descript pattern known cf 1 angluin 1 algorithm find descript pattern run time 4 log n input size n alway output descript pattern maximum possibl length awar possibl improv run time certain special case hope studi would provid insight uniform improv present improv ie algorithm comput descript onevari pattern 2 log n step key idea achiev goal give necessarili find descript pattern maximum possibl length note result concern difficulti find descript pattern depend addit requir comput one maximum possibl length cf eg 1 12 thu result may least support conjectur effici learner may aris one definit tri find descript pattern maximum possibl length descript one instead moreov algorithm also effici parallel use ologn time n processor erewpram previous effici parallel algorithm learn onevari pattern languag known main result version sequenti algorithm still learn onevari pattern languag expect total learn time 2 log sampl string drawn target languag accord probabl distribut expect string length arbitrari except string equal length equal probabl particular shortest string may probabl 0 note expect total learn time differ constant factor time need updat actual hypothes hand could prove olog mani exampl suffici achiev converg final deal activ learn learner gain inform target object ask queri oracl show algorithm descript onevari pattern use learn onevari pattern ask polynomi mani superset queri anoth algorithm learn pattern languag polynomi number superset queri known use much power queri languag ie pattern one variabl even target pattern onevari pattern cf 3 11 pattern languag induct infer set natur number let real number x defin bxc greatest integ less equal x let finit alphabet contain least two element denot free monoid denot set finit nonnul string ie denot empti string let ing infinit set variabl pattern string length string 2 pattern denot jsj jj respect pat denot set pattern denot ith symbol eg call constant otherwis 2 x ie variabl use si denot ith symbol var denot number differ variabl occur x denot number occurr variabl x kvariabl pattern pat k denot set kvariabl pattern case denot variabl occur x denot string obtain substitut u j occurr x j tupl call substitut everi pattern 2 pat k defin languag gener pat k denot set kvariabl pattern languag denot set pattern languag note sever problem decid even effici solvabl pat 1 undecid npcomplet pat exampl gener pattern languag word problem npcomplet cf 1 inclus problem undecid cf 10 problem decid linear time onevari pattern languag hand pat 1 still incompar regular context free languag finit set call sampl pattern consist sampl l onevari pattern call descript consist consist one pattern l ae l next defin relev learn model start induct infer languag text cf eg 15 22 let l languag everi infinit sequenc string text l textl denot set text l let text r 2 set r initi segment length r denot rang r ie rg defin induct infer machin abbr iim algorithm devic take input initi segment text output everi input pattern hypothesi cf 7 definit 1 pat call learnabl limit text iff iim everi l 2 pat everi 2 textl 1 r 2 r defin 2 2 pat almost r 2 r learnabl onevari pattern languag defin analog replac pat pat pat 1 pat 1 respect deal setdriven learner often technic advantag describ depend relev set r ie sampl obtain input let refer n size sampl 3 studi noneras substitut eras substitut also consid variabl may replac lead differ languag class cf 5 pat well pat 1 constitut index class l uniformli recurs languag ie effect enumer l j j2in l recurs function f j 2 2 fj except section 3 use prammodel assum model comput represent pattern 1 next defin updat time total learn time let iim everi l 2 pat least number r stage converg tm r denot time comput r call tm r updat time total learn time taken iim success input defin final defin learn via queri object learn element index class l assum index class h well fix effect enumer hypothesi space l clearli h must compris l hypothesi h describ target languag l iff sourc inform target l queri oracl distinguish membership equival subset superset disjoint queri cf 3 input membership queri string output ye 2 l otherwis queri input index j output ye queri disjoint queri otherwis repli counterexampl return ie string 2 l4h j symmetr differ l h j respect alway assum queri answer truth definit 2 angluin 3 let l index class let h hypothesi space learn algorithm exactli identifi target l 2 l respect h access certain type queri alway halt output index j note learner allow one hypothesi must correct complex queri learner measur number queri ask worstcas 2 improv sequenti algorithm present algorithm comput descript pattern 2 pat 1 sampl input without loss gener assum 0 shortest string algorithm run time js 0 j log js 0 simpler much faster angluin 1 algorithm need time log js 0 j angluin 1 algorithm comput explicitli represent set consist onevari pattern output descript pattern maximum possibl length avoid find descript pattern maximum possibl length thu work polynomials subset consist pattern next review establish basic properti need later obtain substitut pattern 2 pat x pattern consist must string ff obtain substitut ff x given consist pattern set fff denot ff moreov sampl call prefixfre jsj 1 string prefix string note distinct prefixfre sampl nonprefix free sampl well pay lemma 2 prefixfre exist descript pattern 2 pat 1 least two string ff start differ symbol proof let u denot longest common prefix string pattern ux consist u shorter everi string sinc prefixfre consequ exist descript pattern 2 pat 1 know exist pattern 2 pat 1 longest common prefix string conclud henc least two string ff ux must start differ symbol 2 1g conss subset consist pattern prefixfre lemma 3 let prefixfre sampl conss 6 everi maximum length descript proof let prefixfre accord lemma 2 exist descript pattern belong conss thu conss 6 suppos maximum length descript thu moreov exist pattern 2 pat 1 l well l ae l henc lemma 1 know obtain substitut pattern x sinc least two string ff start differ symbol immedi get 1 2 x moreov least two string ff must also start differ symbol henc 2 conss note jj 1 sinc otherwis contradict l ae l final jj 1 may conclud contradict maximum length thu pattern exist henc descript 2 next explain handl nonprefixfre sampl algorithm check whether input sampl consist singl string happen output termin otherwis test whether 0 prefix string case output ux 2 pat 1 u prefix 0 length js termin clearli lux suppos pattern l l ae lux lemma 1 appli ie thu 6 l consequ ux descript otherwis jsj 2 0 prefix string thu lemma 3 suffic find output longest pattern conss improv algorithm prefixfre sampl base fact jconssj bound small polynomi let k l 2 k 0 call pattern x l occurr constant k lpattern k lpattern length k thu k lpattern conss satisfi js refer length string substitut occurr x relev k lpattern obtain 0 therefor bj 0 jkc possibl valu l fix valu k henc number possibl k lpair k lpattern conss exist bound algorithm consid possibl k lpair turn describ algorithm one specif k lpair k lpattern 2 conss string ff 2 ff must satisfi substr length start first posit input string differ js 2 consist k lpattern comput perform k lpair follow lemma show k lpattern conss uniqu exist lemma 4 let prefixfre sampl everi given k lpair one k lpattern conss proof lemma 4 directli yield algorithm 1 either return uniqu k lpattern 2 conss nil k lpattern conss assum subprocedur take input sampl return longest common prefix u algorithm 1 input k l u follow l b k c l els l l return els return nil fi note minor modif algorithm 1 perform consist test even construct put lemma 4 fact oj possibl k lpair togeth directli obtain lemma 5 prefixfre sampl g use algorithm 1 subroutin algorithm 2 find descript pattern prefixfre sampl follow strategi exemplifi thu simpli comput pattern conss output one maximum length input size n overal complex algorithm js 0 j log js 0 2 log n sinc oj 0 j log js 0 test must perform time complex algorithm 2 input follow pi k js0 output maximumlength pattern 2 p note number k lpair process often smaller oj sinc condit js restrict possibl valu k string equal length also advantag process k lpair order nonincreas k l algorithm termin soon find first consist pattern howev worstcas complex improv descript pattern x final summar main result obtain follow theorem theorem 1 use algorithm 2 subroutin pat 1 learn limit setdriven consist iim updat time 2 log n input sampl size n 3 effici parallel algorithm wherea ram model gener accept suitabl model develop analyz sequenti algorithm consensu yet reach area parallel comput pram model introduc 6 usual consid accept compromis pram consist number processor local memori execut local program commun exchang data share memori variant pram model differ constraint simultan access memori locat differ processor crewpram allow concurr read access concurr write ac cess eas present describ algorithm crewpram model algorithm modifi run erewpram howev use standard techniqu comput descript onevari pattern known previous algorithm 2 effici parallel use wellknown techniqu includ prefixsum treecontract listrank subroutin cf 8 parallel algorithm handl nonprefixfre sampl way algorithm 2 check singleton 0 prefix string requir time olog n use log n processor thu may assum input sampl prefixfre addit assum prefixtest return first posit input string differ index parallel algorithm handl oj 0 j log js 0 possibl k lpair par allel k lpair algorithm comput uniqu candid k lpattern conss exist check whether l suffic output obtain pattern maximum length next show effici parallel two step given k lpair algorithm use string 0 calcul uniqu candid k lpattern conss reduc processor requir modif lemma 4 show candid pattern remain uniqu posit j said bcorrespond posit j 0 0 k mean bcorrespond posit follow suppos consist k lpattern fs posit j 0 0 correspond 2 1 jj b occurr x left correspond posit comput candid pattern 0 algorithm calcul entri array equalj b boolean valu first j rang 1 js 0 j b 0 k equalj b true iff symbol posit j 0 symbol bcorrespond posit thu array defin follow equalj array equal okj 0 entri calcul constant time thu use okj 0 log n processor equal comput time olog n moreov direct graph g forest binari intre built equal candid pattern calcul g use treecontract prefixsum listrank detail omit due space restrict thu prove lemma 6 let sampl n size given array equal uniqu candid k lpattern conss nil pattern exist comput erewpram time ologn use okj 0 processor algorithm either discov k lpattern exist obtain candid k lpattern latter case test whether consist lemma 7 given candid pattern consist sampl size n check time ologn use log n processor crewpram put togeth obtain follow theorem theorem 2 exist parallel algorithm comput descript onevari pattern time ologn use oj n processor crewpram sampl size n note product time number processor algorithm time spent improv sequenti algorithm larger product exce time sequenti algorithm factor less oj 4 analyz expect total learn time deal major result present paper ie expect total learn time sequenti learner let target pattern total learn time algorithm tri infer unbound worst case sinc infinit mani string l mislead howev best case two exampl ie two shortest string 0x 1x alway suffic learner output descript pattern guess henc assum string present algorithm drawn l accord certain probabl distribut comput expect total learn time algorithm distribut must satisfi two criteria two string l equal length must equal probabl expect string length must finit refer distribut proper probabl distribut design algorithm 1la infer pattern 2 pat 1 expect total learn time 2 log advantag calcul descript pattern time new string read instead algorithm 1la read certain number string start perform comput wait length sampl string smaller number sampl string read far least two differ sampl string read first two phase output 1 first sampl string guess sampl string read far x otherwis constant pattern correct hypothesi alway output algorithm never reach third phase otherwis algorithm use modifi version algorithm 2 calcul set p 0 candid pattern enter phase 3 precis calcul whole set p 0 instead use function first cand obtain longest pattern p 0 function next cand repeatedli obtain remain pattern p 0 order nonincreas length substanti reduc memori requir pattern obtain call first cand use current candid new string compar 2 l output otherwis next cand call obtain new candid 0 0 current candid output independ 2 l 0 longest common prefix sampl string includ shorter sampl string exclud howev first cand call new list candid pattern consid thu algorithm 1la may output inconsist hypothes algorithm 1la shown figur 1 let defin follow string w fvxg otherwis denot u longest common prefix set pattern comput algorithm 1 2 omit consist check henc p 0 conss conss defin section 2 p 0 necessarili contain pattern 0 2 l longest common prefix 0 longest constant prefix assum first cand 0 return return i1 sinc omit consist check call first cand subsequ call next cand either correct pattern found prefix chang perform time ojsj 2 log jsj show algorithm 1la correctli infer onevari pattern languag text limit correctli infer onevari pattern languag text probabl 1 sampl string drawn l accord proper probabl distribut 4 theorem 3 let arbitrari onevari pattern algorithm 1la correctli infer text limit 4 note learn languag l limit learn l string drawn l accord proper probabl distribut r 0 repeat r r string sr string sr f phase 3 g shortest string fs1 prefix fs1 string fs1 longer els 0 string fs1 differ posit juj first candss 0 forev read string 00 u prefix 00 common prefix 00 first candss 0 els output hypothesi od fig 1 algorithm 1la theorem 4 let 2 pat 1 sampl string drawn l accord proper probabl distribut algorithm 1la learn probabl 1 proof output read first string converg otherwis let string gamma 1 constant symbol 2 pat 1 fg algorithm 1la read two string differ posit pattern one candid set p 0 implicitli maintain algorithm string r r 1 satisfi 1 6 r probabl jaj gamma 1jaj 12 event must happen probabl 1 long current candid differ probabl next string read belong l least 12 cf lemma 8 henc candid pattern discard probabl 1 current candid output algorithm converg 2 lemma 8 let ux onevari pattern constant prefix u arbitrari 0 juj let 6 pattern p 0 fs gener string drawn l accord proper probabl distribut probabl least jaj gamma 1jaj analyz total expect learn time algorithm 1la obvi ousli total expect learn time target pattern 2 henc assum follow contain least one occurr x next recal definit median establish basic properti use later er denot expect random variabl r definit 3 let r random variabl ranger median r number 2 ranger prr 1and prr 1proposit 1 let r random variabl ranger median satisfi 2er lemma 9 let proper probabl distribut let l random variabl take valu length string drawn l respect let median l let expect expect number step perform algorithm 1la phase 1 proof let l random variabl whose valu length ith string read algorithm clearli distribut l l let r random variabl whose valu number string algorithm 1la read phase 1 let l sigma lr number symbol read algorithm 1la phase 1 let w 1 random variabl whose valu time spent algorithm 1la phase 1 obvious w claim 1 el el 1 l must least provid r equat 1 prove follow similarli shown el r furthermor clear el r rewrit el sigma el el sigma r el sigma use well equat 1 3 obtain el fi use equat 1 2 obtain el use r assumpt lemma 9 estim expect number step perform phase 2 follow lemma 10 phase 2 expect number step perform algorithm 1la final deal phase 3 let l lemma 9 averag amount time spent phase 3 estim follow lemma 11 phase 3 expect number step perform call function first cand next cand 2 log lemma 12 phase 3 expect number step perform read string log proof denot w rthe number step perform read string phase 3 make distinct string read correct set candid pattern consid string read afterward end phase 3 former account random variabl v 1 latter v 2 correct set candid pattern ie set contain yet consid probabl new string forc correct set candid pattern consid 12 denot k random variabl whose valu number string read phase 3 correct set candid pattern consid assum correct set candid pattern p 0 contain pattern consid pattern pattern probabl string drawn l accord proper probabl distribut languag 12 either addit variabl addit constant symbol lemma 8 denot v 2 step perform read string ith pattern p 0 consid log r obtain oel log oelr log r henc ew r lemma 13 phase 3 expect number step perform check whether current candid pattern gener newli read sampl string log put togeth arriv follow expect total learn time requir algorithm 1la theorem 5 sampl string drawn l accord proper probabl distribut expect string length expect total learn time algorithm 1la 2 log 5 learn superset queri pat learnabl polynomi mani queri equival membership subset queri allow provid result may easili extend pat 1 howev posit result also known first pat exactli learnabl use polynomi mani disjoint queri respect hypothesi space pat fin fin set finit languag cf 13 proof techniqu easili extend pat 1 second angluin 3 establish algorithm exactli learn pat respect pat ask ojj 2 jjjaj mani superset queri howev requir choos gener pattern ask queri definit work hypothesi space pat 1 henc natur ask exist superset queri algorithm learn pat 1 respect pat 1 use polynomi mani superset queri use result previou section abl answer question af firm nevertheless wherea pat learn respect pat restrict superset queri ie superset queri return counterexampl queri algorithm need counterexampl interestingli need counterexampl everi queri answer neg instead two counterexampl alway suffic next theorem show onevari pattern learnabl polynomi number restrict superset queri theorem 6 algorithm exactli identifi l 2 pat 1 gener pattern length n respect pat 1 use restrict superset queri restrict equival queri must make least jaj ngamma2 2 ngamma2 queri worst case furthermor show learn pat 1 polynomi number superset queri imposs algorithm may ask singl counterexampl theorem 7 algorithm exactli identifi onevari pattern languag restrict superset queri one unrestrict superset queri need least 2 queri worst case k length counterexampl return new algorithm ql work follow see figur 2 assum algorithm learn pattern first ql ask whether l hold case iff answer ye ql know right result otherwis ql obtain counterexampl c0 2 l ask answer ql comput g know start c0 ith posit ask l lc0 determin case sinc would impli ql use counterexampl queri l lc0 x construct set xg construct two counterexampl differ ith posit coincid first posit els l lc0 x els fc0 cc0 xg r conss repeat maxr r r n fg l l fig 2 algorithm ql algorithm learn pattern superset queri queri form l l 2 pat 1 chosen algorithm answer queri l l algorithm ask counterexampl c w denot prefix w length maxr maximumlength element r algorithm 2 section 2 comput coincid first narrow search set r candid let length shortest counterexampl log lemma 5 task left find among pattern r find remov pattern r use follow lemma lemma 14 let impli ql test l l maximum length pattern 2 r remov r l 6 l iter process final yield longest pattern l l lemma 14 guarante thu theorem 8 algorithm ql learn pat 1 respect pat 1 ask superset queri queri complex ql ojjm log mani restrict superset queri plu two superset queri first two queri answer everi languag l 2 pat 1 length shortest counterexampl return thu queri complex ojjm log learner compar well angluin 3 learner ojjjaj restrict learn pat 1 use much power hypothesi space pat long length shortest counterexampl return larg acknowledg substanti part work done second author visit kyushu univers visit support japanes societi promot scienc grant 106011 fifth author kindli acknowledg support grantinaid scientif research c japan ministri educ scienc sport cultur grant 07680403 r find pattern common set string induct infer formal languag posit data machin learn effici learn onevari pattern languag posit data relat two pattern compar languag parallel random access machin languag identif limit introduct parallel algorithm time infer gener pattern languag inclus undecid pattern languag polynomialtim algorithm learn kvariabl pattern languag exampl note twovari patternfind problem system learn introduct learn theori cognit comput scientist induct infer pattern eatc bulletin return pattern pattern infer formal principl languag acquisit lang wiehagen pattern languag learn algorithm averagecas analysi respect total learn time guid tour across boundari learn recurs languag tr theori learnabl system learn introduct learn theori cognit comput scientist complex induct infer pattern languag exampl queri note twovari patternfind problem determinist simul ideal parallel comput realist one prudenc condit formal languag learn polynomialtim algorithm learn italickitalicvari pattern languag exampl polynomialtim infer arbitrari pattern languag effici pram simul distribut memori machin introduct parallel algorithm lang wiehagen pattern languag learn algorithm queri concept learn polynomi time infer extend regular pattern languag inclus undecid pattern languag polynomi time infer gener pattern languag relat two pattern compar languag pattern infer guid tour across boundari learn recurs languag induct infer unbound union pattern languag posit data monoton nonmonoton induct infer function pattern parallel random access machin ctr john case sanjay jain rdiger reischuk frank stephan thoma zeugmann learn subclass regular pattern polynomi time theoret comput scienc v364 n1 p115131 2 novemb 2006 thoma zeugmann learn limit stochast finit learn theoret comput scienc v364 n1 p7797 2 novemb 2006