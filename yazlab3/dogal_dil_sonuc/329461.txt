codemot prune techniqu global schedul highlevel synthesi asic code gener asip presenc condit behavior descript repres obstacl exploit parallel exist method use greedi choic way search space limit appli heurist exampl might miss opportun optim across basic block boundari treat condit execut propos construct method allow gener code motion schedul code motion encod form unifi resourceconstrain optim problem approach mani altern solut construct explor search algorithm optim solut kept search space method cope issu like specul execut code duplic moreov tackl constraint impos advanc choic control pipelinedcontrol delay limit branch capabl underli time model support chain multicycl task code motion account may lead larger search space codemot prune techniqu present prune proven keep optim solut search space cost function term schedul length b introduct highlevel synthesi applicationspecif integr circuit asic code gener applicationspecif instruct set processor asip four main difficulti face schedul condit loop present behavior descript npcomplet resourceconstrain schedul problem 1 leav ineufsc brazil partial support cnpq brazil fellowship award n 200283944 bthe limit parallel oper within basic block avail resourc poorli util c possibl state explos number control path may explod presenc condit dthe limit resourc share mutual exclus oper due late avail test result method appli differ heurist subproblem basicblock schedul code motion code size reduct independ heurist use decid order oper schedul like mani flavor prioriti list anoth decid whether particular code motion worth 1028 yet anoth reduct number state 31 result approach might miss optim solut propos formul 29 encod potenti solut interdepend subproblem formul abstract lineartim model allow us concentr order oper avail resourc differ prioriti encod use induc altern solut mani solut gener explor basic idea highqual solut search space code motion specul execut taken account sinc number explor solut control paramet search method approach allow tradeoff accuraci search time approach code motion principl unrestrict although constrain avail resourc code motion typic lead larger search space envisag techniqu reduc search time main contribut paper codemot prune techniqu techniqu first captur constraint impos downward code motion constraint use criterion select effici code motion show experiment evid induc solut space higher densiti goodqual solut codemot prune appli consequ given local search method number explor solut applic techniqu typic lead superior local optimum convers smaller number solut explor reach given schedul length correl reduct search time paper organ follow section 2 formul problem show represent survey exist method tackl problem describ section 3 approach summar section 4 support global schedul describ section 5 section 6 show constraint impos code motion captur explain codemot prune techniqu section 7 list main featur approach experiment result summar section 8 conclud paper section 9 remark suggest research proof codemot prune present appendix 21 motiv condit present behavior descript introduc basic block bb structur instanc descript figur 1a four bb depict shadow box figur i1 i9 repres input o1 o2 repres output x z local variabl oper label small letter bracket bb label capit letter i5 i6 els descript b c0 1k l figur basic block structur assum adder subtract compar avail could think schedul independ nevertheless straightforward approach would effici amount parallel insid bb limit exampl bb adder would remain idl two cycl even though oper q bb l could schedul step either k l exampl suggest exploit parallel across bb boundari allow oper move one bb anoth call code motion oper q allow move bb l bb cycl save bb l note oper q alway execut regardless result condit c 1 hand oper n condit execut depend result condit c 1 say oper n control depend condit c 1 howev oper data depend oper l could schedul time step code motion violat control depend execut evalu condit soon outcom c 1 known result either commit discard techniqu call specul execut result condit turn true cycl save gener case may necessari insert extra code order clean outcom move oper socal compens code exampl howev compens code need variabl z overwritten oper n consid move oper q bb k execut parallel oper n howev oper q must alway execut oper bb k execut result c 1 fals copi q place end bb j result say code duplic take place exampl duplic save cycl result c 1 fals impact differ applic domain controldomin applic normal requir path optim much possibl role code motion obviou hand dsp applic unnecessari optim beyond given global time constraint 20 although highli optim code might imper code motion overlook even dsp applic reduc schedul length longest path consequ tighter constraint import code motion becom earli phase design flow optim object dictat realtim requir embed system design longest possibl execut time piec code must still meet realtim constraint 6 fact motiv formul problem term schedul length see section 22 moreov earli phase tend iter sever time runtim effici imper often need fast accur estim term schedul length 14 reason motiv develop techniqu prevent prune ineffici code motion see section 6 approach advantag take code motion account bestow expens much larger search space due codemot prune 22 formul order defin optim problem repres specif data control depen denci solut problem form graph defin definit 1 control data flow graph e direct graph node repres oper edg repres depend assum cdfg special node repres condit construct exampl shown figur 1b descript figur 1a circl repres oper triangl repres input output pentagon node associ controlflow decis branch node b distribut singl valu differ oper merg node select singl valu among differ one branch merg node control condit whose result carri control edg dash edg figur 1b detail explan symbol semant found 9 definit 2 state machin graph direct graph node repres state edg repres state transit smg seen skeleton state transit diagram underli finit state machin whose formal definit found 7 keep track code motion use auxiliari graph condens cdfg deriv use depthfirst search defin definit 3 basic block control flow graph direct graph node repres basic block edg repres flow control oper cdfg enclos pair branch merg node control condit condens form basic block bbcg branch merg node cdfg control condit condens singl branch merg node bbcg domain input output node condens singl input output node instanc bbcg depict figur 1c explicitli show bb structur descript figur 1a circl repres basic block bb associ set oper cdfg bbcg domain branch node b repres control select merg node repres data select cdfg contain condit oper may execut differ condit execut condit oper group oper repres boolean function call predic whose variabl call guard 26 guard g k boolean variabl associ output condit c k descript figur 1a condit c 1 associ guard g 1 cons quenc oper n execut predic g 1 g 1 respect oper enclos bb execut condit path bbcg input output defin sequenc bb valu guard data depend taken path determin execut time set oper enclos bb given path call execut instanc exi path bbcg correspond exactli one exi cdfg let us formul resourceconstrain problem address paper optim problem op given number k function unit acycl cdfg find smg depend cdfg obey resourc constraint satisfi function unit type function cost f l 1 l 2 l n minim l schedul length th path bbcg f monoton increas function solut op said complet valid schedul exist everi possibl execut instanc sinc condit resourc share affect time avail guard valu solut said causal guard valu use time avail feasibl solut satisfi constraint must causal complet 31 previou highlevel synthesi approach pathbas schedul pb 25 socal asfastasposs afap schedul found path independ provid fix order oper chosen advanc due fix order fact schedul cast cliqu cover problem interv graph code motion result specul execut allow origin method recent extend releas fix order 3 reorder oper perform insid bb reorder allow across condit oper would destruct notion interv foundat whole pb techniqu consequ although reorder improv handl complex dataflow method support specul execut limit exploit parallel 7with complex control flow 19 limit releas treebas schedul tb 15 specul execut allow afap approach conserv keep path tree howev sinc notion interv lost list schedul use fill state oper condit vector list schedul cvl 31 allow code duplic support form specul execut although shown 27 underli mutual exclus represent limit approach would possibl remain valid extens origin condit vector altern represent suggest 1 27 hierarch reduct approach hra present 18 cdfg condit transform equival cdfgwithout condit schedul convent schedul algorithm code duplic allow specul execut support 28 approach present codemot exploit first bb schedul use list schedul sub sequent code motion allow one prioriti function use bb schedul anoth code motion code motion allow insid window contain bb keep runtim low iter improv need avoid restrict much kind code motion allow among method pb exact solv partial problem specul execut allow tb cvl address bb schedul code motion simultan use classic list schedul heurist 28 differ heurist appli subproblem method may exclud optim solut search space 26 exact symbol techniqu present never theless use exact method earli iter phase design flow unlik especi prune present cope larger search space due code motion 32 previou approach compil arena traceschedul ts 10 main path trace chosen schedul first independ path anoth trace chosen schedul first resourc unconstrain schedul produc heurist map avail resourc ts allow certain type code motion across main trace downsid ts maintracefirst heurist workwel applic whose profil show highli predict control flow eg numer applic percol schedul ps 23 defin set semanticspreserv transform convert program parallel one primit transform induc local code motion ps iter neighborhood schedul algorithm atom transform code motion combin permit explor wider neighborhood heurist use decid code motion worth prioriti assign transform applic direct first import part code import aspect ps primit transform potenti abl expos avail instructionlevel parallel anoth system transform present 11 base notion region controlequival bb oper move one region anoth applic seri primit transforma tion origin ps essenti resourc constrain parallel techniqu extend heurist map ideal schedul avail resourc 2225 drawback heurist map resourc perform ts ps 22 25 greedi code motion undon 8 21 sinc accommod within avail resourc effici global resourceconstrain parallel techniqu report 82130 whose key issu twophas schedul scheme first set oper avail schedul comput global heurist use select best one among 8 global resourceconstrain percol schedul grcp techniqu describ best oper select actual schedul take place sequenc ps primit transform allow oper migrat iter origin final posit global resourceconstrain select schedul gss techniqu present 21 oppos grcp global code motion select oper perform instead appli sequenc local code motion result present 21 give experiment evid although ps gss achiev essenti result gss lead smaller parallel time 33 contribut relat previou work one hand keep approach major achiev resourceconstrain schedul recent year follow like global schedul method 82130 approach also adopt global comput avail oper howev implement differ sinc base cdfg unlik mention approach bwe perform global code motion way similar 21 differ 8 11 sequenc primit transform appli hand distinguish approach relat work follow formul differ mention method respect order oper process allow proper explor altern solut use heuristicbas select instead select base prioriti encod determin extern therefor tunabl search engin see section 4 bunlik resourceconstrain approach 82130 provid support exploit downward code motion see section 61 c main contribut new codemot prune techniqu take constraint impos code motion account prevent ineffici code motion see section 62 envisag approach restrict impos beforehand neither kind code motion order oper select schedul section introduc construct approach free restrict outlin approach shown figur 2 solut encod permut oper cdfg solut explor creat permut solut constructor build solut permut evalu cost explor base local search algorithm 24 select solut lowest cost build solu tion constructor need check mani time condit resourc share test model boolean queri direct socal boolean oracl term coin 4 allow us abstract way queri implement detail view explor scope paper way permut gener accord criteria given local search algorithm found 13 focu solut constructor constructor cost explor boolean oracl figur outlin approach keep highqual solut search space design constructor follow properti hold first neither greedi choic made restrict impos code motion see section 52 74 second prune use discard lowqual solut prevent gener solut certainli lead lower cost see section 62 third everi permut gener complet causal solut see section 73 although method ensur optim solut alway reach consequ localsearch formul least one optim solut kept search space proof claim found appendix 13 gener method allow trade cpu time solut qualiti practic implement method succe find optim solut short cpu time test benchmark see section 8 51 support code motion specul execut use predic model condit execut oper base time avail guard valu distinguish two kind predic predic g said static repres execut condit oper valu guard avail dynam predic repres execut condit oper one guard valu may avail given time step note static predic abstract rel posit time complet condit execut controldepend oper predic use keep track code motion use check condit resourc share g use check whether result specul execut oper commit assum oper move bb bb j let g g j static predic bb j respect product g j give static predic oper figur 1 instanc oper q duplic bb j k copi q bb j execut copi q bb k execut code motion may lead specul execut gmay repres actual execut condit guard valu may time avail new predic must comput drop consider guard whose valu avail observ necessari prevent specul execut might lead noncaus solut figur 1 instanc static predic oper move bb j bb oper specul execut bb actual execut condit given dynam predic insid new bb alway execut note dynam predic condit result produc static predic g condit result commit algorithm show obtain dynam predic predic g given time step endc k stand complet time condit c k assum time slot 0 function support smooth repres concept boolean algebra definit found 7 dynamicpredicateg step slot foreach algorithm 1 evalu dynam predic condit resourc share construct solut need check two oper share resourc differ execut condit let j denot two oper oper share resourc given time step ident j 0 hold boolean oracl use answer queri well comput predic 52 schedul engin solut constructor take permut explor gener solut construc tor borrow techniqu construct topologicalpermut schedul 13 schedul construct permut follow schedul select oper schedul one one instant first readi oper unschedul oper whose predecessor schedul permut select select oper schedul earliest time free resourc avail 13 proven optimum schedul alway among creat principl topologicalpermut construct c e b f g c c f f f e f schedul time step schedul evolut c f els e descript c figur use topolog permut schedul figur 3 shown lineartim sequenc construct topolog permut schedul given behavior descript cdfg shown figur 3a 3b util resourc model place oper entri resourc util vector ruv shown figur 3a entri ruv differ function unit first appli schedul without pay attent mutual exclus show principl see figur 3c second experi appli mutual exclus case oper b schedul second step share adder oper c see figur 3d assum outcom avail insid first step allow b condit share resourc result schedul length reduc 5 step exi note howev could schedul two step thu inform mutual exclus clearli enough limit lineartim model allow effici solut mechan split lineartim sequenc expos flow control mechan base addit inform extract cdfg explain next section 6 method prune ineffici code motion 61 captur encod freedom code motion method want captur freedom code motion without restrict purpos introduc notion link link connect oper u cdfg bb v bbcg given follow interpret oper u execut predic defin execut oper bb v oper link sever mutual exclus bb may belong mani execut instanc figur 4 illustr link concept els e descript b figur link concept initi link encod freedom code motion use set initi link given oper initi link point latest bb given path oper still execut initi link obtain follow first look socal termin oper termin either direct predecessor output node direct predecessor branch merg node whose result must avail control select data select figur 4 condit termin result condit must alway avail control select take place even though oper b direct predecessor branch node termin affect control select oper c termin result must avail prior data select oper e obvious termin termin attach branch merg output node cdfg link bb preced correspond branch merg output node bbcg figur 4 initi link shown termin c due data select due control select e due output afterward link non termin oper predecessor termin link bb latter link oper initi link shown figur bb b bb c oper b singl initi link point bb c initi link interpret follow condit must execut latest bb result must avail control select branch oper c must execut latest bb b oper latest bb c result must avail prior select merg note initi link encod freedom code motion downward mean oper free execut insid preced bb path soon data preced resourc constraint allow control depend satisfi need execut oper latest insid bb point initi linkth underli idea travers bbcg topolog order tri schedul oper visit bb even oper origin belong observ oper u given initi link bb v v reach travers u must schedul insid bb v say assign oper u bb v compulsori equival oper u compulsori bb v notion compulsori assign oper allow us identifi control depend violat also notion one key prune techniqu shown next subsect final assign link call final oper assign call simpli assign schedul respect oper insid point bb obey preced constraint impli need avail function unit assign might increas regist andor interconnect usag includ search space assign oper u bb v given follow attribut begin start time oper u insid complet time oper u insid bb v c g static predic dynam predi cate note assign repres relativetim encod absolut time controldepend given instant bb v start execut plu valu attribut begin handl redund oper may redund path behavior descript shown 15 method redund elimin gener initi link oper b figur 4 instanc link bb c even though origin describ bb belong path tb 15 use tree optim remov redund propag oper latest bb use cvl 31 elimin use extend condit vector even though remov redund method care encod freedom code motion properli code motion determin heuristicbas prioriti function anyway exampl order cast controlflow graph tree structur tb duplic oper bb succeed merg node consequ priori duplic tb loos inform freedom code motion due data select inform could use construct solut avoid ineffici code duplic b c e f els e descript bbcg b figur link uncondit oper freedom code motion initi link elimin redund also encod freedom code motion figur 5 f may link bb bb c bb b bb initi link control depend satisfi f must execut output avail oper f execut bb preced bb soon resourc data depend constraint satisfi unrestrict code motion exploit 62 codemot prune travers topolog order solut constructor follow flow token cdfgwhile bbcg travers topolog order oper assign travers bb soon data preced resourc constraint allow first readi oper permut attempt schedul insid visit bb notic travers oper may readi given exi anoth figur 3d instanc oper g readi third time step fifth step exi e f g reason say oper readi predic g given bb oper readi belong path contain bb given initi link u v assign oper bb visit compulsori long bb v reach bb v reach travers u schedul insid bb v initi link becom final assign howev oper u succe schedul insid ancestor w bb v induc code motion initi link revok replac final assign oper attempt schedul insid travers bb accord criteria criterion 1 codemot prune let oper initi link point bb j readi predic g visit bb ij schedul would requir alloc exactli delayo extra time step accommod execut oper schedul insid bb prevent code motion bb j bb criterion 2 construct schedul visit bb predic g first oper readi predic g reject criterion 1 schedul earliest time insid bb claim applic criteria 1 2 discard better solut optim problem defin section 2 see proof 13 appendix split lineartim sequenc note oper allow alloc extra time step accommod execut insid visit bb assign bb compulsori j make space schedul noncompulsori oper idl resourc readi oper satisfi criterion 1 constructor stop schedul bb anoth bb visit observ result global schedul lineartim sequenc instead sequenc split time travers cross branch flow control kept expos criterion 1 respons split lineartim sequenc decid stop schedul bb prior control data select note decis base constraint resourc constraint control data depend counterexampl heurist criterion use tb lineartim sequenc split time condit turn oper higher prioriti readi queue 15 exampl figur 6 exampl use figur 3 schedul illustr method first show figur 6b exi would schedul independ appli topolog permut schedul note exi e f g schedul five step exi g schedul 2 step yet possibl overlap sequenc b share adder b 0 outcom condit avail insid first step tent solut would noncaus consequ infeas even though path afap schedul given conflict one sequenc chosen impos extra step show constructor gener feasibl solut figur 6c initi link depict figur 6d 6k evolut construct process shown oper circl bold mark current bb travers notic figur 6d even though readi oper e b preced schedul one oper reject criterion 1 compulsori current bb schedul figur 6e step idl adder exist point readi oper schedul bb would requir alloc extra step criterion 1 anoth bb taken figur 6f figur 6k show final result obtain schedul exi 1 independ figur 6b exi 2 need extra step note b exchang solut figur 5b would obtain exi 1 would need extra step conflict happen path method solv certain way induc exist anoth permut induc anoth solut conflict solv opposit way limit search space observ assign oper b first step repres specul execut allow specul execut exi need extra step result schedul length 3 6 c e b f g b f b f c e f c e c e c f e c e c f b c e f g c c c c c c c f figur split lineartim sequenc notion order domin notion time step oppos approach 3118 method use time primari issu decid posit oper instead notion order avail resourc use assign incorpor relativetim encod time use manag resourc util insid bb c j unscheduledscheduledpr asap annot algorithm 2 solut constructor solut constructor summar algorithm 2 permut c set bb u oper v bb assign start time oper u insid bb v function return bb arbitrari topolog order candid assign creat pair uv condit unschedul scheduledpr evalu condit hold earliest step bb v free resourc found function issuit decid whether candid assign commit revok check criterion 1 compulsori oper schedul room schedul other new bb taken function solvecodemot insert compens code duplic succe runtim complex let n number oper b number bb p number path c number condit readi oper kept heap data structur search first readi oper take olog n search may repeat oper bb worst case complex algorithm 2 ob n log n runtim effici approach depend p grow exponenti c oppos pathbas method wewil illustr applic codemot prune discard better solut goal provid outlin proof appendix origin solut induc permut tri construct better solut n figur 7 8 oper 1 4 addit 1 3 subtract 1 multipl assum one resourc type grey entri util vector ruv mean either resourc occupi oper occupi due data depend grey field use abstract oper concentr certain scope figur 7a 8a show differ solut gener constructor mean construct follow criterion 1 exampl oper 1 schedul insid bb must prevent schedul p note empti field mean oper could schedul idl resourc due data depend solut wewil construct new solut n shown figur 7b 8b allow 1 boost bb pwhere alloc exactli step make room oper bb move wewil consid two differ scenario code motion show 1 allow boost bb p better result would reach term schedul length 4 1 2 3 b r 1 2 3 4 r a4 a1 a2 a3 figur first scenario figur 7 assum oper 4 move bb r alloc step notic even though a4 preced a1 a2 permut a4 could schedul time step either s1 s2 figur 7b possibl origin solut mean schedul engin must detect data depend moreov 3 could move step alloc bb p result number step freed number alloc step path shorten note figur 7 even though optimist assum boost oper complet freed step move better solut could reach figur 8 illustr case path p q r shorten possibl oper a4 move first step bb p fill entri occupi oper figur 8b notic s1 schedul time step a4 howev possibl indic empti field first step bb q figur 8a mean schedul detect data depend data depend violat code motion solut n infeas 2 4 1 b r 1 2 4 r a4 a1 a2 a3 figur exampl suggest given permut possibl obtain feasibl solut shorter path solut gener solut constructor feasibl solut could obtain best good construct one underli idea illustr instead allow arbitrari code motion gener topologicalpermut schedul engin solut criterion 1 obey construct lead notion codemot prune sinc applic criterion 1 prune better solut appendix topolog 2calpermut construct guarante least one permut return optim schedul length 13 conclud codemot prune keep least one optim solut search space section summar main featur approach organ follow first two subsect show howw support constraint impos advanc choic control third subsect explain method gener complet causal solut last subsect describ type code motion support approach 71 support pipelinedcontrol delay shown 17 approach found literatur assum fix control architectur would produc infeas solut differ control architectur one constraint limit branch capabl control see next subsect anoth impos pipelin control pipelin regist use reduc critic path control data path 16 delay time step condit execut time step guard valu allow influenc data path guard valu avail within time slot complet respect condit figur 9a illustr effect pipelinedcontrol delay assum singl adder pipelinedcontrol delay 2 cycl valu guard g 1 avail execut earli enough shown figur c delay slot b c g 1 b figur 9 effect pipelinedcontrol delay algorithm 1 consid effect delay slot illustr applic figur 9b static dynam predic shown oper e condit share adder also oper grey specul execut respect condit c 2 exampl emphas import specul execut fill time slot introduc pipelin latenc 72 support limit branch capabl simpl control use eg sake retarget microcod state transit underli fsm limit branch capabl chosen control figur illustr problem figur 10a show static predic oper exampl two differ schedul present figur 10b 10c 1 compar 1 white resourc 1 grey resourc avail g l b c b b figur effect limit branch capabl schedul figur 10b implicitli assum 4way branch capabl shown state machin graph delay execut condit c 2 one cycl obtain schedul figur 10c requir 2way branch capabl n 1 n 2 repres duplic oper n observ oper n share white resourc oper l path taken instead path must delay one cycl make overal schedul length figur 10c longer figur 10b suggest exampl method handl limit branch capabl build solut control limit branch capabl valu k k2 n constructor allow n condit time step similar techniqu present 16 73 gener complet causal solut subsect first show method deal causal complet illustr next method gener causal complet solut pathbas approach 5 complet guarante find schedul everi path overlap singlerepres solut given oper controldepend condit causal guarante prevent oper execut prior c k howev lead limit model specul execut allow symbol method 26 accommod overhead trace valid algorithm requir ensur complet causal schedul trace select coexist without conflict execut solut method complet guarante travers bb predic g associ bb investig make sure possibl execut condit cover without need enumer path causal guarante usag dynam predic check condit resourc share test perform construct solut time first readi oper attempt use alreadi occupi resourc illustr fact revisit exampl 26 potenti solut gener symbol techniqu 26 shown figur 11b cdfg 11a resourc type black grey white assum label duplic oper n solut complet exi schedul resourc preced constraint satisfi howev solut causal decid whether k 1 n 2 execut valu g 1 avail first step figur 11c 11d method use construct two solut two differ permut oper k figur 11c well oper n figur 11d prevent schedul step check condit resourc share observ g k gm1 0 k m1 0 also g g c l l g g 1 l l figur causal construct approach perform trace valid procedur posteriori like 26 test similar effect done increment construct solut describ schedul one oper method evalu dynam predic updat condit resourc share inform new oper process new oper detect conflict trace previous schedul oper schedul new oper postpon later time step name earliest time step wherein conflict occur anymor dynam evalu predic combin construct natur schedul peroper basi advantag prevent construct noncaus solut like figur 11b avoid enumer backtrack infeas solut 74 exploit gener code motion subsect summar relationship initi link final assign code motion detail analysi code motion found 28 b c duplicationup boostingup unif use figur motion basic code motion figur 12 illustr code motion scope singl condit f repres final assign initi link circl bold repres current bb travers figur 12a oper initi link bb assign bb b via f motion requir code compens perform insert assign f result code duplic take place figur 12b oper move across branch node call boostingup may lead specul execut figur 12c oper initi link differ mutual exclus bb succe schedul bb lead unif initi link final assign final figur 12d oper move bb execut condit call use code motion even though upward motion explicitli shown downward motion implicitli support method initi link encod maxim freedom code motion downward gener code motion figur 13 show gener code motion support approach arrow indic possibl upward motion origin bb destin bb gray circl illustr local code motion handl method either correspond basic code motion figur 12 combin 28 combin attempt via iter improv insid window contain bb black circl illustr global code motion also support method note compound motion determin permut result success applic basic code motion oppos ps 23 search best code motion insid solut search best solut whose underli code motion induc best overal cost assign determin permut may induc code motion unrestrict type code motion possibl result search space limit restrict natur amount scope code motion figur gener code motion nevertheless fact gener code motion allow suffici guarante gener highqual solut constraint exploit order avoid gener inferior solut perform prune techniqu describ section 62 whose impact shown experi report next subsect method implement neat system 12 use bdd packag develop geert janssen boolean oracl current implement genet algorithm use explor tabl exampl waka b c 447 347 346 tabl 1 method compar other exampl 31 resourc constraint adopt chain shown top tabl result given shadow row term schedul length path solut case good tb hra 18 case b method tb hra reach result better pb case c method tb better hra pb experi summar follow two tabl search perform sever randomli chosen seed use gener random popul explor cpu mean averag search time second use hp9000735 workstat tabl benchmark without control constraint b b tabl 2 compar result heurist method tb cvl hra one exact method st top tabl show resourc constraint benchmark result shown shadow row result method assembl bottom result schedul length longest path shown averag schedul length assum equal branch probabili tie indic parenthesi note method reach best publish result better averag schedul length 200 found benchmark parkerb notic exact method present 26 guarante optim respect schedul length longest path function schedul length path first indic method highqual solut search space broader class cost function tabl 3 show result benchmark pipelinedcontrol delay constraint approach reach schedul length obtain exact method describ 26 use current localsearch algorithm explor guarante optim spite optim solut reach case within competit cpu time although certainli need perform experi first result encourag seem confirm method abl find code motion induc better solut tabl benchmark pipelinedcontrol delay rotor 26 b c e f g h latenc alu 1cycl alu mult 2cycl pipel multipli specul execut allow also perform experi evalu impact codemot prune search space order compar sampl search space without prune fifti permut gener randomli respect solut construct first comparison count number solut distinguish base overal cost valu figur 14 show result black without prune gray height bar repres number solut count differ cost valu waka1 maha1 use cost use waka2 maha2 exampl waka2 13 differ solut identifi without prune 4 prune reduct explain fact prune appli permut map cost anoth word densiti solut cost increas codemot prune figur reduct number solut second comparison perform look maxim minim cost valu observ maxim cost valu closer minimum prune appli differ maxim minim cost valu call cost rang compact cost rang shown figur 15 normal respect prune case cost rang ratio prun ingno prune 04 waka1 maha1 029 waka2 065 maha2 figur compact cost rang densiti solut cost increas figur 14 simultan maxim cost closer minimum figur 15 conclud densiti highqual solut increas codemot prune fact suggest higher probabl reach near optim solut explor whichev choic localsearch algorithm might final perform experi larger benchmark present previou tabl benchmark s2r whose cdfg 100 node borrow 26 use differ set resourc constraint depict case h first row tabl 4 compar search space without prune 500 permut gener randomli respect solut construct procedur repeat sever randomli chosen seed accur averag valu could evalu experi perform first without codemot prune enabl sequenc permut use induc solut case figur compact cost rang benchmark s2r first measur cost rang set resourc constraint summar figur 16 normal respect prune case note cost rang reduc least 70 prune enabl second count number solut hit optimum latenc evalu averag percentag respect total number solut percentag repres averag densiti optim solut search space present shadow row tabl 4 nopru pru stand prune prune respect result show code motion prune increas densiti highqual solut search space also show tighter resourc constraint impact codemot prune result interpret follow resourc scarc case b e f small fraction potenti parallel accommod within avail resourc consequ code motion prune sinc would ineffici hand resourc abund like case c g h potenti parallel accommod avail resourc need prune code motion contribut construct highqual solut tabl impact codemot prune densiti optima s2r 26 b c e f g h resourc latenc densiti nopru 1 1 41 45 1 2 31 34 densiti pru 41 16 62 62 25 16 45 45 cpu nopru 26 17 09 09 24 17 17 14 cpu alu 1cycl alu mult 2cycl pipel multipli singleport lookup tabl sinc synthesi asic code gener asip want use resourc possibl like observ practic huge unbal potenti parallel exploit parallel constrain avail resourc fact justifi use codemot prune techniqu order compar impact differ densiti optima search time also measur averag time reach given optimum emul kind random search optim latenc shown tabl 4 averag search time report entri cpu result show codemot prune lead substanti improv search time tight resourc constraint 9 conclus futur work paper show schedul code motion treat unifi problem optim solut kept search space problem approach point view optim process construct solut independ explor altern shown permut use induc unrestrict code motion presenc optim solut search space guarante better control construct procedur shown prune techniqu eas optim process exploit constraint sinc control depend repres obstacl exploit parallel might induc violat often possibl howev conclud control depend also exploit combin resourc constraint data depend order detect prevent ineffici code motion way cast problem experiment result allow us conclud codemot prune increas densiti highqual solut search space even though paper focus problem relat earli phase design flow construct method accommod extens mani altern solut gener possibl extend constructor keep track issu like regist interconnect usag number state issu could captur cost function conveni especi late phase design flow optim take sever design issu account futur work intend cast loop pipelin construct approach loop could easili support method simpl extens model condit loop could broken schedul back edg could restor later state machin graph like 5 15 howev extens would allow exploit parallel across differ iter loop reason prefer investig loop topic proof prune techniqu theoremlet solut optim problem describ section 22 assum construct algorithm 2 given let oper assign bb j let delayo solut n obtain move bb j bb alloc exactli extra cycl step accommod execut proof let lk lk schedul length bb k motion respect let p q r bb form path respect schedul length path p n motion assign q alloc step insid p lplp assign r move alloc step a2 oper u assign r move alloc step u depend resourc conflict oper assign q topolog permut construct assign r alloc step insid q c assign r alloc step insid p depend resourc conflict oper assign q topolog permut given solut n path length greater equal gener code motion seen compound code motion built basic code motion cost monoton increas conclud without loss gener cost n r function synthesi digit system tass area perform optim path base schedul controlflow versu dataflowbas schedul combin approach adapt schedul system effici orthonorm test synthesi passtransistor selector pathbas schedul synthesi embed system design synthesi optim digit circuit global resourceconstrain parallel techniqu data flow exchang standard trace schedul techniqu global microcod compact region schedul anapproach detect redistribut parallel neat object orient high level synthesi interfac applic genet algorithm highlevel synthesi pathbas techniqu estim hardwar runtim hwswcosynthesi treebas schedul algorithm control domin circuit unifi schedul model highlevel synthesi code gener global schedul highlevel synthesi code gener embed processor schedul algorithm condit resourc share hierarch reduct approach limit control flow parallel time constrain code compact dsp effici resourceconstrain global schedul techniqu superscalar vliw processor make compactionbas parallel afford uniform parallel exploit ordinari program algorithm complex percol base synthesi new symbol techniqu control depend schedul repres condit branch highlevel synthesi applic global schedul codemot highlevel synthesi applic construct method exploit code motion effici superscalar perform boost resourc share control synthesi method condit branch global schedul independ control depend base condit vector tr combinatori optim algorithm complex region schedul global schedul independ control depend base condit vector repres condit branch highlevel synthesi applic percol base synthesi limit control flow parallel effici superscalar perform boost effici resourceconstrain global schedul techniqu superscalar vliw processor treebas schedul algorithm controldomin circuit global schedul codemot highlevel synthesi applic timeconstrain code compact dsp pathbas techniqu estim hardwar runtim hwswcosynthesi effici orthonorm test synthesi passtransistor selector embed system design controlflow versu dataflowbas schedul italicglobalital resourceconstrain parallel techniqu synthesi optim digit circuit make compactionbas parallel afford unifi schedul model highlevel synthesi code gener construct method exploit code motion area perform optim pathbas schedul ctr aravind vijayakumar f brewer weight control schedul proceed 2005 ieeeacm intern confer computeraid design p777783 novemb 0610 2005 san jose ca steve haynal forrest brewer automatabas symbol schedul loop dfg ieee transact comput v50 n3 p250267 march 2001 apostolo kountouri christoph wolinski effici schedul condit behavior highlevel synthesi acm transact design autom electron system toda v7 n3 p380412 juli 2002