skeleton tree effici decod huffman encod text new data structur investig allow fast decod text encod canon huffman code storag requir much lower convent huffman tree olog2 n tree depth olog n decod faster part bitcomparison necessari decod may save empir result larg reallif distribut show reduct 50 number bit oper basic idea gener yield save b introduct import use data compress inform retriev ir system today wellestablish mani author comment 1 17 31 27 larg fulltext ir system inde voraci consum storag space realtiv size raw textual databas text kept also variou auxiliari file like dictionari concord usual adjoin system make retriev process effici moreov certain data structur decod tabl tree resid ram larg system requir power machin therefor quit natur effort made compress text necessari file therebi reduc demand storag ram equival fix machin given resourc effect increas size data base still handl effici popular compress method base work lempel ziv 29 30 adapt method alway suitabl ir applic context fulltext retriev larg number small passag access simultan eg produc kwic keywordincontext index respons submit queri text fragment decod regardless exact locat adapt code method use would forc us start decod begin text logic block contain retriev passag would either decod much need may impli increas process time prepar priori smaller block would cost us compress effici case advantag use adapt method often yield better compress static one may lost huffman code 14 still one best known popular static data compress method certain applic data transmiss commun channel code decod ought fast applic like ir scenario focu paper compress decompress symmetr task compress done build system wherea decompress need process everi queri directli affect respons time thu special interest fast decod techniqu see eg 15 data structur need decod huffman encod file huffman tree lookup tabl gener consid neglig overhead rel larg text howev text larg huffman code appli connect markov model 2 requir huffman forest may becom storag problem moreov alphabet encod necessarili small may eg consist differ word text huffman tree thousand even million node uncommon 23 tri paper reduc necessari intern memori space devis effici way encod tree addit new suggest data structur also allow speedup decompress process reduc number necessari bit comparison manipul individu bit inde main caus slow decod huffman encod text method base larg tabl construct preprocess stage suggest 5 help entir decod process perform use byte orient command see also 26 howev intern memori requir storag tabl may larg anoth possibl avoid access individu bit use 256ari instead optim binari huffman code obvious reduc compress effici de moura et al 6 report degrad signific next section recal necessari definit canon huffman tree use section 3 present new suggest data structur includ experiment result section 4 main idea extend yield yet smaller tree even faster decod 2 canon huffman code figur 1 canon huffman code given probabl distribut might quit larg number differ huffman tree sinc interchang left right subtre intern node result differ tree whenev two subtre differ structur weight averag path length affect interchang often also optim tree obtain via huffman algorithm one may thu choos one tree addit properti prefer choic mani applic canon tree defin schwartz kallick 25 recommend mani other see eg 15 27 denot p assum length bit codeword assign huffman procedur element probabl depth leaf correspond p huffman tree tree call canon scan leav left right appear nondecreas order depth equival nonincreas order 22 idea huffman algorithm use gener length f g codeword rather codeword latter easili obtain follow ith codeword consist first bit immedi right binari point infinit binari expans mani properti canon code mention 15 3 follow use run exampl paper consid probabl distribut impli zipf law defin weight nth harmon number law believ govern distribut common word larg natur languag text 28 canon code repres string hn 1 call sourc k denot length longest codeword depth tree n number codeword length k sourc correspond zipf distribut 74i code depict figur 1 shall assum eas descript sourc hole ie three integ true mani reallif distribut particular exampl hand distribut one alphabet use compress set spars bitmap 8 techniqu suggest herein easili adapt gener case use vector succi give codeword length next larger codeword length j make exposit clearer shall suppress refer succi sinc distribut without hole one properti canon code set codeword length compris binari represent consecut integ exampl case codeword length 9 bit binari integ rang 110011100 111011010 fact exploit enabl effici decod rel small overhead codeword bit detect one get rel index within sequenc codeword length simpl subtract follow inform thu need let length shortest codeword let basei integ valu first codeword length denot standard sbit binari represent integ k lead zero necessari jth codeword length let seqi sequenti index first codeword length suppos detect codeword w length iw integ valu binari string w ie rel index w within block codeword length thu seq rel index w within full list codeword rewritten iw gamma diff thu one need list integ diff tabl 1 give valu n basei seqi diffi exampl 9 tabl 1 decod valu canon huffman code zipf200 suggest next section new represent canon huffman code spaceeffici may also speed decod process permit time decod singl bit one iter 3 skeleton tree fast decod follow small exampl use data show save possibl suppos decod detect next codeword start 1101 inform enough decid follow codeword ought length 9 bit thu abl detect first 4 bit codeword read follow 5 bit block without check bit end codeword reach goal construct effici datastructur permit similar decis soon possibl fourth bit earliest possibl exampl sinc also codeword length 8 start 110 31 decod sktree suggest solut binari tree call sktree skeletontre structur induc underli huffman tree gener significantli fewer node tree travers like regular huffman tree start pointer root tree anoth pointer first bit encod binari sequenc sequenc scan read zero resp 1 proceed left right child current node regular huffman tree leav correspond full codeword scan decod algorithm output correspond item reset treepoint root proce scan binari string case howev visit tree depth necessari identifi length current codeword leav sktree contain length correspond codeword f tree pointer gamma root start length string f string els tree pointer gamma right tree pointer valu tree pointer 0 f codeword string start output tree pointer gamma root start els figur 2 decod procedur use sktree formal decod process use sktree depict figur 2 variabl start point index bit begin current codeword encod string store vector string node sktree consist three field left right pointer null node leaf valuefield zero intern node contain length bit current codeword node leaf actual implement use fact intern node either zero two children store valuefield rightfield space serv flag use right pointer procedur also use two tabl tabl give jth element nonincreas order frequenc encod alphabet diff defin vari k length shortest length longest codeword procedur pass one level tree one accord bit encod string leaf reach rest current codeword read one oper note bit input vector individu scan yield possibl time save 9 91010 figur 3 sktree zipf200 distribut figur 3 show sktree correspond zipf distribut 200 tree tilt 45 ffi left right children indic arrow point right frame leav correspond last codeword indic length sktree exampl consist 49 node oppos 399 node origin huffman tree idea similar sktree base tabl rather tree suggest moffat turpin 22 instead identifi root subtre codeword depth essenti form complet tree fix depth less depth code tree extend shorter branch examin code tree node depth determin minimum codeword length subsidiari subtre find length codeword fixeds window compress bitstream consid binari valu compar leftjustifi base valu sequenc hardcod cascad ifstat comparison equival transit left right child sktree replac bit comparison equival byte word base comparison reminisc mechan suggest 5 32 construct sktree travers standard canon huffman tree decod given codeword one may stop soon one get root full subtre depth h h 1 ie subtre depth h 2 h leav sinc stage known exactli h bit need complet codeword one way look sktree therefor standard huffman tree full subtre depth h 1 prune direct much effici construct follow onetoon correspond codeword path root leav huffman tree extend defin binari string path p induc tree given root r 0 path consist e e 0 r left resp right child r exampl figur 3 p111 consist four node repres bullet top line skeleton sktree consist path correspond last codeword everi length let codeword denot l exampl etc idea p l serv demarc line node left resp right p l ie left resp right child one node p l correspond prefix codeword length first approxim construct procedur thu take tree obtain clearli need includ longest codeword l k alway string k 1s adjoin miss children turn complet tree intern node left right child label new leaf set equal label closest leaf follow inord travers word creat path l one first follow node alreadi exist tree one branch creat new node label miss right child node path label base assumpt hole miss left children new node path label closer look impli follow refin suppos codeword l zero rightmost posit ie l string ff length gamma 1 first codeword length follow get ith bit one decid length current codeword 1 l termin string 1s l 0 jfij first codeword length length codeword deduc alreadi read bit follow fi follow one alway need full string l sktree prefix includ rightmost zero let l prefix revis version procedur start tree obtain node tree depict bullet figur 3 path p l leaf tree left child leaf new termin node repres figur 3 box contain number addit leav fill explain 33 space complex evalu size sktree count number node ad path p l k sinc codeword canon code order correspond frequenc also alphabet sort suffic compar l l igamma1 let empti string let fli longest common prefix l l string 10 exampl number node sktree given sinc summat alon number intern node bullet figur 3 maximum function come prevent extrem case differ might neg exampl l longest common prefix sinc consid bit includ rightmost zero l case inde new node ad p l immedi bound number node sktree ominn k 2 sinc one hand 2 hand exceed number node underli huffman tree 2n gamma 1 get tighter bound consid node upper level sktree belong full binari tree f leav root sktree depth f 1e leav level gamma 1 tree f part sktree path p l must overlap account node f separ 2k gamma 1 node f k gamma 1 disjoint path path p l extend f log yield bound number node sktree save worst case eg one codeword length except longest alway least two gener depth huffman tree omegagamma n save might signific tree optim skew distribut mani applic like distribut charact charact pair word natur languag depth huffman tree olog n larg n even constant c depth c log 2 n must quit small suppos huffman tree leaf depth 16 theorem 1 probabl element correspond leaf f j jth fibonacci number get 18 exercis 1214 52 golden ratio thu c log 2 n give numer exampl section 4 one huffman tree correspond differ word english leav probabl tree size leaf level 3 log 2 n less 44 theta 10 gamma12 mean word occur everi 4400 billion word exist rare word put lower limit size text case must larg enough fill 35000 cdrom distribut given tabl 2 experi ratio depth huffman tree log 2 n 131 261 even origin huffman tree would deeper sometim conveni impos upper limit olog n depth often impli neglig loss compress effici 10 case given logarithm bound depth size sktree log n log 34 time complex decod base standard huffman tree averag number comparison per codeword sum taken leav depth tree time probabl get similar sum hold sktree differ leaf correspond singl element sever consecut codeword length let w prefix codeword correspond leaf sktree label denot codeword correspond leaf sktree correspond use notat section 2 indic rang diff averag number comparison per codeword use sktree thu evalu i2fleav sktreeg w binari string correspond leaf depth tree shortcut labe probj probabl element index j approxim assum probabl element level tree 2 gammai correspond dyadic probabl distribut probabl integr power 1 great differ actual probabl distribut dyadic one sinc yield huffman tree see 20 bound distanc distribut given model eqn 2 becom i2fleav sktreeg similar sum taken leav origin huffman tree give averag codeword length dyadic distribut therefor larg save whenev number node sktree much smaller underli full huffman tree 35 experiment result test effect use sktree follow reallif distribut use data french collect tresor de la langu francais databas 680 mb french languag text 115 million word 17 th 20 th centuri 4 english sourc 500 mb 87 million word wall street journal 24 hebrew part responsa retriev project 100 mb hebrew arama text 15 million word written past ten centuri 7 first set alphabet consist bigram three languag sourc english distribut 13 next set element encod differ word yield larg alphabet final set contain distribut trigram french complet zipf200 distribut use exampl also ad total averag number averag rel sourc k number codeword node number save element length sktree comparison comparison bigram french 29 2192 7784 285 4620 406 hebrew 24 743 8037 127 4183 480 english 26 289101 11202 425 5726 489 word french 27 439191 10473 443 5581 467 hebrew trigram french 28 25781 10546 381 5026 523 tabl 2 time space requir reallif distribut tabl 2 display result first three column give statist variou distribut depth k huffman tree size n encod alphabet weight averag length codeword measur bit equal averag number comparison standard huffman tree use next two column bring number node sktree given eqn 1 averag number comparison per codeword decod base sktree given eqn 2 final column show rel save number comparison measur percent see larg distribut roughli half comparison may save note save spite fact highprob symbol short codeword rel bit common weight averag take account bit save shorter codeword save multipli higher probabl bit save longer codeword even probabl small larg number cumul effect note also cost store sktree sever percent cost full huffman tree 4 reduc sktree wish explor might gain prune sktree intern node one would thu get leav yet possibl deduc length current codeword partial inform alreadi avail exampl figur 3 bit alreadi process 111 correspond intern node rightmost upper corner know alreadi length current codeword either 9 10 therefor need one comparison know exact length concaten follow seven bit three alreadi process get 10bit string w binari valu w smaller base10 next codeword must length 9 otherwis length 10 use origin sktree explain previou section would least one comparison possibl even eg bit 111 0110 would perform four comparison still know length 9 reflect lead idea reduc sktree obtain sktree prune branch one hand reduc tree obvious smaller saw may also decreas number comparison formal defin node v sktree two valu lowerv upperv v leaf lowerv v intern node lowerv lowerleftv node v codeword correspond leav subtre root v length interv lowerv upperv term earlier notat defin reduc sktree smallest subtre sktree leav w correspond rang two consecut codeword length ie 56 figur 4 reduc sktree zipf200 distribut figur 4 reduc sktree obtain sktree figur 3 leav also indic bullet correspond rang underneath recal origin huffman tree 399 node sktree 49 reduc sktree left 13 note leav origin sktree delet also entir subtre node correspond part p l overlap p l eqn 3 sinc seek minim tree path node highest tree need kept rest branch offspr prune gener view regular reduc sktree would follow consid full canon huffman tree assign node valu lower upper delet node start leaf proceed parent node get smallest tree everi leaf w satisfi lowerw upperw ie correspond codeword length sktree process continu node delet codeword correspond new leav length get reduc sktree henceforth adopt notat sk 1 tree sk 2 tree origin reduc sktree respect subscript refer maxim size set codewordlength associ leav tree use equal eqn 3 would impos rang exactli two codeword length leaf sk 2 tree exampl figur 4 leav equal last element codeword block 56 67 12correspond sk 2 tree figur 5 exampl sk 2 tree special leav eqn 3 exampl leav may exist parent node correspond alreadi rang 3 codeword length case origin leaf sk 1 tree must kept let us call leav sk 2 tree special leav exampl distribut special leav exist distribut hebrew bigram first element sourc h0 0 0 0 left part figur 5 last codeword l codeword length 13 list right part figur 5 correspond section sk 2 tree special leav w indic rectangl contain valu lowerw equal upperw leav depict bullet exampl see codeword length 8 prefix 011 parent node correspond leaf associ prefix 01 may extend codeword length 6 7 8 similarli prefix 11110 impli codeword length 11 1111 prefix codeword length 11 24 decod procedur sk 2 tree similar sk 1 tree given figur 2 ifblock replac one figur 6 use f lag field leaf w f otherwis valu field w store lowerw w leaf 0 w intern node valu tree pointer 0 f len gamma valu tree pointer codeword string start f lag tree f codeword string start len output tree pointer gamma root start figur decod use sk 2 tree leaf w reach current codeword initi length lowerw correct set w special leaf next codeword inde length lowerw w special leaf f lagw 1 check append zero right end codeword get integ valu larger equal first codeword length lowerw 1 updat current codeword includ also follow bit construct sk 2 tree similar underli sk 1 tree consid path node node appear least two differ path intern node sk 2 tree leav ad fill miss left right children may special leav space complex sk 2 tree note principl sever special leav may eman singl branch p l leav upper bound number node ominn k 2 sk 1 tree practic special leav rare appear particular case p l contain either p l former case special leav right children node p l latter left children exampl refer tree figur 5 l prefix l gener special leaf right child wherea l contain l prefix gener special leav left children given huffman tree special leav associ sk 2 tree case exampl besid one figur 5 number node clearli exactli one leaf rang sk 2 tree complet tree ie intern node exactli two children size sk 2 tree earlier exampl distribut list tabl 3 seen even huge huffman tree hundr thousand node size reduc sever ten 7090 reduct even rel size sk 1 tree number save averag save sourc node rel number rel sk2 tree sk1 tree comparison sk1 tree english 15 78 3444 180 bigram french 47 84 3757 187 hebrew english 41 90 4842 154 word french 41 91 4725 153 hebrew 33 90 4715 172 trigram french 43 89 4157 173 tabl 3 time space requir sk 2 tree evalu averag number comparison take sum similar eqn 2 leav sk 2 tree special leav formula eqn 2 appli other let w prefix correspond codeword assum leaf label jwj codeword correspond leaf sk 2 tree w0 first length follow one length 1 exact cutoff point import codeword correspond consecut indic rang iw0 1 probabl codeword multipli number necessari comparison detect jwj 1 sinc need addit comparison decid length 1 yield use notat eqn 2 follow formula i2fleav sktreeg tabl 3 give result averag exampl reallif exampl give reduct 5064 rel regular huffman decod algorithm 1519 rel algorithm use sk 1 tree 5 final remark prune skeleton tree turn profit term time space shouldnt climb even higher defin sk tree accordingli 2 associ valu ranges node v sk 1 tree give size set correspond codeword length leav sk 1 tree ranges sk 2 tree ranges 2 consid path start leaf move parent pointer toward root ranges valu node path form nondecreas sequenc first valu 1 follow possibl sever 2s etc fix path last node valu 2 exist new leaf yield sk 2 tree similarli proceed even last node valu 3 would yield sk 3 tree etc howev save incur pass sk 1 tree sk 2 tree caus fact sever consecut node path ranges valu 2 new leav sever level higher accordingli sever comparison could save parent node node ranges valu 3 also ranges valu 3 child parent node must ranges valu 1 mean special leaf argu earlier case rare therefor whenev special leaf involv pass lowest node ranges valu 2 lowest node ranges valu 3 would let us climb one level save one comparison hand need addit comparison within rang 3 valu case noth gain cours price two addit comparison could process use binari search rang size 4 3 gener need r addit comparison reach leaf sk 2 r tree push idea extrem would skeletontre would find correct length codeword use sequenc binari search step list first last codeword everi codeword length suggest 22 standard binari search search code maxim codeword length k take exactli dlog 2 ke comparison would 4 5 exampl distribut note averag number comparison sk 1 tree threshold exampl tabl 2 correspond valu tabl 3 therefor seem necessarili worthwhil pass sk tree 2 moffat turpin 22 suggest use bias binari search sinc probabl distribut codeword length skew first bit code word approach linear search skeletontre introduc paper conveni data structur perform similar search effici r huffman code dead ziff perl fast search compress text allow error responsa retriev project alway want know afraid ask rabinowitz j moor e inform retriev method construct minimum redund code nemetz art comput program applic inform diverg huffman code implement minimum redund prefix code text compress dynam document databas kallick b fast decod huffman code psychobiolog languag univers algorithm sequenti data compress compress individu sequenc via variabler code ad compress fulltext retriev system tr ctr dana shapira ajay daptardar adapt knuthmorrispratt algorithm pattern match huffman encod text inform process manag intern journal v42 n2 p429439 march 2006