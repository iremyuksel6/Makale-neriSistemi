gener onthefli garbag collector java onthefli garbag collector stop program thread perform collect instead collector execut separ thread process parallel program onthefli collector use multithread applic run multiprocessor server import fulli util processor provid even respons time especi system stop thread costli oper work report incorpor gener onthefli garbag collector incorpor nontrivi sinc onthefli collector avoid explicit synchron program thread best knowledg incorpor tri implement collector prototyp java virtual machin aix measur perform 4way multiprocessor gener collector onthefli gener collector potenti reduc overal run time work set applic concentr collect effort young object howev contrast gener collector onthefli collector move object thu segreg old young object furthermor onthefli collector stop thread extra benefit short paus obtain gener collect nevertheless compar onthefli collector without gener turn gener collector perform better applic best reduct overal run time benchmark measur 25 howev benchmark effect one overal run time increas 4 b introduct garbag collector free space held unreach dead object space reus futur alloc multiprocessor platform desir stop program perform collect singl thread one processor lead long paus time poor processor util sever way deal problem exist two obviou way 1 concurr collector run collector concurr mutat collector run one thread one processor program thread keep run concurr processor program thread may stop short time initi andor nish collect 2 parallel collector stop program thread complet run collector parallel sever collector thread way processor util collector thread ibm haifa research lab email tamarilibmcom ibm haifa research lab email kolodnerilibmcom z comput scienc dept technion israel institu technolog work done author ibm haifa research lab email erezcstechnionacil paper discuss concurr collector particular onth collector stop program thread studi onth garbag collector initi steel dijkstra et al 27 28 8 continu seri paper 9 14 3 4 20 21 culmin doligezleroygonthi dlg collector 11 10 advantag onth collector parallel collector type concurr collector 1 13 24 avoid oper stop program thread oper costli usual program thread stop point thu nonneglig wait last mani thread reach safe point may stop drawback onth collector requir write barrier handshak collector mutat thread collect also typic employ negrain synchron thu lead errorpron algorithm gener garbag collect introduc lieberman hewitt 23 rst publish implement ungar 29 gener garbag collector reli assumpt mani object die young heap partit two part young gener old gener new object alloc young gener collect frequent young object surviv sever collect promot older gener gener assumpt ie object die young inde correct get sever advantag 1 paus collect young gener short 2 collect ecient sinc concentr young part heap expect nd high percentag garbag 3 work set size smaller program repeatedli reus young area collector trace smaller portion heap 11 work paper present design incorpor gener onth garbag collector two issu immedi aris first shorten paus time relev onth collector sinc stop program thread second tradit gener collector partit heap gener physic sens name promot object young gener old gener object move young part heap old part heap onth garbag collector move object cost move object run concurr program thread high thu without demer et al 6 present gener collector move object motiv adapt gener conserv garbag collect build work design gener collector dlg onth garbag collector 11 10 implement gener collector jdk 116 prototyp aix compar perform implement dlg onth collector result show gener collector perform well applic benchmark ran multiprocessor best reduct overal program runtim 25 howev one benchmark gener collect increas overal run time 4 sever properti applic dictat whether gener collect may beneci overal perform first gener hypothesi must hold ie mani object inde die young second import applic modifi mani pointer old gener otherwis cost handl intergener pointer high last lifetim distribut object fool partit gener tenur object old gener actual dead matter promot polici get increas ecienc partial collect collect old gener free fraction object collect young gener may well collect whole heap sinc care paus time furthermor overhead paid maintain intergener pointer caus increas overal run time applic use benchmark specjvm benchmark 25 plu two benchmark describ section 82 benchmark overal applic perform improv gener collect anagram 25 improv 213 javac 15 improv 227 mtrt 10 improv improv multithread raytrac rang 116 depend number applic thread run concurr applic well 202 jess 4 increas overal run time two reason deterior lot object old gener scan intergener pointer object get tenur die becom unreach follow full collect 12 card mark hosk moss stefanov 16 provid studi write barrier gener collect among paramet investig uenc card size card mark barrier overal ecienc applic measur best size card 256 512 byte worst size extrem 16 4096 byte note advantag small card indic pointer modi exact collector need scan big area nd intergener pointer need card howev small card requir space dirti mark reduc local process choos paramet collector run similar measur variou card size turn behavior onth gener collector dierent best choic card size one extrem depend benchmark chose set card size minimum possibl best benchmark far best rest suspect primari reason result dier hosk et al 16 collector move object provid detail section 853 13 techniqu use organ start state art dlg onth collector 11 10 brie review section 2 construct gener collector similar work demer et al 6 present section 3 augment dlg work better gener util addit color section 4 also use colortoggl trick reduc synchron section 5 similar trick previous use 21 17 7 22 19 rst promot polici trivial promot object surviv singl collect also studi option promot object sever collect section 6 section 7 provid code collector lower level detail appropri implement section 8 report experiment result measur justifi choic paramet conclud section 9 2 collector build dlg collector 11 10 onth collector stop program collect two import properti collector make ecient first employ negrain atom name instruct carri without extra synchron second requir writebarri oper use stack regist write barrier requir modic refer insid object heap origin paper also suggest use thread local heap design assum abund use immut object ml use thread local heap start short overview dlg collector thorough descript correct proof reader refer origin paper 11 10 collector mark sweep collector employ standard three color mark method object white begin trace root object mark gray trace continu choos one gray object mark black mark white son gray process continu gray object heap mean color black object object trace whose immedi descend trace well gray object object trace whose son yet check white object object yet trace object remain white end trace reachabl program reclaim sweep procedur shade gray black object recolor white sweep fourth color blue use identifi deal fact collector onth ie trace graph live object object modi program adjust standard mark sweep algorithm requir collector start collect three handshak mutat thread handshak collector chang statu mutat thread cooper ie indic seen chang independ respond rst handshak write barrier becom activ mutat begin gray object pointer updat second handshak requir correct behavior mutat chang result respond third handshak mutat mark root gray ie object referenc stack mutat check whether need respond handshak regularli normal oper never respond handshak middl updat creation object collector consid handshak complet mutat respond complet three handshak collector complet trace heap sweep mutat gray object modifi object slot contain pointer collector complet trace live object amount gray depend part collect cycl suppos refer object modi point anoth object b rst third handshak mutat mark b gray third handshak end sweep mutat mark gray mutat also cooper collector creat object trace object creat black wherea creat white collector idl sweep object creat black sweep pointer seen yet reclaim sweep pointer pass creat white readi next collect sweep pointer directli creation spot object creat gray extra care must taken possibl race creat sweep howev simpl method colortoggl allow avoid consider discuss section 5 gener collect without move object describ approach gener collect reloc object call collect young gener partial collect collect entir heap full collect design similar demer et al 6 design stoptheworld conserv collector ever incorpor featur necessari support onth collect clear card mark without stop thread addit color object creat collect color toggl avoid synchron object alloc sweep instead partit heap physic keep young gener separ place partit heap logic object keep indic whether old young may one bit indic sever bit give inform age simplest version one promot object surviv one collect begin describ simpler algorithm discuss age mechan section 6 demer 6 note object becom old surviv one collect black color may use indic object old clearli sweep object surviv last collect black turn object white sweep interpret black object old gener time one collect next object creat white therefor consid young next partial collect ie collect young gener everyth fall quit nice place trace want trace old gener inde trace black object sweep want reclaim old object inde reclaim black object live object becom black thu also becom old next collect full collect collect old young gener turn color object white full collect similar partial collect 31 intergener pointer remain discuss intergener pointer pointer old object point young object sinc want trace old gener collect young gener must assum old object aliv treat intergener pointer root maintain list intergener pointer similarli gener collector may choos card mark 26 rememb set 23 29 see 18 overview gener collect two method maintain intergener pointer implement use card mark reason java expect mani pointer updat cost updat must minim also extra bit avail object header requir ecient implement rememb set card mark scheme heap partit card initi card mark dirti program thread mutat mark card dirti whenev modi card slot contain pointer collector scan object dirti card pointer young gener may turn card mark nd pointer card card mark maintain invari intergener pointer may exist dirti card size card determin tradeo space time usag bigger card impli less space requir keep dirti mark time requir collector scan dirti card nd intergener pointer tri power 2 16 4096 found two extrem provid best perform see section 853 32 collector partial collect begin mark gray young object referenc intergener pointer particular collector mark gray white object referenc pointer dirti card time card mark clear clear mark okay sinc surviv object promot old gener complet collect exist intergener pointer becom intragener pointer advanc age mechan section 6 would check determin whether card mark could clear handl intergener pointer mutat told mark root use handshak mechan follow trace remain unchang nongener collector sweep sweep modi chang color black object back white full collect begin clear card mark without trace dirti card collector also recolor black object white allow unreach object reclaim full collect mutat told mark root collector continu trace sweep 33 trigger use simpl trigger mechan trigger partial collect paramet repres size young gener determin run partial collect trigger alloc object accumul size exceed predetermin size 1 trigger full collect use standard method start concurr collect heap almost full heap manag trigger exactli time thu predetermin bound serv lower bound trigger time 4 deal prematur promot promot object surviv collect infant object creat start collect immedi made old object may die young alreadi promot old gener collect next full collect onth collect object also creat collect cycl thu compound promot problem ad simpl mechan avoid promot object creat collect old gener advanc mechan keep age object describ section 6 done introduc new color object creat collect cycl instead creat object white black depend stage collect dlg algorithm creat object yellow collect yellow object trace collector sweep turn yellow object back white without reclaim thu collector promot old gener one subtl point discuss technic section see section 7 forc except rule particular rst third handshak collector mutat also mark yellow object gray 5 use colortoggl recal collect mutat alloc object yellow trace chang color reachabl white object black design describ far sweep reclaim white object color blue color nonalloc chunk chang color yellow object white thu end sweep remain white object instead recolor yellow object sweep employ color toggl mechan similar previou work 21 17 7 2 22 19 color toggl mechan exchang mean white yellow without actual chang color indic associ object thu live object remain either black yellow mutat go color new object yellow yellow play role white previou collect cycl new collect begin mutat begin color new object white white begin play role yellow color previou cycl implement color toggl use two color name alloc color clear color initi alloc color white clear color yellow time object alloc use alloc color begin collect cycl valu alloc color clear color exchang rst cycl mean alloc color becom yellow clear color becom white trace reachabl object clear color turn gray object alloc color trace color chang sweep object clear color reclaim use toggl need turn yellow object white sweep import avoid race creat sweep need know sweep pointer order determin color new object newli alloc object alway assign current alloc color remark 51 discuss adequ gener collector one may easili modifi origin collector run improv toggl black white color comparison collector without gener feel fair let gener collector enjoy improv therefor also ad modic collector use gener thu comparison make gener 6 age mechan algorithm describ far age indic combin color promot object surviv one collect promot polici extrem primit question whether parameter promot polici may help keep age object ie number collect surviv age initi 0 creation increment sweep time also x predetermin paramet determin threshold promot old gener object reach threshold sweep procedur stop increment age chose x predetermin threshold dynam polici could easili implement use age mechan old object continu color black howev trace color reachabl object black whether young old thu modic sweep requir sweep recolor reachabl object young age less threshold alloc color continu leav old object black reclaim object clear color pseudocod sweep procedur appear figur 5 sever chang card mark mechan also requir support age simpl clear card mark begin collect longer work sinc intergener pointer current collect cycl may remain intergener pointer next cycl furthermor must also ensur intergener pointer record correctli collect cycl race may occur set reset card mark elabor race technic section see section 7 begin partial collect collector scan card tabl color gray young object referenc pointer dirti card young object referenc given card collector clear card mark collector toggl alloc clear color continu handshak trace sweep full collect collector trace intergener pointer instead recolor black object alloc color toggl alloc clear color continu handshak trace sweep initi done full collect see initfullcollect figur clear dirti bit reason indic dirti card intergener pointer may still relev follow partial collect implement question keep age one option object separ tabl chose keep separ tabl room object header importantli note sweep partial full collect goe age object increas thu reason local better go separ tabl touch object heap keep byte per age although two three bit usual enough could locat age byte card mark color howev would requir synchron write byte eg via compar swap instruct empir check show synchron costli typic java applic note synchron instruct would requir good fraction pointer modic 7 technic detail section provid pseudocod addit technic detail paper written reader may skip section still get broad view collector purpos present code show gener mechan ts dlg collector thu present code concentr detail relat gener present detail mechan keep track object remain trace present detail threadloc alloc mechan necessari avoid synchron thread object alloc see dlg paper 11 10 detail mechan one dierenc dlg separ handshak two part posthandshak waithandshak instead use second collector thread figur 1 show mutat routin uenc collector write barrier updat routin object alloc creat routin cooper routin mutat must call regularli eg backward branch invoc code notat heapx denot slot object address x figur 2 show overal collect cycl figur 3 present routin call collector refer code assum reader familiar dlg collector 11 10 use follow terminolog taken paper period rst handshak second denot sync1 period second handshak third denot sync2 rest time ie third handshak begin next collect cycl denot async mutat percept period depend time cooper handshak delic issu gener collector proper handl card mark set reset properli avoid race maintain correct partit discuss simpl algorithm age algorithm assum tabl design byte card hold card mark byte use 71 simpl algorithm first consid handl card mark simplest algorithm without yellow color color toggl particular algorithm section 3 use algorithm collector mark live object black promot thu intergener pointer creat trace complet thu card mark clear begin cycl without fear lose mark due race condit mutat add yellow color section 4 collector trace object creat yellow cycl thu must keep record pointer referenc yellow object object actual interest pointer black object perform ltere collector solv problem keep correct card mark parent yellow object enough make sure order oper begin collect cycl follow scan card tabl clear dirti mark start creat yellow object notic clearcard code figur 3 preced switchallocationclearcolor code figur 3 collect cycl code figur 2 next add color toggl section 5 window time check object intergener pointer scan card tabl color toggl collector check mutat creat new intergener pointer referenc yellow object b collector miss pointer current collect furthermor color toggl object b becom white ie clear color might collect current partial collect solv make except treatment yellow object dlg write barrier treat white object sync1 sync2 rst third handshak mean usual short period time whenev dlg write barrier would shade white object gray also shade yellow object gray see markgray figur 1 addit point need veri trace alway termin without yellow color modic live object turn white gray gray black sinc number live object nite turn black end trace alway termin still case yellow object either stay yellow till end trace may turn gray later black perform necessari modic note need card mark sync1 sync2 thu get small gain ecienc card mark requir async stage notic markcard call async write barrier code figur 1 summar card mark occur async clear check card mark collector done rst handshak second handshak clear card mark collector toggl clear alloc color thu mutat creat new object yellow color yellow object may shade gray write barrier sync1 sync2 72 age algorithm next discuss age algorithm collector must keep care track intergener pointer collector stage two concern first choic card mark clear statusm 6async markgrayheapxi markgrayi els collector trace markgrayheapxi markcardx els markcardx creat pick x 2 free allocationcolor return x cooper statusm 6 statusc x 2 root markgrayx statusm statusc statusm 6 async gray figur 1 mutat routin clear full collect initfullcollect handshakesync1 mark posthandshakesync2 switchallocationclearcolor waithandshak posthandshakeasync mark global root waithandshak trace gray object pick gray object x markblackx object x heap blue figur 2 collect cycl card c dirtyc object x c gray switchallocationclearcolor temp clearcolor clearcolor allocationcolor allocationcolor temp initfullcollect object x heap allocationcolor card c colorx 6 black pointer 2 x markgrayi black handshak waithandshak statusc waithandshak 2 mutat wait figur 3 collector routin must done care reset second time collector clear card mark mutat may set case must make sure card mark remain set pointer object associ card young object solv rst problem mutat set card mark throughout collect also sync1 sync2 see figur 4 order clear card mark collector check rst pointer young object exist card clear mark howev could still race clear collector set mutat particular follow interleav mutat collector action problemat say dirti mark question associ card 1 collector thread scan card nd intergener pointer determin card mark clear 2 collector actual clear mark program thread write intergener pointer set card mark 3 collector clear card mark sinc check step 1 allow outcom cours event intergener pointer locat unmark card next partial collect referenc object may skip trace reclaim although live solv race let collector mutat act follow collector act three step instead naiv two step step 1 collector reset card mark step 2 check whether card mark clear ie whether young object referenc final step 3 answer step 2 collector set card mark back idea encod clearcard routin figur 6 updat mutat involv two step step 1 perform actual updat step 2 set card mark order step import case seen updat routin figur 4 claim race longer destruct suppos mutat updat slot card store intergener pointer assum updat object contain intergener pointer thu crucial get new updat notic respect record intergener pointer time collector check whether dirti bit eras eras necessari assum processor see store particular processor order two possibl case case 1 mutat set card mark collector clear sinc mutat set mark actual updat mutat must perform updat collector clear card mark sinc collector check intergener pointer clear card mark get updat perform collector check intergener pointer thu collector check nd intergener pointer collector set card mark case 2 mutat set card mark collector clear case card mark remain set requir summari new intergener pointer creat card mark properli set pointer notic subsequ collect 8 experiment result goal compar onth collector without gener compar eect choic paramet govern gener version eg size card size young gener use age etc implement origin onth collector 2 gener onth 2 fair comparison also introduc blackwhit color toggl origin onth collector statusm 6async markgrayheapxi markgrayi els collector trace markgrayheapxi markcardx gray figur 4 age version modi mutat routin clear full collect initfullcollect handshakesync1 mark posthandshakesync2 switchallocationclearcolor waithandshak posthandshakeasync mark global root waithandshak trace gray object pick gray object x markblackx object x heap blue allocationcolor figur 5 age version collect cycl card c dirtyc object x c pointer 2 x markgrayi markcardc initfullcollect object x heap allocationcolor figur age version modi collector routin collector prototyp aix jdk 116 jvm measur done 4way 332mhz ibm powerpc 604e 512 mb main memori run aix 421 addit measur uniprocessor run powerpc 192 mb main memori run aix 42 run execut dedic machin thu although elaps time measur varianc repeat run small run done initi heap size 1 mb maximum heap size mb calcul trigger full collect without gener veri work set run main memori eect due page 81 measur elaps time onth collector delic point onth collector measur perform run singlethread applic multiprocessor garbag collector run separ processor applic measur elaps time applic know much time collector consum second processor real world server handl mani process second processor come free order get reason measur much cpu time applic plu garbag collector actual consum ran four simultan copi applic 4way multiprocessor ensur processor would busi time ecient garbag collector would win parallel run repeat 8 time averag elaps time comput addit measur improv gener collect uniprocessor typic environ onth collector interest check whether gener help case well usual 82 benchmark benchmark taken specjvm benchmark 25 descript benchmark found spec web site 25 ran specjvm benchmark command line har test use s100 paramet also use two addit benchmark rst ibm intern benchmark call anagram 15 program implement anagram gener use simpl recurs routin gener permut thread impro vement 13 26 106 160 117 figur 7 percentag improv elaps time multithread ray tracer 4way multiprocessor benchmark multiprocessor uniprocessor improv improv anagram 250 327 figur 8 percentag improv anagram charact input string result word permut string found dictionari permut string display program collectionintens creat free mani string second code modic 227 mtrt 5 specjvm benchmark 25 order make interest multiprocessor machin program 227 mtrt variant ray tracer two thread render scene input le 340 kb size 5 227 mtrt run matric 200200 use 2 concurr thread modi run bigger matrix dimens 300300 also parametr number render thread call modic multithread ray tracer modi code avail request specjvm license 83 choic paramet applic dierent choic paramet govern gener collect seem yield best perform averag best choic paramet turn object mark ie card mark 16 byte per card without advanc age mechan best size young gener turn 4 megabyt also tri 1 2 8 megabyt young gener next section section 84 present result set paramet section 85 justifi choic compar perform algorithm age variou set paramet 84 result figur 7 present percentag improv multithread ray tracer benchmark describ section 82 number applic thread vari 2 10 gener perform well next figur 8 present improv gener collect yield anagram bench mark gener collect also beneci figur 9 examin applic specjvm benchmark one may see applic gener well omit result benchmark 200 check 222 mpegaudio sinc perform mani garbag collect perform indier collect method perform benchmark either gain boost gener collect remain virtual unchang except two benchmark 202 jess 228 jack suer perform decreas account dierenc applic measur sever runtim properti applic expect applic perform well gener collect mani object die young pointer old gener get frequent modi decreas perform 202 jess 228 jack origin sever reason shown measur first lifetim object typic gener die soon promot unless one make huge young gener second 202 jess 362 object scan partial collect scan dirti object old gener high cost benchmark multiprocessor uniprocessor improv improv compress 00 20 jess 37 25 228 jack 212 77 figur 9 percentag improv specjvm benchmark benchmark percent time partial gc full gc percent time gc gc gc activ activ wo gener wo gener compress 17 5 15 12 17 jess 133 70 2 148 51 228 jack 77 anagram 628 152 8 789 56 figur 10 use garbag collect applic manipul intergener pointer howev note success failur gener collector uenc also factor measur exampl increas local heap caus frequent collect hard measur present measur properti runtim remaind section present measur applic properti measur taken multiprocessor run singl copi applic start figur 10 amount time spent garbag collect number indic much chang garbag collect mechan may aect overal run time applic exampl program spend time garbag collect run anagram wherea program spend small part time garbag collect 201 compress 209 db also includ number collect cycl execut applic next figur 11 12 measur gener behavior benchmark involv particular measur mani object scan collect mani scan due intergener pointer percentag object freed partial collect report percent object young gener collect full collect report percentag alloc object whole heap reclaim alloc object count sum object freed object surviv collect exampl benchmark 201 compress object tend die young howev applic almost object die young next consid mainten intergener pointer see exampl 202 jess 362 object scan partial collect dirti object old gener high cost manipul intergener pointer one reason deterior perform final look mani object reclaim partial full collect applic 228 jack 202 jess object got tenur old gener surviv long see almost object collect full collect non gener behavior anoth reason gener perform well 202 jess 228 jack nongener collect free similar percentag object partial collect gain ecienc partial collect wherea pay overhead cost maintain intergener avg old avg avg avg object scan object scan object scan object scan intergen partial full collect pointer collect collect wo gener compress 3 168 4789 4778 jess 1373 3797 25411 25446 228 jack 151 4890 14972 11241 figur gener character applic part 1 percentag percentag percentag percentag byte freed object freed object freed object freed partial partial full collect collect collect collect wo gener compress 1929 4043 26 23 209 db 9766 9977 222 431 jess 9802 9788 872 863 213 javac 7125 6867 447 268 228 jack 9163 9658 908 947 anagram 8622 9343 142 132 figur 12 gener character applic part 2 pointer next figur 13 figur 14 look cost perform partial full collect variou benchmark cost time requir run collect perform number object collect accumul size note mark sweep algorithm cost sweep similar partial full collect trace time get shorter thu partial collect take less time drastic less figur show number type collect cycl benchmark benchmark number full collect use gener collector less number full collect use nongener collector final examin number page touch collector variou collect see figur 15 measur page touch trace sweep includ tabl collector use card tabl natur number page touch partial collect smaller number page touch full collect smallest ratio anagram benchmark number page touch partial collect 20 number touch full collect largest ratio 213 javac benchmark number page touch partial collect 70 number page touch full collect posit result match similar measur demer et al 6 85 tune paramet section explain choic paramet compar variou card size method age versu simpl promot method evalu variou size young gener age avg time avg time avg time activ partial activ full activ gc ms gc ms gc ms wo gener compress 17 35 31 jess 61 116 87 228 jack anagram 52 429 346 figur 13 ellaps time collect cycl avg avg avg avg space avg space avg space object freed object freed object freed freed freed freed partial full collect partial full collect collect collect wo gener collect collect wo gener compress 112 112 111 1057472 6922551 67953331 jess 106185 166720 160458 3934524 6759448 5982237 228 jack 133671 186370 202109 3677861 6905298 5841292 anagram 12251 30088 41370 3515684 13279332 12590566 figur 14 averag gain collect page touch wo partial full gener compress 76 124 109 jess 1304 2227 2048 228 jack 1199 2052 1767 anagram 1082 4938 5054 figur 15 averag page touch gc number thread block mark 1m young gener 39 88 50 90 82 block mark 2m young gener 08 71 60 98 87 block mark 4m young gener 11 25 66 98 74 block mark 8m young gener 09 47 77 109 88 object mark 1m young gener 47 26 43 140 130 object mark 2m young gener 14 44 59 113 86 object mark 4m young gener 13 26 106 160 117 object mark 8m young gener 19 80 132 188 154 figur tune size young gener percentag improv gener multithread ray tracer block mark object mark benchmark 1m 2m 4m 8m 1m 2m 4m 8m compress 041 019 005 046 004 011 002 029 jess 2244 1297 505 155 1377 872 37 566 228 jack 1214 627 283 1484 685 345 212 223 anagram 1443 3003 3717 3873 867 1206 2467 2642 figur 17 tune size young gener percentag improv gener specjvm benchmark method compar perform variou tenur threshold result summar sever tabl describ 851 size young gener begin evalu variou size young gener compar size 1 2 4 8 megabyt possibl altern size young gener present measur two extrem case card size block mark card size 4096 byte object mark card size byte see subsect 853 card size best applic result multithread ray tracer found figur 16 specjvm benchmark 25 figur 17 result point singl best size benchmark averag best perform obtain size 4 megabyt young gener sequel x young gener 4 megabyt except evalu age mechan 852 age mechan result age disappoint seen result figur 18 figur 19 vari size young gener 1 2 4 8 megabyt age threshold promot old gener 4 6 8 10 recal object alloc age 1 age get increas collect surviv chose card size smallest possibl justi analysi card size section 853 note use simpl promot mechan object get old age 2 thu possibl compar overhead age method compar simpl promot mechan age old age 2 turn age method big overhead see figur 20 show percentag improv actual deterior use age 2 age age 4 old age 6 old benchmark 1m 2m 4m 8m 1m 2m 4m 8m jess 177 158 101 78 126 137 103 92 209 db 24 07 14 04 31 13 11 01 228 jack 114 67 18 15 126 64 25 09 anagram 108 19 200 296 112 08 183 267 figur 18 percentag improv age mechan nongener collector specjvm benchmark part 1 object mark age age 8 old age 10 old benchmark 1m 2m 4m 8m 1m 2m 4m 8m compress jess 146 173 51 38 176 94 49 36 213 javac 270 131 36 174 335 162 32 155 228 jack 116 35 20 04 144 42 26 12 anagram 118 04 161 239 117 16 149 234 figur 19 percentag improv age mechan nongener collector specjvm benchmark part 2 benchmark 1m 2m 4m 8m 201 compress 009 018 097 016 jess 321 343 354 124 228 jack 301 288 148 040 anagram 211 910 363 334 figur 20 percentag improv cost age mechan 2 age simpl promot method instead standard method use object mark ie smallest card size may possibl improv perform age algorithm chang algorithm data structur someth attempt work perhap simpl modic locat valu age insid object instead keep tabl age may help improv local refer light result chosen use age 853 choos size card final ran measur nd best card size vari size 16 4096 includ power 2 best card size depend behavior applic note sinc move object heap object young old gener segreg interest phenomena scan card dirti object concentr heap specic locat big small smaller card shorten scan exampl rst 14 heap contain dirti object take card whose size quarter heap card whose size 16 byte well object actual scan dirti card howev dirti object spread randomli heap rene card size use ner card less object scan thu natur applic determin use small card consider exampl smaller card impli bigger card tabl card tabl access pointer modic may uenc local refer big tabl access frequent random manner decreas local seem consider opposit previou one heap access applic randomli distribut big tabl bad bigger card requir heap access concentr access card tabl concentr even big tabl smaller card ne big question consider domin frequenc access note card get dirti even touch relev issu consider previou paragraph howev local refer matter frequent card touch frequenc may determin consider win card size best applic actual result given follow tabl tabl 21 specifi improv gener collect versu nongener collect benchmark variou card size use young gener 4 megabyt object mark get impress uenc result also present tabl 22 percentag card dirti collect tabl 23 area got scan due dirti card case size card make signic impact run time biggest impact seen benchmark anagram 213 javac 202 jess impact card size benchmark anagram bigger card size better 213 javac smaller better 202 jess two extrem 16 4096 byte best chose use smallest card size denot object mark rest test object mark 4m young gener benchmark byte byte byte byte byte byte byte byte byte compress 011 016 010 041 025 033 040 046 062 jess 425 402 664 917 724 717 696 701 665 228 jack 743 624 701 612 679 716 678 672 650 anagram 2361 1892 2404 2859 3135 3309 3341 3448 3524 figur 21 percentag improv specjvm benchmark variou card size object mark 4m young gener benchmark byte byte byte byte byte byte byte byte byte jess 1581 3070 4285 5016 5343 5665 5946 5908 6118 228 jack 1766 2871 3251 3447 3519 3841 4001 4053 4411 anagram 114 078 207 122 122 125 122 123 131 figur 22 tune parameterscard size percentag dirti card alloc card look tabl 22 23 see almost dirti card scan anagram one properti anagaram make gener collect appropri note anagram best larg card size probabl due smaller card tabl sinc uenc actual scan neglig 209 db size card practic uenc size area scan collect probabl due concentr dirti object discuss object mark 4m young gener benchmark byte byte byte byte byte byte byte byte byte jess 1237 2421 3426 3888 4191 4387 4499 4626 4780 228 jack 1309 2059 2319 2450 2562 2717 2821 2983 3226 anagram 107 175 170 168 167 170 165 167 178 figur 23 tune parameterscard size area scan dirti card 9 conclus present design incorpor gener onth garbag collector java best knowledg combin tri nding impli gener beneci spite two obstacl fact gener segreg space sinc object move collector fact obtain shorter paus collect relev onth collector turn benchmark overal run time reduc 25 one benchmark gener collect increas overal run time multiprocessor 4 best perform variant gener collect variant check one simplest promot polici promot object old gener surviv one collect quit big young gener 4 megabyt small size card card mark algorithm 16 byte per card collect less page touch gener collector thu one especi consid use gener onth collector applic run limit physic memori acknowledg thank han bohm help remark thank alain azaguri katherin barabash bill berg john endicott michael factor arv fisher naama krau yossi levanoni ethan lewi eliot salant dafna sheinwald ron sivan sagi snir igor yanov help discuss r list process realtim serial comput treadmil algorithm onth garbag collect combin gener conserv garbag collect framework implement experi concurr garbag collector mudula2 unobtrus garbag collect multiprocessor system concurr gener garbag collector multithread implement ml exercis prove parallel program correct anagram gener garbag collect algorithm automat dynam memori manag ment use color toggl reduc synchron dlg collector garbag collect multipl process exercis parallel concurr marksweep garbag collect without finegrain synchron real time garbag collector base lifetim object garbag collect larg lisp system lifetimebas garbag collector lisp system generalpurpos comput multiprocess compactifi garbag collect multiprocess compactifi garbag collect gener scaveng nondisrupt high perform storag reclam algorithm tr algorithm onthefli garbag collect combin gener conserv garbag collect framework implement treadmil compar perform evalu write barrier implement concurr gener garbag collector multithread implement ml unobtrus garbag collect multiprocessor system garbag collect concurr markmyampersandampsweep garbag collect without finegrain synchron realtim garbag collector base lifetim object list process real time serial comput onthefli garbag collect exercis prove parallel program correct multiprocess compactifi garbag collect onthefli garbag collect onthefli garbag collect garbag collect larg lisp system garbag collect task delet distribut applic process system gener scaveng lifetimebas garbag collector lisp system gener purpos comput ctr perri cheng guy e blelloch parallel realtim garbag collector acm sigplan notic v36 n5 p125136 may 2001 hezi azatchi yossi levanoni harel paz erez petrank onthefli mark sweep garbag collector base slide view acm sigplan notic v38 n11 novemb david f bacon perri cheng david grove martin vechev syncop gener realtim garbag collect metronom acm sigplan notic v40 n7 juli 2005 david detlef ross knippel william clinger matthia jacob concurr rememb set refin gener garbag collect proceed 2nd java virtual machin research technolog symposium p1326 august 0102 2002 katherin barabash yoav ossia erez petrank mostli concurr garbag collect revisit acm sigplan notic v38 n11 novemb yoav ossia ori benyitzhak irit goft elliot k kolodn victor leikehman avi owshanko parallel increment concurr gc server acm sigplan notic v37 n5 may 2002 hang pham control garbag collect heap growth reduc execut time java applic acm transact program languag system topla v28 n5 p908941 septemb 2006 karen zee martin rinard write barrier remov static analysi acm sigplan notic v37 n11 novemb 2002 katherin barabash niv buchbind tamar domani elliot k kolodn yoav ossia shlomit pinter janic shepherd ron sivan victor umanski mostli accur stack scan proceed javatm virtual machin research technolog symposium javatm virtual machin research technolog symposium p1919 april 2324 2001 monterey california david f bacon clement r attanasio han b lee v rajan stephen smith java without coffe break nonintrus multiprocessor garbag collector acm sigplan notic v36 n5 p92103 may 2001 katherin barabash ori benyitzhak irit goft elliot k kolodn victor leikehman yoav ossia avi owshanko erez petrank parallel increment mostli concurr garbag collector server acm transact program languag system topla v27 n6 p10971146 novemb 2005 martin vechev eran yahav david f bacon correctnesspreserv deriv concurr garbag collect algorithm acm sigplan notic v41 n6 june 2006 antoni l hosk portabl mostlyconcurr mostlycopi garbag collect multiprocessor proceed 2006 intern symposium memori manag june 1011 2006 ottawa ontario canada