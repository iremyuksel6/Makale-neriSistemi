intellig backtrack schema logic program environ present new method repres variabl bind warren abstract machin wam age variabl bind easili found use new represent intellig backtrack schema age variabl bound nonvari term youngest choic point backtrack choic point make variabl unbound variabl procedur backtrack point choic point procedur current execut choic point first ancestor choic point variabl age procedur backtrack point use process figur backtrack point intellig backtrack schema intellig backtrack schema perform much better result intellig backtrack method literatur determinist program perform nondeterminist program compar result b introduct backtrack method use standard prolog implement known naiv backtrack naiv backtrack goal fail backtrack done recent choic point failur last altern although choic point may noth failur approach lot unnecessari backtrack done even though failur occur mani time intellig backtrack method analyz reason failur choos proper choic point avoid redund backtrack chosen choic point may recent choic point failur word altern choic point recent one chosen one discard without retri retri system reencount failur warren abstract machin wam abstract machin prolog execut consist instruct set sever data area instruct oper wam recogn breakthrough design prolog system comput logic system logic program commun mani commerci 2 15 noncommerci 3 prolog system base wam implement last decad paper assum reader familiar wam detail wam found warren origin paper 17 kaci tutori book wam 1 mani intellig backtrack scheme 4 5 6 7 9 11 12 13 14 16 19 present avoid unnecessari backtrack step earli work intellig backtrack 4 9 14 implement prolog interpret implement later work 6 7 11 12 wam base system intellig backtrack schema whose part present paper implement extens wam like system 6 11 mechan similar mechan use system except way keep unif inform variabl bind find reason failur mechan find age variabl caus failur central part intellig backtrack schema paper concentr new represent variabl bind wam age variabl easili found mechan propos natur integr wam architectur perform result better perform result system 4 6 11 rest paper organ follow section 2 summar relat research intellig backtrack section 3 introduc procedur backtrack point play import role determin variabl age section 4 present unif graph give concret definit variabl age prolog variabl section 5 present new represent bind wam variabl algorithm find age wam variabl bound nonvari term mechan use figur intellig backtrack point procedur call failur describ section 6 final present perform result section 7 relat research research intellig backtrack start late 70 initi propos made bruynoogh pereira 4 cox pitrzykowski 9 two system implement extend prolog interpret method collect inform bind unif analyz determin intellig backtrack point failur occur also retain inform failur ensur failur repeat reason method known intellig backtrack method base unif failur analysi backtrack schema similar bruynoggh work sens also collect inform bind tag bind determin intellig backtrack point analyz tag bind failur howev schema implement wambas system prolog interpret lin kumar leung schema 10 11 12 choos intellig backtrack point analysi liter instead analysi unif failur earli work 10 use data depend techniqu claus level parallel execut logic program similar mechan use woo choe 19 andor parallel process model lin kumar 11 12 extend method sequenti execut prolog use data depend techniqu whole proof tree instead data depend techniqu claus level later integr techniqu wam wambas implement maintain list goal goal call blist repres goal backtrack goal may cure failur goal list also tag variabl repres data depend graph tag use figur bind caus failur goal reduc overhead construct data depend graph chang despain 5 construct worstcas data depend graph compil time claus sinc backtrack liter chosen compil time schema littl bit overhead run time howev method capabl handl better situat run time tri meet requir worst case method also need inform possibl activ goal compil time analysi inform must given user without inform static datadepend analysi may degener naiv backtrack main respons user effici method depend well possibl activ goal mark codognet colleagu propos depthfirst intellig backtrack schema 6 give wambas implement 7 schema unif instruct record sourc bind failur routin choos intellig backtrack point updat set intellig backtrack point unif creat simplifi version unif graph record time bind also attach set intellig backtrack point liter set creat first entranc liter maintain backtrack process minim mainten overhead set bitvector use implement claim forward overhead schema occur unif compar wam backward overhead occur failur 5 accept total overhead determinist program 20 toh ramamohanrao 16 propos intellig backtrack schema requir datadepend analysi inform collect unif accord method fail atom use figur intellig backtrack point sinc failuredirect mechan less accur unificationbas schema schema give less accur result compar unif base scheme includ schema intellig backtrack method literatur associ kind set liter store intellig backtrack point set call altern backtrack point 6 7 blist 12 reject procedur 4 wit set 18 candid set 8 set updat either unif failur main differ method maintain kind set method tag bind unif use inform tag bind figur intellig backtrack point failur overhead method occur tri find intellig backtrack point failur method big percentag overhead intellig backtrack mechan occur maintain set sinc method creat set unif pay heavi penalti even determinist program mechan howev pay penalti failur therefor gain intellig backtrack mechan nondeterminist program compens overhead sinc mechan littl overhead unif overhead caus big penalti determinist program fact forward overhead schema occur unif 3 procedur backtrack point regular prolog system backtrack made recent choic point failur occur due unif failur occur variabl bound nonvari term unifi differ nonvari term unif algorithm unifi two variabl bound two differ nonvari term sinc variabl bound nonvari term respons failur reoccurr failur avoid backtrack choic point variabl bound nonvari term unif occur backtrack recent altern regular prolog system may fix problem failur may occur thu backtrack youngest choic point variabl caus failur unbound choic point call reason failur also avoid failur backtrack first altern claus failur occur mean complet skip claus unif caus failur occur cours youngest one two point go backtrack point failur intellig backtrack schema give definit formal describ procedur backtrack point definit 31 procedur backtrack point let p current procedur execut procedur backtrack point certain time execut ffl choic point p p choic point ffl choic point ps first ancestor choic point otherwis unif graph variabl b unif graph term notat unifi choic point procedur p procedur backtrack point figur 1 unif graph procedur backtrack point indic furthest choic point system backtrack failur failur occur system backtrack choic point recent one procedur backtrack point procedur backtrack point equal recent choic point known shallow backtrack case recent choic point tri procedur backtrack point older recent choic point case point system backtrack depend reason failur reason failur indic choic point older procedur backtrack point backtrack procedur backtrack point backtrack current procedur backtrack point complet skip claus unif caus failur occur word reencount failur go execut unif wam base implement intellig backtrack schema introduc new regist pb procedur backtrack point hold procedur backtrack point addit regist origin wam architectur regist pb updat new choic point creat tri instruct previou valu regist pb save new choic point tri instruct backtrack regist chang point backtrack choic point fact choic point recent choic point time regist pb also restor save valu choic point choic point discard pb regist save environ alloc instruct way save environ regist e except regist pb updat alloc instruct reason save environ restor store valu current environ proceed instruct proceed instruct execut get context procedur return context one ancestor sinc ancestor environ procedur backtrack point save environ regist pb restor valu unif graph section introduc unif graph repres unif variabl prolog program aim section defin concept age variabl prolog environ age prolog variabl bound nonvari term caus failur play import role figur intellig backtrack point failur unif graph set variabl label acycl undirect graph vertic graph variabl set edg repres unif variabl indic two vertic label edg indic age unif age unif procedur backtrack point unif backtrack choic point indic age unif avoid reoccurr unif word backtrack age unif complet skip claus unif occur figur 1a give unif graph three variabl x z nonvari term g label edg name procedur whose choic point procedur backtrack point unif exampl x unifi g procedur backtrack point unif choic point procedur p r respect unif z choic point procedur q procedur backtrack point note variabl bound nonvari term g result three unif graph label edg reflect time unif three unif given graph figur 1a perform order age prolog variabl bound nonvari term youngest one among choic point indic label path variabl nonvari term unif graph failur occur variabl bound nonvari term backtrack one choic point indic label path variabl nonvari avoid reoccurr failur figur 1a z bound constant g result three unif age p q r age z youngest one p q r variabl bound complex nonvar term constant age variabl determin depend part term caus failur figur 1b x unifi term fy unifi nonvari term g x caus failur tri unifi nonvari term functor f constant g caus failur first case use youngest one unif age path x case 1 timexi timey z timexg pxi qyz case 2 timexi timexg timey z pxi oe qyz z case 3 timey z timexg timexi qyz pxi oe rxg case 4 timey z timexi timexg qyz z oe pxi case 5 timexg timexi timey z oe pxi z case oe pxi z oe qyz notat pxi l2 locat l1 bound locat l2 unif age unif p variabl involv unif x time unif x relat use indic younger older relat among time assumpt creation order variabl g z x live data area heap figur 2 correspond refer chain unif graph term fy figur intellig backtrack point second case use youngest one unif age path x fy g 5 age wam variabl section present new represent techniqu bind wam locat discuss variabl age term bind age wam locat use unif graph directli wam base implement unif graph map differ structur wam locat calcul age wam locat correspond prolog variabl differ structur wam locat variabl wam chain locat end unbound locat nonvari term sinc nonvari term caus failur unif concentr refer chain end nonvari term unbound locat bound anoth locat oper call bind variabl bind refer chain caus failur bind backtrack procedur backtrack point time bind note age bind may recent choic point time bind follow exampl age bind similar bind variabl x must equal q age bind x 1 2 equal name choic point p p q note recent choic point differ bind age bind choic point procedur p procedur backtrack point bind thu procedur fail due bind 2 backtrack choic point p instead choic point q definit 51 age bind age bind procedur backtrack point regist pb time bind definit correspond definit age unif unif graph obviou age bind must equal age unif caus bind prolog sinc need age bind use extra entri store inform bind represent method use four valu cell bound wam locat first valu cell hold actual valu store result bind oper pointer anoth wam locat constant procedur backtrack point bind save second posit age bind may differ recent choic point bind third fourth posit hold first locat variabl whose unif caus bind unif graph map differ structur wam locat depend time unif creation time locat variabl graph let us assum locat xy z g figur 1a creat revers order ie creation order g z x data area six differ structur refer chain variabl depend time three unif graph figur 2 give refer chain six case figur arrow repres bind label arrow repres age bind first locat variabl whose unif caus bind exampl case 5 function locat nonvari term end refer chain v els f notvisit junctionset visit empti done done f delet first node x ageset xy notvisit els f w z ageset wz junctionset xy w z 6 x w z 62 visit w z 62 notvisit add w z ageset wz notvisit last node w z ageset wz visit x w z share common locat f let b c new pair b c locat x w z b c 6 x b c 62 visit b c 62 notvisit add b c ageset xy ageset wz notvisit last node g add x ageset xy visit last node g g age v youngest ageset v return age v g figur 3 algorithm find age variabl bound ground term arrow z g label q z repres bind z g age bind q first locat variabl caus bind z note q also age unif z correspond unif graph figur 1a definit 52 age set bind two locat let x two wam locat refer chain join locat age set bind x set age bind caus junction use notat ageset xy repres age set bind x definit 53 age wam locat assum x wam locat whose refer chain end locat g hold nonvari term age x youngest age ageset xg use notat agex repres age x refer chain two locat end locat must junction locat worst case junction locat last locat refer chain exampl x case 3 figur 2 locat g junction locat junction locat z z definit 54 junction set x junction locat z junction set set bind x z z use notat junctionset xy junction set x item junction set pair repres bind first element pair also pair first locat variabl whose unif caus bind second element bind pair singleton set age bind exampl junction set x case 3 figur 2 equal fy z fqg x fpg x g frgg junction set z fy z fqgg fact junction set special form set bind age set set bind age set junction set except second element bind pair nonempti set age bind age pair z fqg mean z bound unif whose age q gener age set bind age pair repres age unif caus bind two locat pair figur 3 give algorithm written pseudocod find age variabl bound nonvari term algorithm first find locat g nonvari term end refer chain given variabl v v equal g age locat nonvari term age v otherwis construct ageset v g set age unif caus bind v g find age v start junction set junctionset v g v g accomplish task age least one bind junctionset v g ageset v g continu enlarg set bind age set ad junction set variabl bind current set new bind construct join two bind set two bind join get new bind share common variabl word bind x z creat new bind x z age set new bind union age set bind involv join oper bind consid put set visit rest bind stay set notvisit new bind ad notvisit produc earlier enlarg set check whether find bind v g enlarg stop find algorithm breath first search search space possibl bind sinc age variabl youngest age age set comput youngest age age set instead comput whole set actual implement algorithm exampl show enlarg step algorithm tri find age z case 3 figur 2 step give set visit notvisit indic current search space bind ffl calcul junctionset zg assign notvisit ad junctionset xy result join oper bind visit notvisit ffl visit z ad junctionset z result join oper z fqg bind visit notvisit ffl visit x g ad junctionset xg result join oper x g frg bind visit notvisit ffl visit x z ad junctionset xz result join oper x z fp qg bind visit notvisit ffl visit g ad junctionset g result join oper g fp rg bind visit notvisit ffl visit z g found ageset zg ageset ffl choos youngest age ageset zg agez optim algorithm stop search immedi bind z g fp q rg found visit bind x z fp qg 6 find reason procedur failur failur normal occur unif head argument unif instruct use head match divid two group instruct first group eg get constant unifi constant tri unifi variabl specif nonvari term failur occur variabl bound nonvari term differ specif nonvari term second group instruct eg get val unifi val complet unif instruct take two variabl unifi case failur occur variabl bound two differ nonvari term first case age variabl determin reason failur second case youngest one age two variabl play role determin reason failur case reason failur point choic point actual procedur backtrack point bind caus failur procedur call fail claus procedur fail reason failur procedur call youngest one failur reason claus store youngest reason procedur failur reserv space choic point point call field choic point rb reason backtrack point field initi special valu creation choic point tri instruct failur rb field choic point indic procedur backtrack point regist pb may updat reason failur updat reason failur reason younger valu store rb field rb field alway hold youngest one failur reason claus procedur question failur occur failur reason r point choic point failur routin compar r valu store regist pb r younger pb r chosen backtrack point mean stay context current claus procedur own choic point indic pb word claus fail yet r equal pb claus procedur own choic point indic pb fail failur depend outsid reason case r chosen backtrack point r older pb claus fail due outsid reason sinc procedur altern backtrack point next altern choic point indic pb regist sinc claus procedur question fail reason claus failur may need record rb field choic point cours reason record younger failur reason previou claus procedur mapcolorabcd nextxi next1xi next1greenr next1redyellow nextab nextac nextad nextxi next1yx next1greenyellow next1redblu nexta nextbc next1greenblu next1yellowblu figur 4 map color program codognet kumlin bruper 6queensnaiv 24 26 25 15 8queensnaiv 51 69 44 circuit design 44 42 25 mapcolorbad mapcolorgood 117 12 11 20 tree 103 12 11 14 tabl 1 speedup intellig backtrack method wrt prolog sinc need choos youngest reason among failur reason claus procedur failur reason procedur call procedur also need failur reason last claus make decis mean choic point procedur discard last claus fail reason trust instruct implement discard choic point behav way retri instruct except put address new wam instruct discardfail instead address next claus choic point last claus procedur fail new instruct discardfail execut discard recent choic point invok failur reason store rb field choic point mean procedur call go fail youngest one failur reason claus note need creat choic point procedur singl altern failur reason procedur call procedur failur reason singl claus 7 perform result extend byte emul wam base system al appli logic system prolog implement mechan observ gain overhead system test program three categori addit standard test program intellig backtrack system first categori includ program lot unnecessari backtrack regular prolog system system give good perform program avoid lot redund failur map color program given figur 4 good exampl categori regular prolog system 147 failur find solut system 15 failur term cpu time system 6 time faster prolog system exampl program last subgoal fail first valu variabl b c regular prolog system altern third fourth subgoal tri second subgoal retri get anoth valu variabl c although respons bind variabl b c schema last subgoal complet fail system backtrack next altern second subgoal without retri third fourth subgoal second categori contain prolog program lot backtrack redund kind program use machineri schema without gain fact kind program repres worst case schema exampl put subgoal nextbc third subgoal claus figur 4 redund failur case system regular prolog system backtrack slowdown system 17 percent compar regular prolog system determinist program last categori sinc overhead schema occur failur analysi want see effect determinist program test system complet determinist program slowdown system 23 percent result real encourag overhead schema minimum failur fact reflect overhead keep extra inform bind oper maintain pb regist store regist choic point environ lot failur gain avoid redund backtrack overhead due complex failur routin also test implement certain benchmark compar result intellig backtrack method present 4 7 12 tabl 1 show speed up slow down intellig backtrack method respect differ prolog system figur tabl give comparison intellig backtrack scheme byteemul al prolog posit number reflect speed up intellig backtrack scheme neg number reflect slow down tabl 1 show speed up scheme wors result method nondeterminist program naiv version nqueen problem circuit design problem bad version map color problem good version map color problem reflect worst case scheme lot failur program gain much intellig backtrack scheme problem mean worst case still good method best part scheme low overhead determinist program slow down scheme determinist program clever version nqueen problem tree problem much better result method problem 8 conclus intellig backtrack mechan whose part present choos youngest choic point backtrack failur backtrack choic point avoid reoccurr failur guarante chosen backtrack point youngest choic point backtrack choic point younger chosen choic point avoid recoccur failur mean mechan choos exactli right posit backtrack new method represent bind wam variabl play import role process find age variabl bound nonvari term age variabl procedur backtrack point introduc determin backtrack point failur due variabl new represent smoothli integr origin wam architectur small overhead sinc overhead system occur failur unif process suitabl intellig backtrack schema overhead unif occur everi type program r appli logic system fast increment portabl prolog compil deduct revis intellig backtrack yet anoth intellig backtrack method extend wam intellig backtrack implement backward execut nondeterminist andparallel system basi intellig backtrack intellig backtrack algorithm parallel execut logic program intellig backtrack schema prolog intellig backtrack plan base deduct quintu prolog refer manual abstract prolog instruct set semant transpar select reset parallel interpret base origin failur select backtrack liter andor process model tr