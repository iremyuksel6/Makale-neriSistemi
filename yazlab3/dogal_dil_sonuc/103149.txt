reliabl solut special event locat problem ode comput solut initi valu problem ordinari differenti equat ode may part larger task one task find algebra function solut event function root event occur task difficult theori softwar practic certain use kind event function possibl avoid two fundament difficulti describ achiev reliabl solut problem way allow capabl graft onto popular code initi valu problem b introduct comput solut yfflr n initi valu problem ordinari differenti equat may part larger task possibl common task find either first point 0 set point ft g one equat satisfi g j call event function event j said occur root jth event function paper concern class problem event function g j defin polynomi either 0 specif assum g j 12 form either x compon solut vector yx gener polynomi form g j treat techniqu expens rather complic machineri common problem find compon solut assum given valu ii find compon solut extremum form 13 14 singl event function allow sever event function form time solv complic problem iii tabul valu depend variabl iv determin locat switch point point discontinu defin term linear function depend variabl v determin zero gener event function qx adjoin differenti equat q system 11 difficulti event locat problem often appreci next section investig theoret difficulti two fundament difficulti usual approach one sure notic event one realiz event occur one sure find first occurr special problem consid present effici way overcom difficulti least principl difficulti remain section 3 state key observ describ exploit presenc one event function caus mani complic present softwar design reason easi use provid consider flexibl produc code event locat use mani popular code initi valu problem goal add capabl locat event without alter integr section 4 describ accomplish section 5 discuss code import applic 2 problem difficulti popular code initi valu problem 11 step b produc approxim yx set point usual code test valu event function 12 differ sign x x i1 chang sign one indic event occur x adam backward differenti formula bdf code produc polynomi px approxim yx whole interv natur comput first root approxim locat event j popular rungekutta formula produc solut mesh point x approach event locat problem import reason recent work aim provid formula polynomi approxim solut valid x way locat event describ natur mani led think task easi far true mesh point x chosen provid effici approxim yx 0 x specifi accuraci event function 12 influenc select mesh space may appropri locat posit event root 12 even number root count multipl occur x x i1 notic presenc event notic gener way certain rootsolv find first root cours one might monitor behavior close reduc chanc miss root particularli care algorithm watt 12 13 expens guarante succeed unlik deceiv nearpatholog case event function form qx yx convert form consid analyt partial deriv avail new depend variabl ad system 11 note dz dx look event convers forc integr select step size appropri qx yx consequ locat event much reliabl unfortun may expens comput qx yx accur way cost would paid even event occur b also partial deriv q x q may difficult obtain state event locat problem equat 11 integr least first event occur common use event function determin function fx redefin exampl might one set differenti equat describ temperatur room temperatur drop low thermostat switch heater new situat describ new set equat exampl definit f clearli depend histori integr natur locat event restart integr new definit f decept problem occur f may redefin variou possibl definit depend histori integr exampl suppos fx otherwis temptat program f straightforward fashion larg measur defeat effici locat event difficulti code initi valu problem expect f smooth program f valu determin simpl test magnitud present integr function f continu lack continu deriv integr step valu 1 valu 1 function f smooth enough basic theori underli construct integr appli happen unpredict integr may realiz produc inaccur solut mathemat softwar solv differenti equat tri recogn cope problem design qualiti code like recogn inaccur solut reject step tri smaller step often case code repeatedli tri step cross event reject step fall short succeed way eventu integr step past event step size small result accur proper use code event locat abil avoid clumsi unreli handl discontinu initi valu jyj 1 smooth function fx integr one event occur locat event determin f redefin intgrat restart new f smooth name fx case may way proceed effici furnish reliabl solut task intend paper suppos function f smooth f redefin event new integr initi point accur locat event depend accur integr underli differenti equat conditiong root difficulti present even simpl event function treat discuss matter specif context find root event function step code produc polynomi px approxim solut compon j x event approxim root equat minor sourc error locat event comput code requir user specifi accur comput author prefer comput accur possibl precis avail reason suppos comput satisfi exactli though quit true discrep far smaller error consid relat j approxim p simpl root approxim second term lead immedi approxim error p 0 small root poorli determin easi extend argument deal multipl root come conclus multipl root illcondit differ usual algebra case term repres true global error integr 11 code initi valu problem even tri control error directli best size compar local error toler use integr gener expect locat event accur integr toler problem 11 illcondit may achiev even close accuraci would help user code event locat capabl estim error report code provid estim quantiti multipli global error equival quantiti multipl root esim 21 refer event function form 13 easi obtain analag result event function form 14 code estim condit problem similar way estim error locat would need estim global error j one case 0 awar satisfactori way estim quantiti commonli assum global error compar local error toler assumpt along condit number provid yield crude use indic error implic fact discomfit perfectli possibl event occur integr done one toler occur differ toler unpleas wors happen toler integr perform differ exampl differ output requir alter choic step size particular repeat integr code step alleg locat event ordinarili result valu gx yx 0 x differ obtain use polynomi approxim px mesh point relat matter gener comput event posit contrari one might expect often discuss typic code allow yx 0 x 12 larg part answer suffic mani problem seen practic howev fundament difficulti higher order deriv polynomi may fit yx well yet deriv exhibit even qualit agreement adam method base polynomi approxim 0 x perfectli natur includ 12 method presenc 0 x 12 debat expens way handl first deriv elimin solv instead reliabl nonstiff problem avoid stiff problem wellknown p 0 x associ bdf code ordinarili far better approxim 0 x fx px deriv handl analyt partial deriv avail ad deriv new variabl system 11 rather like event function q ad variabl proceed way caus code produc independ polynomi approxim deriv specifi local accuraci unfortun obtain equat satisfi deriv may difficult besid fundament difficulti anoth aris polynomi approxim produc popular code polynomi produc popular fehlberg 45 rungekutta formula horn 8 adam code shampin gordon 10 connect mesh point x form global continu function bdf adam code gear 5 form continu function first deriv jump discontinu jump seen code compar size local error toler obvious scheme describ locat event exhibit anomal behavior approxim solut use remedi difficulti number author recent suppli algorithm c 1 piecewis polynomi approxim rungekutta 4 11 adam 14 bdf 1 13 code 3 rootfind algorithm section describ techniqu use solv special event locat problem appropri necessari describ detail code aim present import idea suitabl structur realiz code discuss detail section 5 present 2 consid task integr 11 first posit satisfi 12 locat key observ event function form 13 14 yx approxim polynomi px function polynomi cours true kind event function well restrict form 13 14 allow us solv interest practic problem still provid simpl user interfac approach also gener kind approxim found 6 x4 purpos piecewis ration approxim yx offer advantag easi see event function form 13 14 ration approxim also lead find root polynomi shall say obviou gener use sturm sequenc say principl answer question root polynomi g j x px p 0 x interv also possibl sure comput first root one present use exampl bisect sturm sequenc test presenc root follow describ one way exploit observ first need clear mean first posit equat 12 satisfi quit possibl inde fairli common practic 12 satisfi initi point cours user abl check without assist need report integr 11 intend employ code use mode call routin integr step current point x intern chosen point x i1 direct integr intend search current integr interv next occur event defin 12 defin current integr interv half open interv overal lose point rang integr except possibl initi point x definit two signific advantag first techniqu determin posit event base sturm sequenc algorithm 9 count number zero given algorithm alway defin interv second locat event point wish go locat next event direct integr interv search initi natur code provid two basic modul one modul design sole check whether event 12 modul take input interv shift power seri represent event function g j use standard sturm sequenc algorithm determin precis mani occurr count multipl event ii second modul use locat first event user specifi interv call modul describ determin one event occur modul output accur estim first posit event c multipl andor type depend context condit number interv c search c largest interv seen contain one event solut yx approxim px chang posit event possibl multipl especi origin problem event high multipl well separ assum solv state section 2 return condit number root use gain impress accuraci want algorithm locat first posit event effici robust tri devis algorithm converg rapidli satisfi reduc task locat event singl event function cautiou less frequent occur circumst insist effici might employ simpler algorithm exampl could appli standard code comput root polynomi locat occurr event rank result determin locat first event approach would palpabl ineffici even first check event occur shall say event function activ import effici fact mani applic one event function also whether expect mani integr interv event event occur usual one interv sever event occur one integr interv usual isol rel machin roundoff code whenev isol singl activ event function singl occurr henc comput c use standard bisec tionsec algorithm 3 rewritten revers commun form locat posit event accur get stage first identifi event activ interv c current interest make list next use bisect algorithm identifi point dc first element activ event list event occur c suppos current interv c initi set c may singl activ event case set c use bisectionsec algorithm locat precis even one activ event worth proceed similar way varieti possibl includ use bisectionsec algorithm activ event turn follow rank comput posit find first second possibl locat posit first activ event accur check posit first event find activ event c start howev adopt approach gener effici choos arbitrarili work first activ event proceed one iter time bisectionsec algorithm event comput estim e posit event call bisectionsec code sever possibl estim right locat event reduc interv c e similarli left reduc interv e case comput new estim locat event first function repeat remain possibl event function event left e case reduc list activ event function restart interv c e possibl new first event function two variat basic problem comput first event occur frequent present difficulti softwar involv continu integr 11 next event one case event function remain chang difficulti first task one event occur immedi anoth comput posit obtain interv c 2 c contain event big help also difficulti event may occur sever time vicin finit precis arithmet use yet infinit precis arithmet henc even though exclud interv search posit next event point nearbi may identifi incorrectli posit help overcom problem search search proce two stage first check remain part current integr interv use inform comput alreadi least one event occur interv comput posit closest proceed otherwis move next integr interv proceed case find first posit event second problem inform contain comput interv longer use chang event definit may occurr one newli defin event henc never avoid possibl numer root without recours error analysi discuss section 2 implement redefin set event point proceed must comput intern data exampl sturm sequenc coeffici may check occurr event x i1 algorithm proce like one describ earlier possibl work throughout set event includ possibl definit aris stage integr point view least sometim avoid round effect would better choic possibl one use algorithm describ first problem rather second even though might involv postprocess user event posit inform 4 combin rootfind integr section consid design interfac allow root find code graft onto mani popular integr version plan dissemin make minim assumpt integr assum use mode return call program step x x i1 polynomi known degre r repres solut x note earlier anomal behavior possibl interpol certain popular code connect smoothli mesh point interfer rootfind treatment interv provid user appreci potenti difficulti aris lack smooth reason use rootfind code effect lack smooth similar mark aris loss smooth due numer error algorithm discuss end section modul written rootfind task assum polynomi form r r r popular integr repres interpol polynomi mani form viz taylor lagrangian divid differ hermit routin need 7 32e5 14 98e10 tabl 1 condv convert standard form first consid inform form suppli abil evalu interpol hardli surpris better job done inform suppli exampl taken abil evalu polynomi px degre r provid integr convert form 41 choos r form valu construct p way involv solut van der mond system comput illcondit especi high degre sometim occur adam code tabl 1 give extrema chebyshev polynomi r1 x shift 0 1 degre 15 typic bdf rungekutta code higher degre occur adam code condit number uncomfort larg higher degre howev notori pessimist analysi 7 show expect size condit number reflect error coeffici r 41 long use appropri algorithm solv van der mond system gener purpos packag written use node specifi except user may overrid choic approach one might hope nordsieck form interpol polynomi use number popular code taylor seri expans polynomi special interfac convert shift scale form 41 need much natur gener approach special interfac less troubl condit matter straightforward go detail 5 29e3 11 40e8 tabl 2 condv r interpol node function deriv routin evalu px evalu p 0 x time odd replac 43 set distinct point tabl 2 tabul condv valu littl smaller tabl 1 increas similarli recent consider interest provid rungekutta code kind polynomi interpol requir paper 4 provid entri literatur propos 11 6 algorithm base dormandprinceshampin dp formula 45 pair embed formula use local extrapol yield fifth order approxim local solut deriv x quintic hermit interpol yield polynomi approxim order five x connect approxim interv yield global c 1 piecewis polynomi approxim solut natur take node fs g f0 1 46 solv directli use 44 45 experi special interfac similar case well gener one present earlier observ even underli polynomi px theori global properti share comput piecewis polynomi function defin 41 interv x turn loss smooth aris inaccur solut van der mond system interv 41 obtain evalu px impos condit p 0 directli manifest error locat event importantli far less frequent loss event occurr mesh point switch polynomi success interv gener littl code driver routin control move one interv next check report discontinu event locat caus error mesh point first check sign chang mesh point represent event function two interv meet point first approach reveal noth check sturm sequenc count match two represent small subinterv new interv ffi chosen fairli small rel size interv extrapol represent comput like inaccur larger 5 code 2 present collect subroutin implement algorithm describ paper refer reader fuller descript code restrict gener comment pertin materi paper also discuss use driver subroutin alevnt import applic theoret discuss faith reflect code give adequ appreci effici clearli make usual assumpt evalu ode 11 expens part integr event locat techniqu constitut addit overhead compar low cost particular normal case evalu ode requir algorithm requir integr alon assum common modern code calcul interpol associ ode solver involv ode evalu even extra evalu would made per step rather per event function evalu interv contain event locat algorithm nearli effici root finder base use standard way calcul root singl equat addit comput event locat code return condit number base extens 21 take account high order zero turn point event function event occur order g r similarli occurr order event locat event code return condit number appropri note due round integr error effect code may return small valu case compens close cluster root p 51 p m1 thu small henc condit number larg consid problem tabul independ variabl x term equispac valu depend variabl wish solv 11 locat first point x given valu 0 given increment delta pose problem two way first approach defin singl event function proceed comput posit x 0 event redefin event sinc necessari redefin event function differenti equat use subroutin alevnt figur 1 second approach defin set event function simul taneous name tabul point interest event locat must process maintain order tabul subroutin alevnt use purpos design drive integr user choic determin locat event import distinct approach exampl start wish know yx valu 2 3 4 etc quit possibl first approach know definit use next event function happen find exampl wish continu look next event first approach priori inform behavior solut expect reflect comput solut even believ inform use check problem formul code use second approach possibl modifi includ event function could occur start current posit three event function almost case exampl consid problem tabul x equispac step solut artifici construct equat equat solut tabul valu x use nag code d02nbf integr rel local error toler 10 gamma5 would expect result reproduc approxim standard integr defin one event function time alevnt event locat redefin event function altern use four event function correspond four tabul point simultan tabl 3 present tabul valu latter approach error estim base substitut local error toler express though valu substitut global error j local error toler use quantiti avail relat error j though well establish error estim clearli tabul point multipl error estim tabl 3 tabul point equispac valu reason approxim true error overestim error approxim doubl zero comput event use differ error toler call d02nbf suffici stringent toler obtain underlin event locat given tabl 3 case detect one event never detect multipl root even though root multipl two numer approxim either root close pair valu error estim associ close pair consist error toler integr alway indic illcondit root result illustr valu use four event function simultan reveal monoton result first approach use one event function exactli underlin valu tabl 3 result obtain redefin event function restart integr gener like accur calcul without restart integr case restart error made calcul earli event locat propag later integr henc accuraci later event locat case restart effect 6 conclus outlin approach find event locat certain special event function associ solut ode addit emphas difficulti problem shown construct event locat code outlin graft code onto standard integr interpol featur graft process requir integr step orient mode determin degre associ interpol polynomi step evalu interpol polynomi anywher span step pseudocod redefin event function locat detect f declar g f user initi integr set x1 tend g f user defin first event set neqg comps1 alpha1 appropri g f irevcm revers commun integ variabl set alevnt exit determin next action requir userg call alevntneqg comp alpha turn x1 x2 nord mxord neqf xval yval lbound xevent rbound mltplc f variabl input valu alevnt output integr variabl output variabl alevntg f user check ier natur error g f user call integr take first integr step goto call alevnt f user call integr take integr step g goto call alevnt f user evalu interpol xval yval g goto call alevnt print xevent f user reset comps1 alpha1 defin next event g goto call alevnt endif end figur 1 use alevnt redefin event function r c 1 interpol code base backward differ formula code reliabl solut special event locat problem ode algorithm minimis without deriv numer initi valu problem ordinari differenti equat practic aspect interpol rungekutta code analysi bjorckpereyra algorithm solv van der mond system fourth fifthord scale rungekutta algorithm treat dens output first cours numer analysi 2nd edit comput solut ordinari differenti equat initi valu problem practic rungekutta formula backward differenti formula revisit improv debdf new root solv code rdebd smoother interpol adam code tr italiccsupscrpt1 interpol code base backward differenti formula smoother interpol adam code practic rungekutta formula practic aspect interpol rungekutta code analysi bjomyampersandumlrckpereyra algorithm solv vandermond system numer initi valu problem ordinari differenti equat ctr r w brankin gladwel algorithm 771 rksuite90 fortran 90 softwar ordinari differenti equat initialvalu problem acm transact mathemat softwar tom v23 n3 p402415 sept 1997 joel esposito vijay kumar state event detect algorithm numer simul hybrid system model singular acm transact model comput simul tomac v17 n1 p1e januari 2007 joel esposito vijay kumar asynchron integr event detect algorithm simul multiag hybrid system acm transact model comput simul tomac v14 n4 p363388 octob 2004 przemyslaw prusinkiewicz mark hammel eric mjols anim plant develop proceed 20th annual confer comput graphic interact techniqu p351360 septemb 1993 aleksandar donev salvator torquato frank h stilling neighbor list collisiondriven molecular dynam simul nonspher hard particl ii applic ellips ellipsoid journal comput physic v202 n2 p765793 20 januari 2005