implement complex elementari function use except handl algorithm develop reliabl accur evalu complex elementari function requir fortran 77 fortran 9 name cab csqrt cexp clog csin cco algorithm present pseudocod conveni exceptionhandl facil tight error bound deriv algorithm correspond fortran program ieee environ also develop illustr practic algorithm program test care help confirm correct algorithm error bound result test includ paper fortran program b introduct purpos develop algorithm along error bound reliabl accur evalu complex elementari function requir fortran 77 1 fortran 90 4 name cab csqrt cexp clog csin cco seemingli oxi moron complex elementari function express term formula involv real arithmet real elementari function complex arithmet need care taken formula usual arrang seriou numer cancel occur evalu arrang higher precis may necessari critic point calcul work support natur scienc engin research council canada inform technolog research centr ontario well appli mathemat scienc subprogram offic energi research u depart energi contract w31109eng38 star program offic af order resd632 author address e hull f fairgriev depart comput scienc univers toronto toronto ontario canada m5 1a4 email ftehulltffgcsutorontoca ping tak peter tang mathemat comput scienc divis argonn nation laboratori 9700 south cass ave argonn il usa 604394801 email tangantaresmcsanlgov main difficulti remain evalu possibl overflow underflow might occur intermedi stage calcul except often spuriou sens final mathemat result within rang machin represent number circumst normal occur rare algorithm must provid altern calcul may lengthi abl circumv spuriou except situat suggest design algorithm help except handl facil algorithm would begin direct evalu origin care arrang formula would effici almost alway success except occur calcul would caus control calcul transfer except handler would need circumv difficulti possibl possibl caus appropri except return function captur essenti featur algorithm present pseudocod possess conveni except handl facil section 2 provid basic inform error bound assum real arithmet real elementari function use evalu complex func tion special attent given real sine cosin function three function need later introduc convent except return complex function also specifi precis section 3 introduc except handl construct use pseudocod pseudocod algorithm present section 4 along error analys special implement test describ section 5 formula error bound deriv section 4 tabul section 5 extens test done ieee binari arithmet 3 sun system 6 issu consid product implement discuss section 6 conclud remark given section 7 emphas assum throughout function argument exact argument z slightli error induc error correspond valu function fz gener small special situat error also larg rel error fz deltaf zfz approxim zf 0 zfz time rel error z deltazz rel error magnif factor zf 0 zfz larg exampl one extrem case fz logz factor 1 logz arbitrarili larg z near 1 complex exponenti includ paper difficult develop algorithm much better simpli evalu cexpw clogz approxim z lambdaw hope consid problem separ paper earlier version paper appear argonn preprint 2 2 basic numer oper complex elementari function describ section 4 depend real arithmet oper real elementari function main purpos section introduc notat error error bound associ real oper use later deriv error bound complex function bound associ real sine cosin function discuss separ subsect implement log1px consid separ sinc log1p alway avail one standard real function two special function manipul expon also specifi possibl except complex function specifi final subsect 21 error error bound assum input valu complex elementari function normal complex floatingpoint number assumpt arrang intern oper might gener error round error oper normal real floatingpoint number associ error analys mostli rel straightforward produc result simpl easi use would also straightforward matter make provis input output valu complex number whose compon could denorm error analys would much complic also distinguish sign zero latter context see kahan 5 except cab whose output normal real floatingpoint number overflow return output exampl normal complex floatingpoint number except return main assumpt make real arithmet x normal real floatingpoint number op one four basic arithmet oper rel roundoff error bound e f l x op ffl j ffl j e provid except occur f l x op round floatingpoint approxim x op produc machin assum f l x op also assum correspond error bound known real elementari function exampl assum bound e sqrt f l ffl sqrt similarli assum rel error bound name real elementari function use section 4 bound small multipl e bound sin co need special attent consid detail next subsect also assum underflow sin co assumpt deriv bound error evalu express aris section 4 exampl conclud program express x sqrtx f l xy p x valu xy henc correct within rel error bound 2ee sqrt neglect term small multipl e 2 provid except return notat conveni note differ occurr ffl necessarili use result like deriv rel error bound approxim obtain complex function section 4 gener f complex function f r f real imaginari part respect f c f c r f c correspond calcul approxim magnitud rel error f c f r f r r r r rel error f c r f c respect assum f r f zero either one zero case treat separ let us denot bound f r r r bound max r use bound e r e differ turn case exampl section 4 except clog two exampl section 4 csqrt cexp examin detail express bound obtain abl determin bound somewhat smaller max r case clog abl obtain bound dramat smaller max r 22 error sine cosin approxim state previou subsect assum rel error bound e sinco sine cosin function mean assum bound e sinco f l assumpt use unless restrict rang valu x hold section 5 give result measur valu system use test remaind subsect examin detail result depend rang x accuraci rang reduct done radix precis use calcul approxim consid detail one rel common case name case sinx cosx approxim first find x 0 x 0 approxim x mod 2 j x use x 0 standard way determin final approxim sinx cosx suppos approxim 2 use rang reduct p iby2 expect choos bound e 2 ffl 2 much smaller e first determin n rel high precis good discuss might accomplish see payn hanek 7 valu would round x 00 say x least e x 00 would use argument sine cosin approxim valid gamma4 4 common practic use possibl simul high precis arithmet comput case ffl 00 would like bound small multipl e 2 final approxim sinx gamma1 n2 sinx 00 even gamma1 ngamma12 cosx 00 rel error introduc stage error commit approxim sine cosin function interv gamma4 4 bound small multipl e similar express obtain approxim cosx n even calcul approxim sinx therefor f l first requir p iby2 accur enough neglect j j bound small multipl e replac thu rel error f l neglect small multipl express shown j u thu rel error f l sinx bound neglect small multipl e 2 max taken machin represent valu x appropri rang cours e sinco expect somewhat smaller express show clearli factor need control keep reason small result applic n even n odd cotx must replac tanx e singamma44 e cosgamma44 similar result deriv approxim cosx result combin one bound applic approxim either sinx cosx name neglect small multipl e 2 max taken machin represent valu x appropri rang impos even stringent requir accuraci p iby2 must chosen error contribut involv tangent cotang term express bound small multipl e choic depend radix precis number system well appropri rang valu x number system illustr let us consid one exampl x 24bit binari number determin max j n2 tanx almost store accur possibl 66 bit default case sun system 6 p 53 turn j n2 tanx circumst bound rel error sine cosin function indic store p iby2 bit accur enough j x allow larger rang j x almost 586e suggest consider accur valu p iby2 use rang reduct option sun system provid access high precis approxim consid detail point enough illustr sort consider taken account practic bound section 4 depend would help quantiti care document individu system algorithm might implement 23 log1p function subsect 44 need evalu real elementari log function situat argument log function must evalu known approxim introduc seriou problem valu argument near say 1x x small turn often calcul x work precis real elementari function log1px approxim log1 without explicitli ad 1 x ideal suit purpos sinc log1p alway avail present simpl way specifi reason accur log1p function use log function accur implementa 7function possibl except domainerror real real e appropri initi real oneover appropri initi return domainerror return logx return x els return logi endif fig 1 implement log1p use log look three special case program take care obtain accur approxim log1 tion reli log function see tang 8 program figur 1 first look except case x gamma1 x larg log1px replac logx program make replac suffici x 1e also ensur replac made one case necessari x larg x x largest machin represent number round mode roundup j x j small log1px replac x program make replac suffici also necessari make replac arithmet happen truncat otherwis could binari machin exampl would 1 gamma e2 instead 1 logi would gammae2 plu possibl small multipl depend accur log function return valu would 0 small multipl instead gamma 3 either case rel error enorm look special case program assign round valu x recov error x approxim rel error round valu quotient xy denot relerr equal x high accuraci high accuraci test program standard round mode ieee 3 arithmet two elsif claus need believ program also valid arithmet system reason round convent includ truncat 24 logb scalb function need two function manipul expon first return integ valu j x jc x 6 0 use function second function x real n integ unless overflow underflow case appropri except rais function exact provid cours overflow underflow second one 25 except exampl section 4 except return overflow underflow domainerror adopt convent overflow return whenev either one compon result overflow overflow tri provid compon valu minor modif would need provid valu sigma1 appropri consid desir appropri normal valu compon overflow underflow could also provid one compon underflow valu compon much larger set underflow compon zero alter error bound small multipl set underflow compon zero return underflow fact situat occur csqrt clog csin cco underflow compon smaller normal compon factor e quit arbitrari still set underflow compon zero return underflow increas bound requir otherwis criterion set underflow compon zero met compon underflow return underflow describ last sentenc occur cexp set underflow compon zero account error analysi increas bound 5 system use test underflow return tri provid compon valu minor chang would need provid special valu denorm number 3 pseudocod notat need except handl construct shown figur 2 calcul enabl block normal produc requir result enabl handl fig 2 except handl construct enabl block would normal produc requir result handler take except occur enabl block except occur cours calcul control transfer handl block handler action taken circumv otherwis cope except situat variou way construct implement depend program languag use discuss way briefli section 5 6 present purpos matter construct implement particular matter whether transfer control take place soon first except occur whether possibl ieee environ 3 calcul continu end enabl block test made determin whether except occur make use intermedi result might obtain enabl block assum indic except occur enabl block disappear leav handler also except handl construct nest within handler construct howev assum indic type except overflow underflow etc caus transfer control avail handler seem appropri consid impr cise interrupt pipelin machin presenc parallel allow exit except handl construct except possibl return within handler whether return valu return except otherwis pseudocod reason selfexplanatori intend provid easytounderstand descript algorithm calcul good approxim complex elementari function implement program conveni languag other matter return section 5 6 4 pseudocod algorithm section present algorithm form pseudocod program six complex elementari function requir fortran 77 fortran 90 error bound deriv section repeat tabular form section 5 term precis use program denot number signific digit machin represent real number exampl ieee 3 binari represent singl precis 24 41 complex absolut valu cab first consid absolut valu function j z j z program figur 3 calcul approxim function base formula result calcul represent real valu valu z except overflow extrem case x larg main difficulti develop program function deal possibl spuriou overflow underflow sinc occur rare calcul good strategi attempt calcul immedi requir approxim directli basi formula sinc effici reason accur work time approach fail program take time need look except case handler first look special case x zero otherwis logbx logbi exist use determin whether x differ greatli magnitud differ enough smaller j x j neglect otherwis close enough scale correspond scale result calcul without spuriou overflow underflow final scale valu result unscal provid requir result might happen unscal produc result overflow case overflow must return error analysi first consid case except occur analysi proce follow f l sinc sign f l f l neglect f l f l small multipl ffl 2 neglect thu rel error final result bound e e sqrt small multipl e 2 neglect straightforward matter check error exceed bound path handler unless cours overflow occur final unscal bound therefor valid valu input argument long overflow return function possibl except overflow real x integ logbx logbi integ precis appropri initi x zrealpart zimagpart enabl tri simplest formula work time answer sqrtx lambda2 handl overflow underflow occur answer els logbx logbx logbi logbi expon differ one x ignor answer maxabsx absi els scale scale absx near 1 scaledx scalbx gammalogbx scaledi scalbi gammalogbx scaledansw sqrtscaledx lambda2 enabl unscal possibl might overflow answer scalbscaledansw logbx handl must overflow scalb return overflow endif endif return answer fig 3 program absolut valu function first attempt approxim directli effici reason accur almost alway success overflow underflow occur attempt handler take manag avoid spuriou overflow underflow usual scale howev final result still overflow except case scale undon overflow return function possibl except overflow real x x zrealpart zimagpart enabl answer sqrtx lambda2 handl must overflow underflow maxmag maxabsx absi enabl handl must underflow enabl answer maxmag temp handl must overflow return overflow return answer fig 4 altern figur 3 approach error bound somewhat larger conclud section mention anoth differ approach lead altern program shown figur 4 note error bound approach somewhat larger name 225e 42 complex squar root csqrt consid squar root function r e i2 r sin2 r r adopt convent real part nonneg zero imaginari part also nonneg otherwis sign sign note neither compon overflow function overflow furthermor one compon underflow compon set zero without alter error bound small multipl accord criterion describ subsect 25 function underflow avoid loss accuraci due cancel rewrit final obtain accord sign form mathemat specif satisfi sign convent state also avoid possibl loss accuraci due cancel write pin place avoid possibl underflow latter form two remain difficulti taken account program figur 5 one avoid spuriou overflow underflow evalu approxim done way analog done cab except occur handler first look case x zero expon differ enough depend larger expon smaller j x j j j ignor correspond express quit simpl final case scale use avoid except scale must done term even expon final unscal term integ expon two squar root oper requir final approxim overflow unlik case final approxim cab function possibl except none real x real sqrt2 appropri initi integ logbx logbi evennearlogbx integ precis appropri initi complex answer x zrealpart zimagpart enabl answerrealpart t2 answerimagpart yt answerrealpart absyt answerimagpart signi t2 els answerrealpart temp answerimagpart signi temp endif handl overflow underflow occur answerrealpart temp answerimagpart signi temp answerrealpart sqrtx answerimagpart 0 els answerrealpart 0 answerimagpart sqrtgammax endif els determin logbx logbx logbi logbi x ignor ignor els scale unscal scale absx near 1 even expon evennearlogbx scaledx scalbx gammaevennearlogbx scaledi scalbi gammaevennearlogbx scaledt sqrt2 sqrtscaledx lambda2 scaledi endif answerrealpart t2 enabl answerimagpart yt handl underflow occur answerimagpart 0 enabl answerrealpart absyt handl underflow occur answerrealpart 0 answerimagpart signi t2 endif endif return answer fig 5 program squar root function first attempt approxim directli success final approxim p z obtain accord whether x overflow underflow occur attempt handler take manag avoid overflow underflow two place handler underflow might still occur compon involv set 0 approxim obtain approxim real imaginari part p z easili obtain depend whether x greater less zero remain difficulti handler approxim j jt might underflow occur program figur 5 replac underflow valu zero safe still preserv error bound obtain sinc case part approxim z real part x 0 imaginari part x 0 alway well level requir subsect 25 situat error analysi first consid case except occur begin final result cab name f l f l f l binari machin anoth ffl need nonbinari machin r f l r f l r binari machin anoth 05ffl need nonbinari machin cours assum small multipl ffl 2 neglect binari machin divis one compon final result x 6 0 mean rel error compon error compon assum constant sqrt2 initi within 1 ffl 2 also easili seen error path except handler greater thu conclud notat subsect 21 one e r e 2e maximum bound rel error approxim p neglect small multipl binari machin bound tighten somewhat examin error formula detail subsect 21 f r r r x 0 give f r r right hand side inequ reach maximum valu larg possibl howev x f less 2e result x 0 bound even smaller 0 thu conclud rel error approxim z bound q neglect small multipl binari machin nonbinari machin extra 05ffl bound also divis one compon well divis 2 compon x 6 0 error bound compon result equal final rel error bound nonbinari machin therefor neglect small multipl 43 complex exponenti cexp complex exponenti function z easili express term real elementari function x relationship form lead immedi enabl block program figur 6 handler expx first test overflow overflow return admittedli ignor narrow fring possibl valu x overflow could avoid name valu x expx overflow small amount multipl cosi sini would produc valu overflow level chosen ignor fring valu worth troubl detect reinstat howev one wish includ one possibl would develop special procedur return separ significand expon e expx use result procedur determin scalb cosi e scalb sini e overflow occur one compon actual overflow otherwis handler must cope underflow expx underflow even expx maxj cosi underflow must return otherwis compon underflow one agre upon function possibl except overflow underflow real x real e appropri initi complex answer x zrealpart zimagpart enabl expx expx answerrealpart expx cosi answerimagpart expx sini handl overflow underflow occur enabl expx expx handl return overf low els return underf low endif cosi cosi sini sini enabl handl compon underflow return underf low one compon underflow underflow compon set zero answerrealpart expx cosi answerimagpart 0 els answerrealpart 0 answerimagpart expx sini endif els return underf low endif return answer fig 6 program complex exponenti function handler first deal overflow underflow expx one compon underflow determin whether one compon safe set zero test case whether use determin whether result set underflow compon 0 accept otherwis underflow return error analysi straightforward absenc except rel error real part ffl imaginari part ffl give overal bound e neglect small multipl bound somewhat larger case one underflow part set zero rel error underflow part 1 rel error overal approxim bound neglect small multipl henc case overal rel error approxim e z bound q neglect small multipl provid overflow underflow turn bound turn 5 system use test 44 complex natur logarithm clog complex natur logarithm z express term compon follow gamma arg function approxim fortran atan2yx evalu compon function conveni first introduc maximum minimum j x j j j respect except must return design domainerror program figur 7 imaginari part logarithm function easili calcul arg function might underflow real part simpli logm shown underflow part set zero without signific increas error bound main difficulti complex log function aris evalu real part program first deal case real part simpli logm seriou difficulti occur x near 1 accur approxim log function would requir accur approxim 2 1 obtain directli possibl seriou cancel postpon deal difficulti time first consid case interv 12 2 ensur 2 2 interv 12 2 remain difficulti spuriou overflow underflow may occur evalu deal except way analog cab csqrt indic program ignor expon suffici differ result real part simpli logm otherwis scale use avoid overflow underflow scale factor radix gammascal logarithm must correct ad scale theta logradix logarithm scale valu import scale chosen possibl cancel addit let us consid case 2 case 14 2 want calcul accur approxim best way evalu express doubl work precis round result back work precis evalu done work precis error analysi becom complic shall see turn error real part enorm although overal error bound turn less doubl quit modest bound obtain case doubl precis use doubl precis avail could simul sinc simul like extrem slow may worthwhil avoid simul case cancel ie 1 cancel seriou ie close magnitud turn error analysi program figur 7 first assum arithmet binari error bound imaginari part cours unless imaginari part underflow underflow occur imaginari part safe set zero alreadi indic sinc real part simpli logm error bound e log overal rel error bound otherwis real part consid first case 12 except occur f l neglect small multipl know j logm 2 2 log 2 rel error bound real part function clog possibl except domainerror real x integ scale complex answer real sqrt2 logradix appropri initi integ precis appropri initi x zrealpart zimagpart return domainerror endif enabl answerimagpart argz handl must underflow arg answerimagpart return answer determin real part answerrealpart enabl answerrealpart 05 logm handl must overflow underflow ignor answerrealpart els scale except avoid two term answerrealpart sign must overflow scale els must underflow scale logbm endif scaledm scalbm gammascal scaledm scalbm gammascal scaledr scaledm lambda2 answerrealpart scale logradix endif els enabl use doubl precis possibl evalu argument log1p answerrealpart handl must underflow lambda2 answerrealpart endif return answer fig 7 program complex logarithm function first look three special case argument zero imaginari part underflow 0 real part calcul way depend whether maxj x outsid interv 12 first case scale may need cope spuriou overflow underflow second case accuraci final result sensit accur argument log1p calcul 2e log 2 e log bound 2886e e log neglect small multipl except occur bound obvious still valid scale requir scale requir bound valid second term express real part first term scale logradix bound 2e logradix store accur possibl sinc two term sign error sum bound 2886ee log thu case 12 2 overal rel error bound max2886 neglect small multipl consid case 2 except occur case real part logm error bound e log otherwis need determin error evalu affect log1p express express evalu within factor 1 f l log1p neglect small multipl j 2 fflj know show error bound real part h bound j j j doubl precis use evalu exactli sum two express suffer round error ffl 2 final round work precis present log1p argument ffl final rel error real part pi therefor bound 2165e neglect small multipl overal rel error therefor bound neglect small multipl e 2 provid cours domainerror return complet error analysi program figur 7 argument log1p near end program calcul within factor case doubl precis use evalu argument 2886 2165 bound must replac 3886 3165 respect nonbinari machin multipl 05 express evalu doubl precis use situat quit bit complic sinc seriou cancel may occur evalu obvious cancel argument log1p simpli accur within factor 1 case doubl precis 1 also cancel argument accur within factor 1 lead us bound replac 2165 6495 1 cancel 4m 2 cancel seriou shown case argument accur within factor 1 bound therefor leav us situat seriou cancel take place deriv follow f l log1p hi neglect small multipl second term express see rel error real part could enorm confirm test next section continu toward find rel error bound overal result see absolut error real part bound sinc j turn bound express bound e r substitut overal rel error bound develop subsect 21 name f r r r proceed follow f r consid first part bound e r second part rel j f r j lead overal error bound accept small second term obvious bound first term consid two case one j j imaginari part argz first case j argz j contribut first part rel error bound sinc second case j argz contribut first part rel error also turn 4457e thu end overal rel error bound 4457e e log1p case seriou cancel take place collect togeth result obtain program figur 7 work precis use throughout establish follow overal rel error bound clog function neglect small multipl provid cours domainerror return 2886 6495 4457 must increas 1 nonbinari machin multipl 05 express evalu 45 complex sine csin sine function z xiy repres term real elementari function follow program figur 8 base formula overflow occur evalu real imaginari part function coshi sinhi larg magnitud probabl handler return overflow case cexp fring valu z real function possibl except overflow real x complex answer x zrealpart zimagpart enabl answerrealpart sinx coshi answerimagpart cosx sinhi handl enabl coshi coshi sinhi sinhi handl must overflow return overflow answerrealpart sinx coshi enabl answerimagpart cosx sinhi handl must underflow answerimagpart 0 return answer fig 8 program complex sine function straightforward although acknowledg overflow return fring valu z whose correspond real imaginari part actual slightli overflow threshold imaginari part sinz slightli overflow threshold even though least one coshi sinhi alon overflow neglect cexp auxiliari procedur comput expon fraction part expi separ could use avoid situat sinc sinhi coshi effect equal expy2 magnitud function overflow underflow occur occur multipl associ imaginari part happen real part much larger underflow part set zero without signific increas error bound upper bound overal rel error function neglect small multipl cours overflow return 46 complex cosin cco cosin function z repres term real elementari function follow function possibl except overflow real x complex answer x zrealpart zimagpart enabl answerrealpart cosx coshi answerimagpart gammasinx sinhi handl enabl coshi coshi sinhi sinhi handl must overflow return overflow answerrealpart cosx coshi enabl answerimagpart gammasinx sinhi handl must underflow answerimagpart 0 return answer fig 9 program complex cosin function straightforward although acknowledg overflow return fring valu z whose correspond real imaginari part slightli overflow threshold program figur 9 base formula overflow occur coshi sinhi larg magnitud probabl csin previou section handler return overflow also csin fring valu z neglect although could includ help auxiliari procedur return expon fraction part expi separ underflow occur occur multipl associ imaginari part happen real part much larger underflow part set zero without signific increas error bound upper bound overal rel error function neglect small multipl cours overflow return 5 special implement test implement algorithm present section 4 sun 440 fortran 77 compil version 14 order test correct especi correct error bound implement special sens tabl observ error bound singl precis real elementari function sun librari version 14 unit e rel error bound singl precis real arithmet result given e sinco 1000 1152 1102 2326 1382 1000 1000 close possibl pseudocod descript section 4 particular modifi way improv effici effici product implement issu discuss next section except portion one version clog altern suggest subsect 44 float point oper implement singl precis care taken make sure case examin gener assembl languag instruct ensur extend precis use intermedi calcul enabl us use correspond doubl precis result sun system true result test purpos assum true result correct singl precis accuraci except handl construct implement allow enabl block execut test except flag rais possibl ieee environ would natur interpret use ieee handler traphandl facil provid sun system 6 p 67 turn ineffici somewhat difficult use test float point except flag use ieee flag subroutin 6 p 64 also ineffici instead access flag use math librari routin swapex test correct error bound exampl section 4 must first determin bound turn system use requir determin e etc conveni present unit e result given tabl rel error bound determin examin relev singl precis argument except case e sinco consid valu argument less 10 6 absolut valu case e arg determin bound ad e e atan extra allow addit error induc use f l yx argument atan place yx boundari arg function least one x 0 also consid bound log1p sinhcosh 1000e singl precis version function use correctli round result doubl precis implement bound version log1p figur 1 use singl precis 2198e result tabl use determin theoret bound column 3 tabl ii observ bound column 4 tabl ii obtain compar result implement true result provid sun system doubl precis function larg number mostli random input argument ieee singl precis argument observ bound occur given hexadecim form column 5 random argument construct random real part random imag tabl ii comparison theoret observ rel error bound sun fortran version 14 implement complex elementari function program figur 39 column 3 4 unit e rel error bound real arithmet sp pdp stand ieee singl precis partial ieee doubl precis respect cexp real csin cco imag function theoret bound gamma base tabl observ bound argument cabs2 225e e sqrt 3250 2495 e0723701 csqrt sqrt cexp clog inari part gener random expon random significand within appropri rang ten thousand random argument gener 4 semiax 100 000 000 gener 4 quadrant origin also test region restrict necessari overflow underflow would avoid time time ensur good coverag proper domain function mani special case also test includ mani near boundari region separ point would probabl lead except return point would probabl lead except return import special case term tri observ larg error argument real imaginari part chosen maxim error relev real elementari function fact special case produc observ maximum much random test seen tabl ii nonexcept result error would expect basi theoret error bound fact theoret bound much larger observ bound sort discrep shown tabl surpris consid kind reason use determin theoret error bound especi case two clog function happen rel larg discrep case cabs2 explain ieee arithmet system satisfi assum subsect 21 accur within half unit last place make signific differ error analysi cabs2 special form express argu contribut express final rel error bound cabs2 maximum valu greater 15 follow argument obtain final rel error bound 2650 cabs2 place 3250 special mention made result clog version make use doubl precis comput argument log1p much accur term observ overal rel error bound version use singl precis howev real part former much accur real part latter observ bound 3604e former approxim latter enorm error occur 3f7ffffc i3a3504f3 observ error bound imaginari part equal 2292e cours claim experiment result actual prove correct theoret error bound believ evid convinc howev correct program involv correct error bound valu argument lead except return must also true except return reason otherwis program could consid correct alway return except matter input argument accord subsect 25 overflow return either compon overflow one function program return overflow particular valu input argument test program consid correct return least one compon true result within rel error bound true overflow specif huge largest machin represent number ulpup unit last place huge direct 1 test underflow return correct either 1 compon true result within rel error bound true underflow specif 2 one compon underflow nevertheless within error bound greater valu within error bound compon specif min j f r min j f r ini smallest posit machin represent number ulpdown unit last place ini direct 0 criteria modifi slightli obviou way allow fact fring area neglect algorithm cexp csin cco test case overflow underflow return test program determin appropri criterion satisfi except return domainerror clog special case easi check separ 6 product implement except handl construct ada reason close use paper except unfortun fact ada recogn underflow except construct simpler ada expect handler told effect except occur propos somewhat like ada recogn underflow propos fortran 90 reject favor except handl facil construct could implement pl1 elegantli extens exist languag often provid facil implement con struct exampl provid access trap except flag ieee environ alreadi indic preced section absenc except handl facil pretest use exampl case cab j x j j j test advanc make sure overflow underflow occur evalu x case evalu express carri calcul handler use anoth pretest determin whether final unscal caus overflow implement origin pretest determin condit satisfi suffici ensur spuriou except occur may necessari case caus program execut handler often necessari cours higher precis avail may possibl avoid pretest ing long expon rang higher precis suffici broader exampl cab entir calcul done higher preci sion test need perform result calcul coerc origin precis idea littl use work precis alreadi highest avail apart tri implement except handl effici way implement made slightli effici mostli write program intermedi store oper avoid addit float point statu regist would save entri function subprogram later restor updat includ except flag return function 7 conclud remark present algorithm reliabl accur evalu complex elementari function requir fortran 77 fortran 90 conveni describ algorithm help except handl construct implement fortran sun system test extens observ error bound 64 98 theoret bound convinc evid correct theoret bound also indic theoret bound quit tight interest discov choos argument near thought largest error might occur usual led observ bound larger found even extens random test one case 13 test also found except return reason acknowledg much work inspir discuss member ada numer work group chairmanship gil myer jim codi particularli help earli stage investig also wish thank refere help suggest r american nation standard program languag fortran implement complex elementari function use except handl ieee standard binari floatingpoint arithmet branch cut complex elementari function part radian reduct trigonometr function tr tabledriven implement logarithm function ieee floatingpoint arithmet ctr technic report floatingpoint except handl acm sigplan fortran forum v15 n3 p128 dec 1996 e hull thoma f fairgriev ping tak peter tang implement complex arcsin arccosin function use except handl acm transact mathemat softwar tom v23 n3 p299335 sept 1997 e hull thoma f fairgriev ping tak peter tang implement complex arcsin arccosin function use except handl acm transact mathemat softwar tom v23 n3 p299335 sept 1997 david smith algorithm 786 multipleprecis complex arithmet function acm transact mathemat softwar tom v24 n4 p359367 dec 1998 david bindel jame demmel william kahan osni marqu comput given rotat reliabl effici acm transact mathemat softwar tom v28 n2 p206238 june 2002 milo ercegovac jeanmichel muller complex squar root operand prescal journal vlsi signal process system v49 n1 p1930 octob 2007 john r hauser handl floatingpoint except numer program acm transact program languag system topla v18 n2 p139174 march 1996