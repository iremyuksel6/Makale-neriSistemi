zeroalias model fault abstractwhen use builtin selftest bist test vlsi circuit circuit respons input test sequenc may consist thousand million bit compact signatur consist ten bit usual linear feedback shift regist lfsr use respons compact via polynomi divis compact function manytoon function result erron respons may map signatur good respons known aliasingin paper deal select feedback polynomi compact lfsr erron respons result model fault map signatur differ good respons lfsr call zeroalias lfsr zeroalias lfsr primit irreduc feedback polynomi consid due suitabl bist test pattern generationupp bound deriv least degre irreduc primit zeroalias lfsr polynomi bound show practic test applic polynomi degre less 53 expect bound deriv show number fault less 106 degre 21procedur find irreduc primit zeroalias lfsr polynomi 1 smallest degre 2 prespecifi degre present lowcomplex procedur find zeroalias lfsr polynomi also present worst case well expect time complex procedur deriv experiment result present practic problem size demonstr applic propos procedur b introduct builtin selftest bist capabl circuit test idea behind bist creat pattern gener pg gener test pattern circuit respons analyz ra compact circuit respons input appli circuit respons may consist thousand million bit compact signatur consist ten bit compact function manytoon function result erron respons might map signatur good respons known alias erron respons map differ signatur good respons zeroalias two previou scheme achiev zeroalias take account possibl error sequenc first gupta et al 7 14 scheme ra linear feedback shift regist lfsr compact function polynomi divis good respons feedback polynomi scheme requir quotient good respons period achiev proper select lfsr feedback polynomi good respons known give bound n2 length requir regist test sequenc length n second scheme due chakrabarti hay 5 use nonlinear logic detect error respons number memori cell ra dlog ne bound extra logic requir implement scheme major differ scheme aforement zeroalias scheme target specif set possibl fault tri achiev zeroalias error sequenc result model fault tri recogn possibl error sequenc mainli never occur fault model let us focu probabl error sequenc result use less hardwar aforement scheme previou method find zeroalias feedback polynomi model fault present pomeranz et al 13 differ heurist find zeroalias polynomi suggest heurist necessarili find minimum degre zeroalias polynomi necessarili find irreduc primit polynomi import regist also function pg work present upper bound minimum degre irreduc primit zeroalias polynomi provid algorithm find minimum degre polynomi pg ra usual implement reconfigur exist regist regist configur pg gener test block logic reconfigur ra test block logic lfsr feedback polynomi serv purpos overhead reconfigur design save scheme lfsr use pg multipl input shift regist misr use ra exampl misrbas ra shown figur 1 regist configur shift regist input cell xor function previou cell output bit circuit test cut depend linear feedback function feedback bit number cell k stage misr feedback come cell kgamma1 feedback function repres polynomi feedback feed cell iff f 1 feedback polynomi misr figur 1 1 differ lfsr misr extra input connect output cut pg lfsr ra misr use feedback polynomi overhead reconfigur polynomi save previou paper 11 show select feedback polynomi pg paper deal select feedback polynomi ra sinc kstage pg primit feedback polynomi gener nonzero ktupl oppos pg irreduc feedback polynomi prefer primit zeroalias polynomi even though take effort find compact function misr polynomi divis gf 2 effect output polynomi divid feedback polynomi signatur remaind divis cut k output k output sequenc denot sequenc input sequenc length n view polynomi output valu ith output time j effect polynomi l x l object select feedback polynomi compact misr given set model fault erron respons result model fault map differ signatur signatur good respons cut output avail regist might short achiev zeroalias case need lengthen regist ad flipflop keep hardwar overhead minimum want add flipflop possibl henc interest feedback polynomi smallest degre achiev object regist serv pg ra advantag feedback polynomi degre avail regist henc interest feedback polynomi prespecifi degre time might want find feedback polynomi fast even result misr requir extra flipflop optimum assum follow test scenario input sequenc cut design effect output polynomi due target fault differ effect polynomi good respons ie error polynomi nonzero let r effect polynomi good respons effect polynomi due fault repres r h linear remaind oper get differ remaind erron polynomi iff h divis feedback polynomi assum given error polynomi target fault problem deal paper follow given set polynomi find polynomi rel prime polynomi h polynomi refer nonfactor h nonfactor use feedback polynomi compact misr zeroalias achiev set target fault particular irreduc primit feedback polynomi present 1 upper bound smallest degre zeroalias misr 2 procedur select zeroalias misr smallest degre 3 procedur determin whether zeroalias lfsr prespecifi degre exist find one 4 procedur fast select zeroalias misr analyz worst case well expect time complex propos procedur note notat use logarithm notat ln x denot natur logarithm x log x denot base 2 logarithm x polynomi fh g repres error polynomi degre h repres product polynomi h denot h degre h h h product distinct degre j irreduc factor h denot g ij ij degre g ij product polynomi g ij denot g j nonfactor seek refer repres degre rest paper organ follow section 2 establish upper bound degre nonfactor section 3 review polynomi oper gf 2 complex section 4 present procedur find nonfactor smallest degre set h section 5 present procedur find nonfactor prespecifi degre find nonfactor fast also discuss effect conduct exhaust search least degre nonfactor section 6 present experiment data conclud section 7 2 bound least degre nonfactor set polynomi consid follow problem problem 1 let h set jhj polynomi h give upper bound sd h degre irreduc polynomi upper bound pd h degre primit polynomi divid h ie exist irreduc primit polynomi degre sd h pd h divid h similarli let esh eph expect degre irreduc primit polynomi nonfactor h bound sd pd refer worst case bound bound esh eph refer expect bound first establish worst case bound proceed expect bound 21 worst case bound bound sd follow 10 let 2 j denot number irreduc polynomi degre j gf 2 degre product irreduc polynomi degre j j let sd denot least integ product irreduc polynomi degre less equal sd degre q sd greater replac h q sd h least one root root h henc q sd h least one irreduc factor factor h thu sd h upper bound degre irreduc polynomi rel prime polynomi set h follow lemma provid bound sd h turn find bound pd number primit polynomi degre gf 2 ism oeq euler function denot number integ less rel prime q 12 p 37 l p distinct prime factor q lemma 2 16 p 173 q 3 except product first nine prime 5i replac 250637 lemma 3 q 208 log log q proof first prove case q 65 lemma 2 208 log log q equat 1 verifi directli help us deriv bound pd introduc valu let denot least integ ratio time number primit polynomi degre time number irreduc polynomi degre greater 1 ie lemma 4 10 lemma 3 p 293 3 2 lemma 5 log log 2te proof definit verifi express lemma valid valid 2 prove case 2 q 4 function q 208 log log q increas function henc 208 log logq 208 log log also 208 log logq 208 log log q thu sinc 1 1 208 log log q 208 log logq gamma 1 208 log log q least integ 2 0 208 log log 2 0 2 208 log log2 0 equat 1 5 get due lemma 4 thu definit 0 bound solv definit 0 must satisfi 208 log 0 set 0 log log 2te log log2t 2 thu 2 0 log log 2te satisfi 3 henc log log 2te lemma pd denot least integ proof definit lemma 5 log2dlogd1e lemma 1 definit sd exampl 1 tabl 1 valu oe2 degre product primit polynomi degre degre product primit polynomi degre 2 tabul long less maximum valu tabl pd obtain tabl instead use lemma 6 exampl number model fault cut length test sequenc degre product primit polynomi degre less equal 33 first greater thu zeroalias lfsr primit feedback polynomi degre 33 exist cut hand use bound lemma 6 get pd h closer look tabl 1 show product primit polynomi degre less equal 53 degre greater 14 thu long product number fault test sequenc length less case practic test applic zeroalias misr degre less equal 53 exist 22 expect bound deriv expect bound assum polynomi fh g random polynomi denot product distinct irreduc factor degre j h g ij denot number distinct irreduc factor h degre j v valu v rang 0 minfbd jc 2 jg lemma 7 j 2 expect valu v number irreduc degreej factor equal 1 proof let ir 2 set irreduc polynomi degre j gf 2 given polynomi q degre greater equal j defin indic function dp q one p divid q zero otherwis probabl polynomi degre j divid random polynomi degre greater equal j 2 gammaj henc probabl equal 2 gammaj thu type analysi use bound v arv varianc v oe v standard deviat v lemma 8 j 2 varianc number irreduc factor g ij less 1 standard deviat less proof varianc v given v 2 j ik 2 j ik 2 j henc 2 j comput mean varianc number irreduc factor degre j per polynomi comput confid measur result lemma 9 j 4 expect number polynomi g ij 5 50 factor less jhj100 jhj10 000 proof use chebyshev inequ 8 p 376 probabl v greater 5 less 001 use result defin second random process random variabl x 1 iff v greater 5 otherwis process bernoulli experi 6 sec 64 expect number ij 5 factor upper bound jhj100 varianc similarli probabl v greater 50 less 00001 expect number g ij 50 factor bound jhj10 000 lemma 10 expect degre smallest irreduc nonfactor set polynomi h bound dlog jhje 1 proof denot product polynomi g ij 1 jhj g j lemma 7 expect number necessarili distinct factor g j less jhjj smallest j 2 j exce valu upper bound expect degre nonfactor henc ffi appli lemma 5 result lemma 10 corollari 11 expect degre smallest primit nonfactor set polynomi h bound 2 exampl 2 use number exampl 1 let first j exce jhjj henc expect find zeroalias misr primit feedback polynomi degre less equal 14 oppos worst case 33 corollari 11 would give us upper bound 19 expect bound function number fault length test sequenc expect degre zeroalias misr never exceed 53 fact long number fault less 1 million expect find zeroalias misr degre less equal 21 3 polynomi oper gf 2 search least degre nonfactor h use procedur sift factor degre given polynomi procedur base follow lemma lemma 12 12 lemma 213 p48 x product irreduc polynomi degre l l divisor thu basic step find distinct irreduc factor polynomi bx comput result oper product irreduc factor degre l ljm bx polynomi bx interest us 2 degbx therefor first comput analyz complex propos procedur reli follow result state greater detail appendix complex polynomi gcd oper om log 1 pp 300308 degre larger polynomi operand ms complex polynomi multipl product degre complex polynomi divis also consid two multipl algorithm first algorithm due schonhag 17 complex os log log log second algorithm suggest cormen et al 6 p 799 complex os log sequel shall use notat om complex polynomi multipl whenev possibl mean log otherwis taken log log log similarli notat ls denot either log log log log appropri cost find remaind x 2 divid bx without actual carri divis 3 15 omm thu comput omm ms log 4 find nonfactor smallest degre given set polynomi establish bound least degre nonfactor h section 2 section address question find least degre nonfactor h problem 2 given set polynomi let find irreduc primit polynomi ax dega 1 equival h 6j 0 mod 2 irreduc primit polynomi bx degb h j 0 mod b equiv alent exist h j 0 mod b one way solv problem factor polynomi h would requir much work sinc need know factor order find nonfactor need know small factor section present algorithm solv problem 2 analyz complex complex given two form first worst case complex bound refer worst case complex second expect complex bound refer expect complex expect complex refin worst case complex base expect size result procedur lemma 1 6 section 2 upper bound depend whether look irreduc primit nonfactor use bound begin search process made three phase 1 h 2 h find g ij x product distinct irreduc primit factor h degre j 2 found polynomi g ij determin whether irreduc primit polynomi degre j factor h 3 irreduc primit polynomi degre j factor h find one worst case complex three phase irreduc case ojhju 2 mn log n ojhj 2 n 2 u 2 mu domin term ojhj 2 n 2 u 2 mu worst case complex three phase primit case ojhju 3 mn ojhj 2 delta log n ojhj 2 n 2 u 3 mu log log u domin term ojhj 2 n 2 u 3 mu log log u expect complex first two phase ojhju 2 mn ojhj log jhju 2 delta log n expect complex third phase ojhj log jhjd md find irreduc nonfactor ojhj log jhjd 2 log log md find primit nonfactor domin term ojhju 2 mn worst case complex function jhj 2 n 2 multipli term logarithm jhj n wherea expect complex function jhjn multipli term logarithm jhj n 41 product distinct factor degre given polynomi given polynomi h x upper bound u wish comput g ij product distinct factor h degre j u procedur comput polynomi g ij given figur 2 polynomi g ij comput three step first u2 comput gamma x g ij product distinct irreduc factor h x degre j degre l ljj j less equal u2 2j u theorem 12 g i2j contain product irreduc factor degre l ljj h sinc degre g i2j much less degre h effici comput g ij g i2j h thu step 2 end step 2 g ij contain factor degre ljj h sift factor degre less j g ij need divid g ij g il l rang set divisor j carri step 3 procedur distinct factor enough look primit nonfactor end procedur g ij product distinct irreduc polynomi degre j factor h g ij need sift nonprimit factor describ aspect introduc notion maxim divisor distinct prime factor q set maxim divisor q set exampl one prime factor polynomi gf q degre irreduc iff divid x divid x divisor k primit degre iff irreduc divid x l gamma 1 l mdq ch 3 procedur distinct primit shown figur 3 sift nonprimit factor g ij lemma 13 1 complex procedur distinct factor ou 2 mn 2 complex procedur distinct primit ou 3 mn 3 complex first phase ojhju 2 mn irreduc case ojhju 3 delta mn primit case express irreduc case primit case proof 1 worst case complex procedur distinct factor follow step 1 procedur perform u2 gcd comput involv h complex gcd comput ojmd thu total work first stage u step 2 procedur carri u2 gcd oper work requir step step 3 everi element set divisor procedur perform divis oper cost express omd ojmd ij 2 complex procedur distinct primit follow iter procedur distinct primit reduc ij perform one gcd one divis oper cost iter ojmd ij u run procedur u time therefor addit work primit case bound ou 3 md case valu ij much less n henc actual work much less ou 2 mn domin factor step 1 procedur distinct factor 3 set h base 1 2 complex first phase jhju 2 mn irreduc case jhju 3 mn primit case valu u either sd h correspond either irreduc primit case lemma 14 expect complex first phase ojhju 2 mn u equal either esh eph proof expect complex procedur distinct factor domin complex step 1 ou 2 mn differ complex step worst case come use expect size ij instead worst case size equal n expect complex procedur includ procedur distinct primit set h thu ojhju 2 mn u equal either esh eph 42 number distinct factor degre set polynomi first phase degre 1 j u jhj polynomi g ij product distinct irreduc primit factor degre j h g ij might equal pair might factor common goal find least degre nonfactor h first must determin whether irreduc polynomi degre j appear second three phase page 13 simpl test compar degg j 2 j degg j nonfactor degre j primit case compar oe2 j gamma1 j way determin whether irreduc primit polynomi degre j factor g j find factor appear one g ij elimin appear except one consid two method remov repeat factor first refer lcm method second refer gcd method lcm method shown faster also requir space might avail lcm method first sort g ij accord degre place set k g ij 2 k iff 2 set fs k g order accord index increas order begin comput lcm two polynomi taken first set set one polynomi take second polynomi next set result lcm polynomi place set correspond degre process end left one polynomi repres lcm polynomi g ij gcd method polynomi g ij sort degre iter polynomi highest degre taken set pairwis gcd polynomi taken gcd greater 1 polynomi divid gcd end iter none remain polynomi set factor common polynomi taken thu procedur end factor appear one g ij lemma 15 1 complex second phase ojhj 2 mn log n 2 expect complex second phase ojhj log 3 jhjln logjhjn proof 1 bound work requir lcm method follow first assum jhj ij power 2 bound purpos increas nearest power 2 also assum polynomi leav binari tree polynomi level degre level correspond differ set k assum everi lcm step degre lcm sum degre two operand ie operand rel prime maximum degre final lcm jhjn comput lcm cost omjhjn logjhjn comput two lcm next last level cost o2 delta mjhjn2 delta logjhjn2 lower level twice mani lcm comput cost less half cost level henc total cost bound ologjhjnmjhjn logjhjn ou 2 mjhjn use lcm method need enough memori store final lcm requir memori use gcd method work requir ojhj 2 mn log n 2 take account expect size polynomi g ij factor becom practic factor algorithm use cantor zassenhau 4 complex factor product r distinct irreduc polynomi degre j given ormrjj logrj lemma 9 expect number polynomi g ij 5 factor less jhj10 2k2 take number polynomi factor 99jh j polynomi 5 factor assum 5 polynomi assum 50 etc expect work requir factor polynomi bound ob 99jhj use fact 5j bound sum ob factor complet irreduc factor sort time ojhj delta log jhj uniqu factor count sum log n sinc u log jhj express becom ojhj log 3 jhjln logjhjn 43 find nonfactor third phase know smallest degre exist nonfactor h also jhj polynomi g id product distinct irreduc primit factor h g id pairwis rel prime everi irreduc primit factor degre h factor one polynomi want find irreduc primit polynomi degre nonfactor h one approach divid product irreduc primit polynomi degre product polynomi find factor result might pose problem product hand ie polynomi g id product larg handl one polynomi anoth way randomli select irreduc primit polynomi check whether factor nonfactor way check actual divis divis howev regular long divis fft divis whenev divisor small degre compar degre dividend irreduc primit polynomi rel prime g ida nonfactor divid least one polynomi keep result divis reduc work upcom trial reduct requir polynomi repeat select process lemma 1 complex find nonfactor known ojhj md irreduc case ojhj 2 n 2 3 md log log primit case 2 expect complex ojhj log jhjd md irreduc case ojhj delta log jhj delta 2 log log md primit case proof 1 procedur gener random polynomi check irreduc primit whether factor expect number random polynomi test irreduc primit irreduc primit polynomi degre found 2 dalog log 15 work requir test polynomi irreduc od md md 15 sum ij exceed jhjn therefor jh jn da irreduc polynomi tri nonfactor found work involv tri jhjn delta long divis thu expect work requir find nonfactor ojhj md primit case work md log log 2 polynomi g ij factor see proof lemma 152 known draw irreduc primit polynomi nonfactor found expect jhjd factor irreduc primit polynomi drawn take olog jhj check whether factor henc expect work requir find non known bound ojhj log jhjd md irreduc case ojhj log jhjd 2 md delta log log primit case 5 practic scenario section discuss practic scenario find zeroalias polynomi first want nonfactor prespecifi degre second want find nonfactor fast third compar algorithm find least degre nonfactor exhaust search irreduc primit polynomi ascend degre case type search faster 51 find nonfactor prespecifi degre case regist requir function ra pg nonfactor prespecifi degre need thu problem 3 given set polynomi irreduc primit nonfactor degre h problem exactli find least degre nonfactor except need consid case instead iter 1 j u first comput polynomi g determin whether nonfactor degre exist find one lemma 17 1 complex find nonfactor degre ojhj irreduc case ojhj 2 n 2 3 mt log log primit case 2 expect complex ojhjmnt log n proof 1 comput polynomi g involv comput g l 2 mdt comput f cost first gcd comput otmd cost jmdtj subsequ gcd divis bound olog ttmd md log substitut n get olog log n polynomi g need sift multipl instanc irreduc polynomi use gcd method worst case cost ojhj 2 mn delta log n stage know whether nonfactor degre exist one exist carri phase 3 worst case complex ojhj 2 domin term whole process analysi primit case henc worst case complex find irreduc primit nonfactor given degre set polynomi h ojhj log log 2 turn analyz expect complex h comput g x cost ojhjmnt log n cost sift factor degre less g base expect number factor degre insignific factor sort polynomi second phase expect cost ojhj log jhjt log n eq 5 expect number distinct irreduc factor degre h bound jhjt thu cost find nonfactor stage consist draw jhj irreduc primit polynomi expect cost ttmt tlog log delta 2 mt check list factor bound jhj ttmt logjhjt irreduc case ojhjlog jhj gamma log tt 2 mt log log primit case henc expect complex find nonfactor degre h bound ojhjmnt log n 52 find nonfactor fast problem given set polynomi find irreduc primit nonfactor h less 2 c tri sum degre irreduc primit polynomi degre less equal sd h pd h greater h look p u draw uniformli irreduc prim itiv polynomi degre u 2 c draw expect find nonfactor expect work cost case o2 c delta cost 2 c iter draw polynomi test irreduc one found divid jhj polynomi candid nonfactor use long divis primit case becom o2 c delta u 3 mu log log u exampl 3 use number exampl 1 say want find nonfactor 8 tri comput bound p draw primit polynomi comput bound use tabl 1 see instead look polynomi degre less equal 33 need consid primit polynomi degre 34 gener 2 c 2 henc lemma 6 consid polynomi degre greater 2 case want minimum degre nonfactor also use expect bound esd epd lower degre candid nonfactor 53 exhaust search subsect compar algorithm exhaust search least degre nonfactor look irreduc case assum least degre irreduc nonfactor degre also assum list irreduc polynomi ascend order number irreduc root degre j less 2 j bound work requir find nonfactor exhaust search ojhjn2 da1 use expect bound olog jhj bound work n expect work requir find least degre nonfactor algorithm ojhju 2 mn becom ojhj log 2 jhj delta n log n substitut valu u take account constant involv two result ratio work requir exhaust search rel work requir algorithm log 2 jhj log n assum ratio less 1 n 1210 assum ratio less 1 n 124 500 ratio less 1 n 365 284 284 suggest number fault interest small less 1024 exhaust search might effici algorithm howev number fault increas algorithm effici test sequenc realist length final number fault greater 4096 practic test length algorithm effici simpl exhaust search 6 experiment result follow experi conduct verifi result experi conduct hp700 workstat 61 random select base absolut bound experi set follow gener set 1000 random polynomi degre 200 000 correspond cut 1000 fault ie 1000 test length 200 000 ie degre product polynomi h less equal 200 000 000 want probabl greater 12 find nonfactor one draw primit polynomi look tabl 1 achiev select set primit polynomi degre less equal 29 polynomi drawn 2 step process first step select degre primit candid second select candid first step select number took valu modulo number primit root field gf 2 gf 2 29 result use determin degre primit candid look first field gf 2 number primit root field gf 2 gf 2 greater result select actual polynomi done set coeffici lfsr primit feedback polynomi degre gamma 1 initi random state guarante candid select twice candid chanc consid candid test primit primit test nonfactor point found factor search continu current state degre ran 200 experi 200 experi first primit candid turn nonfactor nonfactor found 1 degre 21 2 degre 22 3 degre 23 2 degre 24 7 degre 25 13 degre 26 32 degre 27 35 degre 28 105 degre 29 number polynomi test primit one found rang 1 160 averag number 16 time took find primit polynomi rang 001 second 079 second averag time 0104 second took 15325 16668 second find nonfactor averag 16050 second experi show given error sequenc fault interest easi find zeroalias polynomi circuit 62 random select base expect bound base expect bound corollari 11 abl find nonfactor degre 14 ran 100 experi time select primit polynomi degre 11 expect bound base tabl 1 first primit candid select nonfactor 66 100 experi 19 experi found nonfactor second candid 11 third 2 fourth 1 fifth 1 sixth ran 100 experi select primit candid degre 9 number primit candid tri nonfactor found rang 1 28 averag number candid 75 test tight expect bound ran 126 experi 1024 random polynomi degre 200000 gener exhaust search increas order degre conduct find least degre nonfactor expect bound least degre less 14 one experi least degre 7 35 8 remain 90 experi least degre 9 experi conclud error polynomi fact random polynomi expect bound base analysi expect number factor certain degre random polynomi fact upper bound least degre nonfactor set polynomi expect bound obtain tabl 1 tighter corollari 11 63 experi benchmark circuit tri worst case expect bound error sequenc two circuit berkeley synthesi benchmark 2 first circuit in5 second in7 use fault simul take account fault collaps henc number fault twice number line circuit stuckat0 stuckat1 fault line circuit in5 1092 fault six redund henc 1086 detect fault circuit 14 primari output use test sequenc length 6530 detect nonredund fault comput effect output polynomi fault nonzero henc cancel error one output error anoth output thu 1086 error polynomi degre 6543 tabl 1 worst case bound degre primit nonfactor 23 draw primit nonfactor probabl greater 1we need consid primit polynomi degre 24 less conduct 20 experi draw zeroalias primit polynomi base worst case bound experi first candid nonfactor conduct anoth 20 experi time draw primit polynomi degre 14 size regist avail circuit output experi first candid nonfactor base expect bound tabl 1 find nonfactor degre 11 less tri find nonfactor degre 11 9 7 degre 11 experi 17 20 case first primit candid nonfactor two experi found nonfactor second tri one third conduct 15 degre 9 experi consid 48 primit polynomi degre 9 48 primit polynomi degre 9 33 factor 15 nonfactor averag number candid tri nonfactor found 3 1 primit polynomi degre 7 factor circuit in7 568 fault 567 nonredund circuit 10 primari output use test sequenc length 9280 use worst case bound ensur select primit nonfactor probabl greater 1 consid primit polynomi degre 24 less 20 experi found nonfactor first candid expect bound tabl 1 degre primit nonfactor 10 tri find nonfactor degre 11 10 size regist avail output degre 11 experi found nonfactor first tri 13 found nonfactor first tri 6 second one third circuit tri find least degre nonfactor use exhaust search sinc fault extractor use fault collaps error polynomi ident sum valu nonzero erron output word simul fault found least 292 differ error polynomi in7 least 566 differ error polynomi in5 would make expect bound tabl 1 9 in7 10 in5 circuit least degre nonfactor degre 8 took 11 cpu minut find polynomi experi two benchmark circuit show assumpt error polynomi behav random polynomi invalid analysi result expect bound case random experi upper bound least degre nonfactor conclus paper present procedur select zeroalias feedback polynomi misr base ra pg ra design lfsrsmisr scheme combin algorithm select effici feedback polynomi pattern gener 11 enabl select one feedback polynomi serv task thu reduc overhead reconfigur regist present upper bound least degre irreduc primit zeroalias polynomi set model fault show practic test applic polynomi alway degre less 53 fact expect bound number fault less 10 6 degre 21 experi conduct zeroalias polynomi degre less expect bound alway found also present procedur find zeroalias polynomi object minim degre specif degre speed analyz comput effort requir worst case condit expect condit partial summari result present tabl 2 worst case analysi expect analysi tabl 2 show upper bound smallest nonfactor comput complex find smallest nonfactor complex find factor given degre speed requir show find zero alias polynomi averag two tri increas degre polynomi consid two upper bound size minimum degre base analysi experi conclus error polynomi model target fault avail zeroalias easili achiev goal thu ensur high qualiti test premium put fault model autom test pattern gener design fault simul tool avail zeroalias problem acknowledg wish thank professor l adleman breuer j ierardi l r welch mani help discuss also wish thank anonym refere help comment r design analysi comput algo rithm logic minim algorithm vlsi synthesi factor polynomi larg finit field new algorithm factor polynomi finit field introduct algorithm concret mathemat complex multipl finit field test embed discret logarithm introduct finit field applic achiev zero alias model fault new framework design analyz bist techniqu probabilist algorithm finit field book prime number record schnell multiplik von polynomen uber korpern der charakteristik 2 tr ctr krishnendu chakrabarti brian murray john p hay optim zeroalias space compact test respons ieee transact comput v47 n11 p11711187 novemb 1998 novk z plva j nosek hlawiczka garbolino k gucwa testperclock logic bist semideterminist test pattern zeroalias compactor journal electron test theori applic v20 n1 p109122 februari 2004