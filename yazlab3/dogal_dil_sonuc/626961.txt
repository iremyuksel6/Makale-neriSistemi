distribut reset reset subsystem design embed arbitrari distribut system order allow system process reset system necessari design layer compris three main compon leader elect span tree construct diffus comput compon selfstabil follow sens coordin upprocess system ever lost due failur repair process channel compon eventu reach state coordin regain capabl make reset subsystem robust toler failstop failur repair process channel even reset progress b introduct describ paper augment arbitrari distribut system process reset system predefin global state deem necessari augment introduc new process new commun channel system mere introduc addit modul exist process ad modul commun one anoth exist channel compris call reset subsystem ideal reset distribut system given global state impli resum execut system start given state character howev reset distribut system achiev global freez system seem rather limit mani applic strict need therefor adopt lax character reset distribut system given global state impli resum execut system global state reachabl system comput given global state mani occas desir process distribut system initi reset exampl ffl reconfigur system reconfigur instanc ad process channel process system signal initi reset system appropri initi state ffl mode chang system design execut differ mode phase case chang current mode execut achiev reset system appropri global state next mode ffl coordin loss process observ unexpect behavior pro cess recogn coordin process system lost situat coordin regain reset ffl period mainten system design design process period initi reset precaut case current global state system deviat global system invari process channel fail reset progress led design reset subsystem faulttoler particular reset subsystem toler loss coordin differ process system may caus transient failur memori loss also toler failstop failur subsequ repair process channel abil regain coordin lost achiev make reset subsystem selfstabil follow sens reset subsystem global state coordin process lost reset subsystem guarante reach within finit number step global state coordin restor coordin restor maintain unless later failur caus lost cycl repeat 6 7 abil toler failstop failur subsequ repair process channel achiev allow process channel system either ensur abil system selfstabil affect process channel reset subsystem design simpl modular layer manner design consist three major compon leader elect span tree construct diffus comput compon selfstabil toler process channel failur repair admit boundedspac implement featur distinguish design compon earlier design 1 9 10 redress follow comment made lamport lynch 15 page 1193 selfstabil algorithm translat distribut system design fix arbitrari network one work chang network use finit number identifi would quit use know algorithm rest paper organ follow next section describ layer structur reset subsystem structur consist three layer span tree layer wave layer applic layer three layer discuss section 3 4 5 respect section 6 discuss implement issu particular exhibit bound low atom implement layer final make conclud remark section 7 2 layer reset subsystem make follow assumpt concern distribut system augment reset subsystem system consist k process name p1 pk instant process either binari irreflex symmetr relat defin process call relat adjac relat adjac process commun one anoth set process adjac relat defin chang time simplic howev assum adjac relat never partit process system clearli partit occur reset request initi partit result reset state partit process pi system consist two modul adji appli see figur 0a task modul adji maintain set ni indic process adjac pi detail implement adji outsid scope paper one possibl implement howev adji commun period adjj modul everi potenti adjac process pj employ timeout determin whether index j process pj ni task modul appli applic specif perform task appli commun modul applj j 6 j ni one state appli distinguish togeth distinguish state appli modul compris predefin global reset state distribut system augment distribut system reset subsystem consist ad two modul treei wavei process pi system see figur 0b treei modul adjac process commun order maintain root span tree involv process system henceforth two term process process use interchang construct tree maintain consist current adjac relat system thu chang adjac relat eventu follow correspond chang span tree treei modul keep index father process fi maintain tree inform use local wavei modul execut distribut reset distribut reset execut wavei modul three phase wave first phase appli request system reset local wavei forward request root span tree reset request made process request also forward root process conveni think request form one request wave second phase modul wavei root process receiv request wave reset state local appli state appli predefin global state initi reset wave reset wave travel toward leav span tree caus wavej modul encount process reset state local applj state applj predefin global state reset wave reach leaf process reflect complet wave travel back root process wave compris third phase final complet wave reach root reset complet new request wave start whenev appli deem necessari descript follow state differ appli modul reset differ time within distribut reset caus problem appli whose state reset commun adjac applj whose state yet reset avoid problem provid session number sni appli global state distribut reset progress session number equal reset state appli accompani increment sni requir two adjac appli modul commun unless equal session number requir suffic ensur character distribut reset distribut reset given global state yield global state reachabl system comput given global state treei modul differ process constitut tree layer discuss section 3 wavei modul constitut wave layer discuss section 4 appli modul constitut applic layer discuss section 5 21 program notat program process form begin hmodulei hmodulei end modul form modul hmodul namei var hvariabl declarationsi paramet hparamet declarationsi begin hactioni hactioni thu modul process defin set variabl set paramet set action defin detail next variabl variabl set modul updat ie written modul process variabl read modul process modul adjac process paramet paramet set modul rang finit domain function paramet defin set action one parameter action exampl let j paramet whose valu 0 1 2 parameter action actj action set modul abbrevi follow set three action action action set modul form hguardi gamma hassign statementi guard boolean express variabl paramet modul variabl one adjac process assign statement updat one variabl modul oper semant system process follow state system defin valu everi variabl process system action whose guard true state system said enabl state comput system maxim fair sequenc system step step action enabl current state execut therebi yield next state comput maxim comput impli comput proper prefix anoth comput fair comput mean continu enabl action eventu execut comput 12 3 tree layer task tree layer continu maintain root span tree even chang set process adjac relat solut describ accommod chang ensur tree layer perform task irrespect state start solut root span tree repres father relat process treei modul maintain variabl fi whose valu denot index current father process pi sinc layer start state initi graph father relat induc initi valu fi variabl may arbitrari particular initi graph may forest root tree may contain cycl case initi graph forest root tree tree collaps singl tree give preced tree whose root highest index achiev follow treei modul maintain variabl rooti whose valu denot index current root process pi rooti lower rootj adjac process pj treei set rooti rootj make pj father pi case initi graph cycl cycl detect remov use bound length path process root process span tree achiev follow treei modul maintain variabl di whose valu denot length shortest path pi prooti detect cycl treei set di dfi1 whenev fi 2 ni di k net effect execut action cycl exist di valu process pi cycl get bump repeatedli eventu di exce k gamma 1 k maximum possibl number process sinc length path adjac graph bound kgamma1 cycl detect remov cycl detect treei make pi father assumpt initi state arbitrari need consid case initi valu fi rooti di inconsist one possibl initi valu local inconsist one follow hold rooti rooti 6 di 6 0 fi ni case treei make local consist set rooti fi di 0 anoth possibl rooti may inconsist respect state father process pi rooti 6rootfi may hold last case treei correct valu rooti rootj modul treei given figur 1 modul var begin figur 1 modul treei show appendix start state ie one could reach number chang set process adjac relat tree layer guarante eventu reach state satisfi state predic g state g process pi rooti equal highest index among process fi shortest path process pi root process prooti pass father process pfi di equal length path therefor root span tree exist also note state g fixedpoint ie treei modul reach state g action treei modul enabl proof employ converg stair method 13 exhibit finit sequenc state predic h0 h1 hk iii l 0 l k hl close system execut hl hold arbitrari system com putat continu hold subsequ iv l 0 l k upon start arbitrari state hl system guarante reach state also show converg state g occur within ok round deg maximum degre node adjac graph dia diamet adjac graph inform speak round minim sequenc system step wherein process attempt execut least one action conclud section remark problem leader elect span tree construct receiv consider attent literatur see exampl 15 16 17 algorithm base assumpt process start execut design initi state restrict sever purpos lift design tree layer selfstabil ie insensit initi state note selfstabil span tree algorithm recent describ 9 howev algorithm 9 base simplifi assumpt time exist special process know root made assumpt root process fail remain process elect new root 4 wave layer outlin section 2 task wave layer perform diffus comput 10 appli modul reset state diffus comput use span tree maintain tree layer consist three phase first phase appli modul request local wavei initi global reset request propag wave modul along span tree path process pi tree root pj second phase modul wavej tree root reset state local applj initi reset wave propag along tree toward leav whenev reset wave reach process pk local wavek modul reset state local applk third phase reset wave reach tree leav reflect complet wave propag along tree root diffus comput complet complet wave reach root record current phase wavei modul maintain variabl sti three possibl valu normal initi reset modul wavei propag complet wave last diffus comput wait request wave next diffus comput modul wavei propag request wave ongo diffus comput wait reset wave reset modul wavei propag reset wave ongo diffus comput wait complet wave variabl sti updat follow initi new diffus comput local appli modul updat sti normal initi propag request wave wavei likewis updat sti normal initi propag reset wave wavei updat sti valu reset reset lastli propag complet wave wavei updat sti reset normal possibl appli updat sti normal initi complet wave last diffus comput reach root process thu multipl diffus comput progress simultan distinguish success diffus comput wavei modul maintain integ variabl sni denot current session number wavei recal oper wave layer subject chang set process adjac relat accommod chang ensur layer perform task irrespect state start solut start arbitrari state wave layer guarante reach steadi state sni valu equal sti valu reset particular diffus comput progress steadi state sni valu equal sti valu normal furthermor diffus comput initi steadi state sni valu guarante termin steadi state achiev requir reset wave wavei modul increment sni reset state local appli modul modul wavei given figur 2 modul five action action 1 propag request wave process father span tree request wave reach root process action 2 start reset wave root process action 3 propag reset wave father process process action 4 propag complet wave children process process four action wavei modul collect perform correct diffus comput provid wave layer steadi state steadi state wave layer wavei satisfi gdi action 5 ensur selfstabil wave layer steadi state modul begin stinorm stiiniti fi gamma sti sni reset sni1 2 figur 2 modul wavei show appendix b start state wave layer guarante eventu reach steadi state satisfi 8i snin sti 6reset integ n proof consist show start arbitrari state system guarante reach state gd ii state predic gd close system execut iii start arbitrari state gd root process pk guarante reach state 8i snin sti 6reset also show diffus comput initi state gd termin ie start state satisfi gd system guarante reach state gd lastli show converg gd state occur within oht round diffus comput termin within omin htthetadg n round ht height span tree construct tree layer dg maximum degre node span tree n number process system 5 applic layer applic layer given distribut system compos appli modul shown figur 0 section discuss two modif applic layer reset subsystem correctli ad given distribut system first modif augment appli modul action allow request distribut reset discuss section 4 action set variabl sti initi enabl normal hold distribut reset necessari situat distribut reset necessari applic specif one situat howev global state applic layer erron erron state may detect period execut selfstabil global state detect algorithm 8 14 toward end note possibl implement selfstabil global state detect minor modif reset subsystem second modif restrict action appli modul applic layer continu execut distribut reset progress recal one object design avoid freez execut given distribut system perform reset modif base observ distribut reset appli modul continu execut action long commun modul one reset anoth reset equival appli modul commun session number sn valu therefor requir express sni snj conjoin guard appli action access variabl updat applj 6 j net effect modif upon complet distribut reset collect state appli modul reachabl applic layer execut given collect state appli modul reset 6 implement issu section discuss two issu relat implement modul treei wavei first show statespac process bound second show refin high atom action employ thu far low atom one 61 boundedspac construct treei modul 2f1 kg updat three variabl requir log k bit contrast modul wavei use unbound session number variabl bound construct also possibl wavei transform make sni type f0n gamma1g n arbitrari natur constant greater 1 replac increment oper first action increment oper modulo n arithmet thu wavei modul implement use constant number bit proof correct transform modul similar proof present appendix b left reader 62 transform readwrit atom thu far design treei wavei modul taken account atom constraint action modul high atom action read variabl updat process instantan write variabl refin design implement modul use low atom action consid follow transform variabl xi updat process pi introduc local variabl xji process pj j 6 read xi replac everi occurr xi action pj xji add read action xji xi action pj base transform readwrit atom modul treei wavei present next along proof correct code readwrit atom implement modul treei shown figur 3 show appendix c start state tree layer guarante eventu reach state satisfi state predic g structur proof ident proof present appendix exhibit finit sequenc state predic h0 h1 hk iii l 0 l k hl close system execut hl hold arbitrari system com putat continu hold subsequ iv l 0 l k upon start arbitrari state hl system guarante reach state modul var rootij begin rootij rootij dij rootj fj dj figur 3 implement treei use readwrit atom code readwrit atom implement modul wavei shown figur 4 show appendix start state wave layer guarante eventu reach state satisfi 8i sni n sti 6 reset integ n structur proof ident proof present appendix b exhibit state predic gd start arbitrari state system guarante reach state gd ii gd close system execut modul begin snij gamma sti sni reset stij 6reset sni snij gamma sni snij stij figur 4 implement wavei use readwrit atom iii start arbitrari state gd root process pk guarante reach state 8i snin sti 6reset also show diffus comput initi state gd termin ie upon start state satisfi gd integ n system guarante reach state gd note similar proof exist bound construct low atom wavei modul sni replac variabl type arbitrari natur constant greater 3 increment oper first action replac increment oper modulo n arithmet conclus present algorithm enabl process arbitrari distribut system perform distribut reset algorithm novel selfstabil toler failstop failur repair arbitrari process channel even distribut reset progress two comment order regard choic fair nondeterminist interleav semant first requir fair respect continu enabl action necessari use simplifi proof correct second design remain correct even weaken interleav requir follow step arbitrari subset process execut enabl action long two execut action access share variabl 2 3 5 comment also order regard methodolog achiev faulttoler distribut system one way achiev system faulttoler ensur fault occur system continu satisfi inputoutput relat system design thu mask effect fault henc said mask faulttoler altern way achiev system faulttoler ensur fault occur inputoutput relat system violat temporarili word system guarante eventu resum satisfi inputoutput relat paper latter nonmask approach faulttoler adopt give three reason sometim prefer nonmask faulttoler mask faulttoler design distribut system first distribut system mask faulttoler may imposs achiev exampl mask faulttoler distribut system whose process commun asynchron reach consensu binari valu even one process fail 11 second even possibl implement mask faulttoler cost may prohibit exampl amount redund synchron requir may infeas implement third requir mask faulttoler may strict desir exampl callback telephon servic eventu establish connect may quit use even mask initi failur establish connect cours practic use nonmask faulttoler distribut system design time taken resum satisfi desir inputoutput relat fault occur within accept bound envisag sever applic distribut reset nonmask faulttoler use current implement distribut oper system program base distribut reset includ exampl system program multiprocess resynchron also current studi reconfigur protocol high speed network note distribut reset provid systemat method make arbitrari distribut system selfstabil cf 14 applic layer modul augment perform selfstabil global state detect period request distribut reset upon detect erron global state therebi make distribut system selfstabil distribut reset also use transform arbitrari selfstabil program equival selfstabil program implement readwrit atom sever issu need investig one issu transform readwrit atom program cf figur 3 4 messag pass program analysi result program note messag pass program predefin global reset state includ addit state appli modul state channel system therefor addit reset local state modul appli wavei modul send possibl empti sequenc applic messag tag new session number everi outgo channel pi anoth issu studi design effici mechan maintain time consist state neighbor process indic third issu secur problem involv allow applic process reset distribut system protect mechan necessari enforc applic process interact reset subsystem desir manner final observ selfstabil system one type nonmask faulttoler system desir investig altern nonmask faulttoler solut distribut reset problem less robust selfstabil solut even effici acknowledg thank georg varghes help discuss paper anonym refere suggest r appli static network protocol dynam network foundat faulttoler comput converg iter system distribut reset extend abstract relax interleav assumpt token system selfstabil uniform selfstabil ring distribut snapshot determin global state distribut system selfstabil dynam system assum readwrit atom termin detect diffus computa tion imposs distribut consensu one faulti process stabil commun protocol selfstabil extens messagepass system distribut comput model method algorithm distribut comput span tree extend lan correct proof topolog inform mainten protocol distribut comput network tr uniform selfstabil ring token system selfstabil selfstabil extens messagepass system selfstabil dynam system assum readwrit atom distribut comput stabil commun protocol foundat faulttoler comput imposs distribut consensu one faulti process distribut snapshot algorithm distribut comput spanningtre extend lan correct proof topolog inform mainten protocol distribut comput network distribut reset extend abstract ctr jorg cobb moham g gouda stabil gener loopfre rout journal parallel distribut comput v62 n5 p922944 may 2002 hongwei zhang anish arora gs3 scalabl selfconfigur selfheal wireless sensor network comput network intern journal comput telecommun network v43 n4 p459480 15 novemb wilfri steiner michael paulitsch hermann kopetz tta approach resili transient upset realtim system v32 n3 p213233 march 2006 franck petit vincent villain optim snapstabil depthfirst token circul tree network journal parallel distribut comput v67 n1 p112 januari 2007 christian boulini franck petit vincent villain graph theori help selfstabil proceed twentythird annual acm symposium principl distribut comput juli 2528 2004 st john newfoundland canada neeraj mittal prajwal k mohan prioritybas distribut group mutual exclus algorithm group access nonuniform journal parallel distribut comput v67 n7 p797815 juli 2007 moham g gouda marco schneider maximiz rout metric ieeeacm transact network ton v11 n4 p663675 august moham g gouda marco schneider memori requir silent stabil proceed fifteenth annual acm symposium principl distribut comput p2734 may 2326 1996 philadelphia pennsylvania unit state alain cournier ajoy k datta franck petit vincent villain optim snapstabil pif algorithm unori tree journal high speed network v14 n2 p185200 april 2005 mehmet hakan karaata selfstabil strong fair weak fair ieee transact parallel distribut system v12 n4 p337345 april 2001 anish arora mikhail nesterenko unifi stabil termin messagepass system distribut comput v17 n3 p279290 march 2005 mehmet hakan karaata optim selfstabil strarvationfre altern journal comput system scienc v71 n4 p480494 novemb 2005 mehmet hakan karaata stabil algorithm find biconnect compon journal parallel distribut comput v62 n5 p982999 may 2002 fatima belkouch marc bui lime chen ajoy k datta selfstabil determinist network decomposit journal parallel distribut comput v62 n4 p696714 april 2002 mikhail nesterenko anish arora stabilizationpreserv atom refin journal parallel distribut comput v62 n5 p766791 may 2002 joffroy beauquier maria gradinariu colett johnen memori space requir selfstabil leader elect protocol proceed eighteenth annual acm symposium principl distribut comput p199207 may 0406 1999 atlanta georgia unit state sandeep kulkarni ravik stabil causal determinist merg journal high speed network v14 n2 p155183 april 2005 azzedin boukerch kaouther abrougui effici leader elect protocol mobil network proceed 2006 intern confer commun mobil comput juli 0306 2006 vancouv british columbia canada anish arora paul c atti e allen emerson synthesi faulttoler concurr program proceed seventeenth annual acm symposium principl distribut comput p173182 june 28juli 02 1998 puerto vallarta mexico albert mo kim cheng seiya fujii selfstabil realtim ops5 product system ieee transact knowledg data engin v16 n12 p15431554 decemb 2004 yehuda afek shlomi dolev local stabil journal parallel distribut comput v62 n5 p745765 may 2002 yehuda afek anat bremler selfstabil unidirect network algorithm powersuppli proceed eighth annual acmsiam symposium discret algorithm p111120 januari 0507 1997 new orlean louisiana unit state felix c grtner fundament faulttoler distribut comput asynchron environ acm comput survey csur v31 n1 p126 march 1999 hongwei zhang anish arora gs3 scalabl selfconfigur selfheal wireless network proceed twentyfirst annual symposium principl distribut comput juli 2124 2002 monterey california arora p dutta bapat v kulathumani h zhang v naik v mittal h cao demirba gouda choi herman kulkarni u arumugam nesterenko vora miyashita line sand wireless sensor network target detect classif track comput network intern journal comput telecommun network v46 n5 p605634 5 decemb 2004