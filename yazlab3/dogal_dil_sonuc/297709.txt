automat compilerinsert prefetch pointerbas applic abstracta dispar processor memori speed continu grow memori latenc becom increasingli import perform bottleneck softwarecontrol prefetch attract techniqu toler latenc success limit thu far arraybas numer code paper expand scope automat compilerinsert prefetch also includ recurs data structur commonli found pointerbas applicationsw propos three compilerbas prefetch scheme autom wide applic scheme greedi prefetch optim research compil experiment result demonstr compilerinsert prefetch offer signific perform gain uniprocessor largescal sharedmemori multiprocessor b introduct oftwar control data prefetch 1 2 offer potenti bridg everincreas speed gap memori subsystem today highperform processor recognit potenti number recent processor ad support prefetch instruct 3 4 5 prefetch enjoy consider success arraybas numer code 6 potenti pointerbas applic remain larg unexplor paper investig compilerinsert prefetch pointerbas applicationsin par ticular contain recurs data structur recurs data structur rdss includ familiar object link list tree graph etc individu node dynam alloc heap node link togeth pointer form overal structur purpos recurs data structur broadli interpret includ pointerlink data structur eg mutuallyrecurs data structur even graph heterogen object memori perform perspect pointerbas data structur expect import concern follow reason applic suffer larg memori penalti due data replac miss typic must larg data set rel cach size asid multidimension array recurs data structur one common conveni method build larg data structur eg btree databas applic octre graphic applic etc travers ck luk depart comput scienc univers toronto toronto ontario m5 3g4 canada email lukeecgtorontoedu c mowri comput scienc depart carnegi mellon univers pittsburgh pa 15213 email tcmcscmuedu larg rd may potenti visit enough interven node displac given node cach revisit henc tempor local may poor final contrast arrayswher consecut element contigu addressesther littl inher spatial local consecutivelyaccess node rd sinc dynam alloc arbitrari address cope latenc access pointerbas data structur propos three compilerbas scheme prefetch rdss describ section ii implement widelyapplic schemesgreedi prefetchingin modern research compil suif 7 discuss section iii evalu scheme perform detail simul impact uniprocessor multiprocessor system section iv v respect final present relat work conclus section vi vii ii softwarecontrol prefetch rdss key challeng success prefetch rdss schedul prefetch suffici far advanc fulli hide latenc introduc minim runtim overhead contrast arraybas code prefetch distanc easili control use softwar pipelin 2 fundament difficulti rdss must first derefer pointer comput prefetch address get sever node ahead rd travers typic involv follow pointer chain howev act touch intermedi node along pointer chain mean toler latenc fetch one node ahead overcom pointerchas problem 8 propos three scheme gener prefetch address without follow entir pointer chain first two scheme greedi prefetch historypoint prefetchingus pointer within current node prefetch address differ greedi prefetch use exist point er wherea historypoint prefetch creat new point er third schemedatalinear prefetch gener prefetch address without pointer derefer greedi prefetch kari rd node contain k pointer node greedi prefetch exploit fact one k neighbor immedi follow next node travers often good chanc neighbor visit sometim futur therefor prefetch k pointer node first visit hope enough preordertreenod f prefetchtleft prefetchtright preordertleft preordertright 4 5partial latenc cach miss cach hit cach miss 9 15122 code greedi prefetch b cach miss behavior fig 1 illustr greedi prefetch prefetch success hide least fraction miss latenc illustr greedi prefetch work consid preorder travers binari tree ie figur 1a show code greedi prefetch ad assum comput process take half long cach miss latenc l would want prefetch two node ahead fulli hide latenc figur 1b show cach behavior node obvious suffer full cach miss root node node 1 sinc opportun fetch ahead time howev would suffer half miss penalti l visit node 2 miss penalti eventu visit node 3 sinc time visit subtre root node 2 greater l exampl latenc fulli hidden roughli half node reduc 50 half minu root node greedi prefetch offer follow advantag low runtim overhead sinc addit storag comput need construct prefetch point er ii applic wide varieti rdss regardless access whether structur modifi frequent iii rel straightforward implement compilerin fact implement suif compil describ later section iii main disadvantag greedi prefetch offer precis control prefetch distanc motiv next algorithm b historypoint prefetch rather reli exist pointer approxim prefetch address potenti synthes accur pointer base observ rd travers pat tern prefetch node ahead historypoint prefetch scheme 8 add new pointer call historypoint node n record observ address n id node visit node n recent travers rd subsequ travers rd prefetch node point histori pointer scheme effect travers pattern chang rapidli time construct historypoint maintain fifo queue length contain pointer last node visit visit new node n oldest node queue n igammad ie node visit node ear lier henc updat historypoint n igammad point n first complet travers rd historypoint set contrast greedi prefetch historypoint prefetch offer improv first travers rd potenti hide latenc subsequ travers historypoint prefetch offer potenti advantag improv latenc toler come expens execut overhead construct historypoint ii space overhead store new pointer minim execut overhead potenti updat historypoint less frequent depend rapidli rd structur chang one extrem rd never chang set historypoint problem space overhead potenti worsen cach behavior desir elimin space overhead altogeth motiv next prefetch scheme c datalinear prefetch idea behind datalinear prefetch 8 map heapalloc node like access close togeth time contigu memori locat map one easili gener prefetch address launch earli enough anoth advantag scheme improv spatial local major challeng howev gener data layout theori one could dynam remap data even rd initi construct may result larg runtim overhead may also violat program semant instead easiest time map node creation time appropri either creation order alreadi match travers der safe reorder sinc dynam remap expens imposs scheme obvious work best structur rd chang slowli rd chang radic program still behav correctli prefetch improv perform iii implement greedi prefetch three scheme propos greedi prefetch perhap wide applic sinc reli travers histori inform requir addit storag comput construct prefetch ad dress reason implement version greedi prefetch within suif compil 7 simul two algorithm hand implement consist analysi phase recogn rd access schedul phase insert prefetch analysi recogn rd access recogn rd access compil use type declar inform recogn data object rdss control structur inform recogn object travers rd type record type r contain least one pointer point either directli indirectli record type note r restrict type sinc rdss may struct f int data struct left struct right struct f int struct b kids8 struct c f int j doubl f rd type b rd type c rd type fig 2 exampl type recogn rd type l f list f list n ftree f ktree tn f b c fig 3 exampl control structur recogn rd travers compris heterogen node exampl type declar figur 2a figur 2b would recogn rd type wherea figur 2c would discov data structur appropri type compil look control structur use travers rdss particular compil look loop recurs procedur call new loop iter procedur invoc pointer p rd assign valu result derefer pwe refer recurr pointer updat heurist correspond rd code typic written detect recurr pointer updat compil propag pointer valu use simplifi less pre cise version earlier pointer analysi algorithm 9 10 figur 3 show exampl program fragment compil treat rd access figur 3a l updat lnextnext insid whileloop figur 3b n assign result function call gn insid forloop sinc implement perform interprocedur analysi assum gn result valu nnext figur 3c two derefer function argument pass paramet two recurs call figur 3d similar figur 3c except record rather pointer pass function argument ideal next step would analyz data local across rd node elimin unnecessari prefetch although autom step compil evalu potenti benefit earlier studi 8 b schedul prefetch rd access recogn compil insert greedi prefetch follow point rd object traversedi recurr pointer updat occursth compil insert prefetch pointer within object point rdstype object earliest point address avail within surround loop procedur bodi avail prefetch address comput prop l f l f prefetchlnext loop tree q testtdata els q null tree q prefetchtleft prefetchtright testtdata els q null b procedur fig 4 exampl greedi prefetch schedul benchmark characterist node recurs data input memori benchmark structur use data set alloc octre bisort binari tree 250000 1535 kb integ em3d singlylink list 2000 hnode 1671 kb 100 enod 75 local health fourway tree level 5 925 kb doublylink list mst array singli 512 node 10 kb link list perimet quadtre 4kx4k imag 6445 kb power multiway tree 10000 418 kb singlylink list custom treeadd binari tree 1024k node 12288 kb binari tree 100000 citi 5120 kb doublylink list voronoi binari tree 20000 point 10915 kb agat earliest gener point pointer valu along valu two exampl greedi prefetch schedul shown figur 4 detail implement found luk thesi 11 iv prefetch rdss uniprocessor section quantifi impact prefetch scheme uniprocessor perform later section v turn attent multiprocessor system experiment framework perform detail cyclebycycl simul entir olden benchmark suit 12 dynam schedul superscalar processor similar mip r10000 5 olden benchmark suit contain ten pointerbas applic written c briefli summar tabl rightmost column tabl show amount memori dynam alloc rd node simul model vari slightli actual mip r10000 eg model two memori unit ii uniprocessor simul paramet pipelin paramet issu width 4 function unit 2 int 2 fp 2 memori 1 branch reorder buffer size integ multipli 12 cycl integ divid 76 cycl integ 1 cycl fp divid 15 cycl fp squar root 20 cycl fp 2 cycl branch predict scheme 2bit counter memori paramet primari instr data cach 16kb 2way setassoci unifi secondari cach 512kb 2way setassoci line size 32b primarytosecondari miss 12 cycl primarytomemori miss 75 cycl data cach miss handler 8 data cach bank 2 data cach fill time 4 cycl requir exclus access main memori bandwidth 1 access per 20 cycl assum function unit fullypipelin model rich detail processor includ pipelin regist renam reorder buffer branch pre diction instruct fetch branch penalti memori hierarchi includ content etc tabl ii show paramet model use pixi 13 instrument optim mip object file produc com piler pipe result trace simul avoid miss initi dynam alloc object use modifi version irix mallopt routin 14 wherebi prefetch alloc object initi determin prefetch address straightforward sinc object size typic alloc contigu memori optim alon led twofold speedup rel use malloc major applic particularli frequent alloc small object b perform greedi prefetch figur 5 show result uniprocessor experi ment overal perform improv offer greedi prefetch shown figur 5a two bar correspond case without prefetch n greedi prefetch g bar repres execut time normal case without prefetch broken four categori explain happen potenti graduat slot number graduat slot issu width4 case multipli number cycl bottom section busi number slot instruct actual graduat top two section nongradu slot immedi caus oldest instruct suffer either load store miss inst stall section slot instruct graduat note load stall store stall section firstord approxim perform loss due cach miss sinc delay also exacerb subsequ data depend stall see figur 5a half applic enjoy speedup rang 4 45 half within 2 origin perform applic largest memori stall penaltiesi health perimet treeaddmuch stall time elimin case bisort mst prefetch overhead offset reduct memori stall thu result slight perform degrad problem eight applic understand perform result greater depth figur break origin primari cach miss three categori prefetch subsequ hit primari cach pf hit ii prefetch remain primari miss pf miss iii prefetch nopf miss sum pf hit pf miss case also known coverag factor ideal 100 em3d power voronoi coverag factor quit low un der 20 miss caus array scalar referencesh prefetch rdss yield littl improv case coverag factor 60 four case achiev nearli perfect coverag pf miss categori larg indic prefetch schedul effectivelyeith issu late hide latenc els earli prefetch data displac cach could referenc categori promin mst compil unabl prefetch earli enough travers short link list within hash tabl sinc greedi prefetch offer littl control prefetch distanc surpris schedul imperfectin fact encourag pf miss fraction low help evalu cost prefetch figur 5c show fraction dynam prefetch unnecessari data found primari cach applic show four differ bar indic total dynam unnecessari prefetch caus static prefetch instruct hit rate given threshold henc bar label 100 correspond unnecessari prefetch wherea bar label 99 show total unnecessari prefetch exclud prefetch instruct hit rate 99 etc breakdown indic potenti reduc overhead elimin static prefetch instruct clearli littl valu exampl elimin prefetch hit rate 99 would elimin half unnecessari prefetch perimet thu decreas overhead significantli con trast reduc overhead flat distribut eg bh difficult sinc prefetch sometim hit also miss least 10 time therefor elimin may sacrific latencyhid benefit found elimin prefetch hit rate 95 improv perform 17 applic 8 final measur impact greedi prefetch memori bandwidth consumpt observ av 0normal execut time load stall 1000 966 1000 1012 1000 998 10001000 1016 10001000 999 100010001000 994 bh bisort em3d health mst perimet power treeadd tsp voronoi store stall inst stall busi execut time origin load dcach nopfmiss bisort health perimet treeadd voronoi bh em3d mst power tsp pfmiss pfhit hit 10099 95 90 10099 95 90 10099 95 90 10099 95 90 10099 95 90 10099 95 90 10099 95 90 10099 95 90 10099 95 90 10099 95 90 bh bisort em3d health mst perimet power treeadd tsp voronoi b coverag factor c unnecessari prefetch fig 5 perform impact compilerinsert greedi prefetch uniprocessor erag greedi prefetch increas traffic primari secondari cach 127 traffic secondari cach main memori 78 experi almost impact perfor manc henc greedi prefetch appear suffer memori bandwidth problem summari seen automat compilerinsert prefetch result signific speedup uniprocessor applic contain rdss investig whether two sophist prefetch scheme offer even larger perform gain c perform historypoint prefetch data linear prefetch appli historypoint prefetch data linear prefetch hand sever applica tion historypoint prefetch applic health list structur access key procedur remain unchang across ten thousand time call result historypoint prefetch achiev 40 speedup greedi prefetch better miss coverag fewer unnecessari prefetch although historypoint prefetch fewer unnecessari prefetch greedi prefetch significantli higher instruct overhead due extra work requir maintain historypoint datalinear prefetch applic perimet treeadd creation order ident major subsequ travers order case result data linear requir chang data layout case henc spatial local unaffect reduc number unnecessari prefetch henc prefetch overhead maintain good coverag factor datalinear prefetch result speedup 9 18 greedi prefetch perimet treeadd respect overal see scheme potenti offer signific improv greedi prefetch applic v prefetch rdss multiprocessor observ benefit automat prefetch rdss uniprocessor investig whether compil also acceler pointerbas applic run multiprocessor earlier studi mowri demonstr compil success prefetch parallel matrixbas code 2 15 compil use studi attempt prefetch pointerbas access pattern howev handinsert prefetch ing mowri abl achiev signific speedup barn 15 pointerintens sharedmemori parallel applic splash suit 16 barn perform hierarch nbodi simul evolut galaxi main comput consist depthfirst travers octre structur comput gravit forc exert given bodi bodi tree repeat bodi system bodi static assign processor durat time step cach miss occur whenev processor visit part octre alreadi cach either due replac commun insert prefetch hand mowri use strategi similar greedi prefetch upon first arriv node prefetch immedi children descend depthfirst first child iii memori latenc multiprocessor simul destin access read write primari cach 1 cycl 1 cycl secondari cach 15 cycl 4 cycl remot node 101 cycl 89 cycl dirti remot remot home 132 cycl 120 cycl normal execut time memori stall synchron instructions86 85 origin dcach nopfmiss pfmiss pfhit hit dcach execut b coverag c unnecessari time factor prefetch fig 6 impact compilerinsert greed prefetch barn multiprocessor compilerinsert greedi prefetch handinsert prefetch evalu perform compilerbas implement greedi prefetch multiprocessor compar handinsert prefetch barn sake comparison adopt simul environ use mowri earlier studi 15 briefli summar simul cachecoher sharedmemori multiprocessor resembl dash multiprocessor 17 simul machin consist 16 processor two level directmap cach use 16 byte line tabl iii show latenc servic access differ level memori hierarchi absenc content simul model content howev make simul fea sibl scale problem size cach size accordingli ran 8192 bodi 3 time step 8k64k cach hierarchi done explain detail origin studi 2 figur 6 show impact compilerinsert greedi prefetch g handinsert prefetch h barn execut time figur 6a broken follow bottom section amount time spent execut instruct includ prefetch instruct overhead middl top section synchron memori stall time respect see figur 6a compil achiev nearli ident perform handinsert prefetch compil prefetch 90 origin cach miss 15 miss unnecessari see figur 6b 6c respect prefetch miss latenc fulli hidden half case pf hit partial hidden case pf miss elimin roughli half origin memori stall time compil abl achiev 16 speedup compil greedi strategi insert prefetch quit similar done hand follow except effort minim unnecessari prefetch compil default strategi prefetch first 64 byte within given rd node case barn node longer 64 byte discov handinsert prefetch achiev better perform prefetch entir node case improv miss coverag prefetch entir node worth addit unnecessari prefetch therebi result 1 speedup compilerinsert prefetch overal howev quit pleas compil abl well nearli match best perform could achiev hand vi relat work although prefetch studi extens arraybas numer code 6 18 rel littl work done nonnumer applic chen et al 19 use global instruct schedul techniqu move address gener back earli possibl hide small cach miss latenc 10 cycl found mix result contrast algorithm focu rd access issu prefetch much earlier across procedur loop iter boundari overcom pointerchas problem zhang torrella 20 propos hardwareassist scheme prefetch irregular applic sharedmemori multiprocessor scheme program annot bind togeth group data eg field record two record link pointer prefetch hardwar con trol compar compilerbas approach scheme two shortcom annot insert manual ii hardwar extens like applic uniprocessor joseph grunwald 21 propos hardwarebas markov prefetch scheme prefetch multipl predict address upon primari cach miss markov prefetch potenti handl chaotic miss pattern requir consider hardwar support less flexibl select prefetch control prefetch distanc compilerbas scheme knowledg compilerbas pointer prefetch scheme literatur spaid scheme propos lipasti et al 22 base observ procedur like derefer pointer pass argument spaid insert prefetch object point pointer argument call site therefor scheme effect interv start procedur call derefer pointer compar cach miss latenc earlier studi 8 found greedi prefetch offer substanti better perform spaid hide latenc pay less overhead vii conclus automat compilerinsert prefetch shown consider success hide memori latenc arraybas code compil technolog success prefetch pointerbas data structur thu far lack paper propos three prefetch scheme overcom pointerchas problem autom wide applic scheme greedi prefetch compil evalu perform modern superscalar uniprocessor sim ilar mip r10000 largescal sharedmemori multiprocessor uniprocessor experi show automat compilerinsert prefetch acceler pointerbas applic much 45 addit sophist algorithm current simul hand offer even larger perform gain multiprocessor experi demonstr compil potenti provid equival perform handinsert prefetch even parallel ap plicat encourag result suggest latenc problem pointerbas code may address larg prefetch instruct alreadi exist mani recent microprocessor acknowledg work support grant ibm canada centr advanc studi chikeung luk partial support canadian commonwealthfellowship todd c mowri partial support faculti develop award ibm r softwar prefetch toler latenc softwarecontrol data prefetch com piler techniqu data prefetch powerpc data prefetch hp pa8000 mip r10000 superscalar microprocessor design evalu compil algorithm prefetch suif infrastructur research parallel optim compil compilerbas prefetch recurs data structur contextsensit interprocedur pointsto analysi presenc function pointer interprocedur modif side effect analysi pointer alias optim cach perform nonnumer applic support ing dynam data structur distribut memori machin trace pixi fast fit toler latenc multiprocessor compilerinsert prefetch parallel applic share memori stanford dash multiproc sor effect onchip preload scheme reduc data access penalti data access microarchitectur superscalar processor compilerassist data prefetch speed irregular applic sharedmemori multiprocessor memori bind group prefetch prefetch use markov predic tor spaid softwar prefetch pointer callintens environ tr ctr subramanian ramaswami jaswanth sreeram sudhakar yalamanchili krishna v palem data trace cach applic specif cach architectur acm sigarch comput architectur news v34 n1 march 2006 shimin chen phillip b gibbon todd c mowri improv index perform prefetch acm sigmod record v30 n2 p235246 june 2001 tatsushi inagaki tamiya onodera hideaki komatsu toshio nakatani stride prefetch dynam inspect object acm sigplan notic v38 n5 may evangelia athanasaki niko anastopoulo kornilio kourti nectario koziri explor perform limit simultan multithread memori intens applic journal supercomput v44 n1 p6497 april 2008 chikeung luk toler memori latenc softwarecontrol preexecut simultan multithread processor acm sigarch comput architectur news v29 n2 p4051 may 2001