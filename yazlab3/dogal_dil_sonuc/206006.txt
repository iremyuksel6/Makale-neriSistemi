planar strong connect help parallel depthfirst search paper prove strongli connect planar direct graph size n depthfirst search tree root specifi vertex comput olog5n time nlogn processor previous planar direct graph may strongli connect best depthfirst search algorithm run olog10n time n processor algorithm run parallel random access machin allow concurr read concurr write share memori case write conflict permit arbitrari processor succeed b introduct depthfirst search one use tool graph theori 32 4 depthfirst search problem follow given graph distinguish vertex construct tree correspond perform depthfirst search graph start given vertex parallel depthfirst search studi numer author reif show lexicograph depthfirst search pcomplet even gener undirect graph 28 unord depthfirst search smith gave first nc algorithm planar undirect graph 30 processor complex algorithm reduc linear yesha 15 independ jaja kosaraju 16 shannon 29 also achiev result aggarw anderson gave random nc algorithm gener undirect graph 2 kao studi problem direct graph found nc algorithm use n 4 processor planar direct graph size n 17 follow random nc algorithm aggarw anderson kao gener direct graph 3 recent kao klein gave algorithm comput depthfirst search tree olog 10 n time use n processor planar direct graph may strongli connect 19 paper show strongli connect planar direct graph size n depthfirst search tree root specifi vertex comput olog 5 n time use n log n processor algorithm run parallel random access machin allow concurr read concurr write share memori case write conflict permit arbitrari processor succeed algorithm paper kao klein use direct graph separ defin kao 17 follow framework random nc algorithm gener direct graph 3 algorithm paper achiev superior complex exploit topolog properti strongli connect planar direct graph strongli connect compon key subgraph creat cours algorithm regular structur major task algorithm recurs maintain util structur paper organ follow section 2 review basic definit relev fact planar direct graph depart comput scienc duke univers durham nc 27706 support part nsf grant ccr8909323 section 3 quot previou result report new result comput strongli connect compon direct span tree section 4 discuss direct graph separ detail discuss separ given appendix section 5 detail paper depthfirst search algorithm strongli connect planar direct graph 2 basic planar direct graph planar direct graph one embed plane edg intersect common end vertic start vertic 14 7 33 6 embed planar direct graph one given planar embed subtl technic reason planar graph paper may multipl edg loop edg 21 strong graph breviti strongli connect embed planar direct graph least one vertex simpli call strong graph goal paper effici comput depthfirst search span tree strong graph root specifi vertex 22 face boundari orient let g connect embed planar direct graph vertic edg g delet embed plane plane divid disconnect region exactli one region infinit other finit region call face g infinit region call extern face finit region call intern face let f face g boundari f denot bf set edg vertic surround f g contain least two vertic connect bf arrang uniqu undirect cycl observ stay insid f walk around bf cycl call boundari cycl f may edgesimpl let e boundari edg f orient e respect f defin follow ffl case 1 f extern face edg e posit neg respect f point counterclockwis resp clockwis direct boundari cycl f ffl case 2 f intern face edg e posit neg respect f point clockwis resp counterclockwis direct boundari cycl f 23 hole boundari orient let g connect embed planar direct graph let h connect subgraph g vertic edg h remov embed plane g plane divid disconnect region exactli one region infinit other finit region call hole h infinit region call extern hole finit region call intern hole let x hole h boundari x denot bx set vertic edg surround x h contain least two vertic connect bx arrang uniqu undirect cycl observ stay insid x walk around bx exactli cycl call boundari cycl x may edgesimpl let e boundari edg x orient e respect x defin follow ffl case 1 x extern hole h edg e posit neg respect x point counterclockwis resp clockwis direct boundari cycl x ffl case 2 x intern hole h edg e posit neg respect x point clockwis resp counterclockwis direct boundari cycl x 24 combinatori embed data structur let g connect planar direct graph algorithm planar embed g encod boundari extern face clockwis cyclic order edg incid vertex encod call combinatori planar embed g topolog planar embed uniqu specifi correspond combinatori embed cyclic edg incid combinatori embed encod follow data structur vertex doubli link circular list consist edg incid vertex clockwis order list use effici trace boundari cycl face g also use trace boundari cycl hole connect subgraph given connect planar direct graph size n combinatori planar embed comput ologn time use n log log n log n processor determinist arbitrarycrcw pram 27 25 planar embed induc vertex contract paper vertex contract contract connect vertex subset connect embed planar direct graph ensur planar preserv technic reason multipl edg creat vertex contract kept loop edg delet let g connect embed planar direct graph let h subgraph induc connect vertex subset g let g 0 graph construct g contract h vertex h 0 h consist one vertex g 0 g otherwis planar embed g 0 specifi follow ffl everi vertex u 62 h clockwis cyclic order edg incid u g g 0 ffl edg around nonempti hole x h stay togeth around h 0 clockwis cyclic order around h 0 cyclic order around boundari cycl x neg direct x ffl uncontract edg boundari extern face g remain g 0 orient respect extern face ffl h contain boundari vertex extern face g h 0 boundari extern face g 0 gener planar embed uniqu planar embed fit construct suitabl purpos paper lemma 21 given connect embed planar direct graph size n planar embed induc contract disjoint famili connect vertex subset comput olog n time use n log n processor remark vertex contract requir delet multipl edg creat comput induc embed may take linear space achiev olog n time n log n processor proof edg around new vertex g 0 collect process doubli link circular list combinatori embed g comput take olog n time n log n processor use optim parallel algorithm list rank 5 9 13 prefix comput 24 23 tree contract 26 1 8 22 11 10 planar connect 12 3 strongli connect compon direct span tree section quot previou result report new result comput strongli connect compon direct span tree 31 direct span tree theorem 31 kao shannon 20 strong graph size n direct span tree root specifi vertex comput olog 2 n time use n log n processor determinist arbitrarycrcw pram 32 compact strongli connect compon let g connect embed planar direct graph let h 1 h 2 two nonempti connect subgraph g h 1 enclos h 2 h 2 intern hole h 1 compact strongli connect compon g one enclos strongli connect compon theorem 32 kao 18 let g connect embed planar direct graph let n size g let ff number noncompact strongli connect compon g strongli connect compon g comput odlog use n log n processor determinist arbitrari crcw pram 33 new result comput strongli connect compon next three theorem discuss comput strongli connect compon graph obtain delet contract subgraph embed planar direct graph may connect strongli connect compon compact compact connect compon contain 331 delet vertex subset strong graph let g direct graph let h subgraph vertex subset g let g gamma h subgraph obtain remov vertic h incid edg theorem 33 let g strong graph size n let h subgraph g number connect compon h let ff 0 number noncompact strongli connect compon g 0 follow statement true 1 ff 0 fl 2 strongli connect compon g 0 comput determinist odlog 2 fl use n log n processor proof first statement obtain count argument base follow fact ffl let w noncompact strongli connect compon g 0 planar strong connect g least one connect compon h enclos w g ffl let w 1 w 2 two noncompact strongli connect compon g 0 planar g connect compon h enclos g w 1 w 2 either w one enclos g ffl let w noncompact strongli connect compon g 0 strong connect planar g connect compon h enclos g w noncompact strongli connect compon g 0 enclos w g prove second statement first comput connect compon g 0 take ologn time use n log n processor 12 next comput strongli connect compon connect compon via theorem 32 second statement follow first statement theorem 332 delet edeg subset strong graph theorem 34 let g strong graph size n let u vertex subset g let subset edg g incid u let g 0 graph obtain delet g edg let number vertic u let ff 0 number noncompact strongli connect compon g 0 follow statement true 1 ff 0 2 2 strongli connect compon g 0 comput determinist odlog 2 2 use n log n processor proof second statement follow directli first statement theorem 32 thu suffic prove first statement follow let w noncompact strongli connect compon g vertex absorb w g either vertex w enclos w g definit first statement obtain count argument base follow fact ffl let w noncompact strongli connect compon g 0 planar strong connect g u 2 u absorb w g ffl let w 1 w 2 two noncompact strongli connect compon g 0 planar g vertex u 2 u absorb w 1 w 2 g either w one enclos g ffl let w noncompact strongli connect compon g 0 strong connect planar g vertex u absorb g w one noncompact strongli connect g 0 enclos w g 333 contract connect vertex subset acycl graph theorem 35 let g acycl connect embed planar direct graph let h subgraph g let g 0 graph obtain g contract connect compon h vertex let n size g let fl number connect compon h let ff 0 number noncompact strongli connect compon g 0 follow statement true 1 ff 0 fl 2 strongli connect compon g 0 comput determinist odlog 2 fl use n log n processor proof noncompact strongli connect compon contain least two ver tice thu acycl g noncompact strongli connect compon g 0 contain least one contract connect compon h therefor first statement true second statement follow theorem 32 4 direct graph separ intuit separ graph subgraph whose remov disconnect graph small piec 41 cycl separ kpath separ work parallel depthfirst search reli find form graph separ algorithm planar undirect graph employ undirect cycl separ 30 15 16 algorithm gener undirect graph use path separ 2 procedur mergetwopath input strong graph g twopath separ output path separ g begin 1 let largest index strongli connect compon z g gamma fu heavi g remark 2 exist return 3 let p 0 path u remark p 0 q form twopath separ 4 let smallest index strongli connect compon z g heavi g 5 exist return 6 let q 0 path v remark p 0 q 0 form twopath separ 7 comput direct path r z z u v remark z z strongli connect 8 let direct path form p 0 r q 0 remark vertexsimpl 9 return end fig 1 procedur merg twopath separ path separ notion direct graph separ origin introduc depthfirst search planar direct graph 17 use gener direct graph 3 tailor strongli connect direct graph g ffl vertex subset call heavi g contain two third vertic g ffl separ g set vertic strongli connect compon g gamma heavi g ffl cycl separ vertexsimpl direct cycl whose vertic form separ singl vertex consid cycl length zero thu remov vertex separ graph vertex cycl separ ffl posit integ k kpath separ set k vertexdisjoint vertex simpl direct path whose vertic form separ 1path separ simpli call path separ kao show everi direct graph direct path separ direct cycl separ 17 result includ appendix graph size n proof yield sequenti algorithm comput path separ optim time algorithm comput cycl separ log n time aggarw anderson kao improv sequenti time comput direct cycl separ 3 also show comput cycl separ comput depthfirst search tree ncequival 42 comput cycl separ strong graph lemma 41 given strong graph size n twopath separ comput olog 2 n time use n log n processor proof let direct span tree given graph work lipton tarjan 25 exist two vertic x two tree path root x root form separ twopath separ easili obtain tree path kao teng toyama gave algorithm 21 comput x olog n use n log n processor thu lemma follow theorem 31 lemma 42 given strong graph size n path separ comput olog 3 n time use n log n processor proof let g given graph first use lemma 41 obtain twopath separ g use algorithm mergetwopath fig 1 comput path separ proof correct mergetwopath similar theorem a2 appendix a3 complex suffic show mergetwopath run olog 3 n time use n log n processor z z comput binari search theorem 33 olog 3 n time use n log n processor r 0 obtain comput diverg direct span tree root u subgraph induc z z use theorem 31 take olog 2 n time use n log n processor thu complex mergetwopath state theorem 43 given strong graph size n cycl separ comput olog 3 n time use n log n processor proof proof similar lemma 42 theorem a2 5 parallel depthfirst search section 51 give overview paper algorithm perform depthfirst search strong graph section 52 56 discuss key techniqu use algorithm section 58 detail algorithm 51 overview let g strong graph let r vertex g goal construct depthfirst search span tree root r g tree recurs construct use cycl separ first comput cycl separ g comput path separ start r find direct path r cycl separ path cycl separ form path separ appropri edg cycl separ remov branch final depthfirst search tree ie remain graph search suppos search continu g 0 start vertex r 0 end vertex edg point last vertex time search recurs subgraph b r 0 consist vertic reachabl r 0 via direct path g 0 graph b r 0 call dangl subgraph see x55 separ g everi strongli connect compon g 0 contain two third vertic g howev b r 0 may contain sever strongli connect compon consequ b r 0 may still larg small depth recurs avoid problem set direct path remov g remain direct graph small dangl subgraph remov path form subtre call partial depthfirst search tree final depthfirst search tree see x55 dangl subgraph strong graph special kind graph call bubbl graph structur bubbl graph exploit effici process dangl subgraph see x52 strong graph fact special case bubbl graph depthfirst search algorithm paper actual take bubbl graph input comput depthfirst search tree recus bubbl subgraph see x57 52 bubbl graph strongli connect compon direct graph sink compon outgo edg strongli connect compon let b embed planar direct graph b call bubbl graph root vertex r follow condit hold ffl everi vertex b reach r via direct path ffl vertex r boundari vertex extern face b everi sink compon b contain least one boundari vertex extern face remark assum bubbl graph specifi root breviti root explicitli mention unless risk ambigu lemma 51 let b bubbl graph root r let n size g follow statement true 1 strongli connect compon b comput olog 2 n time use n log n processor 2 direct span tree b root r comput olog 2 n time use n log n processor proof first statement follow theorem 32 fact bubbl graph noncompact strongli connect compon second statement shown follow let b 0 graph obtain b ad direct edg sink compon b r via extern face b direct span tree b 0 root r also one b complex first statement lemma b 0 comput olog 2 n time use n log n processor b 0 strong graph desir direct span tree b 0 comput via theorem 32 olog 2 n time use n log n processor 53 heavi bubbl graph split compon let k integ bubbl graph call kheavi klight resp vertic let b kheavi bubbl graph let w 1 w 2 two distinct strongli connect compon w 2 call descend compon w 1 w 1 reach direct path direct graph g vertex subset vertex h g let rhg set vertic reach h via direct path g let w strongli connect compon b let rwb set vertic b reach w via direct path w call split compon b rwb consist k vertic descend compon w satisfi condit depthfirst search algorithm paper find cycl separ split compon b use separ break b bubbl subgraph smaller split compon 54 comput split compon via st graph acycl embed planar direct graph call st graph uniqu sourc uniqu sink boundari extern face theorem 52 given kheavi bubbl graph size n split compon comput olog 2 n time use n log n processor proof let b kheavi bubbl graph split compon b comput convert b st graph follow graph obtain ad vertex extern face b direct edg point sink compon b graph obtain b 1 contract strongli connect compon b vertex vertic b 2 assign weight weight 0 vertex w contract strongli connect compon w b weight w number vertic w note b 2 st graph sink sourc contract strongli connect compon b contain specifi root lemma 511 21 b 2 comput olog 2 n time use n log n processor next cardin rwb strongli connect compon w b comput olog 2 n time n log n processor comput appli b 2 descend count algorithm tamassia vitter st graph 31 cardin rwb comput split compon b identifi straightforward manner ologn time use n log n 55 partial depthfirst search tree dangl subgraph let b bubbl graph partial depthfirst search tree b subtre depthfirst search tree b tree root specifi root b let partial depthfirst search tree b let x vertic list postord travers sequenc depthfirst search ie sequenc x mark right descend mark x let vertic end vertic edg point x order arbitrari postord use search start x vertex may sever differ indic adjac sever x vertic dangl subgraph b denot di j respect subgraph induc vertic reach ij vertex ij intend postord travers sequenc vertic ie di jg nonempti di j direct edg x ij call dangl edg associ di j next two lemma provid natur way extend complet depthfirst search tree recurs nonempti dangl subgraph parallel lemma 53 let r specifi root b let h connect subgraph b contain r let u vertex h adjac h subgraph b induc ru bubbl graph root u proof let b u subgraph b induc ru first definit b u vertex u reach everi vertex b u via direct path b u next r boundari vertex extern face b connect h relationship r h u vertex u boundari vertex extern face b u let w sink compon b u follow discuss show w contain boundari vertex extern face b u b bubbl graph contain direct path w boundari vertex extern face b two case base whether q intersect h ffl case 1 q intersect h q lie b u w sink compon b u path q lie w therefor w contain last vertex q boundari vertex extern face b u ffl case 2 q intersect h let first vertex q h boundari vertex extern face b adjac h sgamma1 vertex sgamma1 boundari vertex extern face b u furthermor w sink compon b u vertex sgamma1 w lemma 54 letomega set dangl subgraph b respect let l set associ dangl edg follow statement true 1 nonempti di j bubbl graph root ij henc ij chosen specifi root di j 2 dangl subgraph disjoint 3 depthfirst search tree b form l depthfirst search tree dangl subgraph least two vertic proof first statement obtain recurs appli lemma 53 two statement straightforward 56 comput dangl subgraph respect path section show comput dangl subgraph respect partial depthfirst search tree path comput base two bisect strategi use subroutin fig 2 fig 3 561 analyz subroutin fig 2 next two lemma analyz subroutin fig 2 lemma 55 let set end vertic edg b point proof proof two direct contain direct path q 1 p 1 note q 1 contain edg hand 1 strongli connect direct path q 2 p intersect one vertex q 2 contain outgo edg edg let q direct path form q 1 q 2 q goe p p becom direct cycl 2 contain w q contain edg remain direct cycl 3 therefor contain vertexsimpl direct path r 1 w z let r 2 direct path 1 correspond r 1 intersect p one vertex x note x start vertex r 1 1 construct ad incom edg r edg remov 3 vertex x p 1 edg r 2 therefor z 2 ry lemma 56 let b bubbl graph size n procedur fig 2 correctli comput output specifi olog 2 n time use n log n processor proof second fourth output properti procedur straight forward two properti shown subgraph b induc rx therefor lemma 53 b 1 bubbl graph root x q obtain bubbl graph contract connect vertex subset bubbl graph root x p ffl properti 3 lemma 55 nonempti dangl subgraph associ dangl edg b respect p exactli b 1 respect p 1 respect p 2 may may bubbl graph b 1 contract instead delet contract b 1 x q1 may add new edg b 2 procedur subonecomputedsg input bubbl graph b root r vertexsimpl direct path 2 output two graph b 1 b 2 construct b two path bubbl graph root x dp2e x p respect 2 p 1 p 2 vertexsimpl direct path respect b 1 start specifi root 3 nonempti dangl subgraph associ dangl edg b respect p exactli b 1 respect p 1 b 2 respect p 2 4 total size b 1 b 2 size b begin 1 let 2 let p 1 subpath p form x 3 let p 2 subpath p form x 4 let set edg b point p 2 5 b strongli connect let els let 1 graph obtain b ad direct edg sink compon r via extern face b 6 let 2 graph obtain 1 contract p vertex remark edg outgo edg w 7 let 3 graph obtain 2 delet edg 8 let w strongli connect compon 3 contain super vertex w 9 let b 1 subgraph b induc w graph obtain b contract x q1 end fig 2 first subroutin comput dangl subgraph procedur subtwocomputedsg input bubbl graph b root r k 2 edg outgo r output two graph b 1 b 2 construct b follow properti bubbl graph root r 2 nonempti dangl subgraph associ dangl edg b respect r exactli b 1 b 2 respect r r consid path singl vertex 3 outdegre r b 1 b 2 dk2e bk2c respect 4 total size b 1 b 2 size b begin 1 let 2 let k end vertic outgo edg r b 3 let set edg r b 4 b strongli connect let els let 1 graph obtain b ad direct edg sink compon r via extern face b 5 let 2 graph obtain 1 contract vertex w remark edg outgo edg w 6 let 3 graph obtain 2 delet edg 7 let w strongli connect compon 3 contain super vertex w 8 let b 1 subgraph b induc w gamma without edg 9 let b 2 graph obtain b contract r end fig 3 second subroutin comput dangl subgraph x q1 howev contract creat new edg b 2 x q1 edg would point b 1 thu end vertic would includ b 1 therefor contract b 1 x q1 chang nonempti dangl subgraph associ dangl edg respect p 2 complex step 1 4 done olog n time use n log n processor step 5 done via lemma 511 olog 2 n time use n log n processor step 6 done via lemma 21 olog n time use n log n processor step 7 done olog n time use n log n processor 1 strong graph 2 remain strong graph edg adjac w 2 theorem 34 w comput olog 2 n time use n log n processor step 9 done ologn time use n log n processor step 10 done via lemma 21 ologn time use n log n processor thu total complex procedur fig 2 state 562 analyz subroutin fig 3 next lemma analyz subroutin fig 3 lemma 57 let b bubbl graph size n procedur fig 3 correctli comput output specifi olog 2 n time use n log n processor proof proof similar lemma 56 53 subtl point follow b 1 may contain dangl subgraph b respect vertic empti therefor edg delet b 1 without affect nonempti dangl subgraph delet ensur outdegre r b 1 dk2e 563 comput dangl subgraph next theorem use procedur fig 2 fig 3 comput nonempti dangl subgraph respect path theorem 58 let b bubbl graph size n let p vertexsimpl direct path b start specifi root nonempti dangl subgraph associ dangl edg b respect p comput olog 3 n time use n log n processor proof comput divid two phase follow ffl first phase iter appli subonecomputedsg b p bisect p ologn iter collect bubbl subgraph b obtain subgraph b 0 contain one vertex p ffl second phase iter appli subtwocomputedsg b 0 bisect outdegre root olog n iter collect even smaller bubbl subgraph b obtain subgraph b 00 root vertex subgraph b 00 either exactli one outgo edg consist b 00 consist correspond dangl subgraph b empti otherwis b 00 gammafyg nonempti dangl subgraph b associ dangl edg outgo edg b 00 correct complex comput follow directli lemma 56 57 57 parallel depthfirst search bubbl graph fig 6 detail paper algorithm perform depthfirst search bubbl graph subroutin describ fig 5 fig 4 lemma 59 let b bubbl graph size n procedur fig 4 correctli comput output specifi olog 3 n time use n log n processor procedur splitheavydsg input posit integ 2m3heavi bubbl graph b vertic output 1 partial depthfirst search tree b either properti ffl dangl subgraph b respect 2m3heavi ffl dangl subgraph 2m3heavi split compon consist two third vertic split compon b 2 set delta dangl subgraph b respect 3 set k associ dangl edg begin 1 let r specifi root b 2 let w split compon b 3 let c direct cycl separ w 4 let p vertexsimpl direct path b r c p c intersect one vertex u 5 let e edg c point u 6 let vertexsimpl direct path form p c without edg e 7 let delta set dangl subgraph b respect 8 let k set associ dangl edg 9 return tupl delta k end fig 4 procedur split heavi dangl subgraph procedur computepartialtre input bubbl graph b vertic output 1 partial depthfirst search tree b dangl subgraph 2m3light 2 setomega dangl subgraph b respect 3 set l associ dangl edg begin 1 2 b 0 2omega 2m3heavi begin 22 delet dangl edg b 0 l 23 add edg form larger tree 24 25 add form larger tree add delta omegagamma 27 add k l end 3 return tupl end fig 5 procedur comput partial depthfirst search tree procedur computedfstre input bubbl graph b least two vertic output depthfirst search tree b begin 1 2 add l form larger tree 3 b 0 2omega least two vertic begin 31 32 add 0 form larger tree end 4 return end fig 6 procedur comput depthfirst search tree proof correct procedur shown follow let 0 set vertic w assum dangl subgraph b 0 b respect 2m3heavi b vertic b 0 2m3 heavi dangl subgraph b respect split compon strongli connect compon w gamma 0 0 separ w output properti procedur hold complex procedur analyz follow step 1 obviou step 2 done via theorem 52 step 3 done via theorem 43 step 4 done use lemma 512 step 5 6 obviou step 7 8 done via theorem 58 thu total complex state lemma 510 let b bubbl graph size n procedur fig 5 correctli comput output specifi olog 4 n time use n log n processor proof lemma follow directli lemma 59 fact output properti splitheavydsg number iter computepartialtre ologn theorem 511 let b bubbl graph size n let r specifi root b depthfirst search tree b root r comput olog 5 n time use n log n processor determinist arbitrarycrcw pram proof comput done procedur fig 6 theorem follow directli lemma 54 510 fact output properti computepartialtre depth recurs computedfstre olog n 58 parallel depthfirst search strong graph next theorem state main result paper theorem 512 let g strong graph size n let r vertex g depthfirst search span tree g root r comput olog 5 n time use n log n processor determinist arbitrarycrcw pram proof extern face g chang r boundari vertex face strong connect g bubbl graph root r therefor theorem follow theorem 511 fact extern face chang ologn time n log n processor use list rank 5 9 13 prefix comput 24 23 acknowledg author wish thank subhrajit bhattacharya help discuss graph cycl separ follow discuss use depthfirst search tree comput graph separ 17 a1 path cycl separ weight graph weight graph one nonneg vertex weight avoid trivial assum least one vertex posit weight let g weight direct graph let h subgraph vertex subset g h subgraph obtain remov vertic h incid edg let wh total weight h set h call heavi g wh wg2 remark threshold heavi differ x41 23 separ g vertex subset strongli connect compon g gamma heavi g cycl path separ vertexsimpl direct cycl resp path vertic form separ technic uniform vertex consid trivial cycl thu vertex form separ cycl separ empti set consid trivial cycl trivial path thu empti set form separ cycl separ well path separ a2 comput path separ depthfirst search tree next theorem appli weight undirect graph substitut undirect edg pair direct edg theorem a1 everi weight direct graph path separ proof let g weight direct graph without loss gener assum g strongli connect otherwis replac g maximumweight strongli connect compon everi path separ compon also one g path separ p g construct follow let depthfirst search span tree g root arbitrari vertex r let z vertic g correspond depthfirst search postord let p smallest index let p tree path r z p let g let p shown path separ follow draw g plane way postord indic j j vertex z either right z j ancestor z j 4 vertex z p either ancestor right everi vertex gl p greater postord indic vertic gl also everi vertex gr right z p postord indic vertic gr greater p p consist z p ancestor therefor everi vertex gr right everi vertex gl depthfirst search edg point left right everi strongli connect compon g gamma p either entir gl entir gr thu weight strongli connect compon g gamma p wgl wgr a3 comput cycl separ path separ next theorem also appli weight undirect graph edg substitut note separ obtain theorem actual consist either vertex singl vertex least three vertic thu degener undirect edg edg substitut undon theorem a2 everi weight direct graph cycl separ proof let g weight direct graph let path separ g obtain theorem a1 p convert cycl separ follow let largest index strongli connect compon z g gamma fu heavi g path u exist empti set trivial cycl separ otherwis continu convers let let smallest index strongli connect compon z heavi g u path u separ two case base whether u trivial cycl separ otherwis u 62 z u 62 z z z heavi g strongli connect z z contain vertex z vertex simpl direct path q u via z gamma z z via z gamma z u contain none u path q path u vertexsimpl direct cycl least three vertic cycl separ path u separ r simpl tree contract algorithm random nc algorithm depth first search parallel depthfirst search gener direct graph design analysi comput algorithm determinist parallel list rank new york acceler centroid decomposit techniqu optim tree evalu logarithm time optim tree contract erew model optim parallel algorithm dynam express evalu applic optim parallel algorithm planar graph optim link list prefix algorithm local memori comput graph theori nearli optim parallel algorithm construct depth first span tree planar graph parallel algorithm planar graph relat problem graph cycl separ planar direct depthfirst search dnc toward overcom transitiveclosur bottleneck effici parallel algorithm planar digraph log nwork nc algorithm depthfirst search undirect planar graph optim parallel evalu treestructur comput rake power parallel prefix parallel prefix comput separ theorem planar graph parallel tree contract applic optim parallel algorithm graph planar linearprocessor algorithm depthfirst search planar graph parallel algorithm depth first search parallel transit closur point locat planar struc ture graph theori tr