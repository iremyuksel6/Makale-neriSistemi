specul version cach depend among load store whose address unknown hinder extract instruct level parallel execut sequenti program ambigu memori depend overcom memori depend specul enabl load store specul execut address preced load store known furthermor multipl specul store memori locat creat multipl specul version locat program order among specul version must track maintain sequenti semant previous propos approach address resolut buffer arb use central buffer support specul version propos call specul version cach svc use distribut cach elimin latenc bandwidth problem arb svc conceptu unifi cach coher specul version use organ similar snoop busbas coher cach evalu multiscalar architectur show hit latenc import factor affect perform privat cach solut tradeoff hit rate hit latenc b introduct modern microprocessor extract instruct level parallel ilp sequenti program issu instruct activ instruct window data depend among instruct origin program order determin instruct may issu win dow depend involv regist data detect easili regist design complet specifi within instruct howev depend involv memori data eg load store two store ambigu memori address comput straightforward solut problem ambigu memori depend issu load store address determin furthermor store allow complet commit result memori preced instruct known free ex ception store memori locat creat specul version locat specul version held buffer commit multipl specul store locat creat multipl version locat improv perform load allow bypass buffer store long differ address load address buffer store use data bypass store data becom avail import constraint approach load instruct issu address preced store determin approach may diminish ilp unnecessarili especi common case load depend preced store aggress uniprocessor implement issu load instruct soon address known even address previou store may known implement employ memori depend specul 8 predict load depend previou store furthermor one also envis issu comput store address order memori depend specul enabl higher level ilp advanc mechan need support specula tion aggress uniprocessor dispatch instruct singl instruct stream issu load store instruct common set hardwar buffer eg reserv station use common set buffer allow hardwar maintain program order load store via simpl queue mechan coupl address comparison logic presenc queue provid support simpl form specul version howev propos next gener processor design use replic process unit dispatch andor issu instruct distribut manner futur approach partit instruct stream sub stream call task 11 trace 10 higher level instruct control unit distribut task processor execut processor execut instruct within task lead hierarch execut model propos next gener multiprocessor 9 12 provid hardwar support depend specul also use execut model hierarch execut model natur lead memori address stream similar hierarch structur particular individu task gener address stream properli order di ambigu within processor gener higher level multipl address stream produc processor must also properli order challeng support specul version execut model superscalar execut model processor execut load store without know execut processor address resolut buffer 3 arb provid specul version support hierarch execut model entri arb buffer version memori locat howev two signific perform limit arb 1 arb singl share buffer connect multipl processor henc everi load store incur latenc interconnect network also arb provid suffici bandwidth processor 2 task complet instruct arb commit specul state architect storag copi version creat task data cach write back gener bursti traffic increas time commit task delay issu new task processor lower overal perform propos new solut specul version call specul version cach 2 5 svc hierarch execut model svc compris privat cach processor system organ similar snoop busbas cach coher symmetr multiprocessor smp memori refer hit privat cach use bu smp task commit write back specul version en mass cach line individu handl access next time section 2 introduc hierarch execut model briefli identifi issu provid support specul version execut model section 3 present svc progress design eas stand section 4 give preliminari perform evalu svc highlight import privat cach solut specul version deriv conclus section 5 2 specul version first discuss issu involv provid support specul version current gener processor second describ hierarch execut model use propos next gener processor third discuss issu provid support specul version execut model use exampl illustr final present similar multiprocessor cach coher specul version hierarch execut model use unif motiv new design specul version cach specul version involv track program order among multipl buffer version locat guarante follow sequenti program semant ffl load must eventu read valu creat recent store locat requir load must squash reexecut execut store incorrectli read previou version ii store locat follow load program order must buffer load execut ffl memori locat must eventu correct version independ order creation ver sion consequ specul version locat must commit architect storag program order 21 hierarch execut model execut model dynam instruct stream program partit fragment call task task form sequenc correspond order dynam instruct stream higher level control unit predict next task sequenc assign execut free processor processor execut instruct task assign buffer specul state creat task wisconsin multiscalar 11 exampl architectur use hierarch execut model task mispredict detect specul state task sequenc includ incorrectli predict task invalid 1 correspond processor freed call task squash correct task sequenc assign exe cution task predict valid commit copi specul buffer state architect storag task commit one one order sequenc task commit processor free execut new task sinc task commit program order task assign processor program order altern model recoveri invalid depend b figur 1 task commit squash exampl figur commit task squash ini tialli task 0 1 99 3 predict specul execut parallel four processor shown figur 1a mispredict task 99 detect task 99 3 squash buffer state invalid new task 2 3 execut processor show figur 1b task current execut said activ task 0 complet exe cution correspond processor freed task 4 assign execut shown figur 1c program order repres sequenc among task enforc implicit total order among processor arrow show order task specul execut parallel multipl specul loadstor stream processor merg arbitrari order provid support specul version execut model requir mechan establish program order among stream follow subsect outlin order establish use sequenc among task 211 load task execut load soon address avail specul store previou task sequenc write locat closest previou version locat suppli load version could creat either task previou task load suppli version previou task record indic use potenti definit definit store locat previou task occur load suppli incorrect version memori depend violat 212 store task execut store memori locat commun later activ task sequenc 2 task receiv new version locat previou task squash use definit record locat memori depend violat detect task squash task also squash task mispredict simpl squash model 213 task commit squash oldest activ task nonspecul commit specul memori state version creat store task ar chain instruct maintain inform finer granular paper assum simpler model realiti store commun task creat next version locat chitect storag commit version involv logic copi version specul buffer architect storag data cach assum simpl task squash model specul state associ task invalid squash 22 exampl specul version figur 2 illustr issu involv specul version use exampl program sampl execut program four processor hierarch system use exampl later section explain svc design figur 2a show load store exampl program task partit instruct direct relev figur 2b show two snapshot memori system sampl execut program snapshot contain four box one activ task show load store execut correspond task program order among instruct translat sequenc among task impos total order among processor execut solid arrowhead show program order hollow arrowhead show execut time order exampl exampl program b sampl execut st 3 ld r st 0 a23 st 0 st 1 st 0 st 1 st 3 st 5 ld r ld r program order31st 1 depend violation23 figur 2 specul version exampl first snapshot taken task 1 execut store address task 0 3 alreadi store 3 task 2 execut load load suppli version creat buffer task accord origin program load must suppli valu 1 creat store task 1 ie store load depend violat violat detect task 1 store address task includ task 2 squash execut second snapshot taken task squash restart 23 coher specul version action perform memori access task commit squash summar tabl 1 function tabl requir hardwar track activ task processor execut loadstor locat order among differ copiesvers locat cach coher symmetr multiprocessor use similar function track cach copi everi memori locat smp howev need track order among copi sinc copi singl version event action load record use definit task suppli closest previou version store commun store later task later task look memori depend violat commit write back buffer version creat task main memori squash invalid buffer version creat task tabl 1 version event action smp typic use snoop 4 implement multipl readersingl writer protocol use coher directori collect set track sharer line snoop bu base smp directori typic implement distribut fashion compris state bit associ cach line hand specul version cach svc implement multipl readermultipl writer protocol track copi multipl specul version memori locat protocol use version directori maintain order set line track program order among multipl specul version line order set list call version order list vol implement sever differ way svc propos paper use explicit pointer line implement link list like sci 1 follow section elabor design use pointer cach line maintain vol privat cach organ svc make feasibl memori system propos next gener singl chip multiprocessor execut sequenti program tightli coupl processor use automat parallel 9 12 previous ambigu memori depend limit rang program chosen automat parallel svc provid hardwar support overcom ambigu memori depend enabl aggress automat parallel sequenti program 3 svc design section present specul version cach svc progress design eas stand design improv perform previou one track inform begin brief review snoop busbas cach coher present base svc design provid support specul version minim modif cach coher scheme highlight perform bottleneck base design introduc optim one one rest design 31 snoop bu base cach coher figur 3 show 4processor smp privat l1 cach use snoop bu keep cach consi tent cach line compris address tag identifi data cach data cach two bit valid store repres state line valid v bit set line valid store dirti bit set processor store line bu arbit v valid store dirti tag v data next level memori snoop bu figur 3 smp coher cach cach line one three state invalid clean dirti request load store processor l1 cach hit valid line request tag appropri state otherwis miss cach miss issu bu request cach hit specif load clean dirti line store dirti line result cach hit otherwis loadstor miss cach issu busreadbuswrit request l1 cach next level memori snoop bu everi request cach valid line request tag issu appropri respons accord coher protocol store clean line miss cach issu buswrit request invalidationbas coher protocol invalid copi line cach protocol allow dirti line present one cach howev clean line present multipl cach simultan cach dirti line suppli data busread request cach issu buswback request cast dirti line replac simpl protocol extend ad exclus bit state line cut traffic share bu cach line exclus bit set valid copi line perform store line local svc design discuss follow section also use invalidationbas protocol z z z z buswback flush replac buswrit invalid ld r busread flush st 1 0state data wz cach figur 4 cach coher exampl figur 4 show snapshot cach line tag address smp four processor w x z state cach line shown box correspond cach empti box correspond cach repres line present cach first snapshot taken processor z issu load miss privat cach cach issu busread request cach x suppli data bu second snapshot show final state line clean later processor issu buswrit request perform store clean copi cach x z invalid third snapshot show final state choos replac line cast line memori issu buswback request final state shown fourth snapshot next level memori contain valid copi line 32 base svc design organ privat l1 cach svc design shown figur 5 svc design use organ base design minim modifi memori system snoop busbas cach coher smp support specul version processor base hierarch execut model assum memori depend among load store execut individu processor ensur convent loadstor queue design guarante program order among load store differ processor base design also assum cach line size one word later design relax assumpt first introduc modif smp coher cach discuss individu oper list tabl 1 perform 1 cach line maintain extra state bit call load l bit shown figur 6 l bit set task load line store line potenti bu arbit version control logic next level memori snoop bu version control logic task assign inform vcl respons cach state snoop line cach figur 5 specul version cach v valid store l load tag pointer data figur base svc design structur line violat memori depend case previou task store line 2 cach line maintain pointer identifi processor l1 cach next copyvers version order list vol line thu vol line store distribut fashion among privat l1 cach line import note pointer identifi processor rather task store vol explicitli cach line use pointer may necessari base design howev necessari explicitli store vol advanc design introduc base design eas transit advanc design 3 svc use combin logic call version control logic vcl provid support specul version use vol processor request hit privat l1 cach need consult vol henc issu bu request vcl also use cach miss issu bu request snoop l1 cach next level memori state request line l1 cach vol suppli vcl vcl use bu quest program order among task vol comput appropri respons cach cach line updat base initi state bu request vcl respons block diagram version control logic shown figur 5 base design vcl respons similar disambigu logic arb 3 disambigu logic search previou succeed stage line execut load store respect 321 load load handl way smp except l bit set line initi valid busread request vcl locat closest previou version search vol revers order begin requestor version suppli requestor previou version buffer l1 cach next level memori suppli data task assign inform use determin posit requestor vol vcl search vol revers order entir list avail list short 03 task data pointer state wz cach z ld r execut time order program order figur 7 base svc design exampl load illustr load execut task 2 address exampl program figur 7 show two snapshot one load execut one load complet box show line tag address l1 cach valid bit explicitli shown number adjac box give processorcach identifi task identifi processor identifi use explicit pointer line repres vol wherea task identifi serv eas explan exampl task 2 execut load miss cach z result bu request vcl locat cach z vol address use program order search vol revers order find correct version suppli version cach version creat task 1 322 store svc perform oper store miss compar cach coher smp buswrit request issu store miss vcl send invalid respons cach begin questor immedi successor task assign order cach next version includ l bit set invalid respons allow multipl version line exist also serv detect memori depend violat cach send task squash signal processor receiv invalid respons vcl l bit set line z z z st 3 st 1 w figur 8 base svc design exampl store illustr store execut task 1 3 exampl program figur 8 show four snapshot cach line address first snapshot taken task 3 execut store result buswrit quest sinc task 3 recent program order store task 3 result invalid note store line invalid cach line unlik smp allow multipl version line second snapshot taken store task 3 complet task 1 execut store base task assign inform vcl send invalid respons cach one cach one cach w next version line cach w includ sinc l bit set send invalid respons cach z load execut task 2 follow store task 1 program order alreadi execut cach z detect memori depend violat sinc l bit set receiv invalid respons vcl task 2 3 squash shown third snapshot shade box final snapshot taken store task 1 complet 323 task commit squash base svc design handl task commit squash naiv man ner processor commit task dirti line l1 cach immedi written back next level memori line invalid write back dirti line immedi list store execut task maintain processor task squash line correspond cach invalid 33 base design perform drawback base design describ two signific perform limit make less desir write back perform processor commit task lead bursti bu traffic may increas time commit task delay issu new task processor ii clean line also invalid task commit squash buffer version could stale new task alloc processor correct version may present cach consequ everi task begin execut cold l1 cach increas bandwidth demand follow advanc design elimin problem track addit inform 1 first advanc design ec design section 35 make task commit squash effici eas understand design first present intermedi design ec design section 34 make task commit effici distribut write back dirti line time also retain readonli data l1 cach across task commit care bookkeep howev assum mispredict occur present ec design extend ec design allow task squash task squash simpl base design effici retain nonspecul data cach across task squash 2 second advanc design section 36 boost hitrat ec design allow request snarf 6 bu account refer spread snarf involv copi data suppli bu request issu anoth processor attempt combin bu request indirectli 3 final design section 37 realist allow size cach line one word 34 implement effici task commit ec ec design avoid expens cach flush task commit maintain extra state bit call commit bit cach line task commit stall line specul version written back ec design elimin write back burst bu task commit also extra hardwar necessari maintain list store perform task ec design improv cach util keep l1 cach warm across task tag l v data v valid l load c commit store stale figur 9 ec design structur line structur cach line ec design shown figur 9 processor commit task c bit set cach line oper entir local l1 cach issu bu request dirti commit line written back necessari access next time either processor request bu request therefor commit version could remain cach much later time sinc task creat version commit order among commit uncommit version still maintain explicit pointer line order among version necessari write back correct commit version suppli correct version bu request ec design use addit state bit stale bit retain readonli data across task first discuss load store handl cach commit uncommit version discuss stale bit 341 load store load commit line handl like cach miss issu bu request vcl search vol revers order begin requestor closest previou uncommit version version suppli requestor version found vcl suppli recent commit version version first commit version encount revers search commit version need written back invalid store miss commit version purg similar fashion ld r figur 10 ec design exampl load illustr load execut task 2 exampl program figur 10 show two snapshot one load execut one load complet version 0 1 commit c bit set line cach x task 2 execut load miss cach z result bu request vcl know task 2 head task determin cach x recent commit version cach x suppli data also written back next level memori commit version version invalid never written back memori vcl also insert new copi version 1 vol modifi pointer line accordingli second snapshot show modifi vol figur 11 illustr action perform store miss first snapshot taken store execut task 5 version 0 1 commit task 5 execut store miss cach result buswrit request even though line commit ver sion vcl purg commit version line determin version 1 written back next level memori version version invalid purg commit version also make space new version version 5 modifi vol shown second snapshot contain two uncommit version st 5 figur 11 ec design exampl store 342 stale copi ec design make task commit effici delay commit cach line later time therefor cach line could stale copi version recent version buffer commit task could present cach base svc design introduc stale copi invalid nondirti line whenev task commit ec design use stale bit distinguish stale copi correct copi avoid issu bu request access correct copi addit inform allow ec design retain readonli data correct copi across task commit first illustr stale correct copi indistinguish without bit show bit use ld r z cs cl ld r cl w3 y5 cs cs css w7z z figur 12 ec design correct stale copi figur 12 show two execut time line one leav correct copi address shown use solid line cach z anoth leav stale copi address cach shown use dash line first time line show sampl execut modifi version exampl program task 3 figur 2 execut store second time line show execut origin program first snapshot time line second snapshot second time line taken task 0 1 commit c bit set cach new task 4 5 alloc final snapshot time line taken task 4 7 activ task 6 execut load first time line data cach z correct copi sinc version creat version 1 load suppli data reset c bit without issu bu request second time line copi cach z stale sinc creation version 3 henc load miss result bu request howev cach z distinguish two scenario issu request case consult vol obtain copi correct version ec design use stale bit distinguish two scenario avoid bu request whenev copi stale design maintain invari recent version address copi bit reset copi version bit set invari easili guarante reset bit recent version copi thereof creat set bit previou version bit updat buswrit request issu creat version busread request issu copi version henc gener addit bu traffic sinc store differ task execut program order activ task could execut store copi bit set copi stale task stale next task alloc processor figur 13 show two time line exampl statu bit cach z distinguish correct copi bit set stale copi bit set load hit correct copi present bu request issu ld r cstcl ld r z cst cst clt figur 13 ec design use stale bit ec design elimin serial bottleneck flush l1 cach task commit use commit c bit also design retain nondirti line task commit long stale gener readonli data use program fetch l1 cach never invalid unless chosen replac cach miss task commit set c bit line l1 cach 35 implement effici task squash ec ec design extend ec design allow task squash ec design also ec design make task squash effici base design retain nonspecul data cach across squash use anoth state bit architectur bit structur line ec design shown figur 14 v valid store l load c commit stale architectur tag l figur 14 ec design structur line task squash uncommit line line c bit reset invalid reset valid v bit invalid make pointer line vol inexact vol dangl pointer last valid unsquash copi version line statu bit line incorrect ec design repair vol line line access later either processor request bu request updat bit necessari hint avoid bu request squash would incorrectli reset stale version correct howev ec design updat bit bu request consult repair vol w cst st st w wz figur 15 ec design vol repair figur repair exampl time line three snapshot first snapshot taken task squash occur task 3 4 squash version 3 invalid vol incorrect bit dangl pointer shown second snapshot execut load miss cach w result bu request vcl reset dangl pointer bit cach vcl determin version suppli load also recent commit version version back next level memori third snapshot taken load complet 351 squash invalid base design invalid nondirti line l1 cach task squash includ specul data previou task architectur data next level memori commit task base design invalid line track creator specul version line henc determin whether version line commit squash squash nonspecul data lead higher miss rate task squash restart multipl time distinguish copi specul architectur version add architectur bit cach line shown figur 14 bit set copi either next level memori commit version suppli data bu request issu obtain copi els bit reset one vcl respons bu request specifi whether bit set reset copi architectur version invalid task squash ie ec design invalid line c bit reset copi specul version use task becom architectur copi task commit howev bit set line access later task c bit reset bit set 36 hit rate optim base ec design incur sever perform penalti due refer spread uniprocessor program execut multipl processor privat l1 cach success access line hit miss share l1 cach could result seri miss phenomenon also observ parallel program miss rate readonli share data privat cach higher share cach use snarf 6 mitig problem svc implement snarf data bu correspond cach set free line avail howev activ task cach snarf version task use unlik coher cach vcl determin whether task copi particular version inform cach opportun snarf data bu request 37 realist line size base ec design assum line size l1 cach one word final svc design howev allow line longer word similar smp coher cach observ effect due fals share addit caus higher bu traffic fals share lead squash store cach line task execut outoford load differ byte word line later task mitig effect fals share use techniqu similar sector cach 7 line divid subblock l bit maintain subblock size subblock version block less address block storag unit address tag maintain also store miss result buswrit request mask bit indic version block modifi store also made avail bu 4 perform evalu report preliminari perform result svc use spec95 benchmark goal implement evalu prove svc design analyz perform underlin import privat cach solut first show perform degrad rapidli hit latenc share cach solut increas address resolut buffer arb share cach solut use evalu mitig commit time bottleneck arb use extra stage contain architectur data isol effect pure hit latenc perform bottleneck 41 methodolog configur result paper collect simul faith model multiscalar processor simul dynam switch function detail cyclebycycl model provid accur fast simul program memori system model includ fair amount detail includ chip cach dram bank interconnect differ level memori hierarchi multiscalar processor use experi 4 processor issu 2 instruct outoford processor 2 simpl integ alu 1 complex integ unit 1 float point unit 1 branch unit 1 address calcul unit assum complet pipelin interprocessor regist commun latenc 1 cycl processor send mani two regist neighbor everi cycl load store processor execut program order use loadstor queue 16 entri arb fullyassoci set 32byte line total 8kb storag per stage five stage share data cach back arb 2way set associ 64kb size chip cach 4mb size total peak bandwidth 16 byte per processor clock l1 data instruct task cach main memori access time first word 24 processor clock rambuslik interfac oper half speed processor provid peak bandwidth 8 byte everi bu clock cach memori 4way terleav arb l1 data cach mshrswritebuff buffer combin 8 access line disambigu perform bytelevel base arb hit time vari 1 3 cycl experi tag data ram singl port cach privat cach compris svc connect togeth chip cach 8word splittransact snoop bu typic transact requir 3 processor cycl 3 processor privat l1 cach 16kb 4way setassoci storag line load store nonblock 8 mshrswritebuff per cach buffer combin 4 access line disambigu perform bytelevel l1 cach hit time fix 1 cy cle tag ram dual port support snoop data ram singl port 42 benchmark use follow program spec95 benchmark suit train input except case list compress gcc refjumpi vortex perl ijpeg testspecmunppm mgrid testmgridin apsi fpppp turb3d program stop execut 1 billion instruct past experi know program perform chang signific beyond 1 billion instruct 43 experi figur present instruct per cycl ipc multiscalar processor either arb svc configur keep total data storag svc arbcach storag roughli percentag miss rate arb svc shown top ipc bar cluster order svc access count miss data suppli next level mem data transfer l1 cach count miss preliminari experi make three ob servat hit latenc data memori significantli affect arb perform ii svc tradesoff hit rate hit latenc arb tradesoff hit latenc hit rate achiev perform iii total data storag svc perform better arb hit latenc 2 cycl shown figur 16 graph figur show perform improv rang 5 20 decreas hit latenc arb 3 cycl 1 cycl improv indic techniqu use privat cach improv hit latenc import factor increas overal per formanc even latenc toler processor like multiscalar processor 3 bu arbitr occur cach cach data transfer extra cycl use flush commit version next level memori compress gcc vortex perl ijpeg mgrid apsi turb3d ipc 3175 2136 2624 8193 2334 1122 6981 arb 3 cycl figur distribut storag svc produc higher miss rate arb attribut increas miss rate svc two factor first distribut avail storag result refer spread 6 replic data reduc avail storag second latest version line cach finegrain share data multiscalar task constantli move one l1 cach anoth migratori data finegrain commun may increas number total miss well 5 conclus specul version import overcom limit instruct level parallel ilp due ambigu memori depend sequenti program pro posal call specul version cachesvc use distribut cach elimin latenc bandwidth problem previou solut address resolut buffer use central buffer svc conceptu unifi cach coher specul version use organ similar snoop busbas coher cach preliminari evalu multiscalar architectur show hit latenc import factor affect perform privat cach solut tradeoff hit rate hit latenc svc provid hardwar support break ambigu memori depend allow propos next gener multiprocessor use aggress parallel softwar sequenti program acknowledg thank scott breach andrea moshovo subbarao palacharla anonym refere comment valuabl suggest earlier draft paper work support part nsf grant ccr 9303030 mip9505853 onr grant n00014931 0465 us armi intellig center fort huachuca contract dabt6395c0127 arpa order d346 donat intel corp view conclus contain herein author interpret necessarili repres offici polici endors either express impli u armi intellig center fort huachuca us govern r ieee standard scalabl coher interfac sci 1596 1992 data memori altern multiscalar pro cessor arb hardwar mechan dynam reorder memori refer use cach memori reduc processormemori traffic specul version cach memori refer behavior cach perform share memori multi processor structur aspect system360 model 85 part ii cach dynam specul synchron data de pendenc case singlechip multiprocessor trace processor move fourthgener microarchitectur multiscalar processor potenti threadlevel data specul tightlycoupl multiprocessor tr wisconsin multicub new largescal cachecoher multiprocessor expand split window paradigm exploit finegrain parallelsim boost perform hybrid snoop cach protocol multiscalar processor case singlechip multiprocessor improv superscalar instruct dispatch issu exploit dynam code sequenc dynam specul synchron data depend complexityeffect superscalar processor trace processor data specul support chip multiprocessor scalabl approach threadlevel specul architectur support scalabl specul parallel sharedmemori multiprocessor ieee standard scalabl coher interfac scienc use cach memori reduc processormemori traffic potenti use threadlevel data specul facilit automat parallel specul version cach hardwar specul parallel partiallyparallel loop dsm multiprocessor ctr arun kejariw xinmin tian wei li milind girkar sergey kozhukhov hideki saito utpal banerje alexandru nicolau alexand v veidenbaum constantin polychronopoulo perform potenti differ type specul threadlevel parallel dl version paper includ correct made avail print proceed proceed 20th annual intern confer supercomput june 28juli 01 2006 cairn queensland australia