analysi cacherel preemption delay fixedprior preemptiv schedul abstractw propos techniqu analyz cacherel preemption delay task caus unpredict variat task execut time context fixedprior preemptiv schedul propos techniqu consist two step first step perform pertask analysi estim cacherel preemption cost execut point given task second step comput worst case respons time task includ cacherel preemption delay use respons time equat linear program techniqu step take input preemption cost inform task obtain first step paper also compar propos approach previou approach result show propos approach give predict worst case cacherel preemption delay 60 percent tighter obtain previou approach b introduct realtim system task time constraint must satisfi correct op erat guarante time constraint extens studi perform schedul analysi 1 2 3 4 5 6 mani case make number assumpt simplifi analysi one simplifi assumpt cost task preemption zero real system howev task preemption incur addit cost process interrupt 7 8 9 10 manipul task queue 7 8 10 actual perform context switch 8 10 mani direct cost address number recent studi focu practic issu relat task schedul 7 8 9 10 howev addit direct cost task preemption introduc indirect cost due cach memori use almost comput system today comput system cach memori task preempt larg number memori block 1 belong task displac cach memori time task preempt time task resum execut preempt task resum execut spend substanti amount time reload cach previous displac memori block cach reload greatli increas task execut time may invalid result schedul analysi overlook cacherel preemption cost rectifi problem recent studi address issu incorpor cacherel preemption cost schedul analysi 12 13 studi assum cach block use preempt task replac cach memori block need preempt task pessimist assumpt lead loos estim cacherel preemption delay sinc replac memori block may use preempt task exampl possibl replac memori block one longer 1 block minimum unit inform either present present cachemain memori hierarchi 11 assum without loss gener memori refer made unit block need one replac without rereferenc even preemption paper propos schedul analysi techniqu consid use cach block comput cacherel preemption delay goal reduc predict inaccuraci result pessimist assumpt propos techniqu consist two step first step perform pertask analysi comput number use cach block execut point given task use cach block execut point defin cach block contain memori block may rereferenc replac anoth memori block number use cach block execut point give upper bound cacherel preemption cost incur task preempt point result pertask analysi given tabl specifi worst case preemption cost given number preemption task tabl second step deriv worst case respons time task use linear program techniqu 14 worst case respons time equat 2 6 paper organ follow section ii survey relat work section iii describ overal approach schedul analysi consid cacherel preemption cost section iv v detail two step propos schedul analysi techniqu focus directmap instruct cach memori section vi present result experi assess effect propos approach section vii describ extens propos techniqu setassoci cach memori also data cach memori final conclud paper section viii ii relat work schedul analysi fixedprior schedul larg number schedul analysi techniqu propos within fixedprior schedul framework 2 3 4 6 liu layland 4 show rate monoton prioriti assign task shorter period given higher prioriti optim task deadlin equal period also give follow suffici condit schedul task set consist n period task c worst case execut time wcet estim period 2 condit state total util task set ie lower given util bound ie n 2 1n gamma 1 task set guarante schedul rate monoton prioriti assign later lehoczki et al develop necessari suffici condit schedul base util bound 3 anoth approach schedul analysi worst case respons time approach 2 6 approach use follow recurr equat comput worst case respons hpi set task whose prioriti higher equat term j2hpi r ec j total interfer higher prioriti task r c execut time equat solv iter iter termin r converg valu r valu compar deadlin notat use throughout paper along denot deadlin assum without loss gener higher prioriti determin schedul recent katcher et al 10 burn et al 7 8 provid methodolog incorpor cost preemption schedul analysi approach preemption cost aris interrupt handl task queue manipul contextswitch taken account schedul analysi paper also interest incorpor cost preemption schedul analysi howev unlik studi main focu indirect preemption cost due cach memori increasingli use realtim comput system b cach realtim system cach memori use almost comput system today bridg ever increas speed gap processor main memori howev due unpredict per formanc cach memori wide use realtim comput system guarante worst case perform great import unpredict perform come two sourc intratask interfer intertask interfer interfer occur memori block task conflict cach anoth block task recent consider progress analysi intratask interfer due cach memori interest reader refer 15 16 17 18 19 intertask interfer main focu paper occur memori block differ task conflict one anoth cach two way address unpredict result intertask interfer first way use cach partit cach memori divid disjoint partit one partit dedic realtim task 20 21 22 23 techniqu task allow access partit thu need consid intertask terfer two differ approach cach partit hardwarebas softwarebas hardwarebas approach extra addressmap hardwar place processor cach memori limit cach access task partit 20 21 22 hand softwarebas approach special compil linker use map task code data assign cach partit 23 cach partit improv predict system remov cacherel intertask interfer number drawback one common drawback hardwar softwarebas approach requir modif exist hardwar softwar anoth common drawback limit amount cach memori avail individu task final case hardwarebas approach extra addressmap hardwar may stretch processor cycl time affect execut time everi instruct way address unpredict result intertask interfer devis effici method analyz time effect 12 basumallick nilsen extend rate monoton analysi explain previou subsect take account intertask interfer approach wcet estim task modifi c 0 origin wcet estim comput assum task execut without preemption fl worst case preemption cost task might impos preempt task modif base pessimist assumpt cach block use preempt task replac cach memori block need preempt task approach total util given task set comput modifi wcet estim compar util bound given equat 1 determin schedul task set one drawback approach suffer pessimist util bound given equat 1 approach 0693 larg n 4 mani task set total util higher bound success schedul rate monoton prioriti assign 3 rectifi problem busquetsmataix et al 13 propos techniqu base respons time approach techniqu make pessimist assumpt cach block use preempt task replac cach memori block need preempt task assumpt lead follow equat comput worst case respons time task e theta c j cacherel preemption cost task j might impos lower prioriti task term fl j comput multipli number cach block use task j time need refil cach block util bound base respons time base approach assum cach block use preempt task replac cach memori block need preempt task pessimist assumpt lead loos estim cacherel preemption delay sinc possibl replac memori block one longer need one replac without rereferenc even lower prioriti task execut without preemption iii overal approach section overview propos schedul analysi techniqu aim minim overestim cacherel preemption delay due pessimist assumpt explain previou section purpos respons time equat augment follow propos pc r total cacherel preemption delay task r ie total cach reload time 1 r 22 2231 fig 1 exampl pc r mean pc r best explain exampl one given figur 1 exampl three task arrow figur denot point task preempt shade rectangl denot cach reload correspond task resum execut set pc 3 r 3 total cacherel preemption delay task 3 r 3 total sum cach reload time 1 2 3 r 3 correspond sum shade rectangl figur augment respons time equat solv iter follow r 0 4 r k1 r k iter procedur termin r converg r valu compar deadlin determin schedul comput pc r k iter take follow twostep approach 1 pertask analysi static analyz task determin cacherel preemption cost execut point cost task pay preempt execut point upperbound number use cach block execut point base inform inform worst case visit count execut point construct follow preemption cost tabl task preemption 1 cost tabl f k kth margin preemption cost cost task pay worst case kth preemption preemption 2 preemption delay analysi use linear program techniqu comput r k preemption cost tabl task set constraint number preemption task higher prioriti task follow two section detail two step iv pertask analysi use cach block section describ pertask analysi techniqu obtain preemption cost tabl task initi focu case directmap 3 instruct cach memori section section vii discuss extens setassoci cach memori also data cach memori exampl cacherel preemption cost consid directmap cach four cach block assum cach 3 time cach block c 0 assum follow memori block refer made 3 directmap cach memori block place exactli one cach block whose index given memori block number modulo number block cach exampl use cach block time cach block c 1 c 2 sinc contain memori block 5 6 respect rereferenc replac hand cach block c 0 c 3 use time sinc 0 3 replac 4 7 without rereferenc preemption occur time memori block 5 6 contain cach block c 1 c 2 may replac memori block interven task thu need reload cach resumpt addit time reload use cach block cacherel preemption cost time note addit cach reload time need task preempt follow explain techniqu estim number use cach block point program estim number use cach block techniqu estim number use cach block base data flow analysi 24 task program express control flow graph 4 cfg give 4 cfg node repres basic block edg repres potenti flow control basic block 25 x b cach state p use use cach block j cach block control flow p fig 2 analysi use cach block intuit idea data flow analysi consid cfg given figur 2 figur pair c denot refer memori block map cach block c cfg two incom path execut point p ie 1 2 two outgo path p ie 1 2 control flow came incom path 1 cach block c would contain memori block point p sinc last refer cach block c reach p similarli cach block c would memori block b point p control come incom path 2 thu either b may resid cach block c p depend incom path either first refer cach block c outgo path p cach block may reus thu defin use point p outgo path 2 path thu cach block c defin use p formal descript defin reach memori block rmb live memori block lmb cach block similar reach definit live variabl use tradit data flow analysi 24 set reach memori block cach block c point p denot rmb c contain possibl state cach block c point p possibl state correspond memori block may resid cach block point memori block resid cach block c first map cach block c furthermor last refer cach block execut path reach p set live memori block cach block c point p denot p defin similarli set memori block may first refer cach block c p definit use cach block point p defin cach block whose rmb lmb least one common memori block figur 2 rmb c fm b g lmb c p fm g thu cach block c defin use point p follow explain comput rmb cach block variou execut point given program initi focu rmb begin end point basic block 5 rmb point easili deriv rmb basic block boundari see later formul problem comput rmb data flow problem defin set gen c b set either null contain singl memori block null basic block refer memori block map cach block c hand basic block b least one refer memori block map c gen c b contain uniqu element memori block last refer cach block c basic block note latter case memori block gen c b one resid cach block c end basic block b also note gen c b defin manner comput local basic block exampl consid cfg given figur 3 cfg show instruct memori block refer made basic block assum instruct cach direct map two block gen c 0 b 1 fm 2 g sinc 2 memori block whose refer last refer c 0 b 1 gen c b set basic block cach block comput similarli given figur 3 gen c b defin manner rmb c begin b end b denot rmb c b rmb c b respect comput follow two equat p predecessor b b 5 gen c b gen c b null b otherwis first equat state memori block reach begin basic block deriv reach end predecessor b second equa 5 basic block sequenc consecut instruct flow control enter begin leav end without halt possibl branch except end 24 3 c 4 c 1 3 10 c fig 3 exampl gen c b tion state rmb c b equal gen c b gen c b null rmb c b otherwis 6 data flow equat solv use wellknown iter approach 24 start rmb c iter converg desir valu rmb c rmb c iter process describ procedur follow algorithm 1 find rmb cach block begin end basic block assum gen c b comput basic block b cach block c initi rmb c b rmb c bs cs basic block b cach block c begin 6 equat rewritten set kill c b set reach memori block cach block c kill basic block b set kill c b obtain follow 1 null gen c b null 2 mc gamma gen c b gen c b null mc set memori block map c program rewritten form commonli use tradit data flow analysi b b gen c b chang true chang begin chang fals basic block b cach block c begin b p predecessor b p oldout rmb c b b gen c b els rmb c b rmb c b rmb c b 6 oldout chang true indic earlier rmb point within basic block comput rmb begin basic block assum basic block follow sequenc instruct memori block refer refer process sequenti start c clear 1 cach block c 1 point follow refer conflict memori block c 1 point therefor rmb c 1 refer simpli fm 1 g howev rmb cach block b gener rmb c cach block c problem comput lmb formul similarli case rmb differ lmb problem backward data flow problem 24 set ie lmb c b comput set ie lmb c b wherea rmb problem forward data flow problem 24 set ie rmb c b comput set ie rmb c b lmb problem set gen c b either set one element correspond memori block whose refer first refer cach block c basic block b null none refer b memori block map c use gen c b defin manner follow two equat relat lmb c b lmb c b successor b b 6 gen c b gen c b null b otherwis iter algorithm similar one comput rmb use solv backward data flow problem differ algorithm start lmb c bs cs use two equat instead given equat 5 comput lmb begin end basic block lmb point comput analog case rmb differ process refer backward start end basic block rather forward start begin lmb problem lmb c refer cach block use cach block determin point comput intersect cach block rmb lmb point trivial calcul total number use cach block point simpli count use cach block point multipli total number use cach block time refil cach block worst case cacherel preemption cost point comput b deriv preemption cost tabl subsect explain construct preemption cost tabl task whose kth entri cost task pay worst case kth preemption th preemption preemption cost tabl construct two type inform 1 preemption cost point 2 worst case visit count point directli deriv cfg given program loop bound loop program construct assum worst case preemption scenario sinc predict advanc preemption actual occur worst case preemption scenario occur first preemption point largest preemption cost ie point largest number use cach block second preemption point next largest preemption cost worst case preemption scenario assum analysi safe worst case preemption scenario entri preemption cost tabl fill follow first pick point p 1 largest preemption cost fill first entri v p 1 th entri preemption cost v p 1 worst case visit count p 1 pick point second largest preemption cost perform step start v p 1 1th entri process repeat number entri preemption cost tabl exhaust assum number entri tabl k k 0 th margin preemption cost k 0 k conserv estim kth margin preemption cost sinc margin preemption cost nonincreas appli pertask analysi explain section task task set obtain follow set preemption cost tabl one task f ij jth margin preemption cost preemption 1 cost f 11 f 12 f 13 preemption 1 cost f 21 f 22 f 23 preemption 1 cost f 31 f 32 f 33 preemption 1 cost f n1 f n2 f n3 v calcul worst case preemption delay task section explain comput safe upper bound pc r k use equat 4 section iii preemption cost tabl formul problem integ linear program problem set constraint first defin g jl number invoc j preempt least l time given respons time r k exampl consid figur 4 task j invok three time given r k first invoc task j ie j1 preempt three time second third invoc j ie j2 j3 preempt definit g jl g j1 3 g j2 1 g j3 1 note sinc highest prioriti task 1 preempt fig 4 definit g jl assum know g jl valu give worst case preemption scenario among task calcul worst case cacherel preemption delay r k r k f jl lth margin preemption cost j note total cacherel preemption delay includ delay due preemption higher prioriti task r k gener howev determin exactli g jl combin give worst case preemption delay task analysi safe conserv assum scenario guarante wors actual preemption scenario conserv scenario deriv constraint valid g jl combin satisfi give number constraint g jl follow first g jl given interv r k larger number invoc j interv thu formul n j maximum number preemption singl invoc experi r k upper bound n j valu calcul a1 r j a1 r k worst case respons time higher prioriti task avail worst case respons time comput index l g jl bound n j formul second number preemption task j given interv r k larger total number invoc interv sinc arriv task prioriti higher j preempt j thu gener total number preemption given interv r k larger total number invoc interv thu na note constraint subsum previou constraint maximum valu pc r k satisfi constraint safe upper bound total cacherel preemption delay task r k problem formul integ linear program problem follow maxim r k subject constraint 1 constraint 2 na iter iter procedur explain section iii integ linear program problem solv comput pc r k applic iter procedur given appendix vi experiment result assess effect propos approach predict worst case respons time task sampl task set use propos techniqu compar predict use previou approach valid purpos predict worst case respons time also compar measur respons time target machin idt7rs383 board 20 mhz r3000 risc cpu r3010 fpa float point acceler instruct cach data cach 16 kbyte cach direct map block size 4 byte sram static ram use target machin main memori cach refil time 4 cycl although target machin timer chip provid userprogramm timer resolut low measur purpos accur measur execut respons time task built daughter board implement timer resolut one machin cycl experi also implement simpl fixedprior schedul base tick schedul explain 7 schedul manag two queue run queue delay queue run queue maintain task readi run task order prioriti delay queue maintain task wait next period task order releas time schedul invok timer interrupt occur everi 160000 machin cycl invok schedul scan delay queue task delay queue releas time invoc time schedul move run queue one newli move task higher prioriti current run task schedul perform context switch current run task highest prioriti task task complet execut place delay queue next highest prioriti task dispatch run queue take account overhead associ schedul use analysi techniqu explain 7 techniqu schedul overhead respons time r given number schedul invoc r number time schedul move task delay queue run queue r ffl c int time need servic timer interrupt 413 machin cycl exper iment set task period wcet instruct use memori block cach block unit machin cycl unit block task set specif ffl c ql time need move first task delay queue run queue 142 machin cycl experi ffl c qs time need move addit task delay queue run queue 132 machin cycl experi detail explan equat beyond scope paper interest reader refer 7 use three sampl task set experi specif given tabl first column tabl task set name second column list task task set four differ task use fft lud lm fir task fft perform fft invers fft oper array 8 float point number use cooleytukey algorithm 26 lud solv 10 simultan linear equat doolittl method lu decomposit 27 fir implement 35 point finit impuls respons fir filter 28 gener signal final lm 21 point adapt fir filter filter coeffici updat input signal 28 firdata section map noncach area lm fft lud instruct cach memori schedul schedul fig 5 code placement task set 3 tabl also give third fourth column period wcet task task set respect use measur execut time task wcet sinc tight predict task wcet accur estim cacherel preemption delay two orthogon issu measur execut time task obtain execut task without preemption execut time includ time initi task also time two context switch one context switch task task anoth task upon complet tabl also give total number instruct memori block maximum number use cach block task fifth sixth column respect experi intent place code task way caus conflict among memori block differ task although instruct cach target machin larg enough hold code use task expect case typic largescal realtim system figur 5 show code placement task set 3 furthermor sinc consid preemption delay relat instruct cach cf section vii disabl data cach map data 4449284 1365026 3113858 29600 3113778 29520 3104178 19920 3073229 unit machin cycl ii worst case respons time predict measur respons time stack segment task noncach area tabl ii show predict worst case respons time lowest prioriti task task set four differ method use predict worst case respons time task method worst case preemption cost assum cost complet refil cach c method explain 13 u method worst case preemption cost assum cost complet reload code use preempt task final p method propos paper worst case preemption cost assum cost reload maximum number use cach block tabl worst case respons time predict four method denot ra rc ru r p respect also denot delta predict worst case cacherel preemption delay method differ worst case respons time predict method without cacherel preemption cost result show propos techniqu give significantli tighter predict cacherel preemption delay previou approach result fact unlik approach propos approach consid use cach block comput cacherel preemption cost one case task set 1 propos techniqu give predict 60 tighter best previou approach 1304 cycl vs 3392 cycl howev still nontrivi differ r p measur respons time differ result number sourc first contrari pessimist assumpt use cach block task replac cach time task preempt time task resum execut replac preemption actual execut second mani actual preemption occur execut point execut point maximum number use cach block final worst case preemption scenario assum deriv upper bound cacherel preemption delay linear program techniqu occur actual execut anoth point note result cacherel preemption delay ie delta occupi small portion worst case respons time less 1 case result follow two reason first wcet task unrealist larg experi sinc disabl data cach diminish rel impact cacherel preemption delay worst case respons time second sinc target machin use sram main memori cach refil time much smaller current comput system rang 8 cycl 100 cycl dram use main memori 11 dram use instead worst case cacherel preemption delay would occupi much greater portion worst case respons time furthermor sinc speed improv processor much faster dram 11 expect worst case cacherel preemption delay occupi increasingli larg portion worst case respons time futur assess impact cacherel preemption delay worst case respons time typic set predict worst case respons time task set 1 increas cach refil time enabl data cach figur 6a b show delta deltaw orst case respons time respect new set result show cach refil time increas delta increas linearli four method result wider gap cacherel preemption delay predict method p cach refil time200000a u cach refil time05 worst case respons u b fig 6 cach refil time vs delta deltaw orst case respons time method cach refil time increas result task set deem unschedul method c u cach refil time 40 190 210 cycl respect hand task set schedul p even cach refil time 300 cycl method c u sudden jump delta cach refil time 120 cycl jump occur increas worst case respons time due increas cach refil time caus addit invoc higher prioriti task result also show cach refil time increas cacherel preemption delay take proport larger percentag worst case respons time result even method p cacherel preemption delay take 10 worst case respons time cach refil time 100 cycl method cach preemption delay take much higher percentag worst case respons time vii extens set associ cach comput number use cach block section iv consid simplest cach organ call directmap cach organ memori block place one cach block gener cach organ call nway setassoci cach organ memori block place one n block map set whose index given memori block number modulo number set cach setassoci cach organ requir polici call replac polici decid block replac make room new block among block map set least recent use lru polici replac block referenc longest time typic use purpos follow explain comput maximum number use cach block setassoci cach assum lru replac polici accord definit section iv set rmb c contain possibl state cach block c execut point p case directmap cach possibl state correspond memori block cach block c may execut point p interpret state need extend setassoci cach sinc index unit cach set rather unit cach block state cach set nway setassoci cach defin vector 1 2 1 least recent referenc block n recent referenc block follow formul problem comput rmb setassoci cach data flow analysi term directmap cach initi focu rmb begin end basic block defin set rmb c b rmb c b set possibl state cach set c begin end basic block b respect set gen c b contain state cach set c gener basic block b element n distinct memori block referenc basic block b map cach set c specif either empti none memori block map cach set c referenc basic block b singleton set whose element vector gen c vector compon gen c n b memori block whose last refer basic block b last refer cach set c b similarli compon gen c memori block whose last refer b last refer c b except refer memori block gen c n b gener gen c memori block whose last refer b last refer c b except refer memori block gen c exampl consid cach two set assum follow memori block refer made cach set 0 basic block b accord definit gen c b cach set four block ie 4way setassoci cach set gen c 0 b fm similarli cach set eight block ie 8way setassoci cach set gen c0 b fnull null null definit gen c b set rmb c b rmb c b whose element vector n memori block relat follow p predecessor b b 12 fgen c gen c gen c gen c b gen c b empti case directmap cach rmb cach set c point begin end basic block b deriv rmb c b memori block refer within basic block assum basic block follow sequenc memori block refer refer memori block map cach set c refer process sequenti start c process need follow element rmb rmb c updat rmb sinc rmb j recent referenc memori block cach set updat rmb note rmb c need updat refer refer affect state cach set set lmb c setassoci cach contain possibl refer sequenc cach set c p refer sequenc suffici inform determin block cach set c whether rereferenc replac nway setassoci cach lru replac polici inform correspond n distinct memori block referenc p reason set gen c b lmb problem defin either empti singleton set fgen c whose compon first n distinct memori block referenc basic block b map cach set c specif gen c 1 b memori block whose first refer b first refer c b gen c 2 b memori block whose first refer b first refer c b except refer memori block gen c 1 b set lmb c b lmb c b correspond set possibl refer sequenc cach set c begin end basic block b respect relat follow successor b fgen c gen c b fgen c gen c b fgen c gen c b gen c b empti lmb begin end basic block comput lmb point within basic block comput analog manner case rmb set rmb c p lmb c comput execut point p calcul maximum number use block cach set c p straightforward element rmb lmb rmb c comput number cach hit would result refer memori block lmb appli cach set state defin rmb pick element rmb yield largest number cach hit give maximum number use cach block cach set c p total number use cach block p comput sum maximum number use cach block cach set cach inform preemption cost tabl construct case directmap cach b data cach memori focus preemption cost result use instruct cach memori subsect explain extens propos techniqu need data cach memori unlik instruct refer data refer address fix compiletim exampl refer loadstor instruct use implement array access differ address data refer complic direct applic propos techniqu data cach memori sinc techniqu requir address refer basic block fix refer also complic wcet analysi task wcet analysi techniqu take conserv approach fortun conserv approach greatli simplifi adapt propos techniqu data cach memori take extend time schema approach 19 exampl follow discuss wcet analysi base extend time schema approach loadstor instruct refer one memori block call dynam loadstor instruct 29 two cach miss penalti assum refer one cach miss penalti refer may miss cach may replac use cach block analysi preemption cost result use data cach memori loadstor instruct dynam refer handl exactli way case instruct refer sinc address cfg fix also extend time schema approach assum refer dynam loadstor instruct miss cach contribut use cach block furthermor sinc approach conserv assum everi one replac use cach block deriv wcet estim complet ignor comput rmb lmb viii conclus cach memori introduc unpredict variat task execut time use realtim system preemption allow among task propos new schedul analysi techniqu take execut time variat account propos techniqu proce two step first step pertask analysi techniqu construct task tabl call preemption cost tabl tabl give given number preemption upper bound cacherel delay caus second step comput worst case respons time task use linear program techniqu take input preemption cost tabl obtain first step experiment result show propos techniqu give predict worst case cacherel preemption delay 60 tighter obtain previou approach improv predict accuraci result fact propos techniqu consid use cach block deriv worst case cacherel preemption delay number extens possibl analysi techniqu explain paper exampl pertask preemption cost inform made accur pertask analysi section iv cach block consid use use least one path mani path howev taken simultan exampl figur show exampl cach block c use flow control 1 2 hand cach block c j use flow control 2 1 two flow control compat one two cach block use one time nevertheless cach block consid use data flow analysi order rectifi problem preemption cost comput path basi initi attempt base idea describ 30 anoth interest extens propos analysi techniqu consid intersect cach block use preempt task use higher prioriti task releas former task preempt 12 13 purpos propos techniqu augment follow 1 perform data flow analysi explain section iv preempt task 2 count use cach block map intersect cach block use preempt task use higher prioriti task releas preemption although approach accur approach explain paper requir larg number analys ie one analysi preemption instanc current work approxim techniqu similar approach trade accuraci low analysi complex appendix consid task set consist three task preemption cost tabl given preemption 1 cost preemption 1 cost 6 5 4 4 3 3 2 note need preemption cost tabl highest prioriti task 1 sinc preempt worst case respons time lowest prioriti task 3 comput follow r 0 r 0 r 0 pc 3 r 0 comput solv follow integ linear program problem maxim r 0 subject constraint 1 e r 0t 3 e constraint 2 e e problem formul use fact sinc task 1 highest prioriti task preempt thu g also give n maximum number preemption singl invoc task 2 experi comput divid worst case respons time 2 period task 1 worst case respons time 2 equal 49 must comput beforehand thu avail comput worst case respons time task 3 give 2 n 3 maximum number preemption task 3 comput divid r 0 3 period task 1 2 cf equat 9 solv integ linear program problem pc 3 r 0 give r 1 3 valu use next iter comput r 2 3 obtain solv follow integ linear program problem maxim 34 theta f 34 subject constraint 1 e e constraint 2 e e solut integ linear program problem give pc 3 r 1 turn give r 2 repeat procedur r 2 r 3 thu procedur converg r 2 safe upper bound worst case respons time task 3 sinc worst case respons time smaller task 3 deadlin 400 task 3 schedul even cacherel preemption delay consid acknowledg author grate jose v busquetsmataix help suggest comment earlier version paper r result earliest deadlin schedul al gorithm find respons time realtim system rate monoton schedul algorithm exact character averag case behavior schedul algorithm multiprogram hard realtim environ dynam schedul hard realtim task realtim thread extend approach analyz fix prioriti hard realtim task effect analysi engin realtim fix prioriti schedul impact ada runtim system perform characterist schedul model account interrupt handl cost dynam prioriti task system engin analysi fix prioriti schedul comput architectur quantit approach cach issu realtim system ad instruct cach effect schedul analysi preemptiv realtim system linear nonlinear program bound worstcas instruct cach perform integr time analysi pipelin instruct cach worst case time analysi risc processor r3000r3010 case studi effici microarchitectur model path analysi realtim softwar accur worst case time analysi techniqu risc pro cessor smart strateg memori alloc realtim cach design smart strateg memori alloc real time cach design use mip r3000 alloc smart cach segment schedul softwarebas cach partit realtim applic high perform compil parallel comput dftfft convolut algorithm theori elementari numer analysi c algorithm realtim dsp effici worst case time analysi data cach calcul worst case preemption cost instruct cach tr ctr anupam datta sidharth choudhuri anupam basu use random round satisfi time constraint realtim preemptiv task proceed 2002 confer asia south pacif design automationvlsi design p705 januari 0711 2002 yudong tan vincent j mooney iii wcrt analysi uniprocessor unifi priorit cach acm sigplan notic v40 n7 juli 2005 kandemir g chen w zhang kolcu data space orient schedul embed system proceed confer design autom test europ p10416 march 0307 hiroshi nakashima masahiro konishi takashi nakada accur effici simulationbas analysi worst case interrupt delay proceed 2006 intern confer compil architectur synthesi embed system octob 2225 2006 seoul korea mahmut kandemir guilin chen localityawar process schedul embed mpsoc proceed confer design autom test europ p870875 march 0711 2005 account cacherel preemption delay dynam prioriti schedul analysi proceed confer design autom test europ april 1620 2007 nice franc hemendra singh negi tulika mitra abhik roychoudhuri accur estim cacherel preemption delay proceed 1st ieeeacmifip intern confer hardwaresoftwar codesign system synthesi octob 0103 2003 newport beach ca usa hiroyuki tomiyama nikil dutt program path analysi bound cacherel preemption delay preemptiv realtim system proceed eighth intern workshop hardwaresoftwar codesign p6771 may 2000 san diego california unit state kadayif kandemir kolcu g chen localityconsci process schedul embed system proceed tenth intern symposium hardwaresoftwar codesign may 0608 2002 est park colorado sheayun lee sang lyul min chong sang kim changgun lee minsuk lee cacheconsci limit preemptiv schedul realtim system v17 n23 p257282 nov 1999 yudong tan vincent j mooney iii time analysi preemptiv multitask realtim system cach proceed confer design autom test europ p21034 februari 1620 2004 yudong tan vincent mooney time analysi preemptiv multitask realtim system cach acm transact embed comput system tec v6 n1 februari 2007 jan staschulat rolf ernst scalabl precis cach analysi preemptiv schedul acm sigplan notic v40 n7 juli 2005 zhang chandra krintz adapt code unload resourceconstrain jvm acm sigplan notic v39 n7 juli 2004 johan strner lar asplund measur cach interfer cost preemptiv realtim system acm sigplan notic v39 n7 juli 2004 jan staschulat rolf ernst multipl process execut cach relat preemption delay analysi proceed 4th acm intern confer embed softwar septemb 2729 2004 pisa itali sungpack hong sungjoo yoo hoonsang jin kyumyung choi jeongtaek kong sookwan eo runtim distributionawar dynam voltag scale proceed 2006 ieeeacm intern confer computeraid design novemb 0509 2006 san jose california changgun lee kwangpo lee joosun hahn yangmin seo sang lyul min rhan ha seongsoo hong chang yun park minsuk lee chong sang kim bound cacherel preemption delay realtim system ieee transact softwar engin v27 n9 p805826 septemb 2001 nikil dutt alex nicolau hiroyuki tomiyama ashok halambi new direct compil technolog embed system embed tutori proceed 2001 confer asia south pacif design autom p409414 januari 2001 yokohama japan