faster simpler algorithm sort sign permut revers give quadrat time algorithm find minimum number revers need sort sign permut algorithm faster previou algorithm hannenh pevzner faster implement berman hannenh algorithm conceptu simpl requir special data structur studi also consider simplifi combinatori structur use analysi b introduct paper studi problem sort sign permut revers sign permut permut integ number also assign sign plu minu revers j transform minimum number revers need transform one permut anoth call revers distanc problem sort sign permut revers nd given sign permut sequenc revers minimum length transform ident permut 1 motiv studi problem aris molecular biolog concurr fast progress human genom project genet dna data mani model organ accumul rapidli consequ abil compar genom dierent speci grown dramat one best way check similar genom larg scale compar order appear ident gene two speci thirti dobzhanski sturtev 7 alreadi studi notion invers chromosom drosophila late eighti jerey palmer demonstr dierent speci may essenti gene gene order may dier speci take abstract perspect gene along chromosom thought point along line number identifi particular gene gene direction sign correspond direct palmer other shown dierenc order may explain small number revers 17 18 19 20 12 revers correspond evolutionari chang histori two genom numa preliminari version paper present eighth acmsiam symposium discret algorithm 13 attlab research 180 park ave florham park nj 07932 usa hklresearchattcom z depart comput scienc sackler faculti exact scienc tel aviv univers research support part grant ministri scienc art israel us depart energi grant defg0394er61913a000 shamirmathtauacil x depart comput scienc princeton univers princeton nj 08544 usa intertrust technolog corpor sunnyval ca 94086 usa research princeton univers partial support nsf grant ccr8920505 ccr9626862 oce naval research contract n0001491j1463 retcsprincetonedu ber revers ect evolutionari distanc speci henc given two permut revers distanc measur evolutionari distanc mathemat analysi genom rearrang problem initi sanko 22 21 kececioglu sanko 16 gave rst constantfactor polynomi approxim algorithm problem conjectur problem nphard bafna pevzner 3 recent christi 6 improv approxim factor addit studi reveal rich combinatori structur rearrang problem 15 14 2 9 10 quit recent caprara 5 establish sort unsign permut nphard use combinatori tool develop bafna pevzner 3 1995 hannenh pevzner 11 show problem sort sign permut revers polynomi prove dualiti theorem equat revers distanc sum three combinatori paramet see theorem 23 base theorem prove sort sign permut revers done 4 time recent berman hannenh 4 describ faster implement nd minimum sequenc revers 2 n time invers ackerman function 1 see also 23 studi give 2 algorithm sort sign permut n element therebi improv upon previou best known bound 4 fact revers distanc r algorithm requir n addit give better time bound work consider simpli algorithm combinatori structur need analysi follow basic object work implicit represent overlap graph dene later contrast interleav graph 11 4 overlap graph combinatori simpler interleav graph result easier produc represent overlap graph input maintain search revers consequ abil work overlap graph need perform pad transform work simpl permut 11 4 deal unori orient part permut separ make algorithm much simpler notion hurdl one combinatori entiti dene 11 dualiti theorem simpli handl symmetr manner search next revers much simpler requir special data structur algorithm comput connect compon simpl implement suce obtain quadrat time bound con trast 4 logarithm number connect compon comput may perform per revers use unionnd data structur paper organ follow section 2 give necessari preliminari section 3 give overview algorithm section 4 5 give detail algorithm summar result suggest research section 6 2 preliminari section give basic background primarili theori hannenh pevzner base algorithm reader may nd help refer figur 21 main denit illustr start denit unsign permut let permut ng augment permut n vertic ad pair call gap gap classi two type breakpoint otherwis adjac denot b number breakpoint revers j permut transform say revers j act gap c 45 23 fig 21 breakpoint graph b permut edg solid gray edg dash orient edg bold b b decompos two disjoint altern cycl c overlap graph ov black vertic correspond orient edg 21 breakpoint graph breakpoint graph b permut edgecolor graph n 1g join vertic j black edg gray edg j breakpoint 1 dene onetoon map u set sign permut order n set unsign permut order 2n follow let sign permut obtain u replac posit element x 2x neg element x 2x 2x 1 sign permut let note b everi vertex either isol incid exactli one black edg one gray edg therefor uniqu decomposit b cycl edg cycl altern gray black call revers j odd j even even revers revers 2i1 2j u mimic revers i1 j thu sort revers equival sort unsign permut u even revers henceforth consid latter problem revers alway mean even revers let c number cycl b figur 21a show breakpoint graph permut eight breakpoint decompos two altern cycl ie 2 two cycl shown figur 21b figur 22a show breakpoint graph seven breakpoint decompos two cycl arbitrari revers permut dene b c c revers permut clear context abbrevi b b c c bafna pevzner 3 observ follow valu taken b c depend type gap act 1 two adjac 2 2 breakpoint adjac 3 two breakpoint belong dierent cycl 4 two breakpoint cycl c gray edg 2 b exactli one c neither gray edg break c neither gray edg break c dierent path call revers proper b c 1 ie either type 4a 4b 4d say revers act gray edg e act breakpoint correspond black edg incid e gray edg orient revers act proper otherwis unori notic gray edg orient k l even exampl gray edg 0 1 graph figur 21a unori gray edg 7 22 overlap graph two interv real line overlap intersect nonempti neither properli contain graph g interv overlap graph one assign interv vertex two vertic adjac correspond interv overlap see eg 8 permut associ gray edg interv j overlap graph permut denot ov interv overlap graph gray edg b name vertex set ov set gray edg b two vertic connect interv associ gray edg overlap shall identifi vertex ov edg repres interv represent thu endpoint gray edg actual endpoint interv repres correspond vertex ov note endpoint interv represent distinct integ connect compon ov contain orient edg call orient compon otherwis call unori compon figur 21c show interv overlap graph one orient compon figur 22b show overlap graph permut two connect compon one orient unori 45 fig 22 breakpoint graph obtain figur 21 revers 7 10 equival revers dene gray edg 2 3 b overlap graph 0 23 connect compon overlap graph let x set gray edg b dene xg equival one look interv overlap represent ov mention dene span set vertic x minimum interv contain interv vertic x major object algorithm work ov though ecienc consider avoid gener explicitli contrast pevzner han nenhal work interleav graph h whose vertic altern cycl b two cycl c 1 c 2 connect edg h exist gray edg e 1 2 c 1 gray edg e 2 2 c 2 overlap follow lemma corollari impli partit impos connect compon ov set gray edg ident one impos connect compon h lemma 21 set gray edg b correspond connect compon ov minm even maxm odd proof assum minm odd must spanm ie exist l 1 spanm l 1 1 thu minm neither maximum minimum element set f spanmg henc either maximum element minimum element spanm j minm j maxm denit b must gray edg contradict fact connect compon ov proof maxm odd similar illustr lemma 21 consid figur 22a let 10 15 corollari 22 everi connect compon ov correspond set gray edg union cycl proof assum contradict c cycl whose gray edg belong least two connect compon ov assum 1 2 two compon two consecut gray edg along c sinc span dierent connect compon ov overlap two dierent case consid 1 e 1 e 2 dierent compon overlap thu either right endpoint e 2 even equal maxm 2 left endpoint e 2 odd case contradict lemma 21 2 disjoint interv wlog assum maxm 1 right endpoint e 1 even equal maxm 1 contradict lemma 21 note particular corollari 22 impli overlap graph contain isol vertic 24 hurdl let 1 subsequ 0 consist element incid gray edg occur unori compon ov order 1 circl cr j let unori connect compon g set endpoint edg unori compon hurdl element em occur consecut cr denit hurdl dierent one given hannenh pevzner 11 simpler sens minim hurdl maxim one treat dierent way use corollari 22 one prove hurdl dene ident one dene hannenh pevzner let h denot number hurdl permut hurdl simpl one delet ov unori compon becom hurdl super hurdl otherwis fortress permut odd number hurdl super hurdl follow theorem prove hannenh pevzner theorem 23 11 minimum number revers requir sort permut b c h unless fortress case exactli one addit revers necessari sucient 3 overview algorithm denot revers distanc ie fortress follow theori develop 11 turn given permut h 0 one perform permut 0 h 0 ov unori compon algorithm rst nd revers transform 0 orient compon method clear hurdl use theori develop hannenh pevzner section 5 describ ecient implement process use implicit represent overlap graph ov implement run time assum ov alreadi partit connect compon recent berman hannenh 4 gave onn algorithm comput connect compon interv overlap graph given implicitli represent use algorithm clear hurdl permut onn time overlap graph 0 ov 0 orient compon section 4 prove neighborhood orient gray edg e orient gray could e revers act e 1 creat new hurdl call revers safe revers develop ecient algorithm locat safe revers permut least one orient gray edg algorithm use implicit represent overlap graph run time second stage algorithm repeatedli nd safe revers perform long ov empti clearli overal complex n r number revers requir sort 0 31 repres overlap graph assum input given sequenc n sign integ repres 0 first permut construct describ section 21 store array also construct array repres 1 straightforward verifi two array determin element whether left right endpoint gray edg constant time case element endpoint gray edg also nd endpoint check whether edg orient constant time thu array 1 compris represent ov algorithm maintain two array carri revers nd time updat array proport length interv revers shall give highlevel present algorithm use primit like scan orient gray edg increas left endpoint order easi see implement primit use array 1 shall omit detail easi produc list interv represent ov sort either left right endpoint array 1 also possibl maintain without increas asymptot time bound algorithm practic may faster maintain list instead addit 4 elimin orient compon first introduc notat recal vertic ov gray edg b order avoid confus usual refer vertic ov henc vertex ov orient correspond gray edg orient unori otherwis let e vertex ov denot revers act gray edg correspond e denot ne set neighbor e ov includ e denot one subset ne contain orient vertic une subset ne contain unori vertic section prove orient vertex e exist ov exist orient vertex f 2 one rf proper safe also describ algorithm nd proper safe revers permut contain least one orient edg start follow use observ observ 41 let e vertex ov let obtain ov follow oper 1 complement graph induc ov ne feg ip orient everi vertex ne feg 2 e orient ov remov ov 3 exist orient edg e 0 ov note e orient vertex compon ov feg may split sever compon ov 0 compar gure 21c 22b denot compon 0 k e k 1 refer 0 simpli whenev e clear context let c cliqu orient vertic ov say c happi everi orient vertex e 62 c everi vertex f 2 c e f 2 eov exist orient vertex g 62 c g e 2 eov g f 62 eov exampl overlap graph shown figur 21c f2 3 10 11g f6 7g happi cliqu f2 3 10 11 8 9g rst theorem claim one vertic happi cliqu dene safe proper revers theorem 41 let c happi cliqu let e vertex c everi e 0 2 c revers safe proof let assum contradict 0 e unori assum exist 2 ne 0 62 c clearli must orient ov sinc c happi must also orient neighbor 0 adjac e ov stay orient adjac ov 0 contradict assumpt 0 unori henc may assum ne 0 let z 2 une vertex z orient ov 0 adjac ov 0 obtain contradict henc z adjac must adjac ov henc obtain une uni ov corollari 22 impli compon 0 contain alon thu must neighbor x 0 x adjac e ov thu obtain x 2 ov x e 62 ov x unori ov sinc alreadi prove une uni impli une uni contradict choic e exampl theorem 41 impli revers dene gray edg 10 11 safe proper revers permut figur 21 sinc correspond vertex maximum unori degre happi cliqu 11g hand revers dene 2 creat new unori compon yield permut shown figur 22 follow theorem prove happi cliqu exist neighborhood orient edg theorem 42 let e orient vertex ov exist orient vertex f 2 one compon ov 0 orient proof theorem 41 suce show exist happi cliqu c one exist 2 onx 62 oneg ext contain orient neighbor e orient neighbor outsid one case 1 case 2 ext one feg let cliqu let k j maxim cliqu j dene nal cliqu set straightforward verifi two case c inde happi cliqu next section describ algorithm nd orient edg e safe given represent ov describ section 31 algorithm rst nd happi cliqu c search vertex maximum unori degre c accord theorem 41 vertex dene safe revers even though theorem 42 guarante exist happi cliqu neighborhood xed orient vertex algorithm search one particular neighborhood prove algorithm guarante nd happi cliqu assum exist least one orient edg therefor algorithm provid altern proof weaker version theorem 42 claim exist happi cliqu somewher graph 41 find happi cliqu section give algorithm locat happi cliqu ov let e orient vertic ov increas left endpoint order algorithm travers orient vertic ov accord order let le left right endpoint respect vertex e realiz ov travers e algorithm maintain happi cliqu c subgraph ov induc vertic assum jc vertic c vertic c maintain link list order increas left endpoint order exist interv contain interv c algorithm maintain minim interv cliqu c vertex exist satisfi follow invari invari 41 everi vertex e l 62 c l le 1 must adjac ie adjac vertex c either adjac interv e p p le adjac fact c happi subgraph induc e invari initi algorithm set c g initi 1 dene let current interv e i1 j guarante happi ov sinc remain orient vertic adjac c henc algorithm stop return c answer see figur 41a assum le i1 show obtain c i1 i1 consid follow case case 1 interv dene figur 41b case 2 interv dene i1 obtain ad e i1 c figur 41c cliqu c i1 consist e i1 alon figur 41d c previou case c g case i1 set e j last interv c see figur 41e follow theorem prove algorithm produc happi cliqu theorem 43 let c l current cliqu algorithm stop c l happi cliqu ov proof straightforward induct number orient vertic travers algorithm prove c l l satisfi invari 41 algorithm stop either l equal number orient vertic either case sinc c l happi subgraph induc e must happi ov run time algorithm proport number orient vertic travers sinc constant amount work perform vertex 42 search happi cliqu locat happi cliqu c ov need search vertex maximum number unori neighbor section give algorithm perform task e c fig 41 variou case algorithm nding happi cliqu topmost interv alway three thick interv compris c dot interv correspond e i1 interv c order increas left endpoint order clearli rj thu endpoint j vertic c partit line 2j 1 algorithm consist follow three stage stage 1 let e unori vertex nonempti intersect interv l1 rj mark es endpoint index interv contain stage 2 let array j counter correspond vertex c intent assign valu sum p l oi unori degre vertex e l 2 c counter initi zero unori vertex e overlap interv l1 rj chang four counter follow let l r interv le occur respect may assum l r otherwis e adjac vertex c ignor continu accord one follow case case 1 r j vertic e l1 e r adjac e increment ol decrement case 2 j l vertic e l j1 e r j adjac e increment decrement case 3 l j j r let vertic e 1 e adjac e increment o1 decrement om vertic e l1 e j adjac e increment counter ol stage 3 comput jg return e f follow theorem summar result section omit proof straightforward theorem 44 given cliqu c vertex e f 2 c comput algorithm maximum unori degre among vertic c complex algorithm proport size c plu number unori vertic ov henc 5 clear hurdl case unori compon ov exist sequenc r revers transform 0 dh2e section summar character given hannenh pevzner revers outlin nd use implicit represent ov use follow denit revers merg hurdl h 1 h 2 act two breakpoint one incid gray edg h 1 incid gray edg h 2 recal circl cr dene section 2 endpoint edg unori compon ov order consist order two hurdl h 1 h 2 consecut set endpoint occur consecut cr ie hurdl h eh separ eh 1 eh 2 cr follow lemma essenti prove hannenh pevzner though state dierent paper lemma 51 11 let permut even number say 2k hurdl sequenc k 1 revers merg two nonconsecut hurdl follow revers merg remain two hurdl transform 0 orient compon lemma 52 11 let permut odd number say 2k hurdl least one hurdl h simpl revers act two breakpoint incid edg h transform 0 2k hurdl 1 fortress sequenc k 1 revers merg pair nonconsecut hurdl follow two addit merg pair consecut hurdl one merg two origin hurdl next merg hurdl creat rst last origin hurdl transform 0 0 orient compon outlin turn lemma algorithm nd particular sequenc revers r properti describ first ov decompos connect compon describ 4 one identifi unori compon hurdl task done travers endpoint circl cr count number element run consecut endpoint belong compon run contain endpoint particular unori compon hurdl similar fashion one check hurdl whether simpl hurdl super hurdl travers cycl list hurdl order occur cr creat next stage list use identifi correct hurdl merg assum given endpoint one locat connect compon constant time easi verifi data maintain possibl theorem 53 given ov decompos connect compon algorithm outlin nd revers appli obtain 0 hurdlefre algorithm implement run time proof correct follow lemma 51 52 time bound achiev alway merg hurdl separ singl hurdl ith merg merg hurdl h 1 h 2 separ h h merg 1st merg carri merg way guarante span hurdl h overlap two merg revers second elimin h 6 summari figur 61 give schemat descript algorithm algorithm sign revers sign permut 1 comput connect compon ov 2 clear hurdl 3 sort iter begin nd happi cliqu c ov b nd vertex e f 2 c maximum unori degre perform safe revers e f c updat represent ov 4 output sequenc revers fig 61 algorithm sort sign permut theorem 61 algorithm sign revers nd revers distanc r n time particular 2 time proof correct algorithm follow theorem 23 theorem 41 lemma 51 52 algorithm berman hannenh 4 take time theorem 53 step 3 take time per revers discuss section 4 intrigu open question whether faster algorithm sort sign permut revers exist certainli might case one nd optim sequenc revers faster date nontrivi lower bound known problem acknowledg thank donald knuth sridhar hannenh pavel pevzner itsik peer comment preliminari version paper r zum hilbertshen aufbau der reelen zahlen sort permut transposit siam journal comput fast sort revers dicult invers chromosom drosophila pseu doobscura algorithm graph theori perfect graph polynomi algorithm comput transloc distanc genom transform men mice polynomi algorithm genom distanc problem transform cabbag turnip polynomi algorithm sort sign permut revers includ parallel invers faster simpler algorithm sort sign permut revers physic map chromosom use uniqu probe tricircular mitochondri genom brassica raphanu revers repeat con evolutionalri signi edit distanc genom comparison base nonloc oper genom diverg gene rearrang tr ctr tannier ann bergeron mariefr sagot advanc sort revers discret appli mathemat v155 n67 p881888 april 2007 ann bergeron elementari present hannenhallipevzn theori discret appli mathemat v146 n2 p134145 1 march 2005 glenn tesler effici algorithm multichromosom genom rearrang journal comput system scienc v65 n3 p587609 novemb 2002 adam c siepel algorithm enumer sort revers proceed sixth annual intern confer comput biolog p281290 april 1821 2002 washington dc usa max alekseyev pavel pevzner color de bruijn graph genom halv problem ieeeacm transact comput biolog bioinformat tcbb v4 n1 p98107 januari 2007 haim kaplan elad verbin sort sign permut revers revisit journal comput system scienc v70 n3 p321341 may 2005 isaac elia tzvika hartman 1375approxim algorithm sort transposit ieeeacm transact comput biolog bioinformat tcbb v3 n4 p369379 octob 2006 severin berard ann bergeron cedric chauv christoph paul perfect sort revers alway difficult ieeeacm transact comput biolog bioinformat tcbb v4 n1 p416 januari 2007