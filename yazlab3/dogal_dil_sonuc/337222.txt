lightweight context recoveri effici accur program analys comput accur inform effici program use pointer variabl program analysi must account fact procedur may access differ set memori locat procedur invok differ callsit paper present lightweight context recoveri techniqu effici determin whether memori locat access procedur specif callsit paper also present techniqu use inform improv precis effici program analys empir studi show 1 lightweight context recoveri quit precis identifi memori locat access procedur specif callsit 2 distinguish memori locat access procedur differ callsit significantli improv precis effici program analys program use pointer variabl b introduct softwar develop test mainten activ import expens thu research investig way provid softwar tool improv ecienc thu reduc cost activ mani tool requir program analys extract inform program exam ple tool debug program understand impact analysi use program slice eg 5 6 15 focu attent part softwar influenc particular statement support softwar engin tool eectiv program analysi must sucient ecient tool reason respons time accept throughput program analysi must sucient precis use inform hidden within spuriou inform 1 int x 2 fint p 3 4 5 f1int q 6 int 7 fz 8 fq 9 10 int 11 main 12 int 13 14 15 f1i 17 printfdw 18 figur 1 exampl program mani program analys eectiv comput program inform program use pointer variabl howev appli techniqu program use pointer variabl sever issu must consid first program use pointer vari abl two dierent name may refer memori locat program point exampl program figur 1 pointer derefer p variabl name refer memori locat statement 3 phenomenon call alias must consid comput safe program format exampl without consid eect alias program analysi would ignor fact referenc p statement 3 thu conclud incorrectli procedur f modifi second program use pointer variabl procedur access dierent memori locat pointer derefer procedur invok dierent callsit exampl f access x call statement 8 access w x call statement 16 program analysi distinguish memori locat access procedur context specif callsit might comput spuriou program inform callsit exampl program analysi might report z w modifi f f call statement 8 furthermor program analysi propag spuriou program inform throughout program unnecessarili ineci mani exist techniqu eg 2 8 12 14 comput safe program inform account eect alias analysi howev techniqu eg 8 12 distinguish memori locat access procedur context specif callsit techniqu use condit analysi attach condit inform gener program analysi exampl p refer w statement 3 figur 1 p alias w entri f thu program analysi report w modifi statement 3 condit determin whether w modifi f statement 8 execut program analysi determin whether p alias w entri f check alia inform statement 8 q alias w statement 8 p alias w entri f f invok statement 8 thu program analysi report w modifi statement 8 execut although techniqu use condit analysi distinguish memori locat access procedur specif callsit thu avoid comput spuriou program inform ineci first requir condit alia inform current provid expens aliasanalysi algorithm eg 7 second increas cost comput program inform exampl without use condit analysi complex comput interprocedur reach definit 2 v n size program v number name refer memori locat wherea use condit analysi complex comput accur program inform without use expens condit alia inform ad complex program analysi develop new approach two part first examin way memori locat access proce dure ecient identifi set memori locat access procedur specif callsit second use set memori locat reduc spuriou inform propag procedur callsit callsit procedur ecient identifi memori locat access procedur specif callsit develop techniqu lightweight context recoveri techniqu base observ context callsit formal paramet procedur typic point set memori loca tion throughout procedur actual paramet bound formal paramet pointer given memori locat access exclus pointer derefer formal paramet memori locat access procedur specif callsit memori locat access callsit pointer derefer actual paramet bound observ allow techniqu identifi memori locat access procedur specif callsit reduc spuriou inform propag across procedur boundari program analys also develop techniqu use inform memori locat comput lightweight context coveri callsit program inform memori locat identifi access call procedur need propag callsit call procedur call procedur callsit thu techniqu improv precis ecienc program analys paper present new first present lightweight context recoveri algorithm section 2 illustr use interprocedur slice 15 techniqu use inform provid lightweight context recoveri improv program analys section 3 main benefit approach ecient use alia inform provid ecient alia analysi algorithm liang harrold 9 andersen 1 lightweight context recoveri almost ecient modif side eect analysi use inform provid lightweight context recoveri program analysi add littl cost program analysi second benefit approach mani case identifi larg number memori locat whose inform need propag specif callsit thu provid signific improv precis ecienc program analysi third benefit approach orthogon mani techniqu improv ecienc program analys thu use techniqu improv ecienc program analys paper also present set empir studi investig eectiv use lightweight context recoveri improv ecienc precis program analys section 4 studi show number interest result mani program studi lightweight context recoveri algorithm comput rel littl increas cost significantli smaller number memori locat modifi callsit comput tradit modif side eect analysi algorithm sever program use alia inform provid liang harrold algorithm 9 andersen algorithm 1 lightweight context recoveri algorithm report almost modif sideeect callsit landi ryder zhang algorithm 8 must use condit alia inform use inform provid lightweight context recoveri reduc size slice comput use reusedriven slice algorithm 5 time requir comput slice section first give definit present lightweight context recoveri algorithm definit memori locat program referenc object name object name consist variabl possibl empti sequenc derefer field ac cess object name contain derefer object name direct object name otherwis object name indirect object name exampl xf direct object name wherea p indirect object name direct object name obj repres memori locat refer lobj say object name n 1 extens object name construct appli possibl empti sequenc derefer field access n 2 case denot n 1 en 2 refer n 2 prefix n 1 empti n 1 proper extens n 2 n 2 proper prefix n 1 n formal paramet actual paramet bound n callsit c defin function c e n return object name ea exampl suppos r pointer point struct field f e r r e f r rf r proper prefix r r formal paramet function f q actual paramet bound r callsit c f c e f r qf given object name obj statement alia analysi determin set memori locat may alias obj refer set obj access set denot set asetobj exampl figur 1 asetp landi ryder algorithm 7 use given memori locat loc procedur p name set loc p contain object name use refer loc p exampl name set f figur 1 p memori locat loc support object name obj statement valu loc may use resolv derefer obj ex ampl suppos q point r r point x statement r support q lightweight context recoveri identifi memori locat access procedur p specif callsit lightweight context recoveri consid nonloc memori locat p name set nonloc memori locat loc contain direct object name techniqu report loc access callsit p name set loc contain singl indirect object name techniqu comput addit inform determin whether loc access specif callsit p case ecienc techniqu assum loc access callsit p suppos indirect object name obj object name name set nonloc memori locat loc procedur p loc referenc p must referenc obj none memori locat support obj statement p modifi p p execut obj refer memori locat point p case obj extens formal paramet p call callsit c obj must refer memori locat one referenc c obj c thu loc referenc p c loc must referenc c obj c program analysi must propag inform loc p c c obj alias loc c properti memori locat give us opportun avoid propag ie filter spuriou inform inform propag procedur callsit program analys say loc properti p loc elig filter callsit p say loc candid precis loc candid p follow condit hold condit 1 loc name set p contain singl indirect name obj condit 2 obj proper extens formal paramet p condit 3 memori locat support obj statement p modifi p exampl figur 1 name set w f contain p proper extens formal paramet p valu p chang f thu w candid f 16 p w need propag inform w f statement 16 howev 7 p z need propag inform w f statement 7 lightweight context recoveri process procedur revers topolog bottomup order call graph 1 identifi memori locat candid procedur figur 2 show algorithm contextrecoveri perform process nonloc memori locat loc referenc procedur contextrecoveri comput mark markp loc whose valu unmark u elig inelig default markp loc initi u loc candid p markp loc case obj object name loc name set contextrecoveri store obj objp loc loc candid p markp loc objp loc contextrecoveri also set modp loc true loc modifi statement p check whether memori locat support object name modifi p contextrecoveri examin way loc access p call updat variou point eg line 5 algorithm contextrecoveryp input p program global markp map memori locat procedur p mark whether memori locat modifi memori locat object name declar list procedur sort revers topolog order begin contextrecoveri 1 foreach procedur p intraprocedur phase 2 foreach statement p 3 foreach object name obj 4 obj direct 5 updatep lobjf 6 els 7 foreach memori locat loc asetobj 8 updatep loctobj 9 endfor 10 endif 11 endfor 12 set modp memori locat modifi 13 endfor 14 add p w 15 endfor 16 w interprocedur phase 17 take first procedur p w 18 foreach callsit c r p 19 foreach nonloc memori loc referenc r 20 markr loc 21 updatep locf 22 elseif locasetac objr loc c 23 ac objr loc indirect 24 updatep loctac objr loc 25 els 26 updatep locf 27 endif 28 endif 29 updat modp loc 30 endfor 31 endfor 32 valid object name objp modp 33 markp modp updat add p caller w 34 endwhil contextrecoveri procedur updateqlmo input q procedur l memori locat boolean object name global markq mark memori locat q array object name begin updat 36 markq l objq l 38 extens formal 39 markq l objq l 40 els 41 markq l objq l 42 endif 43 elseif markq 44 oobjq l 45 markq l objq l 47 endif updat figur 2 algorithm identifi candid memori locat comput markp loc objp loc updat input procedur q memori locat l boolean flag object name contextrecoveri detect memori locat access statement p memori locat access indirect object name algorithm call updat true otherwis memori locat access indirect object name algorithm call updat f fals updat set valu markq l objq l accord current valu markq l f l candid q condit 1 violat thu markq l updat objq l updat line 36 current valu markq l u updat check see whether extens formal paramet q line 3738 l candid accord inform avail point computa tion thu markq l updat objq l updat otherwis l candid condit 2 violat thu markq l updat objq l updat line 41 markq l updat check whether objq l line 4344 l access q one object name violat condit 1 thu l candid markq l updat objq l updat line 45 case markq l objq l remain unchang contextrecoveri comput mark obj mod use intraprocedur phase interprocedur phase intraprocedur phase contextrecoveri process object name appear statement procedur p line 213 object name obj direct contextrecoveri call updatep lobjf line 45 obj indirect memori locat loc asetobj contextrecoveri call line 79 memori locat l modifi contextrecoveri also set modp l true line 12 exampl contextrecoveri process statement 3 f figur 1 check p p indirect name asetp thu algorithm call updatefytp updatefztp updatefwtp contextrecoveri also check x statement 3 x direct name contextrecoveri call updatef xf f process mark f obj f follow valu mark f mark f mark f interprocedur phase contextrecoveri process callsit c procedur r procedur p line 1634 use worklist w nonloc memori locat loc referenc r contextrecoveri check markr loc line 20 markr loc contextrecoveri assum loc access r callsit r includ c thu contextrecoveri call updatep locf indic loc access r c unknown way line 21 otherwis markr loc contextrecoveri check whether loc aseta c objr loc c line 22 loc loc referenc r c object name c objr loc context recoveri call updatep locta c objr loc c objr loc indirect call updatep locf c objr loc direct line 2327 loc loc referenc r c contextrecoveri noth case interprocedur phase memori locat loc process modr loc true modp loc also set true line 29 exampl contextrecoveri process callsit f statement 8 figur 1 first check x mark f x thu algorithm call updatef1xf algorithm check mark f algorithm check whether thu algorithm call updatef1ytq algorithm final check z w noth z w asetq 8 valu mark f1 obj f1 chang mark f1 mark f1 mark f1 mark f1 statement 8 process interprocedur phase contextrecoveri also valid indirect object name appear objp make sure memori locat support indirect name p modifi p line 32 suppos indirect name obj assign objp loc memori locat l support obj statement p modp l true loc inelig condit 3 vi olat thu contextrecoveri updat markp loc objp loc contextrecoveri process p interprocedur phase modp markp updat algorithm put p caller w line 33 contextrecoveri continu w becom empti tabl 1 show result comput contextrecoveri exampl program figur 1 mark obj mod mark f mark f mark f mark f mark f1 mark f1 markmain markmain tabl 1 mark obj mod exampl program given n size program complex contextrecoveri 2 absenc recurs 3 presenc recurs complex contextrecoveri algorithm comput modif side eect procedur improv slice section show inform comput use contextrecoveri improv interprocedur slice program analys comput interprocedur reach definit construct system depend graph improv similar way interprocedur slice program slice techniqu identifi statement program aect valu variabl v statement v call slice criterion 15 program slice use support task debug regress test revers engin one approach program slice first comput data control depend among statement build systemdepend graph comput slice solv graphreach problem graph 6 approach one use reusedriven interprocedur slice algorithm 5 use precomput controldepend inform comput datadepend inform demand use controlflow graph 2 cfg procedur use reusedriven slice algorithm exampl show program analysi improv use inform provid lightweight context recoveri reusedriven slicer comput interprocedur slice criterion v invok partial slicer procedur program reusedriven slicer first invok partial slicer p procedur contain identifi subset statement p procedur call p subset input p may aect v refer v partial slice standard use partial slicer denot v refer subset statement identifi partial slicer partial slice respect v also refer subset input identifi partial slicer relev input respect v p main function program statement procedur call p might also aect slice criterion v relev input v therefor p process callsit c call p reusedriven slicer bind relev input f back c creat new partial slice standard c given bound f c reusedriven slicer invok partial slicer c identifi statement p c includ slice algorithm continu addit partial slice standard gener algorithm return union partial slice comput partial slicer program slice v figur 3 show call graph program figur 15x 16x f main figur 3 call graph annot partial slice standard 3 x solid line show graph edg dot line show relationship among partial slice standard 1 graph annot partial slice standard creat reusedriven slicer comput slice 3 x reusedriven slicer first invok partial slicer f respect 3 x partial slicer comput partial slice 3 relev input set x f process reusedriven slicer creat new partial slice standard 7 x 8 x callsit f f1 partial slice standard 16 x callsit f main invok partial slicer standard partial slicer comput relev input set x 7 x 8 x partial slicer finish process 7 x 8 x reusedriven slicer creat partial slice standard 15 x callsit f1 main invok partial slicer standard result slice 3 x 3 7 8 13 15 16 union partial slice comput process partial slicer comput partial slice standard v propag memori locat backward throughout p use p cfg node n cfg p partial slicer comput two set memori locat n entri n n exit n n comput use n inform n n comput union set n cfg successor partial slicer iter comput node fix point reach formal paramet nonloc memori locat p entri relev input respect v n callsit partial slicer comput consid n memori locat whose valu modifi use n memori locat n modifi n n statement n control depend ad slice n callsit procedur q partial slicer must process q comput n identifi statement q inclus partial slice figur 4 show processcal procedur process callsit c q processcal use cach store partial slice relev input partial slice standard creat reusedriven slicer memori locat u c processcal bind u u line 2 u modifi q proce procedur processcallc inout input c call node call q set c output set c global cach v pair pslice relinput previous comput computepslic v begin processcal 1 foreach u 2 3 u modifi q pocedur call q 4 5 els 6 cacheqexit u null 7 cacheqexit 8 endif 9 add cacheqexit u pslice slice 11 endif 12 endfor figur 4 procedur process callsit use cach dure call q processcal simpli add u c line 34 otherwis processcal creat partial slice standard qexit u qexit exit q processcal check cach qexit u line 6 cach contain inform qexit u processcal invok computepslic qexit u store partial slice relev input return computepslic cach line 7 processcal merg partial slice program slice line 9 call backbind show bind relev input back c add c line 10 c process statement includ slice c statement c control depend ad slice exampl comput slice 17 w slicer first propag w statement 17 16 statement 16 callsit slicer propag w f creat new partial slice standard 4 w slicer invok partial slicer 4 w comput partial slice 3 relev input xyzwp slicer bind x z w p back statement 16 put xyz w in16 slicer keep process add statement 3 6 7 17 slice interprocedur slice use inform provid lightweight context recoveri precis ecienc reusedriven slicer improv identifi set memori locat modifi procedur specif callsit slicer propag memori locat callsit call procedur first check whether memori locat modifi procedur callsit memori locat modifi procedur callsit reusedriven slicer propag memori locat call procedur similarli precis ecienc reusedriven slicer improv identifi set memori loca procedur processcallc inout input c call node call q set c output set c global cach v pair pslice relinput previous comput computepslic v begin processcal 1 foreach u 2 u modifi q c 3 4 els 5 7 cacheqexit 8 endif 9 add cacheqexit u pslice slice 11 endif 12 endfor function backbindev ar c p input ev ar memori locat reach entri p c call node call p output memori locat callsit begin backbind 13 foreach memori locat l ev ar 14 l formal paramet 15 add memori locat bound l c calleev ar 16 elseif l referenc p c old 16 els 17 add l calleev ar 18 enif 19 endfor 20 return calleev ar backbind figur 5 processcal modifi backbind tion referenc procedur specif callsit slicer propag call procedur callsit memori locat referenc callsit improv reduc spuriou inform propag across procedur boundari thu improv precis effici reusedriven slicer exampl consid action reusedriven slicer 17 w figur 1 two improv describ made improv slicer first propag w statement 17 statement 16 modifi w invok statement 16 improv slicer propag w statement 16 f creat partial slice standard 4 w improv slicer invok partial slicer 4 w add statement 3 partial slice identifi x z w p relev input improv slicer check statement 16 find x w referenc f invok statement 16 thu add x w in16 improv slicer propag x w 15 f1 modifi neither x w invok statement 15 improv slicer propag x w directli in15 without propag f1 improv slicer continu add statement 3 12 13 16 17 slice exampl show use specif callsit inform help reusedriven slicer comput precis slice modifi processcal figur 4 use set memori locat modifi procedur specif callsit reduc spuriou inform propag callsit call procedur figur 5 show modifi processcal line 25 replac line 25 origin version u c new processcal first check whether u modifi q c line 2 u modifi q c new processcal add u c line 3 u modifi q c new processcal bind u u q creat partial slice standard qexit u continu comput usual way line 510 u modifi q c impli u modifi q new processcal need check u also modifi backbind use set memori locat referenc procedur specif callsit reduc spuriou inform propag procedur callsit figur 5 show modifi backbind line 16 chang backbind check memori locat l input ev ar line 13 l formal paramet backbind add memori locat bound l c calleev ar line 1415 otherwis new backbind check whether l referenc p invok c line 16 backbind put l calleev ar line 17 final backbind return calleev ar line 20 use markp objp modp comput contextrecoveri determin memori locat modifi p callsit c 3 nonloc memori locat loc p modp loc true markp loc loc may modifi p callsit p includ c modp loc true markp loc loc loc modifi p c otherwis loc modifi p c exampl accord result tabl 1 mark f thu f modifi f invok statement 8 figur contain howev f modifi f invok statement 16 aseta ie asetw 16 contain use similar approach determin memori locat referenc p p invok c memori locat loc markp loc loc referenc p c markp loc objp loc obj loc aseta c obj c loc referenc p c otherwis loc referenc p c 3 also use condit alia inform determin memori locat may modifi p c howev approach might expens larg program perform sever studi evalu eectiv ness use lightweight context recoveri improv precis ecienc program analys implement contextrecoveri reusedriven slice algorithm use inform provid contextrecoveri use prolang analysi framework paf 3 studi compar result comput alia inform provid liang harrold algorithm lh 9 andersen algorithm 1 4 gather data studi sun ultra30 workstat 640mb physic memori 1gb virtual memori 5 left side tabl 2 give inform subject program cfg lh program node loc ci cr ci cr loader 819 1132 007 011 008 011 dixi 1357 2100 012 019 011 017 learn 1596 1600 011 02 011 017 assembl 1993 2510 026 035 023 034 smail simul 2992 3558 047 059 049 057 arc 3955 7325 038 077 038 068 space 5601 11474 148 162 186 191 larn 11796 9966 218 285 211 284 espresso 15351 12864 734 881 862 1525 moria 20316 25002 2929 3898 2249 2479 twmc 22167 23922 298 469 353 796 tabl 2 inform subject program left time second contextinsensit modif side effect analysi ci contextrecoveri cr right goal studi 1 evalu ecienc algorithm cr compar time requir run cr program time requir comput modif sideeect procedur program contextinsensit algorithm ci make comparison 1 time comput modif sideeect rel small compar time requir mani program analys 2 algorithm use instead ci comput precis modif sideeect requir mani program analys right side tabl 2 show result comput use alia inform provid lh algorithm algorithm tabl see subject studi cr almost ecient ci suggest time ad algorithm might neglig mani program analys goal studi 2 evalu precis algorithm identifi memori locat modifi procedur specif callsit mod 4 see 9 detail comparison two algorithm 5 simul eect librari function use new stub greater detail data report studi subject program dier report previou work figur averag size mod callsit callsit compar size mod callsit comput tradit contextinsensit modif sideeect analysi algorithm cimod al gorithm algorithm reduct size mod callsit indic eectiv techniqu filter spuriou inform call site also compar result comput algorithm result comput landi ryder zhang modif side eect analysi algorithm lrz algorithm 8 use condit anali si result comput lrz algorithm view lower bound algorithm use implement cimod algorithm algorithm use implement lrz algorithm provid paf figur 6 show result studi graph total length bar indic either lh repres averag size mod callsit comput cimod algorithm use alia inform provid algorithm lh al gorithm bar length slant segment repres averag size mod callsit comput algorithm use alia inform provid correspond alia analysi algorithm ex ampl use alia inform provid algorithm cimod algorithm report callsit modifi 29 memori locat space use alia inform howev algorithm report callsit modifi 42 memori locat graph show subject program stud i algorithm comput significantli precis mod callsit cimod algorithm thu expect use inform provid algorithm significantli reduc spuriou inform propag across procedur boundari figur 6 also show averag size mod callsit comput lrz algorithm 6 graph length bar indic lrz repres averag size mod callsit comput lrz algorithm exampl lrz algorithm report callsit space modifi 5 memori locat note algorithm use alia inform comput landi ryder algorithm 7 treat structur way field case algorithm report larger mod callsit algorithm space graph show sever program studi size mod callsit comput algorithm close comput lrz algorithm result suggest algorithm quit precis identifi memori locat may modifi procedur specif callsit graph also show precis mod callsit comput algorithm vari dierent program suggest eectiv ness improv program analys use inform provid algorithm might depend program written studi 3 goal studi 3 evalu eectiv use inform provid lightweight context recoveri improv precis ecienc reusedriven slice algorithm compar size slice time comput slice without use inform provid lightweight context recoveri tabl 3 show result left side tabl 3 show averag size slice comput use inform provid lightweight context recoveri averag size slice comput without use inform tabl also show ratio percentag tabl see program use inform provid lightweight context recoveri significantli improv precis comput interprocedur slice howev program see signific improv one explan may program precis interprocedur slice sensit precis identifi memori locat modifi referenc statement result consist result report refer 9 14 show precis interprocedur slice sensit precis alia inform right side tabl 3 show averag time comput slice use inform provid 6 data program unavail landi ryder algorithm 7 fail termin within 10 hour time limit set comput alia inform program averag size time second name alia ss tt load lh 187 241 779 23 64 350 er 187 241 779 23 64 352 dixi lh 629 648 970 100 230 436 609 648 940 53 123 429 learn lh 499 501 996 162 297 546 479 501 956 109 212 515 791 806 981 83 97 857 assem lh 744 751 991 152 938 162 smail lh 1066 1087 981 158 545 290 1032 1090 947 129 390 330 546 698 783 103 395 262 simu lh 1174 1178 997 111 185 598 later 1174 1178 997 108 187 580 arc lh 788 804 981 94 129 725 771 803 961 76 92 822 space lh 2028 2161 939 318 577 55 2019 2161 934 312 574 54 larn lh 4590 4612 995 642 977 657 4576 4603 994 619 798 775 averag size time hour name alia ss tt espr lh 5704 5705 100 12 47 254 sso 5704 5705 100 69 73 937 moria lh 7820 28 100 7822 71 100 twmc lh 4331 4331 100 19 22 837 4327 4327 100 17 20 841 data collect slice program data collect one slice tabl 3 averag size slice left averag time comput slice right lightweight context recoveri averag time comput slice without use inform provid lightweight context recoveri time measur includ time requir build cfg alia analysi comput modif sideeect context recoveri tabl also show ratio tabl see use inform provid lightweight context recoveri significantli reduc time requir comput interprocedur slice suggest techniqu might eec tive improv ecienc mani program analys flowinsensit alia analysi algorithm ex tend use similar techniqu refer 4 comput polyvari alia inform identifi dierent alia relat procedur dierent callsit use polyvari alia inform program analysi identifi memori locat access procedur specif callsit thu comput accur program informa tion howev comput polyvari alia inform may requir procedur analyz multipl time specif call context requir may make alia analysi ineci observ memori locat point pointer procedur program inform procedur develop techniqu 10 partit memori locat equival class memori locat equival class share program inform procedur therefor procedur analyz inform repres equival class comput inform reus memori locat equival class experi 10 11 show techniqu eec tive improv perform program analys techniqu present paper improv perform program analys anoth dimens thu use togeth equival analysi improv ecienc program analys horwitz rep binkley 6 present techniqu use set variabl may modifi may referenc procedur avoid includ unnecessari callsit slice techniqu need systemdependencegraph base slicer comput slice precis comput interprocedur slicer eg 5 techniqu dier techniqu use set memori locat may access procedur specif callsit filter spuriou program infor mation thu techniqu improv precis perform mani program analys horwitz rep binkley techniqu appli mani techniqu improv perform program analys eg 13 lightweight contextrecoveri techniqu use mani approach improv perform dataflow analys 6 conclus futur work present lightweight context recoveri algorithm illustr techniqu use inform provid lightweight context recoveri improv precis ecienc program anal yse also conduct sever empir studi result studi suggest mani case use lightweight context recoveri eectiv improv precis ecienc program analys futur work first repeat studi paper larger program valid conclus second perform studi evalu eectiv combin lightweight context recoveri equival analysi improv e cienci comput interprocedur slice third appli techniqu program analys evalu eectiv program analys fi nalli perform studi compar techniqu condit analysi acknowledg work support nsf grant ccr 9696157 ccr9707792 ohio state univers r program analysi special c program languag program languag research group call graph construct objectori languag interprocedur slice use depend graph safe approxim algorithm interprocedur pointer alias interprocedur modif side e equival analysi gener techniqu improv e interprocedur defus associ c program program slice tr interprocedur slice use depend graph safe approxim algorithm interprocedur alias interprocedur modif side effect analysi pointer alias call graph construct objectori languag effect wholeprogram analysi presenc pointer reusedriven interprocedur slice equival analysi effici pointsto analysi wholeprogram analysi dataflow analysi program fragment interprocedur defus associ c system singl level pointer effect presis pointer analysi reusedriven interprocedur slice presenc pointer recurs ctr donglin liang maikel pen mari jean harrold evalu impact contextsensit andersen algorithm java program acm sigsoft softwar engin note v31 n1 januari 2006 anatoliy doroshenko ruslan shevchenko rewrit framework rulebas program dynam applic fundamenta informatica v72 n13 p95108 januari 2006 marku mock darren c atkinson craig chamber susan j egger improv program slice dynam pointsto data proceed 10th acm sigsoft symposium foundat softwar engin novemb 1822 2002 charleston south carolina usa marku mock darren c atkinson craig chamber susan j egger improv program slice dynam pointsto data acm sigsoft softwar engin note v27 n6 novemb 2002 marku mock darren c atkinson craig chamber susan j egger program slice dynam pointsto set ieee transact softwar engin v31 n8 p657678 august 2005 michael hind pointer analysi havent solv problem yet proceed 2001 acm sigplansigsoft workshop program analysi softwar tool engin p5461 june 2001 snowbird utah unit state baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slice acm sigsoft softwar engin note v30 n2 march 2005