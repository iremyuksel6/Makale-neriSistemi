use heap elimin stack access valu variabl often given field heap cell frequent program pick valu sever variabl differ field heap cell keep variabl stack frame access origin locat heap instead reduc number load store stack cost introduc smaller number load heap present algorithm find optim set variabl access via heap cell instead stack slot transform code program accordingli implement optim mercuri compil measur show reduc program runtim 12 time reduc program size optim straightforward appli mercuri languag immut data structur adapt languag destruct assign would requir compil perform mutabl analysi b introduct compil tri keep valu variabl per hap virtual regist whenev possibl howev procedur call gener case modifi content permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee ppdp02 octob 68 2002 pittsburgh pennsylvania usa regist standard solut problem alloc slot stack frame everi variabl live call copi variabl stack call paper investig possibl avoid alloc associ copi exploit fact variabl valu must save may alreadi avail memori locat updat call suppos obtain valu variabl eld immut cell heap point variabl b assum cell immut unless specic say otherwis allow us avoid store stack provid nd locat heap everywher need case procedur singl assign languag procedur imper languag express singleassign form place later procedur refer store valu b instead valu stack may look promis worst case requir number stack slot one number store stack call one addit instruct load b stack place later procedur want access howev may happen program need b call case need stack slot store instruct stack slot anyway access via b need addit store may also happen everi basic block program access also access b case access via b requir addit load either thing happen access via b elimin one stack slot one store oper stack slot use denit rst call denit access via b also save load cell would need store stack slot overal access via b may better store stack slot cours may two call procedur access b case access via b incur cost addit load howev often happen two call procedur access variabl point cell eg b access one variabl whose valu came eld cell singl load b give us access a1 a2 a3 cost load b need divid among a1 a2 a3 mean cost access instead store a1 stack slot depend variabl reachabl b access via b inde may happen access a1 via b worthwhil access a2 via b worthwhil access a1 a2 via b worthwhil interdepend decis need make dierent variabl reachabl cell sig nicantli complic task nding optim partit variabl store cell stack slot access via cell compar partit variabl store stack slot optim partit may reduc total number stack access load store perform program may reduc number stack slot requir may cours may also neither optim guarante speedup tri partit obviou algorithm comput best partit unfortun algorithm feasibl cell contain dozen eld requir tri million partit paper describ much ecient algorithm base maxim match bipartit graph implement algorithm mercuri compil experi show give real benet real program eg mercuri compil next section give brief introduct mercuri concentr featur relev optim section 3 give work exampl explain techniqu section 4 dene condit applic optim show collect inform need implement opti mizat section 5 give algorithm comput optim partit section 6 explain sourcetosourc transform use exploit optim partit section 7 give result preliminari experiment evalu optim 2 mercuri assum familiar basic concept logic pro gram prolog syntax also mercuri syntax mercuri pure declar logic program languag design construct larg reliabl ecient softwar system team programm 3 6 mercuri syntax similar syntax prolog mercuri also strong modul type mode determin system catch larg fraction programm error enabl compil gener fast code main featur mercuri relev paper follow everi predic one mode say everi argument whether input output mode system sophist matter paper call mode predic procedur mode system insist abl nd compil time state instanti everi variabl everi point everi procedur abl reorder conjunct goal use valu variabl come goal gener valu variabl perform either task reject program mercuri associ everi procedur determin express upper lower bound number solut procedur procedur guarante exactli one solut determin det procedur may one solut one set input zero solut input determin semidet procedur may number solut determin nondet denit predic mercuri bodi made atom conjunct negat disjunct thenels simplifi algorithm compil convert bodi claus form atom appear b distinct variabl mode analysi compil classi unica tion one type copi one b input output test input deconstruct b input output construct input b output complex unic otherwis use respect notat b b b indic mode unic paper shall mainli concern de construct deconstruct b whether princip functor b f hasnt previous establish n 0 assign eld cell point b variou note eld variabl use later particular anonym variabl compil access eld compil also detect disjunct disjunct deconstruct input variabl dierent function symbol disjunct valu variabl entri disjunct determin di junct succeed other succeed tri unifi variabl function symbol bound compil convert disjunct switch resembl switch construct c mercuri compil sever backend translat mercuri dierent target languag backend work paper compil origin backend translat mercuri low level c code backend use execut algorithm describ 6 execut algorithm use virtual machin whose data structur consist heap two stack set gener purpos regist use argument pass set special purpos regist heap stack pointer differ two stack irrelev purpos paper mercuri compil respons paramet pass ing stack frame manag heap alloc control ow includ manag backtrack almost everi aspect execut signic task leav c compil instruct select instruct schedul regist alloc within basic block eect use c compil high level optim assembl besid achiev portabl approach allow mercuri compil perform optim exploit semant properti mercuri program immut ground term convey c compil mercuri compil assum everi call clobber everi virtual machin regist everi call site ush live variabl slot current procedur switch t0 t0 empti load k0 v0 l0 r0 store k v k0 v0 l0 r0 compareresult k k0 b switch result load k v l0 load k0 v0 r0 load v k0 l0 r0 load k v r0 load k0 v0 l0 switch t0 t0 empti load k0 store k v t0 compareresult k k0 b switch result load k v t0 l0 bc load t0 k0 ce v0 ce r0 ce load v t0 k0 l0 r0 load k v t0 r0 bd updater0 bd k v r load t0 k0 de v0 de l0 de b figur 1 updat predic origin form modi transform b stack frame similarli start nondeterminist di junction ush stack variabl live start second later disjunct sinc start disjunct reach backtrack long execut clobber virtual machin reg ister ifthenels treat similarli els branch correspond second disjunct situat mercuri execut algorithm requir live variabl ush stack mercuri compil therefor pass gure ush point variabl need ush stack point variabl need exist stack simultan need store dierent stack slot one may abl use stack slot store dierent variabl dierent ush point compil use standard graph colour approach see eg 2 assign variabl stack slot 3 motiv exampl consid mercuri predic illustr figur 1a updat binari search tree t0 contain keyvalu pair new version tree map key k valu v text symbol comment predic predic search updat variou kind fairli import mani mercuri program declar natur mercuri encourag programm use repres dictionari instead array must updat destruct origin form predic variabl k0 v0 l0 r0 whose valu produc deconstruct live call compar immedi follow deconstruc tion compil therefor alloc stack slot variabl save valu stack slot call save valu variabl requir load regist rst origin locat memori cell point t0 k v also live call alreadi put regist updat caller execut follow one three path compar turn k k0 equal execut take second arm switch code use k0 v l0 r0 input four variabl must load stack slot k less k0 execut take rst arm switch contain call make call requir l0 k v load regist stack slot call return l regist call need load regist k0 v0 r0 third arm switch analog rst ad comment indic variabl code store stack variabl load stack heap count load store variabl involv deconstruct cell variabl t0 eld variabl k0v0l0r0 requir make valu variabl avail along path execut involv deconstruct execut take rst arm switch result execut four load four store involv variabl program point b three load b c three load c e total ten load four store execut take third arm switch result similar reason also execut total ten load four store execut take second arm switch result execut four load four store b three load b e total seven load four store key idea paper realiz load store b signic cost avoid cost will insert clone deconstruct later procedur bodi clone incur extra cost load t0 long choos perform transform initi save least big extra cost path execut achiev speedup figur 1b show predic transfor mation clone origin deconstruct one region rst use eld variabl execut take rst arm switch result transform predic execut one load one store b two load b c load t0 stack slot regist load l0 bc cell t0 point four load c e load t0 stack slot regist load k0 bc v0 bc r0 bc cell t0 point total seven load one store execut take third arm switch result analysi analog total cost seven load one store execut take second arm switch result execut one load one store b four load b e total load one store overal transform reduc cost path rst third arm ten load four store seven load one store cost path second arm seven load four store load one store transform also reduc number stack slot requir origin code need six stack slot variabl one kvk0v0l0r0 transform code need three stack slot vari abl one kvt0 sourc speedup ad one two extra load t0 path execut replac four load four load b one load one store extra cost alway form extra load cell variabl t0 rst stack ush deconstruct possibl case extra store cell variabl stack ush save alway form elimin store eld variabl stack ush elimin load eld variabl need stack ush case must keep load k0 elimin load well store v0 l0 r0 reason reduct stack slot requir save t0 stack preserv valu eld variabl t0 heap cell across call sinc number eld variabl cell greater one use one stack slot save valu one variabl across call 4 detect opportun optim describ algorithm perform transform shown exampl need introduc background inform denit bodi mercuri procedur goal goal may atom goal compound goal atom goal may unic builtin oper eg arithmet call purpos paper distinct rst order call higher order call method call compound goal may conjunct disjunct switch ifthenels negat existenti quanti er rest paper restrict attent rst four compound goal type algorithm treat negat special case ifthenels notgoal equival goal fail true treat existenti quanti goal goal call di junction switch ifthenels branch control structur branch goal denit 1 ush point point bodi procedur code gener requir store variabl stack slot regist mercuri four kind ush point execut reach call code gener must ush variabl live call stack like compil mercuri compil assum call clobber regist execut reach start ifthenels code gener must ush variabl live start els case els case reach regist may clobber eg call insid condit code gener must ush variabl stack otherwis ush variabl regist well stack slot execut reach start disjunct code gener must ush variabl live start second disjunct later disjunct nonrst disjunct reach via deep backtrack ie failur call insid previou disjunct failur goal follow disjunct whole code gener must ush variabl stack otherwis ush variabl regist well stack slot execut reach end branch control structur code gener must store variabl live afterward specic stack slot specic regist exact locat determin prepass code gener ensur branch leav variabl place denit 2 anchor one follow start procedur bodi call site start branch control structur end condit ifthenels end branch control structur end procedur bodi ush point anchor anchor ush point exampl figur 1a program point abcd e repres start outer switch call compar two call updat end inner switch respect anchor also ush point code fragment also contain two anchor start inner switch end outer switch exampl distinguish two anchor program point b e denit 3 interv sequenc atom goal delimit leftright pair anchor satisfi properti forward execut start left anchor continu without encount failur would initi backtrack ie backward execut next anchor reach right anchor pair consid call part atom goal interv call site right anchor interv left anchor denit 4 segment maxim sequenc one interv right anchor interv sequenc except last left anchor interv follow sequenc sequenc must also satisfi properti execut get left anchor rst interv right anchor last interv without code gener throw away current record valu live variabl segment contain one interv howev right anchor interv start ifthenels interv ifthenels interv start condit belong segment right anchor interv start disjunct interv disjunct interv start rst disjunct belong segment right anchor interv start switch interv disjunct interv start arm switch belong segment interv whose right anchor start switch interv part one segment exampl figur 1a ab bc ce bd de segment empti interv contain atom goal end call compar start follow switch part segment start b transform algorithm three phase rst phase nd interv procedur bodi interv record left right anchor set variabl need input interv includ input atom goal interv interv whose right anchor start switch variabl switch set variabl need segment denot varss union set variabl need compon interv segment also record interv leftmost anchor segment interv belong second phase travers procedur bodi backward look deconstruct b fa1 call eld vari abl oppos b cell variabl nd deconstruct tri nd eld variabl avoid store stack slot load heap cell point cell variabl instead wherev need access eld variabl via cell variabl follow condit hold memori cell point cell variabl must immut isnt valu eld cell may chang origin deconstruct copi deconstruct transform insert elsewher procedur bodi mercuri cell mutabl instanti state cell variabl point deconstruct state pointer cell live point compil may choos destruct updat cell program point valu eld variabl need input atom goal live variabl ush output argument procedur whole must within eectiv scope deconstruct consid variabl follow program fa b rxaz need determin singl locat use r3 henc must store stack slot everi interv need valu eld variabl valu cell variabl must reachabl time execut reach deconstruct consid variabl follow program fab qxab rxa sxyaz access indirectli need add load segment q3 r2 q3 succeed multipl time load execut per success guarante compens remov store call q3 valu eld variabl requir segment deconstruct otherwis point investig whether would worthwhil access via cell variabl segment deconstruct four condit hold least eld variabl form set candid eld variabl partit set candid two subset access via cell vari abl nevertheless store access via stack slot rst nd set maxim path execut take procedur bodi point deconstruct point deconstruct goe scope denit 5 path sequenc segment start segment contain deconstruct segment follow segment j left anchor rst interv segment j right anchor last interv segment b execut resum left anchor rst interv segment j backtrack initi within segment path maxim isnt contain within anoth path maxim path disjunct includ maxim path rst disjunct maxim path second disjunct maxim path third etc maxim path ifthenels either maxim path condit follow maxim path part maxim path condit follow maxim path els part maxim path switch maxim path one arm switch program figur 1a maxim path abbcc abb abbdd sinc backtrack switch maxim path start given deconstruct nonempti set candid eld variabl invok algorithm describ next section partit candid variabl set point view execut take particular maxim path procedur bodi better access via cell variabl set better store stack slot 5 decid variabl load cell 51 introduct maxim match algorithm use decid variabl load cell make use maxim match algorithm bipartit graph section introduc terminolog exampl denit 6 bipartit graph g made two disjoint set vertic b c edg e applic set vertic repres benet cost match bipartit graph g set edg e vertex occur maxim match g match match 0 g jm 0 j jm j ecient algorithm maxim match bipartit graph base search augment path denit 7 given bipartit graph g match altern path path whose edg altern e dene set reachableu set node reachabl u altern path given bipartit graph g match augment path p altern path rst last vertic free ie occur given bipartit graph g match augment path p match jm cost benefit figur 2 stack optim graph program figur 3 togeth maxim match import properti maxim match relationship augment path properti 1 match g maxim exist augment path p g straightforward algorithm bipartit maxim match base search augment path use breadthrst search oju j jej sophist algorithm exampl 1 figur 2 show bipartit graph match illustr solid arc match 5g exampl altern path loadt 0 dene edg fstorek0 loadt 0 5 storek0 storet 0 2g augment path endpoint match inde match maxim match 52 minim stack oper aim nd deconstruct unic b set variabl involv store stack order minim number stack oper requir let f ang candid eld variabl maxim path deconstruct assum given list segment function determin variabl whose valu requir program segment determin maxim path independ set variabl requir stack slot denit 8 cost must incur access candid variabl f via cell variabl b instead via stack loadb need add load b everi segment storeb need add store b rst seg ment b live initi segment 1 call set costf benet gain access candid variabl f via cell variabl b instead via stack b live initi segment even origin program would need store b stack store extra cost incur access eld variabl via b storef store f initi segment loadf 1 avoid load f initi segment call set benefitf use model total cost benet choos access given subset v f via cell variabl instead store stack total set cost incur choos access given subset v f via cell variabl instead store stack costv total benet choic benefitv note benet f independ cost sinc cost load b given segment incur even use access one candid variabl therefor decid candid variabl individu whether store stack access via cell variabl must consid set candid time need ecient algorithm nding set v f benefitv greater equal costv time assum cost load store oper equal discuss relax assumpt section 7 henc search set v f two choic v1 v2 prefer v1 sinc requir fewer stack slot algorithm reduc stack optim problem maxim match problem bipartit graph ecient algorithm known denit 9 stack optim graph deconstruct given bipartit graph g whose vertex set f2f benefitf dene costfg node graph repres load store instruc tion edg repres benet one gain one will incur given set cost diagram cost node top benet node bottom exampl 2 consid program shown figur 3a default compil requir 14 load store deconstruct t0 treek0v0l0r0 singl maxim path entir procedur eld variabl candid segment anchor end call var inform given cost benet eld variabl given cost benet k0 fstoret 0 loadt 0 3 fstorek0g loadt 0 4 loadt 0 5g note sinc t0 requir deconstruct cost candid sinc candid requir initi segment load benet stack optim graph deconstruct shown figur 2 algorithm start nding maxim match stack optim graph figur 2 show edg maxim match solid line mark unmatch cost node node reachabl node use altern path respect cost node mark repres cost paid correspond benet benet node mark benet equal outweigh correspond cost algorithm partit candid whose benet includ mark node whose benet includ mark node result v variabl want access via cell variabl latter set fact benet node candid variabl either mark unmark consequ follow lemma lemma 1 let g stack optim graph adjac subset c maxim match g let mg match node c let node reachabl altern path unmatch node c b1 b2 2 r proof suppos contrari wlog b1 2 r altern path c 2 mc b1 henc altern path c 2 sinc c 2 mc rst edg path sinc path must even number edg last edg must b2 also adjac extend altern path c reach b2 contradict altern sinc altern path c mean path c must use edg henc altern path c b2 contradict exampl 3 figur 2 show stack optim graph program figur 3a togeth maxim match mark node reachabl altern path start unmatch node c case node floadt0 4g figur 2 mark node loadt 0 4 storek0 loadt 0 5 set v dene match set candid variabl whose benet node unmark case 0g result optim program shown figur 3c requir 14 load store note access eld variabl cell result program figur 3b requir 15 load store show choic v wors default access everi candid stack slot choic optim theorem 1 let g stack optim graph maxim match g let load k0 v0 l0 r0 store k0 v0 l0 r0 dodgyk0 v0 l0 r0 load l0 r0 load k0 v0 checkk0 v0 c1 load k0 checkk0 c1 c2 load k0 checkk0 c2 c3 load k0 v0 l0 r0 store t0 dodgyk0 v0 l0 r0 load t0 l0 2 r0 2 load t0 k0 3 v0 3 checkk0 3 v0 3 c1 load t0 k0 4 checkk0 4 c1 c2 load t0 k0 5 checkk0 5 c2 c3 store t0 k0 dodgyk0 v0 l0 r0 load t0 l0 2 r0 2 load k0 t0 v0 3 checkk0 v0 3 c1 load k0 checkk0 c1 c2 load k0 checkk0 c2 c3 b c figur 3 origin arbitrari program b transform program maxim stack space save c optim transform program match node c unmatch node c let maxim proof let node c 2 rc match otherwis would mc must match node rb suppos contrari c match b 2 rb altern path c 0 2 mc b end unmatch edg sinc start unmatch edg c b henc extend path use match edg b c henc c 2 r contradict impli b 2 rb otherwis would augment path c 2 mc b sinc node rb either match node rc unmatch denit benefitv rb sinc v contain exactli f benefitf show costv rc costv node c adjac node benefitv rb sinc node rc match node rb must adjac node rb thu rc costv suppos contrari node c 62 rc adjac b 2 rb c 2 rc henc altern path c 0 2 mc c end edg altern path extend b sinc b c henc b 2 r contradict thu rc netv jmbj consid set variabl v 0 f let mb denit node unmatch match node costv 0 henc jmc 0 j jmb 0 j also clearli mb 0 mb sinc node mb 0 unmatch netv 0 netv 53 merg result differ maxim path exampl 4 program figur 1a 3 maxim path follow t0 treek0v0l0r0 abbcc abbdd abb stack optim graph maxim path shown figur 4 none maxim match leav unmatch cost node v get result along maxim path therefor access variabl fk0 v 0 l0 r0g via t0 along everi maxim path result optim program shown figur 1b howev gener may comput dierent set v along dierent maxim path valu v comput along given maxim path includ given eld variabl access eld variabl via heap cell along maxim path may lead slowdown execut take maxim path access eld variabl via cell maxim path via stack slot maxim path doesnt make sens need store eld variabl stack slot rst interv use maxim path access via stack slot gain noth may lose someth access via cell along maxim path sinc tri make sure optim never slow program rst harm therefor access eld variabl via cell maxim path prefer access eld variabl via cell ie eld variabl set v comput maxim path valu v comput along given maxim path guarante access variabl v via cell instead via stack slot slow program howev similar guarante subset access subset variabl v via cell instead via stack slot slow program would therefor good idea simpli take intersect loadl01 storel0 loadr01 storer0 storek0 loadv01 storev0 cost benefit loadl01 storel0 loadr01 storer0 storek0 loadv01 storev0 cost benefit loadl01 storel0 loadr01 storer0 storek0 loadv01 storev0 cost benefit figur 4 stack optim graph maxim path abbcc abbdd abb program figur 1a set v comput along dierent maxim path access variabl intersect via cell instead restrict candid set remov variabl tersect restart analysi begin new candid set keep get set v maxim path time restart analysi remov least one variabl candid set size initi candid set thu put upper bound number time need perform analysi 54 cost oper assum load store cost reason close truth whole truth optim deal two kind store four kind load kind store deal 1 store eld variabl stack 2 store cell variabl stack kind load deal 1 load eld variabl regist store stack initi segment 2 load cell variabl stack regist later segment use regist base load eld variabl cell 3 load eld variabl cell 4 load variabl stack slot transform add type 2 load possibl type store remov type 1 store possibl type 1 load side eect also turn type 4 load type 3 load store involv either side ledger go current stack frame mean like cach hit type 1 load cluster mean also like cach hit exampl unic deconstruct cell argument machin cach block contain four word type 1 load requir load argument cell regist two cach miss type 2 load occur one per cell per segment cluster therefor much like cach miss type 3 load also like cach load load type 1 typic follow within instruct store load valu load type typic follow within instruct load type 3 use load valu cell address optim turn type 4 load type 3 load noth chang distanc load instruct next instruct need load valu type store properti valu store like access next struction make pipelin stall data hazard unlik type 1 2 load hand signic chanc caus data hazard result stall chanc cost result stall depend independ instruct schedul compil hardwar execut load rst instruct use load valu mean probabl cost thu averag cost stall depend program input data sinc rel cost dierent type load store depend averag number length cach miss stall gener rel cost programdepend lesser extent datadepend well therefor extend optim four paramet give rel cost type 1 load type 1 2 store cost paramet load also suppos account associ cost turn type 4 load type 3 load paramet form small integ extens consist replic node stack optim graph c time c cost paramet type oper repres node replica given origin node connect accord lemma 1 retain properti copi node either mark henc set v remain well dene theorem continu hold howev match algorithm gener solut whose net eect eg addit n type 2 cell variabl load remov type 1 eld variabl store arloadcost f ieldv arstorecost experi set cellv arloadcost 3 three paramet cellv arstorecost f ieldv arloadcost f ieldv arstorecost 1 6 transform code determin set v eld variabl access cell variabl deconstruct transform program ad clone deconstruct perform forward travers procedur bodi start deconstruct appli current substitut go initi current substitut ident substitut reach begin segment v varsi 6 add clone decon struction eld variabl f replac new variabl f 0 construct substitut eect replac variabl access cell copi clone deconstruct remain new variabl clone deconstruct never use proceed appli substitut reach end segment exampl 5 program given figur 3a r0g travers forward decon struction reach segment 2 segment follow call dodgy4 sinc vars2 v empti add clone deconstruct t0 fk0 2 v0 2 construct substitut 2g continu travers appli substitut balancedl0 r0 replac balancedl0 2 r0 2 note k0 2 v0 2 never use reach end segment 2 start segment 3 insert new clone deconstruct t0 construct new current substitut 3g process later segment similar segment share interv must interv end start switch transform insert clone unic uniqu anchor start segment figur 1a would mean insert singl clone deconstruct immedi call compar instead three clone deconstruct start three switch arm show figur 1b howev mercuri code gener load variabl cell need code gener transform therefor exactli eect code figur 1b optim extend straightforward manner case cell variabl b eld variabl anoth deconstruct eg c gbb2bk simpli appli optim rst deconstruct b fa1an appli optim c achiev desir eect implement optim two pass procedur bodi rst pass backward travers build data structur describ interv segment goe along reach deconstruct unic use data structur nd candid variabl appli match algorithm nd candid access via cell vari abl updat data structur ect result associ transform would appli transform yet instead transform requir optimiz deconstruct perform second forward travers procedur 7 perform evalu implement optim describ paper melbourn mercuri compil initi test found necessari add two tune paramet onepath node ratio threshhold valu opr accept result match algorithm given path ratio number benet node number cost node comput match least opr allpath node ratio threshhold valu apr accept result match algorithm ratio total number benet node total number cost node path least apr accept result match algorithm must pass threshold fail one threshold algorithm use cell access path eld variabl store eld variabl stack exampl 6 consid program figur 3 contain one path whose match shown figur 2 ratio unmark benet node unmark cost node correspond benet cost access opr 100 optim reject store stack slot sinc one path allpath ratio exampl 7 program figur 1a three path abbcc abdbd abb match shown figur 4 ratio unmark benet node unmark cost node abbcc abdbd ratio abb onepath node threshold reject transform lead code figur 1b unless opr 233 three path share benet node share one cost node one look path benet node cost node ratio 11666 henc allpath node threshold reject transform apr 116 increas onepath node ratio threshhold beyond 100 kind eect increas number node alloc cell variabl load store rel number node alloc eld variabl load store advantag set threshhold say 125 signicantli cheaper compil time run match algorithm graph copi cost node four copi benet node allpath node ratio threshhold pose dierent test onepath node ratio threshhold dierent path share benet elimin eld variabl store mayb load princip compon cost insert cell variabl load segment control impact optim execut size allpath node ratio threshhold use control impact optim execut size oper number node set paramet 100 virtual guarante optim increas size execut cost oper node benet opera tion set paramet 100 virtual guarante applic transform strictli decreas size execut one make concret guarante c compil mercuri compil nal say execut size two reason found threshold nec essari first impact pipelin eect cach program line opt opt 100125 opt 133133 opt 150100 opt 150125 mmc 262844 5031 4484 891 4405 876 4494 893 4555 905 compress 689 1566 1567 1000 1566 1000 1565 1000 1566 1000 ray 2102 1342 1331 992 1329 990 1330 991 1329 990 tabl 1 perform evalu eect discuss section 54 vari depend circumst sometim variat make transform program faster origin sometim make slower threshold allow us lter applic transform highest chanc slow program leav applic like yield speedup second even origin program transform program perform respect cach pipelin eect reason prefer origin program reason concern happen cell variabl becom dead eld variabl still aliv origin program garbag collector may abl reclaim storag occupi cell dead eld variabl sinc may live root point transform program reclam possibl live root reachabl cell variabl whose lifetim transform artici extend therefor test test program sever set paramet valu unfortun whole paramet space big search even close exhaust realli feasibl due space limit present result paramet set howev four chosen repres result comment make still true one look result date four set paramet valu cost cell variabl load set three oper cost one sinc preliminari investig suggest roughli right set dier valu one path allpath node ratio threshhold four combin paramet valu report 100125 133133 150100 150125 onepathallpath test program follow mmc test case melbourn mercuri compil compil six largest modul code compress mercuri version 129compress benchmark specint95 suit next two entri involv group entri recent icfp program contest 2000 entri ray tracer gener ppm le structur descript scene 2001 entri sourcetosourc compress program hypothet markup languag nuc mercuri version pseudoknot benchmark execut 1000 time ray ray trace program gener pictur helix dodecahedron benchmark machin dell pc 16 mhz pentium iv 512 mb linux 2416 tabl 1 show result rst column identi benchmark program second give size sourc line code measur word count program wc third column give time taken program compil without stack slot optim follow four group two column give time take compil stack slot optim indic set paramet valu ratio time unoptim time time deriv execut benchmark program eight time discard highest lowest time averag remain time tabl show wide rang behavior compress optim eect compress simpli doesnt contain kind code optim appli two program icfp2001 ray stack slot optim consist give speedup 1 icfp2000 stack slot optim consist give slowdown around 1 nuc stack slot optim give speedup bit 2 set paramet valu slowdown bit 2 set paramet valu clearli indic transform perform stack slot optim beneci other harm dierent paramet valu admit dierent proport two kind gener rais threshold reduc probabl slowdown also reduc amount speedup avail one guarante given threshold valu exclud undesir applic transform without also guarante also exclud desir one icfp2000 paramet valu explor rang 100 150 admit mani wrong kind use paramet valu 150 use higher cost cell load store may yield speedup icfp2000 also mmc stack slot optim achiev speedup 9 12 rang one consid one doesnt expect program spend much 30 time stack access also alloc memori cell make decis perform call return arithmet collect garbag result show elimin mayb one quarter stack access result look impress interestingli previou benchmark run may typic slightli earlier version compil yield somewhat smaller speedup around 59 still pretti good result think reason largest complex program benchmark suit give far best result also far program make use complex data structur small program tend use rel simpl data structur code travers complex data structur also complex therefor big therefor reason believ perform stack slot optim larg program like resembl behavior mmc benchmark program howev fact stack slot optim sometim lead slowdown mean may good idea compil turn automat probabl better let programm test eect benchmark also show stack slot optim usual reduc size execut usual 01 05 case increas tini amount less 01 nice given mani optim improv speed cost addit memori enabl stack slot optim slow compil slightli case seen impact compil time 02 rang case seen go 65 havent seen higher also look eect optim size stack frame test version mercuri compil 8815 predic whose implement need stack frame paramet valu explor stack slot optim abl reduc size stack frame 1331 predic 151 also reduc averag size stack frame averag 8815 predic 133 550 word 477 word oddli enough optim lead trivial reduct less 01 stack space requir execut compil point compil requir maximum stack space virtual frame stack predic whose stack frame size aect optim 8 conclus relat work optim describ replac number stack access equival smaller number heap access mani case optim reduc number memori access requir execut pro gram optim also reduc size pro cedur stack frame improv local make cach eectiv optim lead signific perform improv program manipul complex data structur default usag optim need conserv order avoid slowdown paramet valu 150125 would appear suitabl gain maximum benet optim programm may need explor paramet space sinc conserv threshhold restrict benet optim optim dene somewhat similar remateri regist alloc eg 1 2 sometim easier recomput valu variabl keep regist remateri optim eectiv split lifetim variabl order reduc pressur regist stack slot key dier enc remateri variabl independ variabl wherea complex problem aris interdepend choic stack slot fact mercuri compil long optim took variabl denit form b f f constant clone segment b need order avoid store b stack substitut dierent variabl b segment unlik optim present paper optim requir analysi also somewhat relat partial dead code elimin 5 save load initi segment eectiv result sink calcul eld variabl point later program code restrict candid eld variabl ensur sink add overhead worth discuss optim appli languag optim applic prolog even without mode inform sinc even though rst occurr unic may neither construct deconstruct execut copi ad algorithm deconstruct good prolog compil take advantag inform execut ecient cours without inform determin optim danger simpli assum code determinist reason quit larg proport prolog code unfortun advantag like visibl wambas compil sinc regist wam memori strict function languag ml optim straightforwardli applic sinc mode inform syntact avail code alway determinist optim avail next major releas mercuri system also avail releaseoftheday mercuri system httpwwwcsmuozaumercuri near futur 9 r regist alloc spill via graph color david je bernhard ste execut algorithm mercuri tr remateri partial dead code elimin regist alloc myampersandamp spill via graph color