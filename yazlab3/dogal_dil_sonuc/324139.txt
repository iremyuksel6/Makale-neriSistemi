pure function realtim dequ caten describ effici pure function implement dequ caten addit intrigu problem right find pure function implement caten dequ requir add certain sophist program construct function program languag solut worstcas run time o1 push pop inject eject caten best previous known solut ologk time bound kth dequ oper solut faster simpler key idea use result algorithm techniqu relat redund digit represent use avoid carri propag binari count b introduct persist data structur one chang structur made without destroy old version version structur persist least access structur said partial persist even modifi structur said fulli persist function program literatur fulli persist structur often call immut pure att laboratori florham park nj work done princeton univers support offic naval research contract n0001491j1463 nsf grant ccr8920505 ccr9626862 unit statesisrael educ foundat usief fulbright grant hklresearchattcom depart comput scienc princeton univers princeton nj 08544 usa intertrust technolog sunnyval ca research princeton univers partial support nsf grant ccr8920505 ccr9626862 offic naval research contract n0001491j1463 retcsprincetonedu function 1 program without side effect properti everi structur creat automat fullypersist persist data structur aris function program also text program file edit mainten comput geometri algorithm applic area see 6 10 11 12 13 14 15 16 24 37 38 39 40 41 number paper discuss way make specif data structur search tree persist smaller number propos method ad persist gener data structur without incur huge time space cost obviou method copi entir structur whenev chang made particular driscol sarnak sleator tarjan 14 describ make pointerbas structur persist use techniqu call nodesplit relat fraction cascad 7 way yet fulli understood dietz 11 describ method make arraybas structur persist addit refer persist found driscol et al dietz paper gener techniqu fail work data structur combin rather chang local driscol sleator tarjan 13 coin term confluent persist refer persist structur updat oper combin two differ version perhap simplest probabl import exampl combin data structur caten append list confluent persist list caten surprisingli power exampl use selfcaten one build list exponenti size linear time paper deal problem make persist list caten effici consid follow oper manipul list return new list consist singleton element x return list form ad element x front list l popl return pair consist first element list l list consist second last element lfor purpos paper pure function data structur one built use lisp function car con cdr though state construct explicitli term function routin verifi structur pure function definit pure function extrem strict exampl allow techniqu memoiz contrast work exampl okasaki 33 34 35 36 discuss issu see section 2 7 return list form ad element x back list l return pair consist last element list l list consist first nexttolast element l catenatek l return list form caten k l k first observ push inject special case caten conveni us treat separ oper howev accord convent call list subject push pop inject eject stack list subject inject pop push eject queue adopt terminolog knuth 29 call list subject four oper push pop inject eject doubleend queue abbrevi dequ pronounc deck departur exist terminolog call list subject push pop inject stackend queue stequ pronounc steck knuth call stequ outputrestrict dequ stackend queue easi shorten evok idea stequ combin function stack queue stequ caten stack caten sinc caten make inject push matter redund call data structur constant worstcas time bound oper realtim structur main result realtim pure function henc confluent persist implement dequ caten data structur effici simpler previous propos structur 4 13 addit interest problem right data structur provid way add fast caten listbas program languag scheme implement sophist program construct base continu function program languag see 15 16 key ingredi result algorithm techniqu relat redund digit represent devis avoid carri propag binari count remaind paper consist six section section 2 survey previou work deal problem relat make list persist ad caten effici list oper section 3 motiv approach section 4 describ make dequ without caten pure function therebi illustr idea simpl set section 5 describ make stack stequ caten pure function illustr addit idea need handl caten compar simpl set stack section 6 present gener result implement dequ caten result use addit idea need handl underli treelik recurs structur place linear structur section 7 mention addit relat result open problem preliminari version part work present 27 th annual acm symposium theori comput 27 previou work work relat found three branch comput scienc data structur function program perhap surprisingli ture machin complex shall describ work approxim chronolog order detail attempt sort somewhat tangl histori let us put asid caten moment consid problem make noncaten list fulli persist easi make stack persist repres stack pointer singlylink list element top element stack first element list push element onto stack creat new node contain new element pointer node contain previous first element stack pop stack retriev first element pointer node contain previous second element standard lisp represent list collect persist stack repres way consist collect tree pointer child parent two stack common suffix share one list repres common suffix common suffix guarante share howev sinc two stack ident content built two separ sequenc push pop oper maximum share suffix achiev use hash cons techniqu new node creat correspond distinct new stack see 1 42 make queue stequ dequ persist simpl one approach advantag give pure function solut repres data structur fix number stack oper becom fix number stack oper seek realtim simul queue stequ dequ fix number stack problem give realtim simul dequ fix number stack close relat old problem ture machin complex give realtim simul onedimension multihead tape unit fix number onedimension onehead tape unit two problem reduc one anoth note dequ simul twohead tape unit onehead tape unit simul two stack thu dequ problem reduc tape problem convers khead tape unit simul dequ two stack stack simul onehead tape thu tape problem reduc dequ problem two gap reduct first dequ element potenti chosen infinit univers wherea univers tape symbol alway finit allow possibl solv tape problem use clever symbol encod might applic dequ problem none known solut tape problem exploit possibl give solut dequ problem reduct second gap reduct necessarili minim number stack onehead tape simul goal dequ tape problem must address directli first step toward solv tape simul problem taken stoss 43 produc lineartim simul multihead tape fix number onehead tape shortli thereaft fisher meyer rosenberg 17 gave realtim simul multihead tape fix number onehead tape latter simul use tapefold techniqu directli relat method stoss later leong seifera 32 gave realtim multiheadtap simul use fewer tape cleverli augment stosss idea approach also work multidimension tape appar true tapefold idea reduct describ dequ simul problem alreadi solv two differ method time work problem began appear data structur function program literatur nevertheless latter work import deal dequ simul problem directli lead effici conceptu simpler solut although sever work 5 8 19 20 21 22 23 34 39 deal dequ simul problem describ essenti solut solut base two key idea mimic idea stoss leong seifera first idea dequ repres pair stack one repres front part dequ repres rear part one stack becom empti mani pop eject oper dequ one stack copi two stack contain half dequ element fiftyfifti split guarante copi even though expens happen infrequ simpl amort argument use potenti function equal absolut valu differ stack size show give lineartim simul dequ constant number stack k dequ oper start empti dequ simul ok stack oper see 44 discuss amort potenti function simpl idea essenc stosss tape simul idea repres queue two stack way appear 5 20 22 represent dequ appear 19 21 23 39 second idea use increment copi convert lineartim simul realtim simul soon two stack becom suffici unbalanc recopi creat two balanc stack begin recopi must proceed concurr dequ oper among thing caus size dequ move target detail simul littl complic hood melvil 22 first spell detail method case queue hood thesi 21 describ simul dequ see also 19 39 chuang goldberg 8 give particularli nice descript dequ simul okasaki 34 give variat simul use memoiz avoid explicit stacktostack copi solut give persist strictli function sinc memoiz side effect complet differ way make dequ persist appli gener mechan driscol et al 14 solut strictli function constant time bound per dequ oper amort worstcas caten ad oper problem make stack dequ persist becom much harder method mention fail kosaraju obtain coupl intrigu result deserv mention although solv problem consid first 30 gave realtim simul caten dequ noncaten dequ unfor tunat solut support confluent persist particular kosaraju explicitli disallow selfcaten solut also realtim fix number dequ time per dequ oper increas least linearli number dequ second 31 gave realtim randomaccess implement caten dequ find minimum oper problem discuss section 7 solut realtim variabl number dequ support confluent persist inde kosaraju 31 state idea might help make mindequ confluent persist howev previou solut problem make caten dequ fulli persist straightforward use balanc tree give represent persist caten dequ oper dequ dequ total size n take olog n time driscol sleator tarjan 13 combin tree represent sever addit idea obtain implement persist caten stack k th oper take olog log buchsbaum tarjan 4 use recurs decomposit tree obtain two implement persist caten dequ first time bound 2 olog k second time bound olog k k th oper log k iter logarithm defin log 1 log 2 k log 1g work motiv 3 recurs slowdown section describ key insight led result although insight explicit ultim construct need understand idea may help make progress problem reason offer spark work observ concern recurr give time bound buchsbaumtarjan data structur recurr follow form c constant oper structur size n take constant amount time plu fix number oper recurs substructur size log n first version buchsbaumtarjan structur c fix constant greater one recurr give time bound n second version structur c equal one recurr give time bound n olog n suppos could design structur constant c less one recurr would give bound n o1 inde recurr give bound n o1 constant c 1 use similar observ improv time bound select minheap ok2 log k ok thu obtain o1 time bound oper data structur oper requir o1 time plu half oper smaller recurs substructur achiev effect data structur requir one oper recurs substructur everi two oper toplevel structur call idea recurs slowdown main new featur data structur mechan implement recurs slow state abstractli basic problem alloc work cycl level linear recurs top level get half cycl second level get one quarter cycl third level get one eighth cycl exactli happen binari count specif begin zero repeatedli add one binari addit one caus uniqu bit posit chang zero one everi second addit posit one bit everi fourth addit two bit everi eighth addit four bit cours binari count addit one chang mani bit zero obtain realtim perform addit work must avoid one use redund digit represent number one represent singl digit chang need add one clanci knuth 9 use idea implement finger search tree descript redund represent well applic found 2 9 28 clancyknuth method repres number base two use three digit 01 2 redund binari represent rbr nonneg number x sequenc digit n represent gener uniqu call rbr regular everi j exist word scan digit signific least signific find 2 must find 0 find anoth 2 run digit impli particular 0 6 2 add 1 number x repres regular rbr first add 1 0 result rbr x 1 may regular restor regular find least signific digit 1 set rbr alreadi regular straightforward show method correctli add 1 chang constant number digit thu avoid explicit carri propag work alloc mechan list use threestat system correspond three digit 0 1 2 clancyknuth number represent instead digit use color level recurs data structur green yellow red color base state structur level red structur bad convert green structur cost degrad structur one level deeper green yellow yellow red maintain invari level two red level separ least one green level ignor interven yellow level greenyellowr mechan appli underli linear structur suffic add constanttim caten stack handl dequ must extend mechan appli underli tree structur involv ad anoth color orang wherea greenyellowr system close analogu clancyknuth number represent extend system distantli relat postpon discuss extens section 6 use 4 dequ without caten section present realtim pure function implement dequ without cate nation exampl illustr idea simpl set provid altern implement base pair increment copi stack describ section 2 section 5 modifi structur support stack caten add caten oper remov eject final section 6 modifi structur support caten dequ oper last step involv extend work alloc mechan mention end section 3 recal oper possibl dequ pushxd popd injectxd ejectd subsequ section say data structur set store element 41 represent repres dequ recurs structur built boundeds dequ call buffer buffer hold five element buffer two kind prefix suffix nonempti dequ set repres order tripl consist prefix prefixd element child dequ childd whose element order pair element suffix suffixd element order element within one consist order compon part child dequ childd nonempti repres way thu structur recurs unwind linearli defin descend fchild dg dequ standard way name child 0 child child nonempti observ element element element childd pair element element childchildd pair pair element one think element child complet binari tree depth 2 element 2 leav one also think entir structur repres stack descend element prefixsuffix pair element store prefix suffix variou level structur group binari tree appropri depth level contain prefix suffix child see figur 41 pair bring two element level one pop eject level 1 similarli move two element level one push inject level 1 twoforon payoff give recurs slowdown lead realtim perform obtain realtim perform must guarante toplevel dequ oper requir chang constant number level recurs structur reason impos regular constraint structur assign buffer dequ color either green yellow red buffer green two three element yellow one four red zero five observ add one element delet one element green yellow buffer without violat size constraint green buffer stay green becom yellow yellow buffer becom green red order color red yellow green red bad green good higher buffer color 2 depth complet binari tree number edg roottoleaf path figur 41 represent dequ squar bracket denot dequ descend dequ parenthes denot buffer curli bracket denot expans dequ compon part number denot level dequ triangl level three denot pair pair pair equival complet binari tree depth three indic insert delet buffer possibl size outsid allow rang defin color nonempti dequ minimum color prefix suffix unless child one buffer empti case color dequ color nonempti buffer regular constraint dequ constraint color sequenc descend dequ childd child call semiregular two red dequ sequenc green dequ ignor interven yellow formal semiregular two red dequ child child j k child k green call regular semiregular addit first nonyellow dequ sequenc green observ regular semiregular childd inde child 0 semiregular furthermor semiregular red childd regular strategi obtain realtim perform maintain constraint toplevel dequ regular except possibl middl dequ oper dequ temporarili becom semiregular regular dequ top level green yellow mean dequ oper perform oper appropri toplevel buffer may chang top level green yellow yellow red either case dequ may longer regular semiregular semiregular topmost nonyellow descend dequ red restor regular chang red dequ green process possibl chang child dequ green yellow yellow red green observ color chang effect restor regular process correspond addit 1 redund binari number system discuss section 3 process chang red dequ green chang element contain order mere move element buffer buffer child thu make chang obtain toplevel regular dequ mere restor level top chang dequ topmost red dequ may arbitrarili deep recurs structur sinc separ top level mani yellow dequ achiev realtim perform need constanttim access topmost red dequ reason repres dequ obviou way stack prefixsuffix pair instead break stack substack one substack toplevel dequ one nonyellow descend dequ top level substack consist toplevel nonyellow dequ consecut yellow proper descend dequ repres entir dequ stack substack prefixsuffix pair use partit substack equival pointerbas represent use node four pointer nonempti descend dequ two pointer prefix suffix correspond level one pointer node child dequ dequ nonempti yellow one pointer node nearest nonyellow proper descend dequ dequ exist nonyellow toplevel see figur 42 figur singl dequ oper requir access top three substack top two element substack color chang caus dequ oper produc minor chang stack partit substack chang made constant time particular chang color toplevel dequ affect partit g r g r figur 42 pointer represent stack substack structur horizont line denot buffer letter indic dequ color left pointer link element within substack right pointer link top substack null pointer denot substack chang topmost red dequ green child yellow nonyellow split one substack first element new substack rest substack pop oper chang topmost red dequ green child green yellow merg singleton substack substack substack push oper 42 dequ oper remain describ detail buffer manipul verifi produc claim color chang perform push pop push pop appropri element onto toplevel prefix unless prefix child dequ empti case toplevel suffix inject eject symmetr origin dequ regular top level origin green yellow oper perform without overflow underflow buffer unless tri pop eject alreadi empti dequ top level may chang green yellow yellow red may make new dequ semiregular restor semiregular dequ regular regular follow let topmost red th st level prefix st th level suffix respect view element perspect level call element p i1 i1 pair sinc pair leve element note either p i1 i1 empti i1 sinc level red appli appropri one follow three case twobuff case jp 2 p i1 empti pop pair i1 inject eject pair p i1 push onto i1 jp eject two element p pair push pair onto p i1 js j 4 pop two element pair inject pair i1 jp pair p i1 inject two element individu p js eject pair i1 push two element bottommost level p i1 i1 empti elimin level 1 onebuff case jp 2 level bottommost level creat new empti level 1 js pop pair i1 inject p i1 eject two element p pair push pair onto p i1 js j 4 pop two element pair inject pair p i1 jp pair p i1 inject two element p js eject pair p i1 push two element onto nobuff case jp contain 2 3 leve element two pair p i1 i1 move element exist note even though dequ oper one end dequ regular procedur oper end descend dequ concurr theorem 41 given regular dequ method describ perform push pop inject eject oper o1 time result regular dequ proof nontrivi part proof verifi regular procedur correct straightforward verifi dequ oper perform correctli time bound o1 given stackofsubstack represent twobuff case occur p i1 i1 nonempti level yellow first two step level start green yellow semiregular make p i1 i1 nonempti make level red remain step make level green chang size p i1 i1 one situat level green end red jp initi jp final case level must bottommost level elimin end case thu case make color chang need restor regular onebuff case occur sinc level initi red level must bottommost level case make level green make level empti case elimin thu case also make color chang need restor regular nobuff case occur p i1 i1 must contain pair otherwis level empti henc nonexist level yellow nonempti contradict fact level topmost red level also one p contain element follow case restor regular 2 data structur describ simplifi subset four oper push pop inject eject allow exampl push allow prefix restrict size 0 3 0 red 1 yellow 2 3 green similarli eject allow suffix restrict size 0 3 0 1 green 2 yellow 3 red thu repres queue inject pop buffer size 3 altern repres stequ pair consist stack queue push onto stack inject queue pop stack unless stack empti case queue 5 realtim caten next goal dequ structur support fast caten sinc caten stequ dequ without eject easier implement caten dequ discuss caten stequ delay discuss structur support full set oper section 6 throughout rest paper refer caten stequ simpli stequ 51 represent represent stequ like structur section 4 two major differ compon part section 4 use buffer two differ kind prefix suffix unlik section 4 buffer noncaten stequ upper bound size stequ implement use either method section 4 stackrevers method sketch section 2 possibl effici enhanc store buffer size although fact necessari obtain constanttim oper requir prefix contain least two element lower bound size suffix inde suffix empti second differ compon pair store child stequ defin pair set recurs follow pair consist prefix element possibl empti stequ pair repres nonempti stequ either suffix suffix element tripl consist prefix prefix element child stequ child pair suffix suffix element child stequ nonempti repres way nonempti stequ one pair child order element within stequ one consist order compon path figur 51 figur 51 partial expans represent stequ squar bracket denot caten stequ horizont line denot buffer curli bracket denot expans stequ compon part arrow denot membership circl denot element base set number denot level stequ figur structur doubli recurs stequ structur either toplevel stequ child anoth stequ second compon pair store anoth stequ defin level stequ structur follow toplevel stequ level 0 stequ level child leve stequ pair store leve observ everi leve stequ type element name element level0 stequ element element level1 stequ pair element level2 stequ pair pair stequ caten need level otherwis element differ type extra kind recurs compar structur section 4 one sequenc descend stequ mani toplevel stequ stequ store pair structur begin sequenc consist stequ child grandchild among descend one repres suffix instead prefix child suffix tripl last one may order stequ oper term implement complex follow push inject simplest caten nextsimplest pop mostcompl push inject simpl oper singl buffer buffer grow arbitrarili larg mean overflow problem perform caten oper push inject oper extra kind recurs pop complic oper requir caten may also threaten buffer underflow prevent mechan like use section 4 prefix color red prefix contain two element yellow three green four nonempti stequ structur also color color prefix one otherwis green call stequ semiregular pair red stequ descend sequenc within green stequ ignor interven yellow call stequ regular semiregular addit first nonyellow stequ sequenc child 1 child green section 4 maintain invari toplevel stequ regular except possibl middl stequ oper may temporarili semiregular observ regular child semiregular semiregular stequ green prefix child stequ regular represent stequ correspond section 4 name repres descend sequenc stack substack break descend sequenc subsequ begin first stequ nonyellow stequ contain consecut follow yellow stequ element substack pair consist prefix suffix correspond stequ null indic nonexist prefix element prefix suffix element base set prefix suffix level 0 pair appropri type prefix suffix deeper structur see figur 52 r g r g figur 52 pointer represent substack decomposit part partial expand stequ figur 51 sequenc descend shown letter denot stequ color left pointer link element within substack right pointer link top substack null pointer denot 52 stequ oper note push inject oper simplest stequ oper implement chang singl buffer increas size one specif inject element x stequ inject x suffix push element x onto stequ push x onto prefix unless prefix case push x onto suffix push may chang color toplevel stequ red yellow yellow green help regular constraint chang substack decomposit caten oper somewhat complic consist push inject oper specif form caten 3 two stequ 1 2 appli appropri one follow three case case 1 1 tripl suffix 1 contain least two element inject pair suffix 1 child 1 convert suffix 1 prefix otherwis suffix 1 contain one element push element onto 2 2 tripl inject pair prefix 2 3 tripl prefix 1 case 2 1 suffix 2 tripl jsuffix 1 j 4 push pair prefix 2 onto let result 3 tripl suffix 1 green prefix otherwis pop three element suffix 1 push opposit order onto prefix 2 let 3 prefix 2 case 3 1 2 suffix jsuffix 1 j 4 let 3 suffix 1 suffix 2 make suffix 1 green prefix otherwis pop three element suffix 1 push opposit order onto suffix 2 let 3 suffix 2 lemma 51 1 2 semiregular 3 semiregular addit 1 regular 3 regular proof case 3 stequ 3 toplevel one green thu 3 regular case 2 push onto child 2 happen preserv semiregular child 2 prefix result stequ 3 green thu 3 regular case 1 child 1 child 2 semiregular inject child 1 preserv semiregular stequ 1 prefix 1 child stequ 1 save possibl one two inject thu 3 semiregular 1 regular 1 2 pop complic stequ oper pop stequ suffix mere pop suffix pop stequ tripl pop prefix may result stequ longer regular semiregular restor regular modifi nearest red descend stequ say 1 toplevel stequ follow child 1 empti pop two element prefix 1 push opposit order onto suffix 1 repres 1 suffix otherwis pop pair say p pop two element prefix 1 push opposit order onto p caten 2 child 1 form 3 replac 1 tripl p 3 lemma 52 restor method describ convert semiregular stequ regular thu implementaiton pop correct proof let 1 nearest red descend stequ child 1 empti 1 replac green stequ child result regular stequ suppos child 1 nonempti pop regular semiregular sinc 1 semiregular sinc 1 red nearest nonyellow descend child 1 must green henc child 1 least semiregular pop tripl p 3 replac 1 p green 3 semiregular mean regular 2 theorem 51 push pop inject regular stequ take o1 time result regular stequ caten two regular stequ take o1 time result regular stequ proof o1 time bound per stequ oper obviou stack substack represent use regular obviou push inject true caten lemma 51 pop lemma 52 2 altern way build realtim caten stequ use noncaten stack buffer see 25 6 caten dequ final extend idea present previou two section obtain data structur support full set dequ oper name push pop inject eject caten o1 time omit certain definit obviou extens previou section common featur two data structur present far underli linear skeleton sequenc descend structur caten dequ replac linear skeleton binarytre skeleton seem requir effici handl pop eject branch skeleton turn requir chang workalloc mechan must funnel comput cycl branch tree add one color orang color scheme replac twobeat rhythm greenyellowr mechan threebeat rhythm obtain o1 time bound per dequ oper essenti 23 1 2 correspond branch factor tree structur 3 correspond rhythm work cycl connect redund number system much looser greenyellow red scheme use section 4 5 nevertheless abl show directli extend mechan solv problem 61 represent represent dequ use two kind buffer prefix suffix buffer noncaten dequ implement buffer either describ section 4 use increment stackrevers method outlin section 2 henceforth dequ mean caten dequ unless explicitli state otherwis section 5 option store buffer size may provid constantfactor speedup defin tripl set recurs prefix element possibl empti dequ tripl suffix element tripl dequ call store tripl repres nonempti dequ either one tripl call tripl order pair tripl left tripl right tripl dequ within tripl repres recurs way order element within dequ one consist order compon part defin parentchild relat tripl follow dequ suffix tripl dequ 6 children one two tripl make dequ defin ancestor descend standard way relat tripl group tree whose node unari binari toplevel tripl store tripl root tree dequ repres one two tree root toplevel tripl figur 61 figur 61 partial expans represent caten dequ convent figur 51 two tripl compris dequ separ comma figur 61 four differ kind tripl store tripl tripl left tripl right tripl impos size constraint buffer tripl depend upon kind store tripl requir p contain least three element unless one buffer empti case buffer must contain least three element tripl requir p contain least five element unless one buffer empti case buffer contain nonzero number element left tripl requir p contain least five element exactli two symmetr right tripl requir contain least five element p exactli two assign color tripl base type buffer size follow let tripl store tripl green left tripl 6 green p contain least eight element yellow p contain seven orang six red five symmetr right tripl 6 green contain least eight element yellow seven orang six red five tripl 6 green p contain least eight element yellow one contain seven least seven orang one contain six least six red one contain five least five tripl group tree parentchild relat partit tree path follow yellow orang tripl prefer child left child child tripl yellow right child child tripl orang prefer children defin prefer path start tripl prefer child pass success prefer children reach tripl without prefer child thu prefer path consist sequenc zero yellow orang tripl follow green red tripl everi tripl children green assign prefer path color green red accord color last tripl impos regular constraint structur like section 4 5 littl complic call dequ semiregular follow condit hold 1 everi prefer path start child red tripl green path 2 everi prefer path start nonpref child orang tripl green path definit impli dequ semiregular dequ constitu tripl semiregular call dequ regular semiregular addit prefer path start toplevel tripl one one two repres entir dequ green path maintain invari toplevel dequ regular except possibl middl dequ oper may temporarili semiregular note empti dequ regular need represent tree tripl allow us shortcut prefer path end introduc notion adopt child adopt parent everi green red tripl prefer path least three tripl adopt child first tripl path adopt parent adopt parentadopt child relationship first last tripl prefer path contain least three tripl defin compress forest parentchild relat tripl except adopt child child adopt parent instead natur parent compress forest tripl three children one may adopt repres dequ compress forest node tripl contain prefix suffix tripl pointer node repres child tripl see figur 62 figur oper describ next section reli follow properti compress forest represent given node tripl extract constant time pointer compress forest represent toplevel tripl store tripl color either red green 62 dequ oper simplest dequ oper push inject next caten may requir push inject complic oper pop eject violat regular may forc repair deep forest tripl shallow compress forest begin describ push inject symmetr let dequ onto wish push element empti creat new tripl repres new dequ one nonempti buffer contain push element nonempti let left tripl tripl p 1 nonempti push new element onto otherwis push new element onto 1 g r g g figur 62 toplevel tree compress forest represent dequ letter denot tripl correspond color dash arrow denot adoptivepar adoptivechild relationship replac natur parentchild relationship mark hatch arrow complet compress forest represent shown would includ buffer tripl lowerlevel compress tree root store tripl lemma 61 push onto semiregular dequ produc semiregular dequ push onto regular dequ produc regular dequ proof push chang color lemma immedi push chang color must yellow green orang yellow red orang redtoorang happen origin dequ semiregular regular yellow togreen case obvious preserv semiregular regular orangetoyellow case let u nonpref child push nonpref child u exist semiregular impli prefer path contain u green path push add front path mean push preserv semiregular regular u exist push chang prefer path chang orang yellow case also push preserv semiregular regular redtoorang case push everi child start prefer path green mean push nonpref child exist start prefer path green thu push preserv semiregular 2 note effect push prefer path decomposit add delet front prefer path mean compress forest updat o1 time push next describ caten let e two dequ caten assum nonempti otherwis caten trivial caten e appli appropri one follow four case case 1 buffer two three four toplevel tripl e nonempti new dequ consist two tripl u form toplevel tripl tripl u form toplevel tripl tripl e four subcas format subcas 1a dequ consist two tripl contain exactli two element singl buffer p 3 eject last two element 2 add new buffer 3 2 rest inject p 3 subcas 1b dequ consist two tripl inject element 1 p 2 p 1 form p 0 1 replac represent tripl p 0 appli subcas 1c 1d appropri subcas 1c dequ consist tripl eject last two element 1 add new buffer 2 let remaind 1 0 1 form new tripl 0 inject 1 form 0 subcas 1d dequ consist tripl contain eight element move last two element 1 p 1 form p 0 let remain two element 1 form 0 contain eight element move first three element 1 p 1 form p 0 move last two element 1 new buffer 2 let remaind 1 0 1 push tripl 0 empti dequ form dequ 2 let oper symmetr e form u case 2 dequ consist tripl one nonempti buffer buffer toplevel tripl tripl e nonempti let left tripl e combin 1 2 form new tripl left tripl new dequ right tripl e exist right tripl new dequ form let p 3 nonempti one p 1 1 p 3 contain less eight element push element otherwis form tripl p 2 push onto 2 case 3 dequ e consist tripl one nonempti buffer buffer toplevel tripl tripl nonempti case symmetr case 2 case 4 dequ e consist tripl singl nonempti buffer let p nonempti buffer nonempti buffer e either p contain fewer eight element combin singl buffer b let lemma 62 caten two semiregular dequ produc semiregular dequ caten two regular dequ produc regular dequ proof consid case 1 shall show subcas tripl descend satisfi semiregular regular constraint appropri symmetr argument appli u give lemma case 1 subcas 1d tripl green either green child grandchildren child either case satisfi regular constraint consid subcas 1c dequ 0 1 form semiregular dequ 1 inject henc semiregular lemma 61 color tripl least good color tripl sinc color depend size p 1 wherea color 1 depend minimum size p 1 1 must consid sever case depend color 1 whether tri verifi regular semiregular 1 green descend satisfi regular constraint 1 red semiregular impli 1 henc 0 1 regular descend satisfi semiregular constraint 1 orang regular 1 henc 0 1 must regular descend satisfi regular constraint 1 orang semiregular nonpref child 1 exist start green path correspond nonpref child also start green path argument like lemma 61 mean descend satisfi semiregular constraint 1 yellow semiregular 0 1 impli descend satisfi semiregular constraint final 1 yellow regular prefer child 1 green path correspond child argument like lemma 61 thu descend satisfi regular constraint subcas 1b creat onetripl represent semiregular origin represent regular origin one subcas 1b follow applic 1c 1d appropri case tripl descend satisfi semiregular regular constraint appropri last subcas subcas 1a case 1c argument depend color whether tri verifi regular semiregular case 1 exactli color dequ 0 1 semiregular lemma 1 sinc 1 2 semiregular remaind argument exactli subcas 1c consid case 2 p 3 contain less eight element form seven push onto 2 satisfi regular semiregular lemma 61 otherwis dequ 0 2 form dequ 2 push tripl either green color tripl remaind argument exactli subcas 1c case 3 symmetr case 2 case 4 obvious preserv semiregular regularitya caten chang color composit tripl constant number level top compress forest structur henc structur updat constant time caten come final last two oper pop eject shall describ pop eject symmetr pop consist two part first remov element pop second repair damag regular caus remov let left tripl dequ pop first part pop consist pop prefix pop suffix prefix empti replac tripl 0 result pop form 0 shall see 0 may regular semiregular prefer path start 0 may red case let u red tripl end prefer path use compress forest represent access u constant time second part pop replac u descend tree tripl repres element green root v satisfi regular constraint produc regular represent 0 finish pop repair appli appropri one follow case sinc u red case 1 tripl u left tripl pop first tripl p 1 rest 1 case 1a p 2 2 nonempti push 2 onto 0 1 push element 2 caten dequ 2 00 case 1b one p 2 2 empti combin singl buffer p 3 let case 2 tripl u tripl appli appropri one follow three case case 2a suffix 1 contain least eight element proceed case 1 obtain contain least eight element case 2b prefix p 1 contain least eight element proceed symmetr case 1 obtain contain least eight element case 2c p 1 1 contain seven element pop first tripl p 1 without repair let 0 1 rest 1 0 otherwis eject last tripl 1 without repair let 00 1 rest 0 1 one p 2 2 empti combin singl buffer p 4 let 00 push element p 1 onto p 2 form p 4 caten 2 000 1 form 4 symmetr one p 3 3 empti combin p 3 3 1 singl buffer 4 let otherwis inject p 3 4 form 0 inject element 1 4 3 form 5 let lemma 63 remov first element first buffer regular dequ produc semiregular dequ whose violat regular constraint prefer path contain left toplevel tripl may red remov first last element first last buffer respect regular dequ produc semiregular dequ proof let regular dequ let left tripl let 0 form pop p 1 let 0 form replac 0 green yellow orang red regular 0 yellow orang red respect one transit occur unless 0 green case 0 regular sinc case easi verifi regular impli tripl 0 satisfi appropri semiregular constraint tripl sinc color dont chang possibl violat regular prefer path contain 0 may red analog argument show last element 0 remov form 00 00 still semiregular tripl two remov degrad color one color left tripl argument symmetr appli sibl 2 lemma 64 pop regular dequ produc regular dequ proof let dequ pop let 0 dequ form remov first element first buffer let 0 left tripl 0 lemma 63 0 semiregular violat regular prefer path contain 0 may red prefer path green 0 regular pop finish lemma true suppos hand prefer path red let red tripl path sinc 0 semiregular u red 1 must regular claim repair describ case 1 2 replac u descend tree tripl green root satisfi semiregular constraint impli dequ 00 result repair regular thu give lemma consid case 1 sinc 1 regular dequ 0 1 form 1 pop tripl case 1a push onto 0 1 form 00 leav 00 lemma 61 dequ 2 semiregular sinc 1 regular lemma 62 dequ 3 form caten 2 00 1 semiregular tripl give claim case 1b tripl 1 semiregular give claim consid case 2 argument case 1 verifi claim case 2a 2b case 2c 0 green 2 semiregular give claim case 2c 00 1 semiregular lemma 63 dequ 5 semiregular appropri applic lemma 61 62 v green claim true 2 oper pop chang constant number level top compress forest henc perform constant time theorem 61 dequ oper take o1 time preserv regular proof straightforward verifi compress forest represent allow dequ oper perform describ o1 time lemma 61 62 64 give preserv regular 2 dequ represent present hybrid two altern structur describ 25 one base pair quadrupl suggest okasaki 34 base tripl quintupl present structur offer conceptu simplif altern buffer size constraint represent reduc slightli cost make structur less symmetr exampl lower bound suffix size right tripl tripl reduc one modifi definit color appropri 7 result open problem conclud section addit result open problem begin two extens structur mention recent work final give open problem set element store dequ total order extend structur describ support addit heap order base order specif support addit oper find minimum element dequ delet oper remain constanttim implement remain pure function mere store buffer dequ pair minimum element contain relat work see 3 4 19 31 also support flip oper dequ structur section 4 6 flip oper revers linear order element dequ ith front becom ith back viceversa noncaten dequ section 4 implement flip maintain revers bit flip flip oper revers bit set push becom inject pop becom eject inject becom push eject becom pop support caten well flip requir littl work need symmetr structur add revers bit level nonsymmetri structur definit prefer children prefer child yellow tripl left child prefer child orang tripl right child flip exchang left right want oper chang prefer children want partit compress forest prefer path unaffect flip thu creat brandnew tripl design current left child prefer child yellow current right child prefer child orang tripl chang orang yellow yellow orang switch prefer child irrespect current left right handl flip add revers bit everi dequ everi buffer structur revers bit set 1 mean entir dequ buffer flip revers bit cumul along path descend compress forest given dequ buffer revers odd number ancestor includ revers bit set 1 flip entir dequ flip revers bit whenev dequ oper push revers bit structur dequ actual manipul revers revers buffer push inject pop eject switch role detail straightforward turn recent relat work work independ okasaki 33 35 devis confluent persist implement caten stack stequ implement realtim give constant amort time bound per oper also pure function use memoiz okasaki use root tree repres stack element pop use memoiz version path revers techniqu previous use data structur disjoint set union problem 45 though okasaki solut neither realtim pure function simpler extend okasaki method case dequ open problem see earli version work 27 okasaki 35 36 observ amort time bound suffic memoiz allow data structur consider sim plifi idea perform fix lazi fashion use memoiz record result avoid need maintain stack stack structur represent also allow buffer shorter okasaki call result gener method implicit recurs slow argu standard techniqu amort analysi 44 suffic case need deal persist idea fact much gener recurs slowdown howev standard techniqu 44 inde suffic analysi work okasaki devis even simpler version structur need constants buffer take o1 amort time per dequ oper use replac oper gener memoiz 26 final mention open problem note one extend okasaki path revers techniqu dequ second one modifi structur section 6 use buffer bound size know case stack doubleend case unresolv technic cours one solut plug structur section 4 inlin structur section 6 simplifi extent possibl direct approach may well work lead simpler solut anoth open problem devis version structur section 6 use one subdequ instead two thu lead linear recurs structur final open problem devis pure function implement finger search tree randomaccess list constanttim caten best solut problem olog log n caten time 28 acknowledg thank adam buchsbaum david wagner ian munro chri okasaki vital contribut paper adam buchsbaum engag extens fruit discuss concern idea david wagner suggest idea color invari altern explicit use binari count work alloc mechan ian munro see present idea point connect color invari redund binari represent 9 chri okasaki provid valuabl comment draft work also thank refere insight valuabl suggest r anatomi lisp data structur bootstrap confluent persist dequ via data structur bootstrap effici function implement fifo queue search histori fraction cascad program problemsolv seminar fulli persist array effici use past fulli persist list caten make data structur persist theori practic firstclass prompt abstract continu mathemat semant handl full function jump optim select minheap dequ heap order scienc program effici implement veryhighlevel program languag construct symmetr set effici list oper store partial continu firstclass object languag environ pure function list simpl confluent persist caten list extend abstract persist list caten via recurs slowdown pure function represent caten sort list fundament algorithm optim ram implement caten min doubleend queue new realtim simul multihead tape unit persist list caten via lazi link simpl effici pure function queue dequ pure function data structur caten doubleend queue search past search past persist data structur planar point locat use persist search tree control delimit hierarchi exampl hierarch design proof amort comput complex worst case analysi set union algorithm tr worstcas analysi set union algorithm search histori planar point locat use persist search tree search sort similar list dequ heap order abstract continu mathemat semant handl full jump make data structur persist store partial continu firstclass object languag environ theori practic firstclass prompt control delimit hierarchi realtim dequ multihead ture machin pure function program optim algorithm select minheap fulli persist list caten confluent persist dequ via datastructur bootstrap datastructur bootstrap linear path compress caten heapord doubleend queue persist list caten via recurs slowdown pure function represent caten sort list caten doubleend queue pure function list pure function data structur worstcas effici prioriti queue optim ram implement caten min doubleend queue realtim simul multihead tape unit new realtim simul multihead tape unit exampl hierarch design proof art comput program volum 13 box set scienc program anatomi lisp simpl confluent persist caten list extend abstract fulli persist array extend array amort lazi evalu persist realtim simul concaten doubleend queue doubleend queue preliminari version program problemsolv seminar effici implement veryhighlevel program languag construct persist data structur ctr amo fiat haim kaplan make data structur confluent persist proceed twelfth annual acmsiam symposium discret algorithm p537546 januari 0709 2001 washington dc unit state amo fiat haim kaplan make data structur confluent persist journal algorithm v48 n1 p1658 august georg lagogianni yanni panagi spyro siouta athanasio tsakalidi survey persist data structur proceed 9th wsea intern confer comput p16 juli 1416 2005 athen greec