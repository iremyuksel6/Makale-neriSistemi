fulli dynam algorithm recogn repres proper interv graph paper studi problem recogn repres dynam chang proper interv graph input problem consist seri modif perform graph modif delet addit vertex edg object maintain represent graph long remain proper interv graph detect ceas represent enabl one effici construct realiz graph inclusionfre famili interv problem import applic physic map dnaw give nearoptim fulli dynam algorithm problem oper olog n worstcas time per edg insert delet prove close lower bound omegalog nloglog nlog b amort time per oper cell probe model wordsiz b also construct optim increment decrement algorithm problem handl edg oper o1 time byproduct algorithm solv olog n worstcas time problem maintain connect dynam chang proper interv graph b introduct graph g call interv graph vertic assign interv real line two vertic adjac g iff interv intersect set interv assign vertic g call realiz g set interv chosen inclusionfre g call proper interv graph proper interv graph studi extens literatur cf 7 13 sever linear time algorithm known recognit realiz 2 3 paper deal problem recogn repres dynam chang proper interv graph input seri oper perform graph oper follow ad vertex along edg incid delet vertex edg incid ad edg delet edg object maintain represent dynam graph long proper interv graph detect ceas represent enabl one effici construct realiz graph increment version problem addit oper permit ie oper includ addit vertex addit edg decrement version problem delet oper allow motiv problem come applic physic map dna 1 physic map process reconstruct rel posit dna fragment call clone along target dna molecul prior sequenc base inform pairwis overlap biolog framework set clone virtual inclusionfre exampl clone similar length case instanc cosmid clone case physic map problem model use proper interv graph follow graph g built accord biolog data clone repres vertex two vertic adjac iff correspond clone overlap physic map problem translat problem find realiz g determin none exist overlap inform accur two problem would equival howev biolog techniqu may occasion lead incorrect conclus whether two clone intersect addit experi may chang statu intersect two clone result chang correspond graph delet edg addit edg set clone also subject chang ad new clone delet bad clone chimer 14 translat addit delet vertic correspond graph therefor would like abl dynam chang graph reflect chang biolog data long allow us construct map ie long graph remain proper interv graph sever author studi problem dynam recogn repres certain graph famili hsu 10 given om n log ntime increment algorithm recogn interv graph throughout denot number vertic graph n number edg deng hell huang 3 given lineartim increment algorithm recogn repres connect proper interv graph algorithm requir graph remain connect throughout modif algorithm 10 3 vertex increment handl recent ibarra 11 found fulli dynam algorithm recogn chordal graph handl edg oper time altern edg delet log n time edg insert log n time result follow gener problem recogn repres proper interv graph give fulli dynam algorithm handl oper time od log n denot number edg involv oper thu case vertex ad delet equal degre case edg ad delet 1 algorithm build represent proper interv graph given 3 also prove lower bound problem omega log nlog log n log b amort time per edg oper cell probe model comput wordsiz b 16 follow algorithm nearli optim factor olog log n increment decrement version problem give optim algorithm constant factor handl oper time od increment problem gener result 3 arbitrari instanc part gener algorithm give fulli dynam procedur maintain connect proper interv graph procedur receiv input sequenc oper vertex addit delet edg addit delet queri whether two vertic connect compon assum graph remain proper interv throughout modif sinc otherwis main algorithm detect graph longer proper interv graph halt show implement procedur olog n time per oper compar ison best known algorithm maintain connect gener graph requir olog 2 n amort time per oper 9 n worstcas determinist time per oper 4 also show lower bound fredman henzing 5 omega log nlog log nlog b amort time per oper cell probe model wordsiz b maintain connect gener graph appli problem maintain connect proper interv graph paper organ follow section 2 give basic background describ represent proper interv graph realiz defin section 3 4 present increment algorithm section 5 extend increment algorithm fulli dynam algorithm proper interv graph recognit represent also deriv optim decrement algorithm section 6 give fulli dynam algorithm maintain connect proper interv graph final section 7 prove lower bound amort time per oper fulli dynam algorithm recogn proper interv graph lack space proof algorithm detail omit preliminari e graph denot set v vertic also v g set e edg also eg vertex n v n v fvg let r equival relat v defin urv iff equival class r call block g note everi block g complet subgraph g size block number vertic two block b neighbor g henc vertic 2 b 2 b adjac g straight enumer g linear order phi block g everi block block neighbor block consecut phi l order block g 1 say order left b j b j order right b chordless cycl induc cycl length greater 3 claw induc k 13 graph clawfre contain induc claw basic definit graph theori see eg 7 follow use fact interv proper interv graph theorem 1 12 interv graph contain chordless cycl theorem 2 15 graph proper interv graph iff interv clawfre theorem 3 3 graph proper interv graph iff straight enumer lemma 1 umbrella properti let phi straight enumer connect proper interv graph g b c block g adjac c b adjac c see figur 1 fig 1 umbrella properti let g connect proper interv graph let phi straight enumer g shown 3 connect proper interv graph uniqu straight enumer full revers defin outdegre block b wrt phi denot ob number neighbor b order right phi shall use follow represent connect compon dynam graph maintain straight enumer fact technic reason shall maintain enumer revers detail data structur contain inform describ inform implicitli defin realiz dynam graph cf 3 follow assign vertex block b interv outdegre henc realiz graph comput data structur time 3 increment algorithm vertex addit follow two section describ optim increment algorithm recogn repres proper interv graph algorithm receiv input seri addit oper perform graph upon oper algorithm updat represent graph halt current graph longer proper interv graph algorithm handl oper time od denot number edg involv oper assum initi graph empti altern represent initi graph known contig connect proper interv graph g straight enumer g first last block contig call endblock rest block call innerblock mention compon dynam graph exactli two contig full revers maintain algorithm oper involv updat represent sequel concentr describ one two contig compon second contig updat similar way 31 data structur follow data kept updat algorithm 1 vertex keep name block belong 2 block keep follow end pointer null block endblock contig otherwis point endblock contig b size block c left right near pointer point nearest neighbor block left right respect left right far pointer point farthest neighbor block left right respect e left right self pointer point block f counter follow shall omit detail obviou updat name block vertex size block execut algorithm may need updat mani far pointer point certain block point anoth block order abl o1 time use techniqu nest pointer make far pointer point locat whose content address block far pointer point role special locat serv selfpoint valu left right selfpoint b alway address b say certain left right far pointer point b mean point left right selfpoint b let b block order chang left right far pointer point point b requir left right far pointer point b case simpli exchang left right selfpoint left right selfpoint b mean 1 previou left right selfpoint made point b algorithm record new left right self pointer b 2 previou left right selfpoint b made point algorithm record new left right selfpoint shall use follow notat block b denot address memori b set far pointer point left right selfpoint b abbrevi set b denot left right near pointer b l b n r b respect denot left right far pointer b f l b f r b respect denot end pointer eb sequel often refer block address exampl b block n r sometim refer b n r clear context also use name block denot vertex block given contig phi denot revers phi r gener perform oper denot graph oper carri g graph oper carri g 0 32 impact new vertex follow describ chang made represent graph case g 0 form g addit new vertex v degre also give necessari suffici condit decid whether g 0 proper interv let b block g say v adjac b v adjac vertex b say v fulli adjac b v adjac everi vertex b say v partial adjac b v adjac b fulli adjac b follow lemma character assum g 0 proper interv adjac new vertex lemma 2 g 0 proper interv graph v neighbor two connect compon g lemma 3 3 let c connect compon g contain neighbor v let contig c assum g 0 proper interv let 1 k follow properti satisfi 1 v adjac b b c v fulli adjac b b 2 v adjac b b fulli adjac b b c b adjac b c 3 adjac b b v fulli adjac b one view contig phi connect proper interv graph c weak linear vertic c x phi iff block contain x order phi left block contain say phi 0 refin phi everi contig revers also allow complet revers phi lemma 4 g connect induc subgraph proper interv graph g 0 phi contig g phi 0 straight enumer g 0 phi 0 refin phi note whenev v partial adjac block b g addit v caus b split two block g 0 name b nn v b n v otherwis b block g v either fulli adjac adjac b also block g 0 corollari 1 b block g v partial adjac b n n v occur consecut straight enumer g 0 lemma 5 let c connect compon g contain neighbor v let set block c adjac v fb g assum contig g 0 proper interv follow properti satisfi consecut c 2 k 3 v fulli adjac b 3 v adjac singl block b 1 c b 1 endblock 4 v adjac one block c neighbor anoth compo nent b 1 adjac b k one b 1 b k endblock v fulli adjac innerblock proof claim 1 2 follow directli part 1 lemma 3 claim 3 follow part 3 lemma 3 prove last part lemma let us denot compon contain neighbor v examin induc connect subgraph h g whose set vertic v h proper interv induc subgraph g compos three type block block whose vertic v c call henceforth cblock block whose vertic v call henceforth dblock fvg block h sinc fvg connect block c remain intact h except b 1 b k might split b j n n v sure contig h cblock must order complet complet dblock let phi denot contig h cblock order block let x denot rightmost cblock phi umbrella properti moreov x adjac v lemma 4 phi refin contig c henc precis therefor one b 1 b k endblock wlog suppos contrari v fulli adjac b k lemma 4 contradict umbrella properti b 1 must adjac b k els g 0 contain claw consist vertex v dn v remain show b 1 innerblock suppos end block sinc b 1 b k adjac c contain singl block contradict thu claim 4 prove 33 algorithm algorithm reli increment algorithm deng hell huang 3 call henceforth dhh algorithm algorithm handl insert new vertex graph od time provid neighbor connect compon chang straight enumer compon appropri refer reader 3 detail perform follow upon request ad new vertex v neighbor u v add one count block contain u call block full counter equal size empti counter equal zero partial otherwis order find set consecut block contain neighbor v pick arbitrarili neighbor v march enumer block left use left near neighbor pointer continu till hit empti block till reach end contig right way discov maxim sequenc nonempti block compon contain neighbor v call maxim sequenc segment two extrem block segment allow partial els fail lemma 52 segment found contain neighbor v use dhh algorithm order insert v g updat intern data structur accordingli otherwis lemma 2 51 could one segment contain neighbor v case exactli one extrem block segment endblock v fulli adjac segment contain one block two extrem block segment adjac els fail lemma 534 proceed find second segment contain neighbor v make sure two segment two differ contig check endblock point also check condit 3 4 lemma 5 satisfi two segment cover neighbor v fail v adjac vertic two distinct compon c merg contig let r two contig c let l psi r two contig way merg perform depend block v adjac v adjac b k b 0 umbrella properti two new contig refin describ follow describ necessari chang data structur case new contig three case handl similarli block enumer merg two enumer block put new block fvg inbetween two contig let leftmost block adjac v new order let rightmost block adjac v b 0 partial split two block order b 0 j partial split two block v order end pointer set eb 1 l nullifi end pointer b k b 0 1 near pointer updat n l n l b 0 case b split updat n r made case b 0 split near pointer b 0 j1 far pointer b split set f l left selfpoint b left selfpoint split set f r 1 exchang right selfpoint j right selfpoint j addit set right far pointer left far pointer b 0 j fvg od time final set f l 4 increment algorithm edg addit section show handl addit new edg u v o1 time character case g proper interv show effici detect updat represent graph lemma 6 u v distinct compon g g 0 proper interv iff u v endblock respect contig proof prove part let us examin graph fug h proper interv induc subgraph g g 0 proper interv lemma must endblock contig sinc u adjac vertex compon contain v argument appli u prove part give straight enumer new connect compon contain u v g 0 denot c compon contain u v respect let contig c l contig l straight enumer new compon check o1 time u v endblock distinct contig case updat data structur accord straight enumer given proof lemma 6 o1 time remain handl case u v connect compon c g n umbrella properti follow c contain three block merg singl block g 0 case g 0 proper interv updat intern data structur trivial follow lemma analys case n u 6 n v lemma 7 let contig c k assum n u 6 n v g 0 proper interv iff g proof prove part assum g 0 proper interv sinc b b j adjac f r b suppos contrari addit f l b strict contain v z distinct block exist vertex b 2 n vn n z v b z u induc claw g 0 contradict henc f l b f r b distinct block either u 62 eg vertex 2 n u n n x first case v u x vertic shortest path v induc chordless cycl g 0 second case u x v induc claw g 0 henc case arriv contradict proof f l b prove part shall provid straight enumer c fu vg move v b j contain v f l b move u b b i1 u move b oe fug split b b n fug fug order v move b j oe fvg split b j fvg b j n fvg order easi see result straight enumer c fu vg check o1 time condit lemma 7 hold case chang data structur reflect new straight enumer given proof lemma 7 done o1 time similar fashion updat techniqu describ section 33 detail omit follow theorem summar result section 3 4 theorem 4 increment proper interv graph represent problem solvabl o1 time per ad edg 5 fulli dynam algorithm section give fulli dynam algorithm recogn repres proper interv graph algorithm perform oper od log n time denot number edg involv oper support four type oper ad vertex ad edg delet vertex delet edg base idea use increment algorithm main difficulti extend increment algorithm handl type oper updat end pointer block delet allow bypass problem keep end pointer instead maintain connect compon g use inform algorithm next section show maintain connect compon g olog n time per oper describ oper handl algorithm 51 addit vertex edg oper handl essenti way done increment algorithm howev order check endblock two segment distinct compon queri data structur connect compon olog n time similarli order check endpoint ad edg distinct compon check correspond block distinct compon olog n time 52 delet vertex show next updat contig g delet vertex v degre note g 0 proper interv induc subgraph g denot x block contain v x oe fvg chang need delet v henc concentr case fvg find od time segment block includ x neighbor let contig contain x let block segment make follow updat l check whether b merg b igamma1 f l b move vertic b b igamma1 od time delet b l act similarli wrt b j b j1 final delet b l nonadjac umbrella properti longer connect compon contig split two contig one end b lgamma1 one begin b l1 merg updat n r b updat made wrt case merg contig split nullifi n r b lgamma1 l b l1 otherwis updat n r b merg exchang right selfpoint b right selfpoint b igamma1 similar chang made wrt b j also set right far pointer previous point b l b left far pointer previous point b l b l1 od time note updat take od time requir knowledg connect compon g 53 delet edg let u v edg g delet let c denot connect compon g contain u v let contig c result straight enumer g 0 updat trivial case n one show g proper interv graph iff c cliqu k 1 assum henceforth k 1 wlog far neighbor split contig two contig one end b begin b j otherwis updat straight enumer deriv follow lemma lemma 8 let contig c k assum n u 6 n v g 0 proper interv iff f r b f l b g proof assum g 0 proper interv show f r b proof f l b adjac g f r b suppos contrari f r b distinct block either vertex 2 n v n n x vertex b 2 n x n n v first case umbrella properti u 2 eg therefor u x v induc chordless cycl g 0 second case x b u v induc claw g 0 henc case arriv contradict prove opposit direct give straight enumer c n fu vg move u b igamma1 b contain u f r b j1 u move fug order v move fvg order result contig vg condit lemma 8 fulfil one updat data structur accord proof updat requir knowledg connect compon g shown take o1 time henc section 52 53 obtain follow result theorem 5 decrement proper interv graph represent problem solvabl o1 time per remov edg 6 maintain connect compon section describ fulli dynam algorithm maintain connect proper interv graph g ologn time per oper algorithm receiv input seri oper perform graph follow ing ad vertex ad edg delet vertex delet edg queri two block connect compon algorithm depend data structur includ block contig graph henc interact proper interv graph represent algorithm respons updat request chang made represent graph base structur connect compon prior updat connect compon graph updat let us denot bg block graph g graph vertex correspond block g two vertic adjac iff correspond block adjac g algorithm maintain span forest f bg order decid two block connect compon algorithm check belong tree f key idea design f effici updat upon modif g defin edg f follow everi two vertic u v bg correspond block consecut contig g cons quentli tree f path repres contig crucial observ f addit delet vertex edg g induc o1 modif vertic edg f seen note modif g induc o1 updat near pointer represent g remain show implement span forest tree may cut edg delet f link edg insert f allow queri vertex tree belong oper support ettre data structur 8 olog n time per oper readi state main result theorem 6 fulli dynam proper interv graph represent problem solvabl od log n time per modif involv edg 7 lower bound section prove lower bound ofomega log nlog log n log b amort time per edg oper fulli dynam proper interv graph recognit cell probe model comput wordsiz b 16 fredman sak 6 prove lower bound amort time per oper follow pariti prefix sum pp problem given array integ execut arbitrari sequenc addt sumt oper addt increas 1 sumt return 2 fredman henzing 5 show lower bound appli problem maintain connect gener graph show reduct modifi pp problem call help pariti prefix sum prove lower bound slight chang reduct yield lower bound problem maintain connect proper interv graph graph built reduct union two path therefor proper interv use similar construct prove follow result theorem 7 fulli dynam proper interv recognit takesomega log nlog log n log b amort time per edg oper cell probe model wordsiz b acknowledg first author grate acknowledg support nserc second author support part grant ministri scienc israel third author support eshkol scholarship ministri scienc israel r establish order human chromosomespecif dna fragment simpl linear time recognit unit interv graph recognit represent proper circular arc graph siam journal comput lower bound fulli dynam connect problem graph cell probe complex dynam data structur algorithm graph theori perfect graph random dynam graph algorithm polylogarithm time per oper simpl test interv graph fulli dynam algorithm chordal graph represent finit graph set interv real line indiffer graph recombin dna eigenschaften der nerven homologisch einfach familien r n tabl sort tr ctr ron shamir rode sharan fulli dynam algorithm modular decomposit recognit cograph discret appli mathemat v136 n23 p329340 15 februari 2004 c crespel c paul fulli dynam recognit algorithm certif direct cograph discret appli mathemat v154 n12 p17221741 15 juli 2006 derek g corneil simpl 3sweep lbf algorithm recognit unit interv graph discret appli mathemat v138 n3 p371379 15 april 2004 jrgen bangjensen jing huang loui ibarra recogn repres proper interv graph parallel use merg sort discret appli mathemat v155 n4 p442456 februari 2007