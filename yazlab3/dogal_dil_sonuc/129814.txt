lingua franca concurr logic program two import concurr logic program languag nonflat guard ghc parlog balanc requir clean semant provid good control facil rather differ respect merit compar contrast sinc concurr logic program would benefit neither languag abl express program express languag lingua franca languag defin justifi method given translat ghc parlog method preserv ariti execut condit claus enabl lingua franca implement support languag transpar provid simpl concurr logic program languag suitabl program right b introduct among concurr logic program clp languag like concurr prolog 16 two promin ghc 21 parlog 6 ghc parlog similar execut model complementari virtu argu henc could desir find common denomin languag suffici express worth program right yet suffici close languag inter translat implement languag would support program ghc parlog well common denomin style lingua franca simpler implement either ghc parlog benefit streamlin implement could realis well paper describ lingua franca 2 ghc parlog ghc parlog program set relat r 1 r n r made guard horn claus name ariti edinburgh prolog syntax h g 1 g atom formula unitari prolog goal claus follow form h g 1 g b 1 b n claus head h give relat name ariti g b j guard bodi goal separ commit oper metasymbol signifi conjunct oper primit true alway succe fill empti guard bodi claus declar read h true g 1 g b 1 b n true place filler ghc parallel conjunct oper parlog either parallel sequenti conjunct oper one claus form order relat c n c guard horn claus metasymbol act place filler claus search oper symbol termin relat ghc stand parallel search oper wherea parlog stand either parallel sequenti claus search oper oper right associ bind tightli allow nest parlog parlog claus relat r ariti n 0 preced singl mode declar mode rm 1 n r claus head princip functor either input argument symbol output argument symbol head argument parlog claus relat classifi input output declar ghc claus head argument alway input argument oper semant ghc redescrib way correspond parlog come point view execut ghc parlog program refut conjunct goal g 1 g n resolv n 1 input resolut ignor moment parlog sequenti oper claus search goal conjunct goal g solv parallel either primit satisfi remov resolv user defin goal follow goal match input argument claus head relat determin parallel whether relev goal argument unifi input argument head fresh copi claus without bind goal variabl share algorithm explicit input match use primit given later claus may satisfi head match requir goal instanti suspend upon relev goal variabl input head argument unifi correspond goal argument variabl upon suspend bound parallel head match guard goal claus solv parallel one claus head match requir guard goal relat satisfi one select nondeterminist parallel claus search termin goal reduc goal select claus bodi replac resolv guard goal head match fail claus goal relat goal fail resolut succe goal solv resolv empti fail goal resolv obtain origin goal fail parlog execut subject follow special condit output unif head argument author depart comput scienc heriotwatt univers edinburgh scotland ghc actual defin without assum finit failur effect implement make assum finit failur practic necess chapter 4 especi section 410 21 14 p352353 sequenti claus search sequenti goal conjunct reduct output argument parlog claus head specifi mode declar unifi correspond goal argument parallel bodi goal evalu parlog claus sequenti search restrict claus goal initi guard goal satisfact head match claus next unencount sequenti claus search oper order left right guard goal head match fail claus head guard claus next unencount claus search oper evalu parlog goal conjoin sequenti oper goal conjunct left hand side oper satisfi satisfact attempt right hand side goal conjunct ghc execut subject follow special condit synchronis rule sequenc rule synchronis rule state tri bind call argument variabl passiv part head guard prior commit caus unif suspend guarante safeti guard evalu name guard whose claus figur reduct goal instanti goal sequenc rule state claus bodi may execut commit long attempt bind passiv part variabl prior commit caus unif suspend simpli satisfi delay execut bodi goal commit ghc parlog distinct among clp languag 17 perform guard evalu singl bind environ avoid big runtim overhead face clp languag concurr prolog 16 support multipl bind environ flatten clp languag ban user defin goal claus guard overcom problem sacrif signific express power 3 3 lingua franca ghc parlog follow lingua franca ghc parlog characteris justifi main featur parlog ghc claus express lingua franca claus satisfact condit lingua franca common languag variat ghc parlog similar syntax semant like ghc parlog lingua franca program set relat r 1 r n relat r compos guard horn claus h g 1 g b 1 b n metasymbol signifi parallel conjunct oper 1 n 1 like ghc lingua franca sequenti conjunct oper claus c form order relat c n relat c guard horn claus termin relat like parlog act metasymbol place filler either sequenti parallel claus search oper lingua franca relat modeless ghc fashion claus head argument occur input match role lingua franca goal execut andparallel input resolut common way describ earlier ghc parlog except sequenti claus search oper constrain orparallel execut parlog style full metainterpret lingua franca given later lingua franca oper semant differ ghc allow sequenti search parlog disallow sequenti conjunct differ sequenc head match guard evalu instead requir compil time analysi guard ensur guard safeti like parlog requir runtim safeti test like ghc lingua franca impos mandatori requir safeti howev suppli languag primit support runtim safeti test anywher safe guard evalu must guarante shall see standard ghc parlog primit support lingua franca well three new primit 2 satisfy2 ward3 need translat ghc parlog lingua franca point develop lingua franca made review factor respons differ ghc parlog 4 control emphasi parlog thematis control logic program full construct allow programm synchronis sequenc execut part logic program parlog support sequenti parallel oper claus search goal conjunct thu follow claus process1 recurs process list queryrespons messageq r element mode process process processmessag rb true second claus guard test whether queri part q valid goal executeq r unifi r respons otherwis messag queri ignor repli given sequenti conjunct oper second third claus bodi ensur element execut process continu next element second claus sequenti search oper ensur failur validquery1 guard test allow third claus tri type sequenti oper enhanc control featur parlog use sequenc call inputoutput primit help control extent comput demand driven control granular parallel howev sequenti oper weaken complementar parlog oper declar semant need parlog statu logic program languag declar read parlog orsequenti oper signifi negat prior claus guard subsequ claus guard soundli realis oper implement negat mere failur prior guard without impos extra restrict determin compil time analysi 6 p8992 restrict rais problem precis identifi unsaf guard discuss later furthermor sequenti parlog andsequenti oper affect termin properti parlog program contribut declar mean swap sequenti parallel conjunct oper deadlock parlog goal use succeed thu unbound goal valida truth succe relat mode valid validtruth wherea sequenti variant truth suspend ever although oper swap chang declar mean queri make queri longer satisfi lack emphasi clean semant properti parlog allow defin certain kind parlog program could written unsaf guard could validli execut unsaf guard sabotag success reduct goal relev claus enabl irrelev guard evalu whose claus figur reduct goal bind call argument mode choic choicea life waya true choiceb faith true mode way godless make call choicex faith program make follow thing possibl x first top level goal share first argument first claus choice2 x first claus guard bound godless satisfact wayx second top level goal bound faith first top level goal head match first claus fail first top level goal match second claus head succe instanti b godless happen top level goal reduc bodi second claus choice2 fail thu examin subsequ reject claus result unsaf guard goal wayx bind x godless interf top level goal abl succeed second claus order tri rectifi kind difficulti gregori introduc compil time safeti check tri weed unsaf guard claus parlog program unfortun analys safeti parlog program compil time undecid matter gener 6 p121132 thu algorithm exist select claus parlog program whose guard unsaf control emphasi parlog also allow parlog use primit like var1 time call semant 6 p82 thu conjunct goal call unbound succe fail depend upon whether first primit execut second like unsaf guard time call behaviour make harder prove correct properti program whether goal succe fail depend upon mean goal upon nondeterminist properti implement time call properti confin primit like var1 appli even key parlog primit like two argument metacal call2 primit alway succe initi attempt satisfi first argument unifi second argument constant express result howev satisfi goal transform new conjunct obtain whose success failur depend time execut conjunct preserv execut condit transform program claus replac occurr term guardbodi fresh variabl x conjoin goal parallel rest guardbodi call antisubstitut 21 472 clearli parlog claus contain call2 lack properti thu parlog semant drawback sequenti affect goal termin declar mean unsaf guard precis identifi prevent caus invalid execut realis declar mean negat failur also rais safeti identif problem primit time call semant make comput outcom nondeterminist drawback exist addit basic drawback clp languag preclud complet search embrac dont care nondetermin commit choic mechan howev extra semant defici bought signific price enhanc control parlog featur make apt system program argu 5 semant emphasi ghc approach clp languag design opposit point view parlog thematis semant rather control issu clp languag program sequenti conjunct search oper exclud languag remov execut order constraint mar declar read guard claus termin properti program rule synchronis introduc ensur guard guarante safe primit like var1 2 metacal exclud eschew time call effect allow ghc claus possess antisubstitut lastli localis gener output bind unif primit 2 becom simpler reason flow bind ghc execut measur produc simpl power languag open applic variou transform techniqu 5 21 amen formal analysi 9 14 20 howev emphasi ghc clariti simplic semant weaken abil use gener purpos program tool exclud primit like var1 ghc use condit whether variabl current unbound decid whether commit claus although delay commit variabl bound preclud ghc defin unif within also preclud abl defin wide rang relat unif function within abil program variat unif crucial logic program languag abil program metainterpret languag languag flavour differ experi prolog demonstr prolog abil support wide varieti metainterpret relat languag top major part reason success 18 lose access metaprogram unif ghc hamstrung capac mirror prolog wide metaprogram capabl system program clp languag requir abil handl failur except runtim error subcomput modular fashion localis effect also requir abil control interact task suspend resum abort metainterpret flavour extra control featur need either explicitli program implement control metacal 2 oper system also need dynam programm control schedul resourc alloc subcomput sophist control metacal achiev 4 howev ghc refus support parlog metacal refus support primit need program unif ghc limit abil support flavour metainterpret result impoverish system program capabl ghc eschew sequenti search oper make program ghc difficult exampl lack sequenti search oper make difficult control grain orparallel make harder control order claus examin furthermor claus choic userdefin condit test1 hold hold conveni express sequenti search goalin testin processin goalin true transformin use negat failur not1 6 p8992 goalin testin processin goalin nottestin transformin avoid condit testin evalu twice hold wellknown clp languag like fcp parlog cp pprolog support sequenti search form ghc lack sequenti conjunct oper ghc program limit abl use short circuit techniqu test set goal satisfi use techniqu conjunct alphaa betaa b gammac transform give goal two extra argument chain alphaa x1 x2 betaa b x2 x3 gammac x3 x4 goal succe unifi last two argument test joint termin done bind one end x1 constant done wait chain end x4 bound done ghc goal execut andparallel ghc program use parlog simpl expedi sequenc execut goal unif local chain end mode alpha design kl1b basic machin languag icot parallel infer machin 15 alreadi influenc consider kl1b 10 base upon flat ghc extend pragma metacal price loss ghc nice semant properti neither ghc gener use sequenc rule alphaa x1 x2 alphaa achiev effect first goal sequenc violat safeti guard alpha2 second argument accept input tri instanti goal would suspend attempt bind use short circuit fulli gener way ghc program must extend test termin primit call liabl bind variabl relev program unif bodi ghc claus defin alpha2 mean replac goal unifya b x1 x2 defin follow 17 p462463 unifya b x1 x2 true local part short circuit close match4 detect unif done plainli overhead transform mark gulf express ghc parlog paper show choic made clp languag clean semant like ghc one good system program capabl like parlog possibl benefit respect virtu languag singl implement rewrit lingua franca emul languag directli 6 common linguist denomin lingua franca ghc parlog must abstract differ yet enabl languag translat lingua franca back express either neither ghc parlog express enough translat away languag claus parlog support ghc runtim suspens test ghc disallow action mani parlog primit besid restrict primit ghc four main featur distinguish parlog mode declar pure parallel search conjunct oper claus bodi execut commit long tri instanti bodi variabl share head guard caus unif suspend commit attempt guard goal write upon call argument variabl commit suspend 61 mode declar ghc input match head argument explicitli repres output bind unif bodi claus parlog easili transform obey rule 6 p6469 output mode parlog head argument remov replac fresh variabl extra unif goal origin head argument ad claus bodi chang parlog head argument treat input argument mode declar dispens way lingua franca translat away mode declar parlog relat without support 62 passiv part concurr ghc parlog allow head match proceed parallel guard evalu lingua franca would made simpler requir instead head match complet guard evalu begin would elimin implement overhead provid safe storag variabl share head argument user defin guard goal access execut guard goal relev bind variabl suppli goal head match would also enabl index test head match use sole mean determin earli whether claus suitabl reduc goal would avoid earli evalu guard claus whose head dont yet match goal detect whether guard fail claus guard empti signifi true transform need translat ghc parlog lingua franca compens lingua franca sequenc head match guard evalu furthermor guard goal fail head match succe transform necessari either howev case head match perform parallel guard evalu otherwis suspens head match could delay indefinit discoveri guard goal execut fail thu guard nonempti known guard fail head match succe head match decompos extra one way unif guard fashion translat parlog kernel parlog 6 p6566 variant gregori method use differ oneway unif primit 2 tri unifi argument suspend relev left hand argument variabl success unif would bind one share two whole head match realis form aggreg term head argument occur uniqu variabl head oneway unifi similar aggreg distinct variabl replac thu guard claus compareab cd testa c compareb translat compare f e f ab cd testa c compareb new claus head distinct fresh variabl argument approach give simpler represent head match separ goal creat match head argument repeat variabl gregori method howev multiprocess implement may want implement 2 use sever simpl match goal gregori fashion avoid creat content exclus access variabl tie variabl togeth one primit process sequenti algorithm given figur 1 specifi behaviour requir oneway unif oper algorithm return success failur suspend execut execut time 2 process run return success failur return suspend 2 process suspend least left hand side variabl detect bound unifi procedur earli detect failur requir suspend variabl well awoken made runnabl variabl get bound list repres two argument structur handl separ whole algorithm execut atom faster algorithm would circumv use full unif test nonunifi determin variabl suspend order avoid obtain exclus access left hand variabl execut 63 sequenti oper unlik ghc parlog support andsequenti oper howev synchronis satisfact parlog goal achiev indirectli sequenti conjoin goal remov parlog claus use metacal synchronis flag link metacal 6 p 9899 141142 absenc andsequenti oper ghc possibl elimin sequenti conjunct oper parlog way establish anoth common featur ghc parlog copi lingua franca need support andparallel conjunct andsequenti oper elimin transform away parlog sourc would help lingua franca program extract andparallel applic ghclike program style make program less prone sequenti style prolog program dog mani parlog program rather use gregori method employ parlog three argument control metacal simpler two argument metacal satisfy2 introduc instead attempt satisfi first argument succe bind second argument simpl term succe attempt satisfact fail fail differ parlog metacal call2 never fail although metacal satisfy2 defin use call2 howev violat antisubstitut unlik call2 seen earlier introduc new primit ground1 suspend argument ground satisfy2 use defin auxiliari relat wait3 follow waitgoal control flag groundcontrol satisfygo flag wait3 suspend second argument ground execut first argument goal fail goal fail succe signal fact bind third argument constant wait3 provid simpl mean realis sequenti execut control execut order andparallel goal synchronis flag thu mix conjunct translat follow aa b waitonea waittwob e waitthreeab e control variabl e delay execut threeab onea twob satisfi gener form method translat away sequenti conjunct appli prolog syntax structur contain reserv predic wait3 pure prolog program given figur 2 queri pgoal newgoal parallel goal conjunct parlog goal unifi newgoal lingua franca translat 64 orsequenti search ghc support orparallel claus search although option allow sequenti search mean otherwis predic consid ghc design one stage 21 347 hand parlog allow claus search parallel sequenc gregori shown possibl elimin orsequenti claus search use three argument parlog metacal 6 p140141 howev use gregori rather complex method would mean abandon principl repres parlog ghc claus lingua franca claus translat relat name ariti fortun unnecessari sequenti search easi support directli clp implement 1 7 65 rule sequenc option execut bodi ghc claus commit subject ghc rule sequenc 21 may seem appropri highli parallel dataflow architectur like result lot redund comput less parallel architectur expens could profit execut furthermor allow prematur comput almost ghc program guarante termin without import extra fair assumpt 14 p353354 avoid semant difficulti keep extant implement ghc 8 12 special suspens mechan propos support ghc rule sequenc lingua franca rule obey parlog strict sequenc evalu obey lingua franca claus commit evalu bodi commenc 66 rule synchronis ghc rule synchronis preserv guard safeti requir unif would bind share call argument variabl ancestor guard unif suspend thu claus ye call aska suspend unif ye suspend order instanti call argument variabl ancestor guard two main approach canvass implement guard suspens test ueda pointer colour scheme 12 21 miyazaki guard number scheme 11 scheme concentr upon suspend unif bodi ghc claus use evalu guard goal event unif attempt write upon call argument variabl either scheme threaten impos suspens test overhead upon everi explicit unif howev ghc claus either match input head argument primit input argument guard evalu remain case necessari test user defin primit guard goal output argument write upon call argument variabl demand driven scheme could separ suspens produc condit ghc claus order localis requir suspend evalu extra primit goal respons guard would impos gener overhead upon unif bodi allow unsaf userdefin guard goal evalu without suspens constraint output bind evalu made eager comput space effect recycl comput space use repres guard goal process process tree claim releas soon guard goal satisfi fail claim frozen unus pend commun input valu remov suspens goal process suspend unsaf bind deep guard evalu frozen space may includ space claim store ancestor process suspend upon suspend userdefin guard process well claim store process perform suspend unif 661 localis central idea behind localis 19 suspens effect due rule synchronis aris happen guard evalu restrict locu evalu follow variabl term unsaf occur head ghc claus either user defin guard goal argument posit primit guard goal liabl bind given valu unsaf variabl guard goal replac fresh variabl transform call guard goal allow proceed without subject safeti suspens condit safeti suspens condit achiev new primit relink unsaf guard variabl new replac way ghc program distil lingua franca claus interleav special primit achiev safe guard suspens mechan special primit job allow old variabl valu pass new replac ensur unifi new old guard variabl would bind call argument variabl commit special primit suspend exampl take ghc claus remov head match manner alreadi describ replac fresh variabl a1 userdefin guard test1 special primit ward2 ad link two variabl way protect call environ bound suspend call instead result ward2 need abl suspend sever variabl must handl complex term complex term get progress bound also need abl suspend awak pass valu mayb suspend properti ward2 infer fact guard goal test1 might need argument bound valu succeed satisfact guard achiev ward2 goal pass bind second argument first howev ward2 goal allow user defin guard goal export valu satisfact ward2 simpli unifi a1 unidirect unif apt howev ward2 equat 2 second goal guard succeed case call argument b bound might get bound 121 first input match unidirect unif succeed share 121 sinc a1 still unbound second guard safeti unidirect unif succeed share shortli afterward parallel test1 call might bind variabl a1 incorrect result could instanti call argument variabl 121 incorrect claus commit behaviour avoid insist second goal unidirect unif perform test1 goal succeed bind could never pass ward2 user defin guard goal better idea make ward2 predic reluct unidirect unif ward2 predic suspend order unifi unidirect argument share variabl reluct unidirect unif unidirect unif bind made instanti side whenev nonvari bind detect noninstanti side unidirect unif possibl fail two side never unifi instanti side variabl need associ complex noninstanti side term contain variabl bound consist copi complex term avoid variabl share unidirect unif reluct variabl instanti side get bound nonvari never get share variabl noninstanti side predic suspend instead problem test sever guard goal need partial bound unbound argument order succeed ward2 predic must suspend ever exampl guard goal defin follow true true result reluct unidirect unif would ward2 predic suspend two variabl argument even userdefin guard test1 succeed ward2 predic suspend two unbound argument long guard goal ward succeed implement variabl bind use signal success userdefin guard goal signal sent ward predic extra argument predic defin get signal abandon reluct oneway unif tri relink origin variabl replac nonreluctantli unidirect ensur bind gener evalu guard goal pass call environ caus primit suspend attempt put consider togeth give follow origin claus get transform first guard goal implement head match next two implement origin guard goal set ghc suspens test userdefin guard goal succe call argument variabl replac link reluct unidirect unif allow share variabl ward3 first two argument guard goal succe c bound metacal satisfy2 signal ward3 unidirect unifi first two argument allow share variabl algorithm ward3 first two argument unifi opposit order given 19 662 gener localis suspens transfer translat scheme gener scheme requir take account multipl occurr unsaf variabl one guard goal simpl sound way place entir origin guard satisfy2 metacal part guard contain origin head argument variabl aggreg term unsaf variabl consist copi also form substitut fresh variabl unsaf variabl two term relat ward3 gener rule implement guard safeti suspens ghc appli guard goal contain userdefin predic primit liabl bind argument variabl head argument userdefin guard goal primit goal argument primit goal may bind form risk set distinct fresh substitut variabl set creat risk set empti noth done everi member risk set guard goal uniformli replac substitut whole ghc guard put first argument satisfy2 metacal fresh variabl call control variabl put second argument structur arbitrari functor argument consist member risk set variabl form copi structur made substitut variabl replac risk variabl ward3 predic goal ad guard structur structur copi control variabl satisfy2 first three argument head match decompos guard fashion describ earlier although ward3 use compil ghc lingua franca use satisfy2 compil ghc flat ghc metacal violat antisubstitut unlik parlog metacal call2 21 472 primit ward3 unbound variabl goal wardcd aa ye suspend wherea antisubstitut may succeed henc ward3 made ghc primit appli 2 7 exampl translat exampl show result appli transform ghc follow ghc claus processab c ad checkab e testad e processb c translat lingua franca claus processj c k j k ab ad e testfh e processb c first guard goal implement head match second implement safe guard suspens test three relev variabl third satisfi origin guard two extra primit goal metacal requir implement localis runtim suspens test head match differ exampl show transform parlog claus mode test e testb c follow lingua franca claus waitchecka j waittestc j k waitanalysea l waitsynthesiseb f waittransformb f l n waitunfoldc e l waittestb c l n p 8 translat back lingua franca revers translat translat ghc simpl gener method presuppos occurr predic ward3 2 satisfy2 sole product origin correct translat 1 satisfy2 predic replac first argument 2 first two argument ward3 unifi goal remov two argument 2 unifi goal remov guard left empti space fill primit true simplic revers translat method done translat ghc lingua franca decompos unif way appropri suspens effect unif direction associ clearli reunifi restor statu quo revers translat lingua franca parlog perform three step first head match restor unifi two argument 2 remov 2 goal sequenti conjunct put back final output head argument restor gener algorithm sequenti conjunct replac given execut queri qgoal newgoal pure prolog program given figur 3 goal bound lingua franca conjunct goal newgoal unifi origin parlog conjunct output head argument restor unifi argument 2 predic bodi creat origin translat remov uniqu identifi give reserv name origin translat mode declar alway correctli infer initi translat lingua franca preserv independ 9 lingua franca semant metainterpret full lingua franca invok callgoal given figur 4 call1 first claus handl conjunct second claus evalu primit recognis suspend primit primitive1 third claus handl commit choic resolut frozen claus retriev second list argument clauses2 defin first argument relat oper join adjac claus claus select test reduce3 first claus reduce3 examin whether lead claus reduc goal second claus search next claus parallel third claus examin last claus group claus search parallel sequenti search oper ensur fourth claus consid first three consid reject continu claus search previou reduce3 claus shown unabl reduc goal test3 ensur head match perform guard call match3 use primit melt2 obtain fresh melt copi frozen claus input match goal instead impos inadequ select guard safeti criterion valid program like parlog requir mandatori runtim safeti test evalu everi claus guard like ghc lingua franca suppli precis mean support runtim safeti test anywher safe guard evalu must guarante test use augment compil time safeti analysi 6 p121132 thu unsaf guard reduce3 made safe replac test3 ward3 goal act valv prevent execut g1 metacal satisfy2 export bind g henc goal call environ lingua franca simplifi clp languag semant make safeti clp claus guard constraint must satisfi execut clp languag validli guarante guard safeti enabl provid mean let precis test safeti appli anywher need languag semant make option appli test realis claus use method translat describ earlier exercis gener program unsaf guard use safe guard metainterpret describ lingua franca exce ghc parlog express power abl translat ghc parlog claus lingua franca claus oper semant ghc parlog unabl lingua franca claus furthermor abl translat clp languag lingua franca back lingua franca implement present transpar ghc parlog lingua franca implement program style lingua franca hybrid ghc parlog lingua franca follow ghc eschew provis andsequenti oper modeless steer programm away laps sequenti prologlik style reli mislead assur given mode declar lingua franca follow parlog provid rich set control construct disallow use time call primit thu provid clp vehicl right rather like parlog program system uncoupl evalu user defin guard suspens mechan use ward3 localis suspens effect unsaf guard lingua franca make execut guard goal eager effect recycl comput space ghc comput space use repres user defin guard goal process claim releas soon guard goal satisfi fail claim frozen unus pend commun input valu remov suspens goal process suspend unsaf bind lingua franca requir head match concurr guard evalu incur less runtim overhead respect ghc parlog elimin need provid safe storag variabl share head argument user defin guard goal access guard goal execut relev variabl bind suppli head match also expedit use index claus select avoid earli evalu guard claus whose head dont yet match goal detect whether guard fail 10 kernel parlog view intermedi languag compil parlog lingua franca play role similar kernel parlog 6 p6469 howev sever import differ unlik kernel parlog lingua franca made express enough use program vehicl first instanc like parlog ghc thu preserv full head match function rather translat away fashion kernel parlog furthermor kernel parlog support primit like ward3 would enabl translat away ghc runtim suspens test kernel parlog execut obey runtim suspens test implement independ support ward3 complex action perform kernel parlog simpl input match primit would requir ensur atom execut sever togeth howev kernel parlog lack mean part method describ translat away ghc runtim suspens test complex seri simpl match perform parallel context translat full ghc clp languag cp 14 howev translat exploit multipl environ properti clp languag atom oper requir kind possibl kernel parlog follow cp ward3 suitabl treat kernel parlog primit design philosophi underli choic kernel parlog primit aim ensur process intend andor tree implement model 6 pp163164 never requir suspend variabl howev ward3 abl 11 conclus strategi absorb differ two promin clp languag assimil common languag variant propos meet differ demand clp languag support common medium strategi detail translat ghc parlog lingua franca back implement lingua franca transpar present user either execut ghc parlog directli support languag lingua franca provid user semant desir properti ghc control featur parlog simpl program style singl implement accord requir acknowledg would like thank steve gregori paper review mani detail help comment well colleagu heriotwatt univers member imperi colleg parlog group r implement commit choic languag share memori multiprocessor logic oper system design issu flat parlog basi comparison parlog system program languag partial evalu ghc program base upon urset constraint parallel logic program parlog languag implement abstract machin implement parlog uniprocessor distribut implement flat ghc multipsi preliminari note semant guard horn claus abstract kl1 machin instruct set dataflowbas parallel infer machin support two basic languag kl1 ghc abstract machin instruct set translat safe ghc safe concurr prolog fcp ghc oper semant problem relationship cp subset concurr prolog interpret famili concurr logic program languag metainterpret expert system construct localis ghc suspens test oper semant guard horn claus guard horn claus tr parallel logic program parlog languag implement metainterpret expert system construct abstract machin implement parlog uniprocessor famili concurr logic program languag ghc abstract machin instruct set implement commit choic logic languag share memori multiprocessor