implement cilk5 multithread languag fifth releas multithread languag cilk use provabl good worksteal schedul algorithm similar first system languag complet redesign runtim system complet reengin effici new implement aid clear strategi aros theoret analysi schedul algorithm concentr minim overhead contribut work even expens overhead contribut critic path although may seem counterintuit move overhead onto critic path workfirst principl led portabl cilk5 implement typic cost spawn parallel thread 2 6 time cost c function call varieti contemporari machin mani cilk program run one processor virtual degrad compar equival c program paper describ workfirst principl exploit design cilk5 compil runtim system particular present cilk5 novel twoclon compil strategi dijkstralik mutualexclus protocol implement readi dequ worksteal schedul b introduct cilk multithread languag parallel program gener semant c introduc linguist construct parallel control origin cilk1 releas 3 4 18 featur provabl effici random work steal schedul 3 5 languag clumsi parallel expos hand use explicit continu pass cilk languag implement research support part defens advanc research project agenc darpa grant n000149410985 comput facil provid mit xola project thank gener equip donat sun microsystem appear proceed 1998 acm sigplan confer program languag design implement pldi montreal canada june 1998 latest cilk5 releas 8 still use theoret effici schedul languag simplifi consider employ callreturn semant parallel featur linguist simpl inlet mechan nondeterminist control cilk5 design run effici contemporari symmetr multiprocessor smp featur hardwar support share memori code mani applic cilk includ socrat cilkchess chessplay program prize intern competit philosophi behind cilk develop make cilk languag true parallel extens c semant respect perform parallel comput cilk control construct allow program execut parallel cilk keyword parallel control elid cilk program howev syntact semant correct c program result call c elis gener serial elis cilk program cilk faith extens c c elis cilk program correct implement semant program moreov one processor parallel cilk program scale run nearli fast c elis unlik cilk1 cilk schedul identifi piec code cilk5 compil runtim system bear respons schedul obtain ef ficienc cours attempt reduc schedul overhead overhead larger impact execut time other howev theoret understand cilk schedul algorithm 3 5 allow us identifi optim common case accord abstract theori perform cilk comput character two quantiti work total time need execut comput serial criticalpath length execut time infinit number processor cilk provid instrument allow user measur two quantiti within cilk schedul identifi given cost contribut either work overhead criticalpath overhead much effici cilk deriv follow principl shall justifi section 3 workfirst principl minim schedul overhead born work comput specif move overhead work onto critic path workfirst principl play import role design earlier cilk system cilk5 exploit principl extens workfirst principl inspir twoclon strategi compil cilk program cilk2c compil 23 sourcetosourc translat transform cilk sourc c postsourc make call cilk runtim librari c postsourc run gcc compil produc object code cilk2c compil produc two clone everi cilk procedurea fast clone slow clone fast clone ident respect c elis cilk program execut common case serial semant suffic slow clone execut infrequ case parallel semant concomit bookkeep requir commun due schedul occur slow clone contribut criticalpath overhead work overhead workfirst principl also inspir dijkstralik 11 sharedmemori mutualexclus protocol part runtim loadbalanc schedul cilk schedul use worksteal algorithm idl processor call thiev steal thread busi processor call vic tim cilk schedul guarante cost steal contribut criticalpath overhead work overhead nevertheless hard avoid mutualexclus cost incur potenti victim contribut work minim work overhead instead use lock cilk runtim system use dijkstralik protocol call protocol manag runtim dequ readi thread worksteal algorithm ad advantag protocol allow except signal work processor addit work overhead featur use cilk abort mechan remaind paper organ follow section 2 overview basic featur cilk languag section 3 justifi workfirst principl section 4 describ twoclon strategi implement section 5 present protocol section 6 give empir evid cilk5 schedul effici final section 7 present relat work offer conclus 2 cilk languag section present brief overview cilk extens c support cilk5 complet descript consult cilk5 manual 8 key featur languag specif parallel synchroniza tion spawn sync keyword specif nondetermin use inlet abort includ stdlibh includ stdioh includ cilkh cilk int fib int n n2 return n els int x return cilk int main int argc char argv int n result printf result dn result return 0 figur 1 simpl cilk program comput nth fibonacci number parallel use bad algorithm basic cilk languag understood exampl figur 1 show cilk program comput nth fibonacci number 1 observ program would ordinari c program three keyword cilk spawn sync elid keyword cilk identifi fib cilk procedur parallel analog c function parallel creat keyword spawn preced invoc procedur semant spawn differ c function call parent continu execut parallel child instead wait child complet done c cilk schedul take respons schedul spawn procedur processor parallel comput cilk procedur safe use valu return children execut sync statement sync statement local barrier global one ex ampl use messagepass program fibonacci exampl sync statement requir statement return xy avoid anomali would occur x sum comput addit explicit synchron provid sync statement everi cilk procedur sync implicitli return thu ensur children termin ordinarili spawn procedur return return valu simpli store variabl parent frame program use ineffici algorithm run exponenti time although logarithmictim method known 9 p 850 program nevertheless provid good didact exampl cilk int fib int n int inlet void summer int result x result return n2 return n els summerspawn fib n1 summerspawn fib n2 return figur 2 use inlet comput nth fibonnaci number occasion one would like incorpor return valu parent frame complex way cilk provid inlet featur purpos inspir part inlet featur tam 10 inlet essenti c function intern cilk pro cedur normal syntax cilk spawn procedur must occur separ statement express except made rule spawn perform argument inlet call case procedur spawn return inlet invok meantim control parent procedur proce statement follow inlet call princi ple inlet take multipl spawn argument cilk5 restrict exactli one argument inlet may spawn argument must first argument necessari restrict easi program around figur illustr fib function might code use inlet inlet summer defin take return valu result add variabl x frame procedur spawn variabl fib avail within summer sinc intern function fib 2 lock requir around access x summer cilk provid atom implicitli concern two updat might occur parallel atom impos updat might lost cilk provid implicit atom among thread procedur stanc thread maxim sequenc instruct end spawn sync return either explicit implicit statement inlet preclud contain spawn sync statement thu oper atom singl thread implicit atom simplifi reason 2 c elis cilk program inlet ansi c ansi c support intern c function cilk base gnu c technolog howev provid support concurr nondetermin without requir lock declar critic region like cilk provid syntact sugar produc certain commonli use inlet implicitli exampl statement x spawn fibn1 conceptu gener inlet similar one figur 2 sometim procedur spawn parallel work later discov unnecessari specul work abort cilk use abort primit insid let common use abort occur parallel search mani possibl search parallel soon solut found one search one wish abort current execut search soon possibl wast processor resourc abort statement execut insid inlet caus alreadyspawn children procedur termin consid use futur 19 implicit synchro nizat well synchron specif variabl instead use simpl spawn sync statement realiz workfirst principl howev differ synchron mechan could impact criticalpath comput issu secondari concern consequ opt implement simplic also system support relax memoryconsist model explicit sync statement use ensur sideeffect previous spawn subprocedur occur addit control synchron provid sync cilk programm use explicit lock synchron access data provid mutual exclus atom data synchron overhead born work howev although striven minim overhead finegrain lock contemporari processor expens current investig incorpor atom cilk languag protocol issu involv lock avoid user level aid debug cilk program use lock develop tool call nond 7 13 detect common synchron bug call data race 3 workfirst principl section justifi workfirst principl state section 1 show follow three assumpt first assum cilk schedul oper practic accord theoret analysi present 3 5 sec ond assum common case ampl parallel slack 28 exist averag parallel cilk program exce number processor run suffici margin third assum inde case everi cilk program c elis oneprocessor perform measur theoret analysi present 3 5 cite two fundament lower bound fast cilk program run let us denot tp execut time given comput p processor work comput criticalpath length comput work lower bound tp t1p must hold p unit work execut singl step addit lower bound tp must hold sinc finit number processor execut faster infinit cilk random worksteal schedul 3 5 execut cilk comput p processor expect time assum ideal parallel comput equat resembl brent theorem 6 15 optim within constant factor sinc t1p lower bound call first term righthand side equat 1 work term second term criticalpath term importantli commun cost due cilk schedul born criticalpath term schedul cost make overhead explicit defin criticalpath overhead smallest constant c1 second assumpt need justifi workfirst principl focus commoncas regim parallel program oper defin averag parallel correspond maximum possibl speedup applic obtain defin also parallel slack 28 ratio pp assumpt parallel slack pp ae c1 mean number p processor much smaller averag parallel p assumpt follow t1p ae c1t1 henc inequ 2 obtain linear speedup criticalpath overhead c1 littl effect perform suffici slack exist although determin much slack must exist ensur linear speedup whether substanti slack exist common applic matter opinion empiric suggest slack common case express cilk make easi code applic larg amount parallel modests problem mani applic exhibit averag parallel 200 yield substanti slack contemporari smp even sandia nation laboratori intel paragon contain 1824 node socrat chess program code cilk1 ran linearspeedup regim 1995 icca world comput chess championship place second field 24 section 6 describ dozen divers applic run 8processor smp 3 abstract model execut time ignor reallif detail memoryhierarchi effect nonetheless quit accur 4 consider parallel slack parallelisim applic increas problem size therebi ensur run well larg machin third assumpt behind workfirst principl everi cilk program c elis oneprocessor perform measur let us denot ts run time c elis defin work overhead incorpor criticalpath work overhead inequ 2 yield sinc assum parallel slack restat workfirst principl precis minim c1 even expens larger c1 c1 direct impact perform adopt workfirst principl may advers affect abil applic scale howev criticalpath overhead c1 larg shall see section 6 criticalpath overhead reason small cilk5 mani applic code larg amount parallel workfirst principl pervad cilk5 implementa tion worksteal schedul guarante high probabl opt1 steal migrat attempt occur ot1 averag per processor cost born critic path consequ schedul cilk5 postpon much schedul cost possibl work stolen therebi remov contributor work overhead strategi amort cost steal attempt permeat virtual everi decis made design schedul 4 cilk compil strategi section describ cilk2c compil gener c postsourc cilk program dictat work first principl compil schedul design reduc work overhead much possibl strategi gener two clone procedurea fast clone slow clone fast clone oper much c elis littl support parallel slow clone full support parallel along concomit overhead first describ cilk schedul algorithm describ compil translat cilk languag construct code fast slow clone procedur lastli describ runtim system link togeth action fast slow clone produc complet cilk implement lazi task creation 24 cilk5 proce sor call worker maintain readi dequ doubli end queue readi procedur technic procedur instanc dequ two end head tail procedur ad remov worker oper local tail dequ treat much int fib int n 3 fibfram f frame pointer 8 return n int x live var c call return 0 frame stolen 22 return xy figur 3 fast clone gener cilk2c fib procedur figur 1 code second spawn omit function alloc free inlin call runtim system fast memori alloc signatur fib sig contain descript fib procedur includ pointer slow clone push pop call oper schedul dequ describ detail section 5 c treat call stack push pop spawn activ frame worker run work becom thief attempt steal procedur anoth worker call victim thief steal procedur head victim dequ opposit end victim work procedur spawn fast clone run whenev thief steal procedur howev procedur convert slow clone cilk schedul guarante number steal small suffici slack exist expect fast clone execut time thu workfirst principl reduc minim cost fast clone contribut heavili work overhead minim cost slow clone although desir goal less import sinc cost contribut less heavili work overhead criticalpath overhead minim cost fast clone exploit structur cilk schedul convert procedur slow clone stolen maintain invari fast clone never stolen none descend fast clone stolen either sinc strategi steal head readi dequ guarante parent stolen children shall see simpl fact allow mani optim perform fast clone describ cilk2c compil gener post sourc c code fib procedur figur 1 exampl postsourc fast clone fib given figur 3 gener c code gener structur c elis addit statement line 45 activ frame alloc fib initi cilk runtim system use activ frame repres procedur instanc use techniqu similar 16 17 inlin alloc typic take cycl frame initi line 5 store pointer static structur call signatur describ fib first spawn fib translat line 1218 line 1213 state fib procedur save activ frame save state includ program counter encod entri number live dirti vari abl frame push runtim dequ line 1415 4 next call fib routin would c spawn statement compil directli c elis postsourc exploit optim capabl c compil includ abil pass argument receiv return valu regist rather memori fib return line 1718 check see whether parent procedur stolen return immedi dummi valu sinc ancestor stolen well c stack quickli unwind control return runtim system 5 protocol check whether parent procedur stolen quit subtlew postpon discuss implement section 5 parent procedur stolen continu execut line 19 perform second spawn shown fast clone sync statement compil noop fast clone never children exe cute know compil time previous spawn procedur complet thu oper requir sync statement alway succe exam ple line 20 figur 3 translat sync statement empti statement final line 2122 fib dealloc activ frame return comput result parent procedur slow clone similar fast clone except provid support parallel execut procedur stolen control suspend two procedur thread spawn sync point slow clone resum use goto statement restor program counter restor local variabl state activ frame spawn statement translat slow clone fast clone sync statement cilk2c insert call runtim system check see whether procedur spawn children return although parallel book 4 share memori sequenti consist memori fenc must insert line 14 15 ensur surround write execut proper order 5 setjmplongjmp facil c could use well unwind strategi simpler keep slow clone substanti contribut littl work overhead sinc slow clone rare execut separ fast clone slow clone also allow us compil inlet abort statement effici fast clone inlet call compil effici ordinari spawn exampl code inlet call figur compil similarli follow cilk code implicit inlet call x spawn fibn1 compil directli c elis abort statement compil noop sync statement execut fast clone children abort runtim system provid glue fast slow clone make whole system work includ protocol steal procedur return valu processor execut inlet abort comput subtre like cost protocol amort critic path overhead significantli affect run time suffici parallel slack exist portion steal protocol execut worker contribut work overhead howev therebi warrant care implement discuss protocol detail section 5 work overhead spawn cilk5 read write fast clone3 read 5 write fib exampl experiment quantifi work overhead section 6 work overhead still remain im plement howev includ alloc free activ frame save state spawn push pop frame dequ check procedur stolen portion work overhead due fact cilk5 duplic work c compil perform section 6 show overhead small although product cilk compil might abl elimin unnecessari work would like compromis portabl cilk4 precursor cilk5 took workfirst principl extrem cilk4 perform stackbas alloc activ frame sinc work overhead stack alloc smaller overhead heap alloca tion cactu stack 25 semant cilk stack 6 howev cilk4 manag virtualmemori map processor explicitli done 27 work overhead cilk4 frame alloc littl increment stack pointer whenev stack pointer overflow page expens userlevel ensu cilk4 would modifi memori map unfortun operatingsystem mechan support oper slow un predict possibl page fault critic sec 6 suppos procedur spawn two children b c two children refer object activ frame b c see other frame tion led complic protocol even though overhead could charg criticalpath term practic becam larg criticalpath term contribut significantli run time therebi violat assumpt parallel slack oneprocessor execut program inde fast insuffici slack sometim result poor parallel perform cilk5 simplifi alloc activ frame simpli use heap common case frame alloc remov free list dealloc perform insert frame manag virtual memori requir except initi setup share memori heap alloc contribut slightli stack alloc work overhead save substanti critic path term downsid heap alloc potenti wast memori stack alloc due fragment care analysi rel merit stack heap base alloc support heap alloc see paper appel shao 1 equal care analysi support stack alloc see 22 thu although workfirst principl give gener understand overhead born experi cilk4 show larg enough criticalpath overhead tip scale point assumpt underli principl longer hold believ cilk5 work overhead nearli low possibl given goal gener portabl c output compil 7 research abl reduc overhead even howev expens portabl exampl lazi thread 14 obtain effici expens implement call convent stack layout etc although could principl incorpor machinedepend techniqu compil feel cilk5 strike good balanc perform portabl also feel current overhead suffici low problem notabl minim overhead data synchron deserv attent 5 implement worksteal section describ cilk5 worksteal mecha nism base dijkstralik 11 sharedmemori mutualexclus protocol call protocol accord workfirst principl protocol design minim work overhead exampl 167megahertz ultrasparc fib program protocol run 25 faster hardwar lock primit first present simplifi version protocol discuss actual implement allow except signal addit overhead 7 although runtim system requir effort port architectur compil requir chang whatsoev differ platform sever straightforward mechan might consid implement worksteal protocol exampl thief might interrupt worker demand attent victim strategi present problem two reason first mechan signal interrupt slow although interrupt would born critic path larg cost could threaten assumpt parallel slack ness second worker would necessarili incur overhead work term ensur could safe interrupt critic section altern send interrupt thiev could post steal request worker could period poll howev cost accru work overhead time poll techniqu known limit overhead poll 12 requir support sophist compil workfirst principl suggest reason put substanti effort minim work overhead worksteal protocol sinc cilk5 design sharedmemori machin chose implement worksteal sharedmemori rather messagepass might otherwis appropri distributedmemori implement implement victim oper directli share memori victim readi dequ crucial issu resolv race condit aris thief tri steal frame victim attempt pop one simpl solut add lock dequ use rel heavyweight hardwar primit like compareandswap testand set whenev thief worker wish remov frame dequ first grab lock solut fundament problem interrupt poll mechan describ howev whenev worker pop frame pay heavi price grab lock contribut work overhead consequ adopt solut employ di jkstra protocol mutual exclus 11 assum read write atom protocol use three atom share variabl h e call protocol key idea action worker tail queue contribut work overhead action thiev head queue contribut criticalpath overhead therefor accord workfirst principl attempt move cost worker thief arbitr among differ thiev attempt steal victim use hardwar lock sinc overhead amort critic path resolv conflict worker sole thief hold lock howev use lightweight dijkstralik protocol contribut minim work overhead worker resort heavyweight hardwar lock encount actual conflict thief case charg overhead victim incur critic path rest section describ protocol 9 return failur return success thief 7 return failur 9 unlockl return success figur 4 pseudocod simplifi version protocol left part figur show action perform victim right part show action thief none action besid read write assum atom exampl implement detail first present simplifi protocol use two share variabl h design tail head dequ respect later extend protocol third variabl e allow except signal worker except mechan use implement cilk abort statement interestingli extens introduc addit work overhead pseudocod simplifi protocol shown figur 4 assum share memori sequenti consist 20 8 code assum readi dequ implement array frame head tail dequ determin two indic h store share memori visibl processor index point first unus element array h point first frame dequ indic grow head toward tail normal con dition h moreov dequ lock l implement atom hardwar primit os call worker use dequ stack see section 4 spawn push frame onto tail dequ spawn pop frame unless frame stolen thief attempt steal frame head dequ one thief time may steal dequ sinc thief grab l first action seen code worker alter h wherea thief increment h alter possibl interact thief vic 8 share memori sequenti consist memori fenc must insert line 5 6 workervictim code line 3 4 thief code ensur instruct execut proper order b000000000000000111111111111111000000000000111111111111111 h24a c thief figur 5 three case readi dequ simplifi protocol shade entri indic presenc frame certain posit dequ head tail mark h occur thief increment h victim decrement consequ alway safe worker append new frame end dequ worri action thief pop oper three case shown figur 5 case thief victim get frame dequ case b dequ contain one frame victim decrement without interfer thiev get frame similarli thief steal frame long victim tri obtain thief victim tri grab frame howev protocol guarante least one discov h thief discov h restor h origin valu retreat victim discov h restor origin valu restart protocol acquir l l acquir thief steal dequ victim pop frame without interfer frame still final case c dequ empti thief tri steal alway fail victim tri pop attempt fail control return cilk runtim system protocol deadlock process hold one lock time argu protocol contribut littl work overhead push frame involv overhead beyond updat common case worker succes pop frame pop protocol perform 6 operations2 memori load 1 memori store 1 decr ment 1 comparison 1 predict condit branch moreov common case thief oper dequ h cach exclus worker expens oper worker grab lock l occur thief simultan tri steal frame pop sinc number steal attempt depend t1 t1 rel heavi cost victim grab l consid part criticalpath overhead c1 influenc work overhead c1 ran experi determin rel perform protocol versu straightforward protocol pop lock dequ access 167megahertz ultrasparc protocol 25 faster simpl lock protocol machin memori model requir memori fenc instruct membar insert line 5 6 pop pseudocod tri quantifi perform impact membar instruct experi execut time code without membar 200megahertz pentium pro run linux gcc 271 protocol 5 faster lock protocol processor protocol spend half time memori fenc replac lock memori synchron protocol nonblock straightforward lock protocol consequ protocol less prone problem aris spin lock use extens exampl even worker suspend oper system execut pop infrequ lock protocol mean usual complet steal oper worker dequ recent work arora et al 2 shown complet nonblock worksteal schedul im plement use idea lisiecki medina 21 modifi cilk5 schedul make complet non block experi protocol greatli simplifi nonblock implement simplifi protocol extend support signal except worker figur 4 index h play two role mark head dequ mark point worker cross pop place dequ need full protocol separ two function h two variabl h mark head dequ e mark point victim cross except condit occur includ frame stolen also use except exampl set caus worker discov except next pop new protocol e replac h line 6 workervictim moreov line 715 workervictim replac call except handler determin type except stolen frame otherwis proper action perform thief code also modifi tri program size fib blockedmul 1024 299 00044 6730 105 43 70 66 notempmul 1024 297 0015 1970 105 39 76 72 strassen 1024 202 058 35 101 354 57 56 cilksort 4 100 000 54 00049 1108 121 090 60 50 yqueen 22 150 00015 96898 099 188 80 80 yknapsack heat 4096 theta 512 623 016 384 108 94 66 61 43 00020 2145 093 077 56 60 figur perform exampl cilk program time second accur within 10 serial program c elis cilk program except program star parallel program implement differ algorithm serial program program label dagger nondeterminist thu run time one processor work perform comput program valu 1 indic actual work comput 8 processor run time one processor steal thief increment e noth steal restor e origin valu otherwis thief steal frame h increment h point view worker common case simplifi protocol compar two pointer e rather h except mechan use implement abort cilk procedur execut abort instruct runtim system serial walk tree outstand descend procedur mark descend abort signal abort except processor work descend next pop abort procedur discov except notic abort return immedi conceiv procedur could run long time without execut pop discov abort made design decis accept possibl unlik scenario figur cycl like lost work overhead abandon protocol mechan solv minor problem 6 benchmark section evalu perform cilk5 show 12 applic work overhead c1 close 1 indic cilk5 implement exploit workfirst principl effect present breakdown cilk work overhead c1 four machin final present experi show criticalpath overhead c1 reason small well figur 6 show tabl perform measur taken 12 cilk program sun enterpris 5000 smp 8 167megahertz ultrasparc processor 512 kilobyt l2 cach 16 kilobyt l1 data instruct cach run solari 25 compil program gcc 272 optim level o3 full descript program see cilk 51 manual 8 tabl show work cilk program t1 critic path two deriv quantiti p c1 tabl also list run time t8 8 processor speedup t1t8 rel oneprocessor execut time speedup tst8 rel serial execut time 12 program averag parallel p case quit larg rel number processor typic smp measur valid assumpt parallel slack impli work term domin inequ 4 instanc 1024 theta 1024 matri ce notempmul run averag parallel 1970 yield adequ parallel slack sever hundr processor even larger machin one normal would run small problem notempmul well 11 applic averag parallel grow problem size thu suffici parallel slack like exist even much larger machin long problem size scale appropri work overhead c1 percent larger 1 program show design cilk5 faith implement workfirst principl two case work overhead larger cilksort choleski due fact chang serial algorithm obtain parallel algorithm thu comparison c elis exampl serial c algorithm sort inplac quicksort parallel algorithm cilksort requir addit temporari array add overhead beyond overhead cilk self similarli parallel choleski factor use quadtre represent spars matrix induc work linkedlist represent use serial c algorithm final work overhead fib larg fib essenti work besid spawn procedur thu overhead good estim cost cilk spawn versu tradit c function call small overhead spawn one understand applic perform signific work spawn overhead cilk5 schedul bare notic compar 10 nois measur 195 mhz mip r10000 ultra sparc 200 mhz pentium pro alpha 21164 overhead protocol frame alloc state save 115n 113n 78n 27n figur 7 breakdown overhead fib run one processor variou architectur overhead normal run time serial c elis three overhead save state procedur spawn alloc activ frame procedur protocol absolut time given perspawn run time c elis present breakdown cilk serial overhead c1 compon schedul overhead small program perform analysi fib program figur 1 program unusu sensit schedul overhead contain littl actual comput give breakdown serial overhead three compon overhead save state spawn overhead alloc activ frame overhead protocol figur 7 show breakdown cilk serial overhead fib four machin methodolog obtain number follow first take serial c fib program time execut individu add code gener overhead time execut result program attribut addit time requir modifi program schedul code ad order verifi number time fib code cilk overhead ad code shown figur 3 compar result time sum individu overhead case two time differ less 10 overhead vari across architectur overhead cilk typic time c run time spawnintens program overhead alpha machin particularli larg nativ c function call fast compar architectur statesav cost small fib four architectur write buffer hide latenc write requir also attempt measur criticalpath overhead c1 use synthet knari benchmark 4 synthes comput artifici wide rang work criticalpath length figur 8 show outcom mani experi figur plot measured01001 normal normal machin size experiment data model work bound critic path bound figur 8 normal speedup curv cilk5 horizont axi number p processor vertic axi speedup t1tp data point normal divid t1t1 graph also show speedup predict formula speedup t1tp run machin size p run order plot differ comput graph normal machin size speedup divid valu averag parallel done 4 run horizont posit plot datum invers slack pp thu normal machin size 10 number processor equal averag parallel vertic posit plot datum t1tp measur fraction maximum obtain speedup seen chart almost run bench mark observ tp t1p 10t1 one except data point satisfi tp t1p workfirst principl caus us move overhead critic path abil cilk applic scale significantli compromis 7 conclus conclud paper examin relat work mohr et al 24 introduc lazi task creation implement mult languag lazi task creation similar mani way lazi schedul techniqu mohr et al report work overhead around 2 compar serial scheme dialect mult base research confirm intuit behind method show work overhead close 1 achiev cid languag 26 like cilk use c base languag simpl preprocess compil convert parallel cid construct c cid design work distribut memori environ employ latencyhid mechan cilk5 could avoid work distribut version cilk howev cilk cid recogn attract base parallel languag c leverag c compil technolog highperform code cilk faith extens c howev support simplifi notion c elis allow cilk exploit c compil technolog readili tam 10 lazi thread 14 also analyz mani overhead issu gener nonstrict languag set individu perform whole host mechan requir applic obtain good overal perform contrast cilk multithread languag provid execut model base work criticalpath length allow us focu implement effort use workfirst principl use principl guid concentr optim effort commoncas protocol code develop effici portabl implement cilk languag acknowledg grate thank contribut cilk develop includ bobbi blumof ien cheng dailey mingdong feng chri joerg bradley kuszmaul phil lisiecki alberto medina rob miller ask plaat bin song andi stark volker strumpen yuli zhou mani thank user provid us feedback suggest improv martin rinard suggest term workfirst r empir analyt studi stack versu heap cost languag closur thread schedul multiprogram multiprocessor execut multithread program ef ficient schedul multithread comput work steal parallel evalu gener arithmet express detect data race cilk program use lock introduct algorithm solut problem concurr program control poll effici stock hardwar effici detect determinaci race cilk program lazi thread implement fast parallel call bound multiprocess time anoma lie heap stack time space effici thread without oper system support cilk system parallel multithread comput jr make multiprocessor comput correctli execut multiprocess program person commun garbag collect fast function function lisp funarg problem call environ prob lem parallel symbol comput cid vlsi support cactu stack orient memori organ bridg model parallel comput tr multilisp languag concurr symbol comput vlsi support cactu stack orient memori organ bridg model parallel comput introduct algorithm finegrain parallel minim hardwar support compilercontrol thread abstract machin poll effici stock hardwar wholeprogram optim time space effici thread cilk system parallel multithread comput lazi thread cilk execut multithread program effici effici detect determinaci race cilk program thread schedul multiprogram multiprocessor detect data race cilk program use lock parallel evalu gener arithmet express solut problem concurr program control lazi task creation parallel symbol comput cid garbag collect fast stack faster function function lisp funarg problem call environ problem ctr liang peng wengfai wong chungkwong yuen silkroad ii mix paradigm cluster comput rcdag consist parallel comput v29 n8 p10911115 1 august matteo frigo fast fourier transform compil acm sigplan notic v39 n4 april 2004 kalyan perumalla richard fujimoto effici largescal processori parallel simul proceed 30th confer winter simul p459466 decemb 1316 1998 washington dc unit state doug lea java forkjoin framework proceed acm 2000 confer java grand p3643 june 0304 2000 san francisco california unit state christoph j hugh radek grzeszczuk eftychio sifaki daehyun kim sanjeev kumar andrew p sell jatin chhugani matthew holliman yenkuang chen physic simul anim visual effect parallel character chip multiprocessor acm sigarch comput architectur news v35 n2 may 2007 yaron shoham sivan toledo parallel random bestfirst minimax search artifici intellig v137 n12 p165196 may 2002 philip cox simon gauvin andrew rauchaplin ad parallel visual data flow program proceed 2005 acm symposium softwar visual may 1415 2005 st loui missouri voonye vee wenj hsu localitypreserv loadbalanc mechan synchron simul sharedmemori multiprocessor proceed fourteenth workshop parallel distribut simul p131138 may 2831 2000 bologna itali marcel van lohuizen gener approach parallel chart pars applic lingo proceed 39th annual meet associ comput linguist p507514 juli 0611 2001 toulous franc bryan chan tarek abdelrahman runtim support automat parallel java program journal supercomput v28 n1 p91117 april 2004 madanl musuvathi shaz qadeer iter context bound systemat test multithread program acm sigplan notic v42 n6 june 2007 gregori w price david k lowenth compar analysi finegrain thread packag journal parallel distribut comput v63 n11 p10501063 novemb kenjiro taura kunio tabata akinori yonezawa stackthreadsmp integr futur call standard acm sigplan notic v34 n8 p6071 aug 1999 dorit naishlo joseph nuzman chauwen tseng uzi vishkin toward first vertic prototyp extrem finegrain parallel program approach proceed thirteenth annual acm symposium parallel algorithm architectur p93102 juli 2001 crete island greec robert ennal simon peyton jone optimist evalu adapt evalu strategi nonstrict program acm sigplan notic v38 n9 p287298 septemb radu rugina martin rinard pointer analysi multithread program acm sigplan notic v34 n5 p7790 may 1999 john danah ite angelina lee charl e leiserson program except jcilk scienc comput program v63 n2 p147171 1 decemb 2006 matteo frigo fast fourier transform compil acm sigplan notic v34 n5 p169180 may 1999 rezaul alam chowdhuri vijaya ramachandran cacheoblivi gaussian elimin paradigm theoret framework parallel experiment evalu proceed nineteenth annual acm symposium parallel algorithm architectur june 0911 2007 san diego california usa kenjiro taura kenji kaneda toshio endo akinori yonezawa phoenix parallel program model accommod dynam joiningleav resourc acm sigplan notic v38 n10 octob sanjeev kumar christoph j hugh anthoni nguyen carbon architectur support finegrain parallel chip multiprocessor acm sigarch comput architectur news v35 n2 may 2007 lawrenc rauchwerg nanci amato smartapp middlewar adapt applic reconfigur platform acm sigop oper system review v40 n2 april 2006 v vasenin n vodomerov formal model system autom program parallel program comput softwar v33 n4 p181194 juli 2007 radu rugina martin rinard symbol bound analysi pointer array indic access memori region acm sigplan notic v35 n5 p182195 may 2000 matteo frigo volker strumpen cach complex multithread cach oblivi algorithm proceed eighteenth annual acm symposium parallel algorithm architectur juli 30august 02 2006 cambridg massachusett usa guangien cheng mingdong feng charl e leiserson keith h randal andrew f stark detect data race cilk program use lock proceed tenth annual acm symposium parallel algorithm architectur p298309 june 28juli 02 1998 puerto vallarta mexico polyvio pratikaki jaim spacco michael hick transpar proxi java futur acm sigplan notic v39 n10 octob 2004 nimar arora robert blumof c greg plaxton thread schedul multiprogram multiprocessor proceed tenth annual acm symposium parallel algorithm architectur p119129 june 28juli 02 1998 puerto vallarta mexico michael bender cynthia phillip schedul dag asynchron processor proceed nineteenth annual acm symposium parallel algorithm architectur june 0911 2007 san diego california usa matteo frigo fast fourier transform compil acm sigplan notic v39 n4 april 2004 girija j narlikar schedul thread low space requir good local proceed eleventh annual acm symposium parallel algorithm architectur p8395 june 2730 1999 saint malo franc michael bender jeremi fineman seth gilbert charl e leiserson onthefli mainten seriesparallel relationship forkjoin multithread program proceed sixteenth annual acm symposium parallel algorithm architectur june 2730 2004 barcelona spain dror ironi gil shklarski sivan toledo parallel fulli recurs multifront spars choleski futur gener comput system v20 n3 p425440 april 2004 charl r toll timothi r mcjunkin david j gorisch suboptim minimum cluster volum coverbas method measur fractal dimens ieee transact pattern analysi machin intellig v25 n1 p3241 januari robert blumof charl e leiserson schedul multithread comput work steal journal acm jacm v46 n5 p720748 sept 1999 kunal agraw yuxiong wen jing hsu charl e leiserson adapt schedul parallel feedback proceed eleventh acm sigplan symposium principl practic parallel program march 2931 2006 new york new york usa radu rugina martin c rinard symbol bound analysi pointer array indic access memori region acm transact program languag system topla v27 n2 p185235 march 2005 kunal agraw yuxiong charl e leiserson adapt work steal parallel feedback proceed 12th acm sigplan symposium principl practic parallel program march 1417 2007 san jose california usa radu rugina martin c rinard pointer analysi structur parallel program acm transact program languag system topla v25 n1 p70116 januari girija j narlikar guy e blelloch pthread dynam irregular parallel proceed 1998 acmiee confer supercomput cdrom p116 novemb 0713 1998 san jose ca