modulo schedul loop controlintens nonnumer program much previou work modulo schedul target numer program often major loop wellbehav loopcounterbas loop without earli exit controlintens nonnumer program loop frequent characterist make difficult effect appli modulo schedul characterist includ multipl control flow path loop base loop counter multipl exit loop presenc unimport path high resourc usag long depend chain penal import path path contain hazard anoth nest loop prohibit modulo schedul loop control depend sever restrict overlap block within across iter paper describ set method allow effect modulo schedul loop multipl exit techniqu includ remov control depend enabl specul extens modulo variabl expans new epilogu gener scheme method use superblock hyperblock techniqu allow modulo schedul select path loop arbitrari control flow case studi present show method combin superblock techniqu enabl modulo schedul effect appli controlintens nonnumer program perform result sever spec cint92 benchmark unix util program report demonstr applic modulo schedul class program b introduct schedul instruct loop great interest mani program spend major execut time loop often necessari schedul overlap success iter loop order find copyright 1996 ieee publish proceed 29th annual intern symposium microarchitectur decemb 24 1996 pari franc person use materi permit howev permiss reprintrepublish materi resal redistribut purpos creat new collect work resal redistribut server list reus copyright compon work work must obtain ieee contact manag copyright permiss ieee servic center 445 hoe lane po 9085623966 suffici instructionlevel parallel ilp effect util resourc highperform processor softwar pipelin 18 6 1 15 loop schedul scheme allow motion instruct one iter anoth maintain overlap loop iter throughout execut loop descript variou approach softwar pipelin given 17 paper focus class softwar pipelin method call schedul 16 modulo schedul simplifi gener overlap schedul initi iter constant rate requir iter loop common schedul constant interv start success iter call initi interv ii initi candid ii chosen maximum two lower bound resourceconstrain lower bound ii resmii 16 equal number cycl heavili use resourc use singl iter worstcas constraint among cycl depend graph determin recurrenceconstrain lower bound ii recmii 16 previou work modulo schedul target numer program often major loop wellbehav loop loopcount base loop without earli exit extens perform evalu modulo schedul techniqu loop seem exist percept modulo schedul primarili applic program controlintens nonnumer program loop frequent characterist make difficult appli modulo schedul obtain signific speedup characterist includ multipl control flow path loop base loop counter multipl exit sever techniqu develop allow modulo schedul loop intraiter control flow hierarch reduct 11 predic execut 5 revers ifconvers 21 work assum path loop bodi includ schedul includ path detriment overal loop perform presenc unimport path high resourc usag long depend chain result schedul penal import path infrequ path contain hazard anoth nest loop function call prohibit modulo schedul loop previou work also done modulo schedul loop base loop counter 20 19 key difficulti type loop may take mani cycl determin whether start next iter limit overlap iter difficulti overcom specul initi next erat work 20 also mention sourcetosourc transform convert loop multipl exit singleexit loop result loop contain multipl path control dealt use one method modulo schedul loop intraiter control flow refer howev method add extra instruct delay earli exit end loop bodi work need evalu perform approach especi architectur without predic execut paper describ new set method allow effect modulo schedul loop multipl path control multipl exit use superblock 10 futur hyperblock 14 techniqu exclud unimport detriment path loop loop multipl exit often occur natur controlintens program benefici exclus path via format superblock hyperblock loop creat mani thu effect method handl multipl exit essenti rather transform loop singl exit loop propos method modulo schedul loop multipl exit present new code gener scheme describ creat correct epilogu exit specul use increas overlap basic block within iter overlap success iter extend modulo variabl expans allow specul instruct write variabl live loop exit altogeth method describ paper allow effect modulo schedul select path loop arbitrari control flow paper report speedup result sever spec cint92 benchmark unix util first report perform result modulo schedul controlintens nonnumer program demonstr applic modulo schedul class program valid correct propos method paper organ follow section 2 describ method develop present case studi show method combin superblock tech niqu enabl modulo schedul effect appli controlintens loop section 3 report perform result section 4 provid summari direct futur work 2 modulo schedul controlintens loop detail exampl use illustr difficulti caus controlintens loop benefit techniqu develop loop chosen case studi one frequent execut loop lex lexic analyz gener sourc code loop shown figur 1 tempj break return figur 1 sourc code exampl loop lex loop gener purpos nonnumer program frequent complex control flow evid exampl loop outer loop contain ifstat inner loop earli exit via return statement inner loop contain ifstat earli exit via break statement obvious loop contain number hazard modulo schedul modulo schedul would ordinarili target inner loop howev profil inform indic inner loop infrequ invok usual iter condit ifstat evalu fals 90 time figur 2a show simplifi version control flow graph loop block x contain code load statei j comparison statement s1 block consist postincr pointer j code bodi ifstat s1 control flow within block omit clariti block z contain code updat test exit condit z z b figur 2 superblock format exampl loop detriment path contain inner loop exclud loop via superblock format effect superblock format done use profil inform 3 andor static analysi structur hazard program 9 superblock loop consist frequent path outer loop block x z form shown figur 2b path block exclud via tail duplic block z superblock loop consist singl path loop singl entranc one exit loop consist block x z appear inner loop multipl exit target modulo schedul detail descript superblock format see 10 3 shown superblock optim acycl schedul techniqu provid substanti speedup 10 gener abil superblock similarli hyperblock exclud undesir path execut provid follow benefit modulo schedul ffl decreas resmii exclud unimport path high resourc usag ffl decreas recmii exclud unimport path contribut long depend cycl ffl increas number loop modulo schedul exclud path contain hazard nest loop function call although modulo schedul method develop paper describ use superblock exampl equal applic hyperblock code figur 3 show assembl code exampl superblock loop instruct number later refer enc block x control flow graph consist instruct 3 instruct 4 6 block z assembl code shown produc impact compil classic optim appli element array state four byte size regist shown virtual regist regist alloc done modulo schedul inst assembl regist content 6 ble 0 r4 l1 figur 3 assembl code superblock loop control exit superblock loop instruct 3 taken instruct 6 taken paper exit associ fallthrough path loop back branch term final exit exit superblock loop via taken branch term earli exit virtual regist r34 r4 r12 live earli exit l2 block taken valu r34 r4 decrement block z valu r12 increment block virtual regist live loop exit via final exit instruct 6 loop complex control flow occur frequent gener purpos nonnumer program tabl 1 show statist percentag dynam instruct singl basic block loop basic block multipl exit superblock loop superblock spec cint92 benchmark sever unix util program column label total sum two column time spent two type loop spent exclud path inner outer loop acycl code tabl 1 percentag dynam instruct singl basic block superblock loop benchmark basic superblock total block 008espresso 56 578 634 026compress 06 498 504 072sc 44 346 390 085gcc 141 285 426 cmp eqn 26 209 235 lex 20 862 882 tbl 174 96 27 wc yacc 32 455 487 program except gcc tbl littl time spent singl basic block loop program except tbl time usual much spent multipl exit superblock loop singl basic block loop tabl clear modulo schedul must abl effect handl loop control flow applic program remaind section describ propos techniqu overcom control depend regist antidepend associ loop multipl exit liveout virtual reg ister code gener scheme loop multipl exit also present 21 overcom control depend use specul code motion control depend major impedi exploit ilp loop generalpurpos nonnumer program crossiter control depend restrict overlap loop iter delay start subsequ iter branch current iter execut frequent branch depend earlier comput loop bodi execut late iter sever limit overlap intraiter control depend combin crossiter data depend creat recurr limit throughput modulo schedul loop also increas length critic path singl iter result longer schedul iter import consider short trip count loop describ 20 19 crossiter control depend loop back branch instruct next iter relax allow specul code motion overlap iter loop multipl exit concept must extend earli exit branch often necessari remov crossiter control depend earli exit branch instruct subsequ iter achiev desir level overlap also often necessari remov intraiter control depend allow overlap block within iter achiev good perform short trip count loop remov either type control depend quit simpl howev current assum store branch specul execut reorder branch subject futur work order specul execut load instruct caus except either processor architectur must contain support specul execut 4 13 compil must abl prove via program analysi specul execut instruct except 2 paper assum instruct set architectur contain silent nontrap version instruct caus except 4 furthermor instruct write virtual regist live loop exit requir special attent remov control depen denc issu discuss section 22 show effect control depend exampl superblock loop figur 4a show depend graph node number id figur 3 instruct repres branch node shade data control depend shown solid dash line respect transit depend shown none regist antidepend shown assum remov remov antidepend discuss section 22 control data figur 4 depend graph exampl loop arc label two number first minimum delay cycl requir start two instruct second number distanc number iter two depend struction arc distanc zero intraiter depend distanc greater zero crossiter depend instruct set assum similar hp parisc 11 branch delay slot except branch delay shown pa7100 assum instruct fallthrough path branch potenti execut cycl branch instruct taken path execut cycl follow branch sever nontrivi recurr appar graph longest recurr circuit run instruct 1 2 3 4 6 back 1 total delay six span one iter result recmii six loop schedul use depend graph overlap iter crossiter control depend loop back branch instruct next iter except instruct 3 remov allow specul code motion overlap itera tion howev still limit control depend present recurr circuit consist instruct limit recmii five break recurr intraiter control depend instruct 3 5 must remov enabl specul execut instruct 5 control depend instruct 3 instruct 4 must also remov break remain limit recurr figur 4b show depend graph limit control depend remov reduc recmii one instruct legal move modulo schedul branch branch data depend instruct exampl instruct 5 could legal schedul instruct 6 instruct move branch automat move path branch gener epilogu follow actual modulo schedul process section 22 24 shown special attent must paid type code motion correct code gener multipl exit loop assum 4issu processor execut one branch per cycl resmii exampl loop two recmii one result ii two speedup three modulo schedul use depend graph figur 4a 22 overcom antidepend use modulo variabl expans thu far noth said antidepend constraint impos virtual regist live loop exit origin form instruct write virtual regist v live exit branch b move b overwrit valu v use exit b taken constraint upward code motion exactli v one operand b ie antidepend constraint repres differ mani compil instead ad explicit antidepend arc mani compil includ impact overload control depend arc repres control depend antidepend sever exampl antidepend case studi loop instruct 1 use r34 later defin instruct 5 virtual regist r34 live branch l2 instruct 3 taken anti depend instruct 3 instruct 5 antidepend remov renam modulo variabl expans 11 19 unrol kernel renam success lifetim correspond loop variant longer overlap time allow regist antidepend remov schedul ing know modulo variabl expans correct overlap lifetim lack depend allow modulo variabl expans algorithm origin describ 11 allow remov crossiter antidepend howev intraiter antidepend also remov lifetim analysi renam algorithm extend includ lifetim cross iter assum done 19 paper describ chang need figur 5 illustr relax crossiter antidepend use modulo variabl expans describ 11 three iter abstract loop bodi contain definit use virtual regist r1 shown intraiter flow depend mark f crossiter antidepend mark cycl instruct issu shown squar bracket right abstract struction assum delay flow depend two antidepend zero origin form shown left minimum ii achiev two use modulo variabl expans antidepend remov prior schedul reduc ii one two virtual regist use shown right use r1 2 f use r1 4 f use r1 6 f use r1 2 f use r2 3 f use r1 4 f b figur 5 relax crossiter anti depend figur 6 show relax intraiter anti depend case use appear definit origin iter lifetim r1 cross iter remov intraiter anti depend prior schedul allow definit move use within iter shown right previou case two regist use ii reduc 2 1 use r1 0 use r1 2 f use r1 4 f use r1 1 use r2 2 f use r1 3 f b figur 6 relax intraiter anti depend lifetim virtual regist extend first definit last use lifetim loopvari virtual regist v definit use u comput use follow equat assum lifetim start issu end u issu issu issueu issu time instanc u origin iter 1 distv number iter separ instanc u use valu defin origin loop note equat 1 use u could branch v live correct renam lifetim analysi must extend includ use addit consider live virtual regist instruct move downward across branch b code motion occur definit move path branch epilogu gener v longer liveout lifetimev comput equat 1 becom less equal 0 thu lifetim v comput use except associ exit move across figur 7 show execut two iter case studi loop modulo schedul first iter start time 0 instruct denot subscript 1 second iter start time 2 instruct denot subscript 2 second erat instruct also shade distinguish two iter lifetim virtual regist written loop shown right execut record virtual regist lifetim begin schedul gener schedul singl iter origin loop schedul work analyz lifetim modulo variabl expans definit first iter subsequ tic mark denot either explicit use virtual regist sourc operand branch regist liveout lifetim extend last use regist cycl issu slot lifetim figur 7 execut record lifetim two iter lifetim r13 entir contain within one iter ation defin instruct 2 use instruct 3 issue2 2 issue3 4 distr13 0 ii 2 use equat 1 length lifetim 2 lifetim r34 cross iter defin instruct 5 use instruct 1 5 next iter live instruct 3 next iter issue5 1 issue3 4 distr34 1 use equat 1 total length lifetim 5 definit v renam cycl set virtual regist assign v use v renam first find iter contain correspond definit v current iter di tancev zero previou iter distancev one use virtual regist name definit iter longest lifetim r34 5 cycl loop must unrol three time modulo variabl expans figur 8 show unrol kernel modulo schedul loop modulo variabl expans instruct renumb renam one name use origin virtual regist name set regist use r34 r34 r342 r343 set regist use r12 r12 r122 r123 instruct put sequenti order would done gener code superscalar processor target fallthrough path first two copi loop back branch instruct 6 12 revers prepar epilogu gener block l3 origin fall path loop inst assembl cycl ble 0 r4 l1 5 l3 figur 8 unrol kernel superscalar processor 23 review code gener scheme singl exit loop subsect review exist code gener scheme singl exit loop prepar introduc modifi scheme multipl exit loop complet discuss possibl code scheme singl exit loop see 19 use abstract code represent 19 reduc complex exampl figur 9a show singl iter gener singleexit loop modulo schedul squar repres code one stage ii cycl singl iter origin sourc loop number stage call stage count a3 ii cycl b unrolledkernel code structur one iter figur 9 abstract represent iter figur 9b show code structur modulo schedul loop kernel unrol gener prologu epilogu iter progress left right one start one stage previou one backedg arrow row 6 row 3 identifi start end unrol kernel degre unrol unrel stage count squar kernel repres prologu squar afterward repres epilogu squar also given number specifi version code use version use differ name regist avoid overwrit live valu code structur figur 9b simplist allow arbitrari number iter correctli execut 19 illustr basic concept prepar reader complex correct code scheme describ later section paper loop back branch refer loop back branch origin loop bodi multipl copi branch modulo schedul kernel unrol prologu gener copi except one becom loop back branch kernel target fallthrough path revers shown figur 8 loop exit branch taken rather fall exit associ copi loop back branch call final exit exit earli exit chain depend lead loop back branch determin earliest stage loop back branch place stage loop back branch schedul determin number iter specul initi assum stage iter number stage correspond 0 stage b correspond 1 use terminolog 19 loop back branch schedul stage specul execut stage iter first exampl figur 9b loop back branch schedul stage b stage everi iter first execut specul paper last iter refer last iter would execut origin nonpipelin loop exit last iter taken specul iter abort figur show structur code gener possibl stage loop back branch could place threestag schedul figur 10a b c loop back branch schedul end stage b c respect a3 a3 c a3 figur 10 code gener scheme singl exit loop arrow except backedg repres control transfer prologu kernel epilogu shown final exit schedul end stage arrow origin close bottom row squar epilogu contain code complet nonspecul iter progress time exit taken although explicitli shown end epilogu exist code move live valu regist code outsid loop expect find jump origin target block exit compar figur 10a b one see structur gener code chang loop back branch schedul end stage b instead stage loop back branch execut one stage later fewer stage left execut epilogu last iter predecessor thu epilogu one less row one specul iter progress loop exit abort one less column epilogu one less exit prologu one epilogu disappear altogeth gener loop back branch place stage instead stage 0 rightmost column epilogu remov correspond abort specul iter 19 result epilogu stage count figur 10c loop back branch schedul end last stage thu last iter predecessor complet loop exit epilogu consist code need move live valu shown 24 code gener scheme multipl exit loop figur 11 illustr chang code gener scheme multipl exit loop figur assum loop two exit earli exit loop back branch schedul stage figur 11a b c branch schedul stage b c respect exit modulo schedul loop thu epilogu arrow associ earli exit origin close top row dash line distinguish final exit two key differ final exit earli exit first final exit schedul end stage earli exit branch middl stage thu final exit epilogu start begin stage follow one contain final exit branch earli exit remaind row contain exit branch kernel must examin copi epilogu iter last one remaind iter stage row contain exit branch copi epilogu treatment last iter discuss shortli figur small letter use denot partial stage result exit branch middl stage a3 a3 c3 c2 c1 a3 c3 c2 c1 a3 c3 c2 c1 figur 11 code gener scheme multipl exit loop second key differ loop back branch alway last instruct origin loop bodi earli exit branch somewher middl origin loop bodi final exit taken last iter alway fulli execut remain stage last iter copi epilogu entireti howev earli exit taken instruct last iter appear exit branch origin loop bodi execut assum basic block superblock assign numer id sequenti zero sc gamma 1 defin home block instruct basic block instruct resid origin loop bodi earli exit instruct remain stage last iter copi epilogu id home block less equal home block id exit branch figur 11 shade squar use denot stage home block check copi instruct figur 11 epilogu final exit figur 10 epilogu earli exit alway one row usual one column correspond final exit stage extra row consist remaind row kernel earli exit branch resid thu squar extra row mark small letter extra column correspond last stage oldest iter progress time exit taken final exit iter finish exit taken earli exit part last stage remain complet epilogu epilogu earli exit prologu extra column none iter start execut last stage rightmost column earli exit epilogu shade column correspond last iter last iter instruct appear exit branch origin loop bodi copi epilogu figur 12 show algorithm gener epilogu exit branch algorithm start instruct follow exit branch copi row instruct unrol kernel epilogu wrap around kernel last row epilogu complet squar copi correspond instruct iter last instruct last iter appear exit branch origin loop bodi algorithm shown assum processor branch delay slot follow paragraph describ data structur concept need understand algorithm unrol kernel divid section ii cycl call kernel row kmin row kmin degre unrol kernel row contain link list instruct contain row data structur instruct contain pointer inform structur contain among item stage instruct schedul instruct home block id row kernel contain instruct sc gamma row epilogu number zero stage exit branch schedul row zero partial row empti final exit link list kernel row end final exit row epi row epilogu last iter execut stage instruct stage less epi row must iter last thu copi simplic algorithm shown gener correct epilogu exit kernel exit prologu practic algorithm contain addit code map exit prologu correspond exit kernel prologu gener similar manner epilogu copi select instruct row unrol kernel map prologu exit correspond kernel exit facilit copi row epilogu also practic epilogu exit prologu algorithm copi instruct later stage stage first iter execut instruct correspond nonexist iter prior first one appli code gener scheme exampl loop schedul singl iter exampl loop contain 3 stage stage consist instruct 1 5 origin loop see figur 7 stage b contain instruct 2 instruct 3 earli exit 4 6 final exit stage c code scheme figur 11c similar would gener exampl loop depend structur loop opportun downward code motion across earli exit branch thu earli exit branch taken remain instruct last iter appear exit branch origin loop bodi algorithm genepiexit branch creat epilogu block gener row epilogu determin start copi epirow partial row exit final exit exitnextop null instruct copi partial row els full row gener one full partial row oper null copi instruct iter previou last iter last iter appear exit branch origin loop bodi operstag insertopafterepiloguelastop newop rotat row kernel insert move end epilogu variant live exit insertmovesforlivevariantsepilogu exit last exit branch fall epilogu exit last exit unrol kernel creat jump target exit branch make epilogu block target exit branch figur 12 epilogu gener algorithm shade epilogu empti 25 insert move liveout valu mention earlier code must append end epilogu move valu liveout correspond exit regist code outsid loop expect find singl exit superblock loop valu use outsid loop must defin last iter thu final exit instruct last iter examin correspond epilogu kernel valu produc instruct liveout destin regist one expect outsid loop move instruct insert end epilogu multipl exit loop procedur final exit howev earli exit addit consider live valu could defin last iter one instruct preced exit branch origin loop bodi could defin secondtolast iter one instruct follow exit branch origin loop bodi thu last iter examin instruct origin resid earlier home block earli exit branch secondtolast iter examin instruct origin resid later home block exit exampl loop earli exit instruct 3 figur taken live valu r34 r4 secondtolast iter live valu r12 last iter valu live final exit figur 13 show code gener exampl loop use multipl epilogu code scheme figur 11c instruct renumb move live valu instruct 25 27 28 30 also shown block label pro l1 prologu unrol kernel respect block label le1 le3 le5 epilogu block immedi follow kernel epilogu reach fall loop back branch block l3 origin fall path loop label l2 start block epilogu final exit instruct 11 17 23 empti code move downward across loop back branch virtual regist live final exit rather branch empti epilogu final exit branch directli l3 except loop back branch fall epilogu jump l3 earli exit instruct 6 12 18 requir move one live virtual regist branch epilogu mention end 22 renam one name use origin virtual regist name thu live valu alreadi correct regist move necessari case r34 epilogu le1 r12 epilogu le5 jump place end earli exit epilogu transfer control block inst assembl cycl 22 ble 0 r4 l1 5 26 jump l2 0 28 29 jump l2 0 l3 figur 13 final assembl code exampl loop virtual regist renam modulo variabl expans use livein virtual regist first iter refer origin virtual regist name thu move requir livein valu exampl virtual regist r34 livein first iter prologu use r34 instruct 1 2 rather one renam version r342 r343 3 experiment result section report experiment result applic modulo schedul controlintens nonnumer program result obtain use impact compil interprocedur alia analysi 7 data depend analysi done front end memori depend arc pass back end give optim schedul accur depend inform addit classic optim optim perform back end increas ilp code 10 modulo schedul done prepass acycl schedul global regist alloc modulo schedul implement rau iter modulo schedul 16 use machin descript system 8 get inform instruct latenc resourc requir modulo schedul use pipelin loop high issu rate version parisc paper sparc architectur loop elig modulo schedul inner loop outer loop may becom inner loop superblock format singl basic block superblock loop contain function call includ path function call may exclud loop superblock format enabl modulo schedul target processor experi multipl issu processor issu rate 4 8 vari resourc constraint tabl 2 show function unit mix processor processor assum integ regist 32 doubleprecis floatingpoint regist latenc use hp pa7100 processor tabl 2 processor characterist number name issu integ memori branch fp slot alu port unit alu base speedup report singleissu base pro cessor base processor ilp optim modulo schedul appli multipl issu pro cessor code gener three way without modulo schedul modulo schedul singl basic block loop modulo schedul superblock loop use techniqu describ pa per code softwar pipelin schedul use acycl superblock schedul 10 none loop unrol acycl schedul modulo schedul gener prior unrol improv perform acyclicli schedul modulo schedul loop 12 howev complex interact unrol optim schedul add anoth variabl tri focu effect modulo schedul purpos paper primarili describ effect method modulo schedul loop controlintens nonnumer pro gram result paper use demonstr applic modulo schedul class program valid correct method effect unrol prior schedul perform comparison modulo schedul acycl schedul unrol loop controlintens nonnumer program subject futur work describ section 4 execut time whole program calcul use schedul cycl count basic block profil inform 100 cach hit rate assum benchmark profil transform insur accuraci profil done instrument target virtual processor assembl code emul aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaaaaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa aaaa superblock modulo schedul basic block modulo schedul schedul espresso eqntott compress gcc cmp lex wc yacc figur 14 speedup singl issu processor without modulo schedul hp seri 700 workstat execut produc benchmark output use verifi correct target processor assembl code benchmark chosen experi four spec cint92 four unix program tabl 1 espresso eqntott compress gcc cmp lex wc yacc spend time basic block superblock loop loop appli modulo schedul chosen program 40 dynam instruct loop total 305 loop modulo schedul figur 14 show speedup result white part bar show speedup base processor acycl schedul appli code espresso eqntott lex yacc perform flat resourc increas without overlap iter ilp exploit limit black part bar show slightli increas perform modulo schedul appli singl basic block loop benchmark except gcc less 6 dynam instruct basic block loop thu slight perform improv expect benchmark gcc spend half much time 14 singl basic block loop superblock loop show speedup 5 crosshatch part bar show increas perform superblock modulo schedul appli elig loop modulo schedul almost doubl perform lex 4issu processor almost tripl perform 8issu processor shown case studi limit ilp within singl iter loop program modulo schedul provid good speedup across benchmark processor particular speedup 25 obtain across processor espresso eqntott com press lex yacc aggress processor perform improv 30 benchmark except gcc wc superblock modulo schedul perform espresso eqntott lex yacc longer flat processor resourc increas ilp exploit overlap loop iter result clearli show modulo schedul use techniqu describ paper applic controlintens nonnumer program 4 conclus paper describ set method allow effect modulo schedul loop multipl exit method use allow modulo schedul select path loop arbitrari control flow case studi present show method enabl modulo schedul effect appli controlintens nonnumer program perform result sever spec cint92 benchmark unix util program demonstr modulo schedul significantli acceler loop class program previou work shown unrol prior modulo schedul improv perform numer program 12 unrol enabl addit optim effect ii integ acycl schedul unrol done allow optim overlap iter modulo schedul unrol done optim effect resmii recmii much research need done studi effect unrol prior modulo schedul nonnumer program understand amount unrol necessari achiev minimum ii possibl given loop next step effort appli modulo schedul controlintens nonnumer program one result next step abil compar modulo schedul global acycl schedul unrol loop within common framework acknowledg research paper benefit convers mike schlansker bob rau hp lab thank bob rau scott mahlk grant haab provid feedback earli version paper brian deitrich john gyllenha anonym refere suggest submit version author would also like thank jurgen mihm whose work inspir thought modulo variabl expan sion nanci warterperez noubar partamian past present member impact research group provid underli technolog modulo schedul built research support nation scienc foundat nsf grant mip9308013 intel advanc micro devic hewlettpackard sun microsystem ncr nation aeronaut space administr nasa contract nasa nag 1613 cooper illinoi comput laboratori aerospac system softwar iclass r realist resourceconstrain softwar pipelin algorithm use profil inform assist classic code optim three architectur model compilercontrol specul execut overlap loop support cydra 5 new compil techniqu parallel loop unpredict branch vliw architectur memori disambigu facilit instructionlevel parallel compil machin descript languag compil superblock format use static program analysi superblock effect techniqu vliw superscalar compil softwar pipelin effect schedul techniqu vliw machin sentinel schedul model compilercontrol specul execut effect compil support predic execut use hyperblock effici schedul fine grain parallel loop iter modulo schedul algorithm softwar pipelin loop schedul techniqu easili schedul horizont architectur high perform scientif comput code gener schema modulo schedul loop parallel loop exit pipelin architectur enhanc modulo schedul loop condit branch tr softwar pipelin effect schedul techniqu vliw machin overlap loop support cydra 5 new compil techniqu parallel loop unpredict branch vliw architectur parallel loop exit pipelin architectur advanc languag compil parallel process use profil inform assist classic code optim effect compil support predic execut use hyperblock code gener schema modulo schedul loop enhanc modulo schedul loop condit branch sentinel schedul instructionlevel parallel process superblock iter modulo schedul unrollingbas optim modulo schedul effici schedul fine grain parallel loop superblock format use static program analysi three architectur model compilercontrol specul execut schedul techniqu easili schedul horizont architectur high perform scientif comput ctr elana granston eric stotzer joe zbiciak softwar pipelin irregular loop tms320c6000 vliw dsp architectur acm sigplan notic v36 n8 p138144 aug 2001 fei chen timothi w oneil edwin hm sha optim overal loop schedul use prefetch partit ieee transact parallel distribut system v11 n6 p604614 june 2000 suhyun kim soomook moon jinpyo park kemal ebcioglu unrollbas copi elimin enhanc pipelin schedul ieee transact comput v51 n9 p977994 septemb 2002 moon evalu schedul techniqu sparcbas vliw testb proceed 30th annual acmiee intern symposium microarchitectur p104113 decemb 0103 1997 research triangl park north carolina unit state ganesh lakshminarayana kamal khouri niraj k jha wavesch josep llosa stefan freudenberg reduc code size modulo schedul absenc hardwar support proceed 35th annual acmiee intern symposium microarchitectur novemb 1822 2002 istanbul turkey enric gibert jess snchez antonio gonzlez interleav cach cluster vliw processor proceed 16th intern confer supercomput june 2226 2002 new york new york usa mari lou soffa interprocedur condit branch elimin acm sigplan notic v32 n5 p146158 may 1997 nystrom alexandr e eichenberg effect cluster assign modulo schedul proceed 31st annual acmiee intern symposium microarchitectur p103114 novemb 1998 dalla texa unit state satish pillai margarida f jacom compilerdirect ilp extract cluster vliwep machin predic specul modulo schedul proceed confer design autom test europ p10422 march 0307 alexand g dean complement softwar pipelin softwar thread integr acm sigplan notic v40 n7 juli 2005 samuel larsen rodric rabbah saman amarasingh exploit vector parallel softwar pipelin loop proceed 38th annual ieeeacm intern symposium microarchitectur p119129 novemb 1216 2005 barcelona spain sangmin shim soomook moon splitpath enhanc pipelin schedul ieee transact parallel distribut system v14 n5 p447462 may michael dupr nathali drach olivi temam vhc quickli build optim complex embed architectur proceed intern symposium code gener optim feedbackdirect runtim optim p53 march 2024 2004 palo alto california