redund synchron elimin doacross loop abstractcrossiter data depend doacross loop requir explicit data synchron enforc howev composit effect data synchron may cover depend make enforc cover depend redund paper propos effici gener algorithm identifi redund synchron multipli nest doacross loop may multipl statement loopexit control branch elimin redund sychron doacross loop allow effici execut loop also address issu enforc data synchron iter near boundari iter space depend may exist boundari iter add complex determin redund synchron boundari iter necessari suffici condit synchron uniformli redund also studi result allow parallel compil gener effici data synchron instruct doacross loop b introduct concurr execut loop crossiter data depend term doacross loop allow us exploit looplevel parallel beyond vector loop doall loop applic program machin size becom larger exploitingmor parallel programbecom import howev effici data synchron requir support execut model commerci avail multiprocessor alliant fx seri alreadi provid architectur hardwar support execut doacross loop effici mani crossiter data depend doacross loop data depend need enforc explicit synchron order satisfi origin memori access order program howev mani synchron redund transit natur data depend statement elimin redund data synchron sever advantag first fewer data synchron allow us use system resourc synchron regist alliant machin effect second data synchron usual requir long commun delay processor fewer synchron caus fewer processor stall third fewer data synchron mean fewer synchron instruct need gener make code size smaller paper propos effici algorithm identifi redund synchron multiplynest doacross loop often multipl statement loop bodi also address nonuniform redund boundari iter multidimension iter space caus possibl backward depend direct inner loop level nonuniform redund make enforc data depend complic necessari suffici condit identifi redund synchron nonuniform problem also present paper present organ follow section 2 3 describ algorithm start singl loop follow multipl loop case discuss summari previou research area given section 4 section 5 conclud present tree edg forward edg seodf search tree b control path graph cpg c iter space depend graph isdg i1100 end singl loop figur 1 simpl loop exampl redund synchron elimin 21 loop straight control flow first look simpl case singlynest loop branch loop bodi figur 1a identifi redund synchron among statement differ iter build control path graph cpg cpg loop twodimension graph column repres iter node column statement iter assum iter doacross loop execut sequenti one processor control flow edg one statement immedi successor iter repres broken edg figur 1b solid edg repres loopcarri crossiter data depend number row determin number statement one iter number column longest distanc data depend loop figur 1a loopcarri data depend distanc 1 2 figur 1b show correspond cpg shade area three column 2 8 show identifi redund data depend singl loop need examin 4 krothap use sequenti execut order depth first search seodf algorithm iter space depend graph isdg entir loop bodi iter repres singl node isdg edg exist two node loopcarri depend two iter isdg simpl loop obtain collaps node column cpg figur 1b one big node figur 1c import note everi iter figur 1b figur 1c incom edg outgo edg except first last iter incom outgo edg miss nonexist depend sourc one import characterist isdg acycl otherwis iter would execut anoth iter seodf differ normal depthfirst search df successor depth level examin accord sequenti execut order loop edg mark one follow see figur 1d ffl tree edg search path seodf ffl forward edg alreadi path form tree edg tail node head node ffl cross edg neither tree edg forward edg goal seodf find forward edg first iter isdg start search node repres first iter forward edg repres transit edg correspond redund synchron definit path form tree edg tail ie depend sourc head ie depend sink let us see extend seodf cpg cpg also acycl similar isdg observ 1 node cpg successor column alway search successor 2 import note column ie iter depend pattern need identifi forward edg node first column 3 cross edg node first column algorithm perform df cpg shown figur 2 first observ know node reach node column must travers node column travers procedur perform df mark redund depend procedur invok call check00 due depthfirst natur procedur process check forward edg actual perform start last statement iter markit marker iter mark progress check iter initi n total number statement loop bodi procedur check iter start begin mark iter start statement n downto statement start begin depend sourc sequenti execut order begin sink iter iter dist sink iter dmax noth rang els mark sink iter sink sink visit iter 0 check depend iter 0 mark depend redund els check sink iter sink sink first reach recurs examin end end procedur check figur 2 df algorithm cpg column use marker record statement travers column marker initi last statement column edg whose head statement lexic later mark statement column edg forward edg accord df algorithm figur 2 head statement must visit henc must altern path tail statement head statement edg mark edg forward edg correspond redund synchron everi edg travers time complex algorithm 2 n number node cpg storag use proport sum number depend number column cpg check redund synchron start check0 0 22 loop multipl control flow section show gener algorithm handl control branch loop howev assum exitloop branch loop statement abort loop execut discuss section 4 branch one control flow path iter examin everi possibl control flow path make sure synchron realli redund path 8 author show examin cpg possibl control flow combin window dmax iter necessari suffici determin redund synchron singl loop algorithm base approach also incorpor df algorithm previou section make check case easier need identifi possibl path one iter record path pathij jth statement path anoth array ipath act invers function path ipathpathijij sequenc number statement path given ipathsi final iter pathi give control flow path assum iter current cpg total pcount1 possibl control flow path one iter valu iter path rang 0 pcount also assum backward jump loop possibl control flow path found variat depthfirst travers figur 3 show gener algorithm algorithm start cond check0 examin finish synchron depend redund countm zero 3 doublynest loop redund synchron elimin section extend singl loop algorithm multiplynest loop singl loop one dimens iter space data depend must point forward therefor sourc sink depend fall within iter space iter sourc sink iter within iter space multiplynest loop depend neg direct nest level outmost level synchron depend redund middl iter space may redund boundari iter necessari intermedi iter may outsid iter space caus redund synchron check differ nonuniform boundari iter iter space 4 shown doublynest loop inner loop least pmax anmin 1 iter pmax posit distanc anmin absolut valu neg distanc inner loop redund check uniform redund synchron found cover iter howev point 11 true loop bodi singl statement synchron done iter level instead statement level cpg altern path cover redund synchron consid lexic order statement isdg statement iter group togeth procedur check iter start begin u ipath n iter path iter get sequenc number last statement n ipath start iter path iter get sequenc number statement start mark iter start n u downto v begin path iter path iter n current statement examin depend sourc sequenti execut order begin sink iter iter dist sink iter dmax noth rang els sink cpg noth els mark sink iter sink sink cover iter 0 examin depend iter 0 count redund cpg els check sink iter sink sink first reach recurs examin end procedur check procedur cond check iter begin tri possibl flow path iter p iter path iter p last iter call recurs iter dmax cond check iter 1 els begin last iter perform redund check marker bottom depend node first iter begin record depend need check sourc sink depend control flow path examin count gammagamma check 00 start check end procedur cond check figur 3 df algorithm loop branch therefor altern path isdg impli altern path correspond cpg restrict algorithm loop multipl statement propos 11 find subset redund synchron guarante redund throughout entir iter space unfortun algorithm could also miss mani synchron redund throughout iter space section propos new scheme identifi uniformli redund synchron multiplynest loop multipl statement iter scheme base necessari suffici condit determin synchron uniformli redund use doublynest loop illustr howev easili extend multiplynest loop without loss gener also assum depend distanc loop level posit goal determin larg area iter space use gener cpg df algorithm show depend distanc vector space iter space node point iter cpg df algorithm present figur 3 use identifi redund synchron df algorithm work cpg handl loop multipl statement synchron done statement level instead iter level 31 depend slope synchron chain first given data depend determin area need check uniform redund synchron depend sourc sink j iter space depend distanc vector definit 2 depend slope depend distanc vector defin possibl depend slope interv gamma1 1 first compon valid depend distanc vector posit zero must valid loop execut order zero j second compon posit integ zero henc slope gamma1 possibl region 1 region 2 region 3 region 4 outer loop index inner loop index j 1 2 ebmb yaxi xaxi xa figur 4 2d depend distanc vector space gammam theta figur 5 line equat figur 4 show depend repres depend distanc vector 2d depend vector space let denot set depend distanc vector loop gammam maxim minim valu depend slope four line 1 2 3 4 figur 4 defin equat figur 5 four intersect point o0 form parallelogram also four region figur 4 specifi figur 6 region well defin 6 1 region 1 4 empti set easi see union four region parallelogram adco alway includ point line check redund synchron doublynest loop area left right x region 2 x region 3 region 4 x figur defnit region figur 4 ignor synchron chain depend distanc vector space path p consist order set point fp ng space segment depend vector lemma 1 figur 4 exist synchron chain point point g region 1 region 1 empti lemma true otherwis 6 1 suppos synchron chain p g region 1 let maximum depend slope segment p b b contradict fact g region 1 henc synchron chain point g region 1 figur 4 2 lemma 2 figur 4 exist synchron chain point g region 2 point proof observ 1 gammam 6 gamma1 suppos synchron chain p g region 2 let ng sinc gammam minimum depend slope segment p b b contradict fact g region 2 b henc synchron chain point g region 2 2 similar lemma prove region 3 4 theorem 1 show parallelogram adco need examin find redund synchron theorem 1 synchron chain p contain point region 1 2 3 4 proof exist synchron chain p contain g region 1 subpath g synchron chain end point g region 1 contradict result lemma 1 therefor synchron chain p contain point region 1 similar result region 2 3 4 prove lemma 1 2 2 32 boundari problem redund synchron elimin previou section see exist altern path must follow synchron chain contain entir parallelogram adco use conclus examin everi iter iter space eg figur 7a origin correspond iter examin see figur 7b howev suffici examin adco order determin instanc redund exampl origin figur 4 correspond iter bottom iter space figur 7c synchron chain contain intermedi point region fco would invalid cover intermedi point iter space loop xaxi execut mainli caus neg valu second compon correspond inner loop depend distanc vector section show suffici condit follow necessari suffici condit determin iter space larg enough contain altern path synchron chain particular depend suffici condit easier understand calcul necessari suffici condit give precis redund inform assum rectangular 2d iter space shown figur 7a result follow lemma use later theorem lemma 3 follow relat true figur 4 h gamma b outer loop index inner loop index top middl bottom iter space b redund synchron c nonredund synchron figur 7 2d iter space h 0 proof valu h h 0 theta obtain combin equat line 1 3 2 4 respect figur 5 addit 1 theta gamma b 0 therefor mm 0theorem 2 depend distanc vector da b 0 b 0 altern path trapezoid adfo synchron unnecessari sourc iter middl bottom section iter space figur 7a proof sourc instanc middl bottom section iter space figur 7a align origin figur 4 sourc iter two possibl case aris sink iter iter space synchron need otherwis show trapezoid adfo entir iter space sinc h row iter top section h also rectangular iter space final sinc gamma b f also rectangular iter space adfo trapezoid four corner insid rectangular iter space entir trapezoid adfo iter space sinc altern path adfo conclud synchron depend unnecessari 2 theorem 3 depend distanc vector da b 0 b 0 altern path trapezoid oedc synchron unnecessari sourc iter top middl section iter space figur 7a proof sourc instanc top middl section iter space figur 7a align origin figur 4 sourc iter two possibl case aris sink iter iter space synchron need otherwis show trapezoid oedc entir iter space sinc h 0 row iter bottom section h 0 c also rectangular iter space final sinc b e also rectangular iter space oedc trapezoid four corner insid rectangular iter space entir trapezoid oedc iter space sinc altern path oedc conclud synchron depend unnecessarytheorem 4 rectangular iter space eg figur 7a least hh 0 row depend altern path trapezoid adfo oedc respect synchron redund iter includ boundari iter iter space proof rectangular iter space least h top bottom section probabl nonempti middl section figur 7a theorem 2 synchron redund middl bottom section theorem 3 synchron redund top middl section therefor synchron redund iter 2 theorem 4 give suffici condit synchron redund larg enough iter space besid h h 0 easili determin equat 5 6 dimens iter space known compil time redund synchron determin compil hand dimens iter space depend program input may gener multipl version loop simpl test place loop dynam determin version execut take advantag elimin redund synchron although precis inform redund synchron determin appli df algorithm section 2 entir iter space certainli quit time consum impract base result deriv far actual find necessari suffici condit synchron redund iter space condit specifi threshold height iter space call critic height describ calcul critic height lemma 4 figur 4 altern path rectangl corner 0 0 0 k k 0 k posit integ altern path rectangl corner 0 0 0 proof easi see second rectangl enclos entir first rectangl therefor altern path smaller rectangl must altern path larger rectangl 2 basic idea find critic height find trapezoid adfo smallest integ valu k specifi rectangl contain altern path similarli k 0 determin trapezoid oedc except rectangl grow downward two corner fix 0 b b base result lemma 4 search k k 0 done effici binari search interv b h 0 h 0 k found search interv specifi rectangl altern path redund matter larg iter space critic height equal 1 otherwis critic height k theorem 5 doublynest loop synchron depend redund iter space height larger critic height proof first prove part iter space height larger k use partit scheme similar figur 7a h h 0 replac k k 0 respect synchron redund top middl section bottom section provid necessari room contain altern path sourc iter lowest row middl section similarli synchron redund middl bottom section top section provid necessari room contain altern path sourc iter highest row middl section therefor synchron redund iter prove part suppos contrari height iter space less critic height critic height 1 synchron redund otherwis let height k r posit integ let row beneath jth row definit k 0 row larg enough contain altern path sourc iter jth row similarli sinc k row jth row definit k row larg enough contain altern path sourc iter jth row therefor synchron sourc iter jth row redund impli synchron redund iter 2 implement issu h h 0 small theorem 4 satisfi loop use better effici two trapezoid adfo oedc figur 4 need examin integ loop bound easi determin instead use rectangl corner 0 0 0 dhe dhe 0 adfo oedc use rectangl corner 0 b b bgammah 0 c 0 bgammah 0 c two rectangl actual similar size shown b depend distanc vector da b number iter need examin approxim 2 theta theta theta theta b theta theta theta theta theta theta theta mani depend check trade precis effici calcul largest rectangl depend check everi depend rectangl instead rectangl result one pair h h 0 set depend thu obtain redund iter iter space height larger h also simpl optim done check iter space larg enough contain sourc sink depend synchron need exitloop control branch exitloop control branch loop impli execut later iter depend branch context redund synchron elimin sinc assum statement iter execut sequenti add depend sourc condit statement branch sink first statement next iter use algorithm describ section 2 higher dimens iter space use doublynest loop exampl extend result section 3 ngammadimension iter space simpli modifi definit 2 defin depend slope dimens calcul maximum minimum slope dimens ngammadimens region correspond parallelogram adco figur 4 thu found higher dimension version suffici condit similar specifi theorem 4 except differ hh 0 dimens obtain critic height necessari suffici condit theorem 5 dimens also straightforward need examin n differ dimens one one search critic height critic height found later dimens also guarante exist altern path one order examin critic backtrack necessari previou work redund synchron elimin problem first describ li abusufah 7 6 use domin lock lock specifi depend relat lock domin anoth lock enforc first lock ensur second lock preserv three condit identifi domin lock provid cover limit case midkiff padua 10 9 describ scheme gener synchron instruct compil use test testset similar await advanc instruct use alliant minisupercomput 1 also introduc control path graph cpg show order impos synchron control depend mimd machin elimin redund synchron use transit closur method check given synchron whether transit closur remain synchron cover arc previous determin redund check time complex algorithm odn 3 number statement cpg number depend bound n 2 complex also shown 5 singl loop show column cpg need dmax largest depend distanc shaffer 12 show algorithm find transit synchron arc task synchron transit successor synchron sourc least one path sink algorithm time complex 3 n number node task graph work done callahan et al 2 use data flow analysi algebra formul determin whether depend properli cover synchron synchron primit use postwait handl gener program construct limit parallel loop henc time complex potenti higher effici algorithm find redund synchron doacross loop uniform depend propos krothap sadayappan 4 5 work either singl statement loop synchron iter level instead statement level depend uniform iter depend first iter need verifi use variat depthfirst search df determin transit synchron arc scheme extend multiplynest loop provid iter space larg enough depend uniform even iter boundari given graph n node e edg depthfirst search algorithm time complex oe equival 2 approach effici find redund synchron iter howev synchron iter level often satisfactori parallel provid overlap loop iter doacross loop execut lost recent scheme propos midkiff padua 11 equival examin rectangl corner 0 0 0 b b 0 figur 4 altern path depend altern path depend rectangl must parallelogram oedf intersect two trapezoid adfo oedc satisfi theorem 2 3 synchron redund iter case k exactli minim size sourc sink iter space uniform redund synchronizationsthu found subset uniformredund synchron foundus scheme describ previou section number iter need examin rectangl theta b theta 2 5 conclus paper describ algorithm detect redund synchron effici multiplynest loop multipl statement could also branch loop multipl control flow solv boundari problem multiplynest loop use doublynest loop exampl deriv necessari suffici condit synchron redund entir iter space scheme signific improv previou scheme sens effici identifi redund synchron previou scheme either unabl ineffici find result present paper import parallel compil gener effici code doacross loop r alliant comput system corp analysi event synchron parallel program tool remov redund depend doacross loop constant depend remov redund depend doacross loop constant depend reduc data synchron multiprocess loop techniqu reduc synchron overhead larg scale multiprocessor automat gener synchron instruct parallel processor compil algorithm synchron compil gener synchron loop comparison four synchron optim techniqu minim interprocessor synchron multiprocessor share privat memori tr ctr antonia zhai christoph b colohan j gregori steffan todd c mowri compil optim memoryresid valu commun specul thread proceed intern symposium code gener optim feedbackdirect runtim optim p39 march 2024 2004 palo alto california michiel ronss koen de bosscher nonintrus detect synchron error use execut replay autom softwar engin v9 n1 p95121 januari 2002 chengzhong xu vipin chaudhari time stamp algorithm runtim parallel doacross loop dynam depend ieee transact parallel distribut system v12 n5 p433450 may 2001 long li bo huang jinquan dai luddi harrison automat multithread multiprocess c program ixp proceed tenth acm sigplan symposium principl practic parallel program june 1517 2005 chicago il usa