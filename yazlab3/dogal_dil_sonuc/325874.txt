optim queri object updat objectori databas oodb provid power data abstract model facil usual lack suitabl framework queri process optim even though increas number recent propos oodb queri optim actual focus queri optim presenc object ident destruct updat featur often support realist oodb languag paper present formal framework optim objectori queri presenc side effect queri may contain object updat place form present languag extens monoid comprehens calculu express objectori featur give formal mean extens method base denot semant often use give formal mean imper program languag semant languag extens express term monoid calculu without need fundament chang basic framework method maintain referenti transpar allow us meaning queri optim also practic optim oodb queri sinc allow optim techniqu appli regular queri use minim chang oodb queri updat b introduct one key factor oodb system success compet relat system well meet perform requir mani nontradit applic develop effect queri optim even though mani aspect oodb queri optim problem benefit alreadi success relat queri optim research mani key featur oodb languag make problem uniqu hard solv featur includ object ident method encapsul userdefin type constructor larg multimedia object multipl collect type arbitrari nest collect nest queri express increas number recent propos oodb queri optim focus handl nest collect ow92 col89 other convert path express join km90 cd92 other unnest nest queri cm95b cm95a other focus handl encapsul method dgk 91 howev propos queri optim presenc object ident destruct updat featur often support realist oodb languag earlier work fm98 fm95b fm95a propos effect framework solid theoret basi optim oodb queri languag calculu call monoid comprehens calculu alreadi shown captur featur odmg oql cat94 good basi express variou optim algorithm concis includ queri unnest feg98 translat path express join feg97 paper extend framework handl object ident object updat 11 object complic queri optim objectori program base sideeffect modif object store even though modern oodb provid declar queri languag associ access data queri languag allow invok method includ perform side effect object creation common oodb queri side effect sinc insert new object class extent consid exampl follow oql queri select personenameeaddress e employe creat new person employe even though queri seem free side effect first glanc modifi extent class person insert new person queri part anoth queri queri scan extent class person extent would modifi accordingli use outer queri therefor semant queri must reflect fact person extent modifi execut queri failur may result incorrect optim may lead invalid execut plan problem assign semant objectori queri becom even wors allow object state modif arbitrari place queri like oodb languag exampl oql queri select esalari esalary108 e employe esalary50000 give 8 rais employe earn 50000 semant queri reflect fact salari modifi iter situat queri mix freeli updat occur frequent oodb languag ag89 support set iter embed comput complet program languag even though languag begin disappear favor declar languag oql surg interest provid comput power exist declar queri languag without sacrif perform consid exampl follow queri taken ld92 divis e employe suchthat edivisiond f totpay type queri allow kind c code insid forloop includ code modifi databas earlier research queri optim ld92 shown queri form hard optim anoth problem consid set bag combin side effect result may unpredict due commut exampl follow queri e employe valu x end execut program would depend way employe scan understand extent problem consid function fn contain assign xn bodi return n valu x execut ff1 f2g 1 2 sinc fx ff1 f2g equal ff2 f1g given side effect may appear place program prove equival oodb express becom hard make task express verifi optim rule difficult accomplish exampl well known transform x x term x valid sinc x may queri perform side effect order execut side effect would chang transform appli thu chang semant program one way patch error attach guard transform rule prevent execut term x contain side effect unfortun approach conserv may miss optim eg side effect x interfer furthermor fundament problem algebra oper side effect exampl x appear valid translat declar queri sinc declar queri defin execut order consequ optim realist oodb queri languag need address problem object ident properli handl implicit explicit side effect due use object ident also highli desir use exist optim techniqu minim chang possibl necessari captur handl object ident framework regular queri side effect unfortun extens difficult incorpor exist optim framework understand level difficulti consid follow equal predic personsmithpark predic must evalu fals sinc left object differ ident right one hand given function gx comput predic xx function call gpersonsmithpark av return true unfold call g get previou fals express consequ substitut bodi function definit function call valid transform goal give formal mean oodb queri side effect importantli provid equat theori allow us meaning queri optim highli desir theori seamlessli incorpor monoid comprehens calculu possibl discov new monoid captur mean object ident anoth goal whenev object updat queri would like queri treat way current treat basic optim without object extens 12 approach paper present framework incorpor impur featur name object ident monoid comprehens calculu accord earlier discuss import give semant extens preserv referenti transpar referenti transpar abl substitut equal subexpress context larger express give equal result rea89 queri languag lack properti transform rule queri optim would depend context express appli research program languag often use formal method denot semant solv problem denot semant approach impur featur languag captur pass state object store oper program piec program updat state state propag otherwis modifi reflect updat say state modifi mean new copi state creat approach may becom quit ineffici destruct updat matter small new object store ie entir databas must creat obvious techniqu unaccept databas applic solut problem allow state manipul small number primit preserv referenti transpar effici implement well specif even though primit defin pure function way implement perform destruct updat state way deriv effici program importantli maintain referenti transpar allow us meaning queri optim catch solut work state singlethread sch85 roughli speak state singlethread program program undo state modif point strict sequenc state updat program case state replac access right singl global variabl state oper made caus side effect preserv oper properti follow exampl non singlethread program assum x2 x1 statement assum s1 s2 execut statement s1 local state modif s1 use s2 exclus discard thu valu x complet program 1 3 respect sinc bind x2 discard use yx1 statement requir local copi state execut probabl form stack state handl nest assum statement sinc need backtrack previou state complet execut rollback databas transact anoth exampl non singlethread oper two common way guarante singlethreaded first allow state manipul languag detect violat singlethreaded perform semant analysi ie kind abstract interpret sch85 use linear type system ss95 detect violat typecheck second approach adopt framework restrict syntax languag way state guarante alway singlethread anoth seriou problem mention denot semant approach pass state oper program need sequenti oper restrict good idea commut oper sinc may miss optim opportun exampl rang r assign x r evalu scan r two way one set x 1 end 2 depend way r scan solut valid consid optim address problem gener possibl solut gener altern first stage optim select best one end perform cost analysi even though approach may gener exponenti number solut appli constant data practic provid queri contain larg number union oper altern solut correspond typic differ final databas state end one solut chosen optim collect semant queri queri collect possibl correct answer decid consid solut instead report error one solut exist use program fall categori consid altern queri optim necessari prove program equival prove ff1 f2g equal ff2 f1g plan gener phase ie optim complet select altern framework inspir ohori work repres object ident use monad oho90 contribut mix state transform set bag appli theori databas queri languag satisfi strong normal properti normal remov unnecessari state transform thu make approach practic optim program objectori calculu import contribut work develop method map program state transform remov normal imper loop much way one could express program use regular imper languag c result program effici written hand rest paper organ follow section 2 describ earlier result monoid comprehens calculu section 3 describ object extens monoid calculu section 4 propos new monoid captur object ident side effect section 5 describ framework handl object ident use denot semant section 6 address practic consider build optim base framework section 7 present prototyp implement framework final section 8 extend framework captur databas updat discuss theori appli solv view mainten problem background monoid comprehens calculu section summar earlier work monoid calculu formal treatment present elsewher fm98 fm95b fm95a monoid calculu base concept monoid abstract algebra monoid type pair phi z phi phi associ function type theta ie binari function take two valu return valu call accumul merg function monoid z phi type call zero element monoid left right ident phi zero element satisfi z phi phi everi x sinc accumul function uniqu identifi monoid often use accumul name monoid name exampl monoid includ f g set ffgg bag list 0 1 max 0 integ fals true boolean monoid integ boolean call primit monoid construct valu primit type set bag list monoid call collect monoid collect monoid phi z phi requir addit definit unit function u phi along merg zero allow us construct possibl valu type exampl unit function set monoid x fxg take valu x input construct singleton set fxg output list monoid commut ie satisfi x phi addit max idempot ie satisfi x phi monoid comprehens monoid phi take form phif e j r g express e call head comprehens term r term sequenc call qualifi either gener form v e 0 v rang variabl e 0 express gener domain construct collect filter p p predic use shorthand f e j r g denot set comprehens f e j r g monoid comprehens defin follow reduct rule omega collect monoid possibl differ phi ae u phi e phi collect monoid e otherwis d1 rule d2 d3 reduc comprehens leftmost qualifi filter rule d4 d6 reduc comprehens leftmost qualifi gener letstat d5 bind v e 0 use bind everi free occurr v phif e j r g calculu semant wellformed requir comprehens idempot commut monoid gener idempot commut monoid exampl valid monoid comprehens sinc map set monoid commut idempot list monoid neither commut idempot fx j x ff1 2gg g valid sinc commut requir easili check compil time restrict set monoid comprehens equival set monad comprehens bl captur precis nest relat algebra fm95b oql express direct translat monoid calculu exampl oql queri select distinct hotelpric hotel select h c citi h chotel exist r hotelroom rbed hotelnam select tname state sattract translat follow comprehens f hotelpric hotel f h c citi h chotel cnamearlington g f rbed num3 r hotelroom g use shorthand x j u repres bind variabl x valu u mean construct given follow reduct eux express e u substitut free occurr x ie eux equival let addit syntact sugar allow irrefut pattern place lambda variabl rang variabl variabl bind pattern like compil away use standard pattern decomposit techniqu pj87 exampl equival f afst asndfst retriev firstsecond element pair anoth exampl x function take three paramet return sum equival afst asndfst monoid calculu put canon form effici rewrit algorithm call normal algorithm evalu canon form gener produc fewer intermedi data structur initi unnorm program moreov normal algorithm improv program perform mani case gener mani optim techniqu alreadi use relat algebra fuse two select one select follow import rule normal algorithm reduct n2 pred j r idempot phi n4 sound normal rule prove use definit monoid comprehens fm98 rule n3 flatten comprehens contain gener whose domain anoth comprehens may requir variabl renam avoid name conflict rule n4 unnest existenti quantif exampl previou oql queri normal cnamearlington rbed num3 snametexa tnamehnam g appli rule n3 unnest two inner set comprehens rule n4 unnest two existenti quantif 3 object monoid calculu section monoid calculu extend captur object ident extend calculu call object monoid calculu exampl one valid objectori comprehens first creat list contain two new object new1 new2 variabl x rang list state x increment one x x1 x refer object x x return state object x result comput list 2 3 objectori comprehens translat state transform propag object heap contain bind object ident object state oper express chang oper creat new object modifi state object translat captur precis semant object ident without need extend base model also provid equat theori allow us valid optim objectori queri introduc new type constructor objt captur object state repres valu type addit extend monoid calculu follow polymorph oper oho90 style sml pau91 ffl new type objt oper news creat new object state ffl type objt oper e derefer object e return state e ffl type objt bool oper e chang state object e return true mani objectori languag differ way construct manipul object exam ple oql use object constructor creat object requir explicit object dereferenc oper languag featur easili express term primit mention give formal semant primit better choic sinc deal detail object class inherit etc optim real objectori languag though detail address properli objectori oper may appear place monoid comprehens follow exampl comprehens object oper call object comprehens recal v j e defin new variabl name v synonym valu e e1 e2 chang state object whose oid equal valu e1 result e2 true first exampl indic differ object distinct second exampl indic object may equal state ninth exampl comput cardin set f1 2 2 indic duplic set count last exampl interest one sinc order set f1 2 2 3g mani result permut set name f1 3 6g f1 4 6g f2 3 6g f2 5 6g f3 4 6g f3 5 6g consid result valid optim construct plan end gener one result practic exampl queri edepart emanagerdepart g set depart employe depart employe manag 4 state transform monoid one way handl side effect denot semant map term comput valu type function type theta type state side effect take place term type map function take initi state s0 type input gener valu type new state s1 denot semant function type theta call state transform wad92 wad90 term perform side effect state transform map s0 differ state s1 reflect chang otherwis state remain unchang exampl constant integ 3 map state transform s3 propag state note new state comput valu well may depend input state way side effect captur pure function map state new state unfortun add side effect calculu program may multipl interpret mainli due commut monoid result nondeterminaci highli desir captur interpret let optim select best one end handl type nondetermin function way given input state state transform must abl return multipl valu multipl state word must abl return multipl valuest pair consequ state transform type sett theta captur possibl interpret program transform state transform phit type state type show shortli given monoid phi type alway defin primit monoid phi state transform phit contrast monoid describ earlier monoid must higherord monoid ie instanc monoid function definit phi describ import prove correct variou transform rule safe skip reader interest proof first present simpl definit work well noncommut nonidempot monoid extent captur monoid transform monoid state transform monoid monoid phi z phi primit monoid phi z phi defin follow z phi function appli state type construct valu fz phi sg merg function phi propag state first state transform second merg result valu use phi easi prove n 0 state monoid comprehens simpli monoid comprehens state transform monoid exampl f fv sg j v 1 2 3 g s0 f3 sg s0 state type suppos state integ count list element follow state comprehens increment element list 1 2 3 use state count list element f fv state transform monoid phi effect must properti monoid phi otherwis may introduc semant inconsist phi commut idempot must phi captur properti redefin phi behav way phi f g defin follow ae phi commut f g otherwis ae g phi commut oe 1 phi oe 2 two interpret one propag state oe 1 oe 2 oe 2 oe 1 contribut factor g phi idempot element x remov x phi evalu exampl integ state count set element fz phi s1g els g propag state right left equal ff1g 1g counter count list element 1 even though appear twice prove appendix theorem 1 extens phi valid monoid also compat phi monoid ie phi commut andor idempot phi captur object far discuss state type inde type wish captur databas updat exampl state would entir databas though interest captur object ident state state transform captur object ident view pair l n oho90 valu l call object store map object type ie instanc type objt valu type map oid object state integ n counter use comput next avail oid four primit manipul state follow type lookup ref n map integ n oid refer object type emptystor initi object store valu without object ext l v extend object store l bind oid state valu v lookup l access object store l retriev state object oid exampl lookup int ext int l ref int 100 1 ref int 100 return 1 state object type objint oid 100 abov primit satisfi follow equival ext ext lookup lookup figur 1 present denot semant import construct monoid calculu without object extens ie without new without object extens state figur 1 denot semant monoid calculu use state transform propag chang semant object extens form nonstandard interpret given later equat semant bracket give mean syntax enclos bracket term pure monoid comprehens calculu type domain typecorrect term object monoid calculu monotyp nonfunct type gener e type type e denot defin follow recal also state type pair l n conveni use notat l n whenev either compon l n need access rule s7 figur 1 handl function term exampl translat fv 0 fv 0 g sg appli state rule s8 assum callbyvalu interpret rea89 e2 e1e2 evalu e1 appli rule s13 s14 translat monoid comprehens rule s14 use monoid comprehens monoid phi propag state everi element collect u notic comprehens head state transform state transform merg use phi comprehens valid type collect u sinc monoid phi compat monoid phi higherord comprehens necessari sinc term u may modifi object store time new object construct case though state propag chang chang follow rule appli elimin state propag correct rule straightforward omit follow rule give denot semant object extens oper new take avail oid n use oid new object state e addit object store extend bind ref n state valu rule s16 instead destruct chang object store extend store new bind oid left part valu right part rule s17 simpli look object store request oid appendix provid proof theorem theorem 2 indic state modif oper calculu output state input state canon form deriv normal similar canon form get pure monoid calculu theorem basic guarante even though state transform sequenti oper program perform state modif normal algorithm remov unnecessari state transform follow exampl translat normal term object monoid calculu state l n interest exampl increment element set integ type setobjint set cardin express help counter x support bag set object without inconsist exampl ffnew1 new2gg valid express equal ffnew2 new1gg similarli assign freeli move insid set construct 6 translat object comprehens effici program seen previou section objectori comprehens express term basic monoid comprehens calculu use denot semant rule figur 1 result program usual ineffici sinc manipul state even state use ineffici reduc help normal algorithm algebra equal object primit rule o1 o5 fact part result program normal firstord program look similar program one might write use four object primit directli section focus effici execut program reduc firstord program normal algorithm translat object monoid calculu basic calculu consid possibl altern due commut oper absolut necessari prove program equal normal complet algebra equal use check program equival optim safe discard one altern follow function choos select random altern practic choic made help cost function given program p object calculu initi state s0 system evalu choosenormalizep p first translat normal final altern select pair valu state choos function defin follow rule figur 1 guarante alway least one choic case miss rule choos altern state monoid comprehens state monoid comprehens remov normal algorithm effici implement comprehens crucial consid system perform default implement state monoid comprehens loop creat state transform ie function iter compos state transform use merg function state transform monoid approach obvious ineffici would like find better algorithm evalu state comprehens faster one possibl solut actual compil comprehens loop updat like one found imper languag particular choos phif e j v r g s0 translat follow loop pascallik syntax initi state re z phi initi result valu v r retriev one possibl valuest pair re re phi xfst updat result xsnd updat state return exampl previous shown set cardin translat follow state monoid comprehens map follow loop re 0 r f re maxr lookupl refn return re l n even though loop right function still ineffici sinc manipul object store l everi step loop result program implement effici store global array object primit program directli manipul global array rule s15 s16 singlethread sinc object creation undon point rule s17 enforc singl array pointer fetch state first use lookup return pointer l consequ alway one pointer store therefor store implement global store updat inplac destruct updat primit oper object store done destruct specif let store global array mention whose domain element type eg store defin void c object primit implement follow lookup 0 implement s1 evalu statement order return e exampl lookup ext ext x implement result program state transform evalu effici real objectori program exampl previou loop correspond set cardin becom re 0 r f re maxresstoren1 return use global array implement object primit 7 implement alreadi built prototyp implement framework translat oodb queri shown paper gener program sourc code avail httpwwwcseutaedufegarasoid follow exampl illustr translat five object queri system notat use exampl littl bit differ use theoret framework execut statement sequenc return valu v loopiteratex execut statement valu x x accessn return valu storen updaten v evalu storen v everi object queri type translat express type theta void theta int valu return valu void valu correspond state ignor int valu new oid counter assum valu oid counter execut queri equal n exampl object queri e contain object oper translat would pairepairnulln pair construct pair two valu null type void assignres0 loopiteratee assignresmaxresplusaccessn assignspairblockupdatenplusaccessnenullsnd assignestructbindnameprojectderefenam assignres0 loopiterateeemploye assignresplusresifgtprojectaccessesalary5000010 assignsifgtprojectaccessesalary50000 bindsalarytimesprojectaccessesalary108 snd figur 2 denot semant databas updat first queri new1 assign 1 storen store next avail oid set n n 1 return old valu n second queri execut storex storex third queri correspond f x gener block contain storen 1 old valu storen 2 new valu execut sequenc fourth queri gener state monoid comprehens turn translat loop return sum element e last queri give 8 rais employe earn 50000 return number employe got rais simplic assum employe name salari 8 databas updat view mainten monoid state transform also use express destruct databas updat term basic algebra way databas updat queri optim singl framework let db current databas state let db type typic db aggreg persist object applic follow analysi previou section want translat updat monoid algebra way propag state ie entir databas singlethread databas updat captur use state transform propag occasion chang entir databas updat captur pure function map exist databas new databas make approach practic defin set updat primit express updat similar one object updat primit even though pure interpret effici implement approach requir signific extens formal framework normal queri optim use improv perform databas updat express use follow comprehens qualifi feg qualifi path u destruct replac valu store path u qualifi path u merg singleton u path qualifi path u delet element path equal u qualifi fundament construct sinc two defin follow path u j path u phi u phi path path u j path phif j apath 6 ug exampl comprehens chotel num 1 g insert new hotel arlington increas total number hotel denot semant express e may contain updat ae bind list bind rang variabl current databas state rule s1 s13 figur 1 need slightli modifi includ bind list ae everi map exampl rule s13 figur 1 map rule s13 figur 2 rule s14 figur 1 though map rule s14 figur 2 chang ae includ bind v rang variabl v1 gener domain bind list ae use rule s15 give semant updat qualifi express reconstruct databas state copi compon except one reach path replac v defin follow aev type phi type path possibl empti path sequenc project express sdbaev replac occurr db aev second rule appli state collect type third rule appli state record second rule use condit forc comprehens reconstruct collect valu replac element v bound updat new valu e exampl point updat chotel previou exampl bind list ae bind c dbciti case predic guarante hotel citi c ie arlington chang one implement ppath ae v path v destruct modifi part databas reach path v better explain introduct motiv use denot semant simpli give formal mean destruct construct use semant actual translat construct importantli use translat queri optim need defin invers function ppath ppath function need translat updat program optim invers function need gener destruct updat optim given reconstruct state say 0 copi except number place new valu v use instead 0 gener list destruct updat form path v composit ppath construct state 0 function ie defin follow list concaten exampl return chotel e origin updat approach first semant program given term state transform ppath state reconstruct expand normal queri optim take place elimin unnecessari updat final reconstruct state transform number destruct updat databas use ie leav futur work demonstr framework effect framework handl object updat optim framework destruct updat also use handl view mainten problem gm95 ckl97 gener form view function f databas state db valu domain materi view v fdb store view f databas compon v recogn case v use directli instead comput possibl expens view f queri becom easier queri normal unnest sinc unnest flatten queri databas updat new databas becom udb u function interpret updat thu view mainten problem equival express fudb term materi view v view recognit problem mention transform updat primit fudb appli v instead db easili attain express state transform term updat primit normal result form way fudb comput new materi view term old one v appli techniqu use databas updat new materi view fudb gener effici use destruct updat v plan show futur research framework requir minim extens basic framework practic effect well 9 conclus present formal framework handl object updat oodb queri optim even though framework appli monoid comprehens calculu adapt work optim framework mani type object manipul construct express term basic languag construct use denot semant consequ queri optim applic basic languag construct use minim chang remov ineffici due composit way translat program denot semant addit implement object store primit use side effect result program evalu effici program written hand acknowledg author grate david maier help comment paper work support part nation scienc foundat grant iri9509955 iis9811525 r rational design persist queri process facil databas program languag comprehens syntax object databas standard odmg93 gener framework optim objectori queri effici evalu aggreg bulk type nest queri object base recurs algebra queri optim nest relat support multipl view mainten polici queri optim revel uniform calculu collect type experiment optim oql queri unnest objectori databas algebra framework physic oodb design toward effect calculu object queri languag optim object queri use effect calculu mainten materi view problem advanc queri process object base use access support relat transformationbas approach optim loop databas program languag repres object ident pure function languag key method nest relat databas manag system ml work programm peyton jone element function program detect global variabl denot specif extend function databas languag updat complet comprehend monad essenc function program tr detect global variabl denot specif recurs algebra queri optim nest relat comprehend monad advanc queri process object base use access support relat rational design persist queri process facil databas program languag queri optim revel overview repres object ident pure function languag ml work programm element function program transformationbas approach optim loop databas program languag gener framework optim objectori queri essenc function program comprehens syntax toward effect calculu object queri languag support multipl view mainten polici queri unnest objectori databas optim object queri use effect calculu key method nest relat databas manag system extend function databas languag updat complet algebra framework physic oodb design ctr hiroaki nakamura increment comput complex object queri acm sigplan notic v36 n11 p156165 11012001 g bierman formal semant analysi object queri proceed acm sigmod intern confer manag data june 0912 2003 san diego california leonida fegara david maier optim object queri use effect calculu acm transact databas system tod v25 n4 p457516 dec 2000