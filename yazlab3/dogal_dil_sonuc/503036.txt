check infer via drive dag grammar abramov glck recent introduc techniqu call ura invert first order function program given desir output valu ura comput potenti infinit sequenc substitutionsrestrict correspond relev input valu case process terminatein present paper propos new program analysi invert program techniqu work comput finit grammar describ set input relat given output product grammar origin program implicitli transform use socal drive step wherea ura sound complet sometim fail termin techniqu alway termin complet sound exampl demonstr deriv type infer type checkingth idea approxim function program grammar new instanc second author develop techniqu use tree grammar approxim termin behaviour deforest howev present purpos necessari invent new type grammar extend tree grammar permit notion share product dag grammar seem independ interest b introduct programtransform techniqu collect call supercompil shown eectiv handl problem partial evalu deforest han dle appar strength supercompil stem drive object program specul unfold express contain variabl base possibl execut describ program exampl drive consid haskelllik program convent main denit serv interfac program possibl execut program variabl v vs main v vs drive program result process tree describ possibl comput program program one possibl process tree append con v vs nil con v append vs nil append vs nil let u append nil nil vsnil append con x xs nil vscon x xs con v u 1 gener process tree construct follow root process tree label righthand side main denit new leav ad tree repeatedli inspect label leaf either 1 unfold outermost call 2 instanti variabl hinder unfold 3 generalis creat two disjoint label whenev label leaf ident label ancestor renam variabl leaf unfold 9 9 k new slightli ecient program easili extract process tree name main interest paper transform checker descript input satisfi checker given program answer true fals transform program descript input checker answer true activ gener known program invers descript satisfi input yet anoth program howev nontrivi task perform program invers follow exampl show exampl 1 consid program check whether two list ident auxiliari function isnil iscon need allow pattern match one argument time reason restrict associ everi pattern match particular function denit result invert program wrt true anoth program produc pair ident list howev unreason assum produc program even though easi imagin program produc innit stream pair list ident spine element come base type element could enumer enumer clearli lead nontermin gener case wors still imagin program per se give us good descript input set mere get indic input set run observ everincreas output instead invert program one might perform comput backward gener method perform invers comput propos abramov gluck 1 name univers resolv algorithm ura ura construct process tree object program produc process tree potenti innit set constraint uninstanti input variabl xs ys exampl constraint describ set input valu mean substitutionrestrict pair produc constraint pairwis disjoint sens set describ pairwis disjoint variabl appear sever time constraint indic ident valu exampl ura would produc someth like xs 7 nil ys 7 nil xs 7 con x1 nil ys 7 con x1 nil xs 7 con x1 con x2 nil ys 7 con x1 con x2 nil 2 ura would never termin merit ura sound complet termin result precis captur input set paper sacric sound develop approach alway produc nite descript satisfi input 12 overview section 2 present formalis certain kind contextfre grammar name dag grammar instanc checker describ grammar nil nil con x con grammar consist two product form acycl direct graph also known dag rst say rewritten dag consist two singl node label nil second say rewritten complex dag two root two product view nite represent 2 dag grammar precis express data control ow program someth possibl standard tree grammar section 4 present automat method extract dag grammar program conceptu extract work two step first drive object program produc process tree second extract grammar process tree precursor drive program precis formul semant program languag present section 3 extract dag grammar approxim input set section 6 consid variou way improv precis method applic section 5 show given type checker term possibl deriv type scheme term 2 dag grammar denot fs0 set contain s0 g binari relat denot domain set determinist binari relat ie partial function denot partial function g denot set biject denit 1 given set graph g consist label function lab 2 n connectedbi relat mean node kth successor node j js th predecessor relat satisfi properti label node successor predecessor number consecut 0 formal order successor predecessor immateri simpli use binari relat write j whenev 9k 2 n k j follow use subscript like lab g g otherwis obviou graph refer denot transit closur gener superscript binari relat denot transit closur superscript denot exiv closur denit 2 graph g dag contain cycl ie 2 n dag natur talk root leav root g g leav g g j two dag e equival denot e e transform one anoth renumb node set dag denot ds exampl 2 two structur 3 depict equival class dag fs nil con xg sens structur describ famili equival dag node set n left unspeci order successor predecessor howev speci adopt convent head tail arc order left right concretis right dag exampl leav f3 4g root f0g denit 3 given set dag grammar set nite dag set dag grammar denot g exampl 3 two dag 3 compris dag grammar fs x nil consg dag grammar describ dag languag everi dag gener number rewrit initi dag give formal denit rewrit languag exampl order exampl 4 dag rewritten dag grammar 3 nil nil con x con con x nil con con x con x con con symbol use maintain order otherwis unord set root nd formal denit graph grammar rewrit exampl hope illustr rewrit work inform dag rewritten leaf node match root node j dag graph grammar match mean j label number predecessor match number successor j result rewrit leaf root j dissolv predecessor becom predecessor successor j right order illustr below6 6k1 kn 6 6 6k1 kn denit generalis notion rewrit sever leav need gener section 4 denit 4 denot p set nite sequenc set sequenc tupl denot angl h denit 5 given dag e dene match ng lab maxmatch denit 6 given set disjoint write case disjoint union dene unden otherwis given relat set 0 dene remov 0 ns 0 disjoint union two binari relat dene domain disjoint follow care pay attent exact set node n particular dag compris avoid node clash rewrit graph use fact given nite dag g 0 innit mani equival dag g denit 7 given dag grammar 2 g one steprewrit relat dene 9 hi ji 2 maxmatch g6 6 6 denit 8 given dag grammar initi dag dag languag li set normal form li grammar framework readili express set input next step show dag grammar extract program start dene semant object languag top semant build machineri calcul desir grammar 3 object languag object languag rstorder function languag pattern match oper term equal boolean denit 9 given set variabl x function name f patternfunct name g constructor c includ constant true fals dene g usual requir variabl occur lefthand side function denit leftlinear variabl righthand side function definit subset lefthand side close final requir pattern dene gfunction pairwis distinct modulo variabl name non overlap particular gfunction one catchal pattern concret program use haskelllik syntax includ datatyp denit syntax view intermedi languag obtain type check rule term like nil nil nil true denit 10 given term denot v variabl collect left right term exampl 5 tripl x denit 11 function 2 x regard substitut usual way 2 write result substitut given program p write say g c mean p function denit ident variabl name give normalord semant object languag dene smallstep relat take redex contracta separ redex context follow syntact class true figur 1 normalord semant denit 12 e 3 dt denot result replac term ground term either valu uniqu decompos context redex ie decomposit properti allow us dene semant semant impos lefttoright evalu except equal oper evalu argument two outermost constructor compar denit 13 given program p smallstep semant p dene smallest relat rt close term dene fig 1 follow use subscript like p otherwis obviou program refer get full semant languag simpli need close relat context semant determinist lemma 1 proof sketch induct case analysi syntact structur term term either decompos context redex uniqu decompos case redex one smallstep deriv 4 explicit previou section aloow us deal execut ground term abl drive program howev need handl term contain variabl use follow syntact class combin previous dene one describ term decompos context redex denit 14 variabl letterm v let use letterm describ previou section obtain uniquedecomposit properti term either valu uniqu decompos context redex uniqu decompos context specul ie ds extra syntact class enabl us identifi term need driven ie instanti supercompil drive use obtain process tree object program process tree serv two orthogon purpos keep track data control ow essenti variabl instanti recurs call provid conveni way monitor drive process perform generalis need ensur nite process tree generalis need replac term let point make generalis abl treat t1 t2 independ exam ple might want revisit 1 introduct thorough introduct techniqu see srensen gluck 13 approach program invers call explicit assum generalis necessari ensur termin comput advanc olin generalis analysi specic assum term replac term form let t1 t2 program interest respect data control ow program ow express dag grammar elabor later section sinc thu elimin need process tree keep thing simpl drive object program without construct actual process tree construct process tree although import practic essenc approach remark 1 note exist olin generalis analysi essenti explicit process describ follow could incorpor wellknown nontermin detect perform necessari generalis 1 incorpor would induc unnecessari clutter present concentr descript extract dag grammar drive birdsey view explicit process singl branch specul execut work follow start main term object program dag grammar gradual built drive term time specul cf def 14 hinder normal reduct perform instanti term dag gram mar reduct term proceed ect structur input variabl fact drive step term result new product grammar everi term meet drive program product meet term seen loop introduc grammar drive term stop term driven compar output desir name nonfals output fals result empti grammar otherwis accumul grammar gener parameteris explicit process discrimin function h purpos fashion produc grammar everi specul execut program possibl instanti term give rise slightli dierent term grammar nal grammar union grammar produc execut exampl instanti dag grammar consid dag xs ys 6 6 6x ys con iscon ys x xs7 7 xs ys con iscon ys x xs7 repres call argument un known e repres bodi pattern match variabl xs call iscon three argument cf exampl 1 order arrow import sinc present method prevent nontermin perform generalis danger term base certain quasiord extens method appli lan guag prove extend method inde guarante termin explicit appli gener framework prove termin program transform present second author 14 dene data ow view feg dag grammar rewritten 0 mean feg shown formal denit 15 given dag e dag substitut fegd dene cf def 5 otherwis substitut extend grammar obviou way construct dag term use follow shorthand denit 16 given term full explicit process explain detail low formal sum follow denit denit 17 given program p function h 2 explicit p dag grammar eh p describ fig 2 follow explan explicit process carri number refer hope guid understand fig 2 explicit start main term program empti dag grammar empti set previous seen term step inspect structur current term either stop add product make new step ad seenbefor set seen product alreadi present grammar return accumul unchang renam seen captur biject introduc recurs grammar ad product connect pre viousli seen respect number variabl redex unfold use standard semant cf def 12 13 product link unfold ad process continu unfold generalis term hinder unfold t1 t2 dt 2 t1 process independ fore product ad grammar link dt 2 t1 product dangl root 2 name x v t1 v t2 ect data ow approxim trace t1 tell us noth output function h cf 4 unmatch root allow dag rewrit cf def 7 eh let ftg tthen c ac r x ac x c x true x fals figur 2 explicit drive suppos discrimin variou output replac function xyy discrimin alway return accumul grammar pattern match function process continu dene pattern pattern q substitut argument match bodi put back context turn receiv instanti fx 7 qg add grammar product ect instanti comparison three case rst simpli make sure variabl left side com parison settl righthand side anoth variabl two possibl explor either comparison fail henc replac specul fals comparison succeed replac specul true updat grammar context ect side must ident grammar equal variabl coalesc mean special symbol r need maintain invari inout degre term correspond number distinct variabl righthand side nari constructor either comparison fail succeed case propag variabl must particular outermost constructor children must test equal children constructor boolean express depend variabl variabl evalu either true fals inform propag branch term driven ie 2 v fed function h turn decid accumul grammar exampl 6 let p program exampl 1 h dene 4 explicit eh depict fig 3 grammar produc fa b f jg deriv grammar suboptim product intermedi sens directli unfold inlin say grammar normalis contain intermedi product easili normalis grammar denit 18 dag grammar normalis denot b follow root g leav g exampl 7 normalis grammar exampl 6 almost get grammar promis introduction4 xs ys xs ys con con r xs ys particular grammar bookkeep symbol r elimin yet anoth normalis process desir given object program contain necessari gen eralis lemma surpris howev incorpor standard onlin termin strategi explic process explain remark 1 follow lemma would still hold lemma 2 explicit produc nite grammar proof process tree program nite sinc program contain necessari generalis thu nite number dag produc assum h function total comput interestingli explicit return dag grammar contain solut express complet theorem need precis formul set term gener dag grammar given infor malli term extract dag simpli follow edg left right collect label except label variabl bookkeep symbol r everi variabl given distinct name r treat indirect left term denit 19 given dag grammar label ariti n set variabl g term languag n set tupl term extract underli dag languag 4 0 s5 fhi 0 0 relat possibl execut program set term gener explicit eh xs ys fsame xs ysg eh fsame xs ys isnil ysg eh fsame xs ys isnil ysg eh iscon ys x xs fsame xs ysg eh fsame xs ys iscon ys x xsg fsame xs ys iscon ys x xsg fif xy xs ys falseg fif xy xs ys fals fals xs ys fif xy xs ys falseg fsame xs ys 6 6same xs ys nil 6 6isnil ys con iscon ys x xs nil x xs7g 2 xs ysfals x fals xs ysfalse7 7 xs ysfals r x true xs ys isnil ys xs ys con iscon ys x xs7 7 75 26 6 6 6 6iscon ys x xs con 6 6if fals xs ys xs ys7 6 6if true xs ys xs ys7 figur 3 explicit sameprogram theorem 1 given program p main hold 5 applic type infer show type check algorithm transform type infer algorithm explicit specif ical check calculu express given type given environ use standard relat exampl consid express mean type xyzxzyz empti environ would expect answer someth like perform explicit express type checker take encod proof tree p express environ return true p inde valid proof type encod 3 xyzxzyz becom becom empti want explicit express add denit main implement type checker refer specialis typecheck data 3 ab int term 4 data 5 data proof infer premis type 6 data 7 intro proof 9 expchk var x z match z x 14 elimchk elim x z v w 3 implement assum primit integ type int 19 arrowcheck v x z w match bind x z v 22 v x w match z v w match x arrowcheck ar x z v w 26 conclus z 28 conclus infer x 29 fals x explicit specialis typecheck give term languag consist singl pair ar ar x ar z ar ar x ar x z rst element inde encod type 5 second proof tree left 6 improv sound automat method invers turingcomplet program make compromis respect com plete sound termin made compromis result possibl unsound result explicit program produc grammar gener mani term practic point view feel right compromis better obtain approxim obtain answer moreov explicit produc grammar precis identi input set seen two exampl previou section indic explicit tight enough least practic problem howev still remain identifi exactli caus loss sound gener case method inher imprecis three reason generalis caus term split separ part mean letterm prevent instanti left branch process tree aect right branch vice versa neg inform taken account drive exampl drive specul term x propag fact x 6 right branch process tree although fact propag left branch mean substitut moreov dag grammar repres neg inform occur check perform specul term like situat n discov obvious equal would never impli similarli symmetr properti x x never impli x 6 x use either occur check counterpart easili incorpor rule respect fig 2 interest ingli explicit type checker specialis would sound check incorpor neg inform describ handl propag inform anoth paper 11 incorpor neg inform propos paper would simpl task incorpor neg inform dag grammar howev would destroy simplic thu sever crippl usabl henc generalis inabl dag grammar repres neg inform true culprit one could therefor imagin variant explicit algorithm let call exp one incorpor extens suggest improv sound exp one target way generalis carri posit conjectur follow roundabout relationship exp ura 1 describ introduct given program p without generalisa tion exp termin p whenev ura termin p moreov result ura contain restrict neg ativ inform result grammar exp sound 7 relat work program invers literatur program invers carri hand one except romanenko 9 describ pseudo algorithm invert small class program written refal later paper romanenko 10 extend refal languag nondeterminist construct akin seen logic program facilit exhaust search also consid invert program respect subset paramet socal partial invers would like extend method handl partial invers write unclear done fulli autom program invers method know one present abramov gluck 1 method construct process tree object pro gram solut extract leav tree form substitutionrestrict pair process tree perfect gluck klimov 3 sens inform lost branch complet everi branch node divid inform disjoint set sound unfortun sound togeth complet impli nontermin small class program method present sacric sound termin common method build upon ground break work turchin cowork rst english paper contain exampl program invers drive seem 15 refer see srensen gluck 4 grammar idea approxim function program grammar new instanc jone 5 present ow analysi nonstrict languag mean tree gram mar base work second author develop techniqu use tree grammar approxim termin behaviour deforest 12 tree grammar ever captur precis data control ow denit branch tree grammar develop ind pendent render imposs kind synchronis need variabl function call dag grammar present precis captur data control ow singl specul comput trace synchronis lost sever altern recurs product exist grammar seem possibl devis precis ow analysi base dag grammar could use along line 12 inde way use dag grammar trace data control ow turn strike similar use sizechang graph present lee jone ben amram 7 sizechang graph approxim data ow one function anoth captur sizechang paramet dagrewrit mechan present turn lot common faninfanout rewrit present lamp 6 quest optim reduct calculu faninfanout repres complex way synchronis dierent part graph wherea dag rewrit perform simpl useonc synchroni sation rewrit mechan also akin graph substitut hypergraph grammar see bauderon courcel 2 noncategorytheori formul except allow number leav rewritten allow inner node rewritten strengthwis hypergraph grammar appar equival attribut grammar present sure gener power dag grammar 8 conclus futur work develop method invert given program respect given output result invers nite dag grammar give complet descript input run dag grammar produc possibl innit set term contain tupl term result given output method seem particularli use object program checker one return either true fals exempli deriv type scheme type checker given term thu eectiv synthesis type infer algorithm follow line one could imagin program check whether document valid xml invert program would result dag grammar could compar speci cation valid xml mean verifi program invert program specialis particular doc ument would result document type denit one could even imagin invert proofcarryingcod verier 8 respect particular program thu obtain proof skeleton correct code experi kind applic carri establish strength usabl method 9 r graph express graph rewrit flow analysi lazi higherord function program algorithm optim lambda calculu reduct sizechang principl program termin compil proof gener invers function refal invers metacomput de tr algorithm optim lambda calculu reduct invers metacomput converg program transform metric space tree sizechang principl program termin introduct supercompil perfect supercompil occam razor metacompu roadmap metacomput supercompil semant definit refal automat product compil univers resolv algorithm grammarbas dataflow analysi stop deforest compil proof ctr siaucheng khoo kun shi outputconstraint special proceed asian symposium partial evalu semanticsbas program manipul p106116 septemb 1214 2002 aizu japan aaron tomb cormac flanagan automat type infer via partial evalu proceed 7th acm sigplan intern confer principl practic declar program p106116 juli 1113 2005 lisbon portug siaucheng khoo kun shi program adapt via outputconstraint special higherord symbol comput v17 n12 p93128 marchjun 2004 morten hein srensen jen peter secher type infer configur essenc comput complex analysi transform springerverlag new york inc new york ny 2002 principl invers comput univers resolv algorithm essenc comput complex analysi transform springerverlag new york inc new york ny 2002