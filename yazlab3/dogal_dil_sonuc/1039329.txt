exponenti lower bound 2queri local decod code via quantum argument local decod code ldc encod nbit string x mbit codeword cx way one recov bit xi corrupt codeword queri bit word use quantum argument prove ldc 2 classic queri requir exponenti 2n previous known linear code goldreich et al proceed 17th ieee confer comput complex 2002 pp 175183 proof proce show 2queri ldc decod singl quantum queri defin appropri sens goe establish exponenti lower bound lqueri local quantumdecod code extend lower bound nonbinari alphabet also somewhat improv polynomi lower bound katz trevisan ldc 2 queri furthermor show q quantum queri allow succinct ldc best known ldc q classic queri final give new classic lower bound quantum upper bound set privat inform retriev particular exhibit quantum 2server privat inform retriev pir scheme on310 qubit commun beat on13 bit commun best known classic 2server pir b introduct 11 set correct code allow one encod nbit string x mbit codeword cx way x still recov even codeword corrupt number place exampl codeword length alreadi suce recov error constant fraction bitposit codeword even linear time 33 one disadvantag standard error correct one usual need consid corrupt preliminari version paper appear stoc03 22 support darpa agreement number f 306020120524 part work done visit cwi z work done postdoc uc berkeley support talent grant 62565 netherland organ scientic research nwo also partial fund project qaip ist1999 resq ist200137559 istfet programm ec codeword recov anyth x one interest recov one bit x ecient scheme possibl allow us extract small part encod inform corrupt codeword look queri posit word scheme call local decod code ldc found variou applic complex theori cryptographi selfcorrect comput 5 24 17 16 18 probabilist checkabl proof 2 worstcas averagecas reduct 3 34 privat inform retriev 11 extractor 25 inform ldc describ follow q local decod code encod nbit string x mbit codeword cx bit x recov probabl make q queri even codeword corrupt bit exampl hadamard code local decod code two queri suce predict bit constant advantag even constant fraction error code recoveri corrupt codeword possibl pick random j 2 f0 1g n queri j je comput xor two bit guess x neither two queri bit corrupt output cx corrupt posit fraction least 1 2 j j e pair indic uncorrupt recoveri probabl least 1 2 12 long 14 main drawback hadamard code exponenti length clearli would like codeword length number queri q small main complex question ldc larg need function n q et al 2 show achiev almost linear size code xed beimel et al 8 recent improv best known upper bound constant q log qq log q precis bound small q studi lower bound initi katz trevisan 21 prove exist n larger constant depend q 2 prove bound q queri made nonadapt bound gener adapt case deshpand et al 14 establish superlinear quadrat lower bound length ldc constant number queri still larg gap best known upper lower bound particular open achiev constant q goldreich et al 20 examin case show 2 n8 c linear code obata 29 subsequ strengthen depend 2 essenti optim recent bensasson et al 9 studi relax notion ldc decod allow output dont know constant fraction indic construct relax ldc constant number queri katz trevisan goldreich et al establish close connect local decod code privat inform retriev pir scheme pir scheme allow user extract nbit databas x replic k 1 server without server learn user want main complex measur pir scheme commun complex ie sum length queri user send server length server answer roughli queri ldc correspond server pir scheme fact best known ldc constant q deriv pir scheme one server privaci maintain let server send whole nbit databas user take n bit commun optim databas replic k 2 server exist protocol signicantli less commun chor et al 11 exhibit 2server pir scheme commun complex 13 one 1k k 2 ambaini 1 improv latter 12k 1 beimel et al 8 improv commun complex 2 log log kk log k result improv previou best bound k 3 2 lower bound better n known pir k 2 server case 2 server best known lower bound 4 log n due mann 26 pir scheme linear everi queri user make answer bit linear combin bit x goldreich et al 20 prove linear 2server pir tbit queri abit answer user look k predetermin posit answer requir 12 result local decod code main result paper exponenti lower bound gener 2queri ldc theorem 4 c f0 1g n f0 1g 2 local decod code rst superpolynomi lower bound gener ldc one queri constant c expon somewhat wors goldreich et al 20 obata 29 proof establish exponenti lower bound ldc linear one proof introduc one radic new ingredi quantum comput show two classic queri recov x probabl also recov probabl 1247 use one quantum queri word 2 local decod code 1 47local quantumdecod code prove exponenti lower bound 1queri lqdc show roughli speak 1queri lqdc length induc quantum random access code x length log code enabl user recov bit x choic nayak 27 linear lower bound length code nish proof sake complet includ proof result appendix b lower bound classic ldc one exampl tool quantum comput enabl one prove new result classic comput scienc know exampl 1 radhakrishnan et al 30 prove lower bound set membership data structur hold quantum algorithm fact stronger previou classic lower bound buhrman et al 10 sen venkatesh data structur predecessor problem 32 quantph version klauck et al 23 prove lower bound kround quantum commun complex treejump problem somewhat stronger previou best classic lower bound cryptographi gisin renner wolf 19 use analog quantum bound entangl provid evid conjectur intrins inform random variabl share alic bob eavesdropp eve alway equal amount secret key alic bob extract later conjectur inde disprov 31 though without use quantum method case underli proof techniqu easili yield classic proof one replac quantum notion like von neumann entropi trace distanc classic analogu get classic proof classic 1 quantum lower bound commun complex inner product function cleve et al 12 provid new insight classic result establish new result classic comput scienc case contrast proof seem inher quantum sinc classic analog 2classicalqueriesto1quantumqueri reduct 2queri ldc exist 1queri dont section 3 focus code binari alphabet section 41 extend result case larger alphabet use classic reduct due trevisan 35 section 42 look ldc q 3 queri improv polynomi lower bound katz trevisan 21 bound still polynomi far best known upper bound section 43 observ construct impli exist 1queri quantumdecod code n hadamard code exampl codeword still classic decod quantum mention allow one classic queri ldc exist n larger constant depend 21 larger q turn best known 2q ldc due beimel et al 8 actual q lqdc henc xed number queri q obtain lqdc signicantli shorter best known ldc particular beimel et al give 4queri ldc length 2queri lqdc signicantli shorter 2queri ldc need summar situat tabl 1 contribut indic boldfac queri length ldc length lqdc exist 2 n tabl 1 best known bound length ldc lqdc q queri 13 result privat inform retriev privat inform retriev set techniqu allow us reduc classic 2server pir scheme 1bit answer quantum 1server pir turn reduc random access code 27 thu section 51 obtain n lower bound commun complex classic 2server pir 1bit answer section 52 extend lower bound pir scheme larger answer previous bound known linear pir rst proven 11 section 52 1bit answer extend constantlength answer 20 furthermor result combin katz trevisan give 44 log n lower bound gener 2server pir rst modest improv bound mann 26 subsequ work beigel fortnow gasarch 7 found classic proof 2server pir perfect recoveri answer need queri length n 2 howev proof seem extend case 12 larger answer apart give new lower bound classic pir also use 2to1 reduct obtain quantum pir scheme beat best known classic pir particular beimel et al 8 exampl 42 exhibit classic 4server pir scheme 1bit answer commun complex 310 reduc quantum 2server pir 310 qubit commun beat best known classic 2server pir complex 13 similarli give quantum improv best known kserver pir scheme k 2 howev constitut true classicalquantum separ pir set yet sinc good lower bound known classic pir summar best known bound classic quantum pir tabl 2 server pir complex qpir complex tabl 2 best known bound commun complex classic quantum pir preliminari 21 quantum give precis denit local decod code pir scheme relat notion rst explain standard notat quantum comput let h denot 2dimension complex vector space equip standard inner product pick orthonorm basi space label two basi vector j0i j1i simplic identifi vector respect qubit unit length vector space express linear combin basi state complex amplitud mqubit system unit vector mfold tensor space h 2 basi state space mfold tensor product state j0i j1i exampl basi state 2qubit system four 4dimension unit vector j0i j1i j0i j1i abbrevi eg j0i j0ij1i j1 0i j10i even j2i sinc 2 10 binari basi state mqubit state ji 2 dimension complex unit vector use denot conjug transpos vector ji hj inner product state ji j two state orthogon hj ji k hji mix state fp ig classic distribut pure quantum state system state j probabl p repres mix quantum state densiti matrix dene j note posit semidenit oper trace sum diagon entri equal 1 densiti matrix pure state ji quantum system call bipartit consist two subsystem describ state subsystem separ reduc densiti matrix exampl quantum state form state system hold second part ji describ reduc densiti matrix quantum state evolv unitari oper measur unitari transform linear map preserv 2 norm appli unitari u state ji evolv u ji mix state evolv uu gener measur allow quantum mechan speci famili posit semidenit oper subject condit given densiti matrix probabl observ ith outcom measur given trace nonneg e posit semidenit also sum 1 measur yield outcom result quantum state particular result state jik ji k special case form orthonorm basi mqubit space measur bbasi mean appli measur given appli pure state ji give result state j probabl final word quantum queri queri mbit string commonli formal follow unitari transform j 2 b 2 f0 1g call target bit quantum comput may appli superposit equival formal use c control bit control whether phase 1 j ad given extra workspac one queri either type simul exactli one queri type refer nielsen chuang 28 detail 22 code decod algorithm mean algorithm quantum classic depend context oracl access bit possibl corrupt codeword x algorithm get input suppos recov x make queri want emphas speak algorithm mere conveni way formal decod process focu algorithm decod informationtheoret aspect ie tradeo number q queri allow decod requir codelength denit q local decod code ldc classic random decod algorithm 1 make q queri mbit string nonadapt 2 x 2 f0 1g ham distanc dcx pra ldc call linear c linear function gf 2 ie cx allow quantum comput make queri superposit similarli dene q local quantumdecod code lqdc conveni work nonadapt queri use denit distribut queri make independ howev main lower bound also hold adapt queri see rst remark end section 33 23 privat inform retriev next dene privat inform retriev scheme denit 2 oneround 1 secur kserver privat inform retriev pir scheme recoveri probabl answer size consist random algorithm user k determinist algorithm server 1 input 2 n user produc k tbit queri q send respect server jth server send back abit string user output bit b depend random 2 x probabl user random least 12 3 x j distribut q j user random close total variat distanc dierent scheme call linear everi j q j jth server answer j x q j linear combin gf 2 bit x straightforwardli gener denit quantum pir case server state queri independ case need known upper bound pir one round commun perfect recoveri server get inform whatsoev assum one round mention 3 lower bound 2queri local decod code proof two part clear intuit requir quit technic 1 2queri ldc 1queri lqdc one quantum queri comput boolean function two classic queri albeit slightli wors error probabl 2 length 1queri lqdc must exponenti uniform superposit indic contain log qubit induc quantum random access code x linear lower bound alreadi known 27 31 2 classic 1 quantum queri key rst step follow lemma suppos make queri bit input string exist quantum algorithm make one queri one independ f output fa probabl exactli 1114 output 1 fa otherwis proof could construct state one quantum queri could determin certainti sinc four possibl state orthonorm basi could also see state hadamard encod string b 2 f0 1g 2 unfortun construct j perfectli one queri instead approxim state make querypj0ij1i rst bit control bit appropri phase 1 j put front jji control bit 1 result queri state algorithm measur state ji orthonorm basi consist four state probabl get outcom jhj ij 3 outcom probabl 112 algorithm determin output base f measur outcom b distinguish 3 case f 1 complet analog 0 1 revers algorithm output 1 probabl 1 output 0 probabl 67 1 probabl 17 accordingli probabl output 1 probabl output 0 2 2 algorithm output fb probabl 1314 output 1 fb probabl 114 probabl output fa exactli 1114 3 f constant case algorithm output valu probabl 1114 thu alway output fa probabl 1114 2 peter hyer person commun recent improv 1114 lemma 910 describ algorithm appendix show success probabl best possibl one quantum queri use lemma prove theorem 1 2 ldc 1 47lqdc proof consid x dcx 1queri quantum decod use random 2queri classic decod random string classic decod determin two indic f f0 1g 2 f0 1g probabl taken decod random use lemma 1 obtain 1queri quantum decod output bit b success probabl quantum decod 2 4 promis 2 32 lower bound 1queri lqdc quantum random access code encod x 7 x nbit string x mqubit state x possibl mix bit x recov probabl p x follow lower bound known length quantum code 27 see appendix b theorem 2 nayak encod x 7 x nbit string mqubit state recoveri probabl least p 1 hpn allow us prove exponenti lower bound 1queri lqdc theorem 3 1 lqdc proof goal show recov x good probabl number copi uniform logm 1qubit state intuit reason follow sinc c lqdc abl recov x even codeword corrupt mani place therefor distribut queri decod must smooth ie spread almost posit codewordotherwis adversari could choos corrupt bit way make recoveri probabl low uniform distribut provid reason approxim smooth distribut sinc uniform state juxi independ actual recov bit x good probabl constitut quantum random access code x appli theorem 2 give result use exactli part lemma 1 see could go wrong exactli least suppos classic decod output andy1 y2 output x probabl 35 12 howev quantum procedur comput andy1 y2 success probabl 1114 xory3 y4 success probabl 1 recoveri probabl 351114 12 let us precis gener queri quantum decod could make recov x form j cj pure state decod workspac cj nonneg real phase could put j cj workspac also incorpor classic random use howev decod could equival add workspac state queri use unitari map jcijjij0i 7 jcijjij cj henc assum without loss gener actual queri cj jcijji decod measur state result queri let two measur oper decod use measur correspond output 1 0 respect probabl give output 1 queryresult jri clariti dont write ji insid p inspir smooth techniqu 21 split amplitud j queri jq small larg one 1mg sinc queri aect j0ijjist assum without loss gener 0j j 0j 1 henc 0 let cj norm smallamplitud part sinc cj 1 jbj dene nonnorm state cj2a cj jcijji pure state jaxi jbi jaxi jbi correspond 2 f0 1g corrupt compar cx jbj posit decod recov x state x x averag previou two inequ give similarli x 0 x 0 henc normal state 1 jaxi 1 jax 0 sinc hold everi x x 0 x constant q p 1 copi state 1 jaxi could run procedur recov x assum q 1 12 must q 0 12 2 use argument 0 1 revers q 1 alreadi done output 0 probabl otherwis output result decod 2outcom measur 1 jaxi probabl procedur output 1 probabl procedur output 0 ax thu recov x good probabl state 1 jaxi depend well x remain show obtain 1 jaxi juxi reason probabl appli measur oper juxi cj2a cj jc jihc jj posit oper requir cj 1 c measur give rst outcom probabl cj2a case obtain normal version juxi 1 jaxi suppos copi juxi measur separ probabl 1 1 2 2 r 12 one give rst outcom case predict x probabl measur give second outcom output fair coin ip guess x overal recoveri probabl accordingli r copi logm 1qubit state juxi form quantum random access code recoveri probabl p use theorem 2 henc log 2 n 33 lower bound 2queri ldc theorem 4 c f0 1g n f0 1g 2 local decod code proof theorem combin theorem 1 3 straightforwardli would give constant 2 49 ln 2 get better constant claim observ 1queri lqdc deriv 2queri ldc actual 13 overal squar amplitud queri control bit c zero 0j henc proof theorem 3 reden small amplitud cj 23m still b element cj 23 turn allow us make factor 32 larger improv probabl get 1 jaxi juxi 3a 2 4 allow us decreas r 43a 2 translat lower bound log 3 2 n32 ln 2 1 combin theorem 1 make factor 47 smaller give remark 1 note 2 ldc adapt queri give 2 2ldc nonadapt queri queri q 1 would follow queri q 0 2 q 1 2 depend outcom q 1 guess advanc whether queri q 1 q 0 2 q 1 q 1 2 probabl 12 second queri one would made adapt case ne case ip coin give overal recoveri probabl 1212 thu also get slightli weaker still exponenti lower bound adapt 2queri ldc 2 constant 398 ln 2 optim bit choos number r copi bit larger proof theorem 3 use peter hyer 910algorithm appendix instead 1114algorithm lemma 1 interest howev question whether quadrat depend improv 3 2 ldc decod output xor two queri give better reduct theorem 1 quantum decod queri 1 extract 1 2 certainti thu recoveri probabl remain go 1247 accordingli also get better lower bound 2queri ldc output xor two queri expon 4 second part proof reduct local quantumdecod code smooth quantum code code distribut queri uniform reduct known classic code well see next section henc altern way get exponenti lower bound would rst invok result katz trevisan reduc ldc code uniform queri distribut reduc case decod output xor q queri bit start uniformli smooth code use reduct 2 classic queri 1 quantum queri without loss recoveri probabl see remark 3 reduct immedi end quantum random access code log qubit done howev proof would give wors depend current result extens section give variou extens variat lower bound previou section 41 nonbinari alphabet extend lower bound binari 2queri ldc case 2queri ldc larger alphabet simplic assum alphabet queri posit j return bit string cx j denit q ldc section 22 carri immedi measur ham distanc cx need notion smooth code connect ldc state 21 denit q c smooth code classic random decod algorithm 1 make q queri nonadapt 2 x pra cx 3 x j probabl input machin queri index j cm note smooth code requir good decod codeword cx close cx katz trevisan 21 theorem 1 establish follow connect theorem 5 katz trevisan q ldc q qsmooth code convers theorem 5 also hold q c smooth code q cldc probabl decod queri one corrupt posit henc ldc smooth code essenti equival appropri choic paramet prove exponenti lower bound ldc nonbinari alphabet reduc smooth code somewhat longer binari smooth code work well averag x show lower bound averagecas binari smooth code way similar proof theorem 4 follow key lemma suggest us luca trevisan 35 2 c smooth code exist good averag ie decod proof form new binari code c 0 replac symbol cx j 2 old code hadamard code consist 2 bit length c 0 x 2 bit new decod algorithm use random old one let us x two queri output old decod describ new decod algorithm good averag x look one bit hadamard code first specic j k f pr x fa new decod output random bit case least good old one averag x consid case pr x fa switch f0 1gnotat 1gnotat enabl us say 2 view b two bit string repres f fourier represent see eg 6 fa s2 henc 2 averag use follow exist subset return f0 1gnotat must either pr x pr x product mod 2 bit string accordingli either xor two bit 0 0 b negat predict x averag probabl 122 2 bit binari code c 0 x csmooth c translat c 2 smooth c 0 averag classic random ie choic j k f give lemma 2 lemma enabl us modifi proof theorem 4 work nonbinari theorem 6 local decod code proof use theorem 5 lemma 2 turn c binari 2 2 1 2 2 smooth code c 0 averag recoveri probabl bit sinc decod xor two binari queri reduc one quantum queri without loss averag recoveri probabl see third remark follow theorem 4 reduc quantum smooth code quantum random access code modi version proof theorem 4 smooth c 0 impli amplitud j depend one quantum queri satisfi j henc need split set js b also control bit c alway 1 ignor consid state jji 2outcom measur oper probabl measur take us juxi renorm juxi jaxi equal henc copi juxi form quantum random access code averag success probabl 1 hpn lower bound quantum random access code hold even recoveri probabl p averag x give impli statement theorem 2 42 bound 2 queri address case ldc binari alphabet decod ask 2 queri obviou way extend 2to1 reduct 2 classic queri sinc quantum comput need dq2e queri comput pariti q bit advantag 4 15 particular need 2 quantum queri comput pariti 3 bit dont lower bound 2queri lqdc still ldc q 3 queri abl improv polynomi lower bound katz trevisan 21 somewhat theorem 7 q local decod code log n constant depend q proof suppos simplic q even multipl q theorem 5 suce prove bound q c smooth code use follow result make smooth code uniform fact katz trevisan 21 discuss section 4 q c smooth code q q 2 2c smooth code good averag everi new qqueri decod xed partit mq qtupl pick random qtupl j output boolean function q bit everi decod x correct probabl least 12 averag x proof analog lemma 2 ensur decod actual comput xor q queri bit negat averag correct probabl still least deriv quantum random access code uniform smooth code let jjihjj projector state jii jji suppos 1 partit qtupl pair measur uniform state oper p random 1 m2 obtain cx gener xor random pair partit order recov x need nd q2 dierent pair come qtupl state juxi give us random pair possibl m2 birthday paradox om 1 2q copi log mqubit state juxi high probabl nd q2 dierent pair come qtupl henc abl recov x word copi log mqubit state juxi constitut averag random access code random access code lower bound appendix b give impli exampl queri lower bound 3 n log n 2 katz trevisan 43 local quantumdecod code queri third remark section 33 immedi gener theorem 8 2q ldc decod output xor 2q queri bit q lqdc ldc q queri obtain qserver pir scheme 1bit answer concaten answer server give possibl queri user beimel et al 8 corollari 43 recent improv best known upper bound qqueri ldc base improv pir construct give gener upper bound qqueri ldc constant depend well precis estim small q particular construct ldc length xortyp reduc number queri half allow quantum decod instanc 4queri ldc 2queri lqdc length contrast 2queri ldc need length n prove gener ldc someth nearli good use van dam result qbit oracl recov probabl nearli 1 use q2 p q quantum queri 13 theorem 9 q ldc q2 p q 2lqdc 44 local decod erasur code recent notion local decod erasur code ldec use construct extractor 25 section 31 code even 1 posit codeword eras still recov x use q queri remain posit denit 4 consid map say messag posit decod codeword posit exist function f fcx j 1 x c q ldec everi everi fraction posit codeword exist qtupl posit decod show ldec equival smooth code dene section 41 henc ldc consid ldec codeword length equival show lower bound also hold ldec particular 2 ldec need exponenti length first consid ldec take set fraction posit codeword denit exist good qtupl ie one decod messag posit remov q posit codeword replac q posit new set 0 posit still good qtupl remov go repeat substitut 1 mq time size code therefor disjoint qtupl good x code smooth code smooth decod pick one tupl random queri posit convers also true smooth code contain disjoint qtupl say good x henc subset posit codeword size 1 1 exist good qtupl therefor code ldec 1 5 privat inform retriev mention close connect local decod code privat inform retriev section use variant 2to1 reduct prove new lower bound pir new upper bound qpir 51 lower bound binari 2server pir get lower bound 2server pir 1bit answer give 2step proof reduct 2 classic server 1 quantum server combin lower bound 1server quantum pir theorem 10 exist classic 2server pir scheme tbit queri 1bit answer recoveri probabl exist quantum 1server pir scheme recoveri probabl proof proof analog proof local decod code theorem 1 let quantum user employ random classic one problem boil comput fa 1 2 1 rst server 1bit answer queri q 1 2 second server 1bit answer queri q 2 howev addit hide quantum server make quantum user set 4 0 string 0s user send everyth rst regist server state server uniform mixtur j0 0 j1 q 1 j2 q 2 secur classic protocol j1 q 1 contain inform averag user random hold j2 q 2 henc server get inform quantum server put 1 j front jj q j j 2 f1 2g leav j0 0 alon send everyth back note need suppli name classic server j 2 f1 2g tell server superposit whether play role server 1 2 user comput fa 1 2 success probabl exactli 1114 give overal recoveri probabl theorem 1 2 combin reduct quantum random access code lower bound obtain rst n lower bound hold 1bitansw 2server pir linear one theorem 11 classic 2server pir scheme tbit queri 1bit answer recoveri probabl 2 proof rst reduc 2 classic server 1 quantum server way theorem 10 consid state quantum pir scheme user send r p r classic probabl user depend q j r tbit queri user send server j classic 2server scheme want x random string r let server basi state write j ja ib pure state depend x coecient b nonneg real depend otherwis measur b would give server inform contradict privaci server tag appropri phase bx 1 2g give b ja ib bx jbi follow pure state random access code x user unitarili map j0ijbi 7 ja ib ijbi map j0ij x 7 j ix get complet quantum pir protocol state j x qubit henc theorem 2 obtain 1 hpn 2 2 special case classic pir output xor two answer bit improv lower bound 1 h12 n 1 particular n 1 case perfect recoveri tight 52 lower bound 2server pir larger answer also extend linear lower bound 2server pir scheme answer length theorem 11 case 2server pir larger answer length use translat pir smooth code given lemma 71 goldreich et al 20 lemma 3 gkst classic 2server pir scheme queri length answer length recoveri probabl 2 3 smooth code go roughli step proof theorem 6 obtain theorem 12 classic 2server pir scheme tbit queri abit answer recoveri probabl 53 lower bound gener 2server pir previou lower bound queri length 2server pir scheme signic protocol short answer length slightli improv best known bound 4 log n 26 overal commun complex 2server pir scheme combin theorem 12 theorem 6 katz trevisan 21 restat theorem pir set remaind section assum xed posit constant theorem 13 katz trevisan everi 2server pir scheme tbit queri abit answer prove follow lower bound total commun 2server pir scheme tbit queri abit answer theorem 14 everi 2server pir scheme total commun c 44 o1 log n proof distinguish three case depend answer length scheme let log log n log n case 1 02 log n theorem 12 get c 4648 n 5 case 2 02 log n 22 log n theorem 13 case 3 22 log n obvious log n54 upper bound quantum pir best known ldc deriv classic pir scheme 1bit answer output xor 1bit answer user receiv allow quantum queri reduc number queri half obtain ecient lqdc similarli also turn underli classic kserver pir directli quantum pir k2 server interestingli exist 4server pir 1bit answer commun complex 310 8 exampl 42 give us quantum 2server pir scheme 310 commun improv upon commun requir best known classic 2server pir scheme 13 ever sinc introduct pir chor et al 11 introduct mention also quantum upper bound k 2 server obtain similarli 6 conclus open problem paper rst new classic result prove use techniqu quantum comput appar essenti way least dont know classic proof result clearli would interest nd applic would much broaden relev quantum comput make less condit whether actual quantum comput ever built also mani interest open question relat tradeo variou paramet ldc particular still open whether one achiev use constant even sublogarithm number queri would like obtain better lower bound q 2 queri explor connect ldc combinatori construct similarli main complex question gener pir scheme still wide open even 2server case dont restrict answer size 13 protocol 11 best known long time 2server case would nice show close optim final exhibit 2server quantum pir scheme ecient best known classic one would interest improv prove qpir ecient best rather best known classic pir scheme acknowledg would like thank luca trevisan mani insight comment throughout work also allow us includ lemma 2 section 41 also thank harri buhrman richard gill peter hyer hartmut klauck ashwin nayak kenji obata pranab sen via also rahul jain mario szegedi ashish thapliy john tromp stephani wehner help discuss thank amo beimel send us version 8 bill gasarch send us version 7 claud crepeau nicola gisin refer 19 31 anonym jcss refere mani comment improv present paper r upper bound commun complex privat inform retriev check comput polylogarithm time bpp subexponenti time simul unless exptim publish proof quantum lower bound polynomi hide instanc multioracl queri polynomi method circuit complex nearli tight bound privat inform retriev system break 1 robust pcp proxim bitvector optim privat inform retriev quantum entangl commun complex inner product function quantum oracl interrog get inform almost half price better lower bound local decod code limit speed quantum comput determin pariti highli resili corrector polynomi link classic quantum key agreement classic analog bound entangl ecienc local decod procedur errorcorrect code exponenti lower bound 2queri local decod code via quantum argument interact quantum commun complex set disjoint new direct test extractor optim constant factor privat access distribut inform optim lower bound quantum automata random access code quantum comput quantum inform optim lower bound 2queri local decod linear code quantum complex set membership new bound secretkey agreement gap format secreci extract lower bound quantum cell probe model expand code pseudorandom gener without xor lemma person commun tr hide instanc multioracl queri check comput polylogarithm time selftestingcorrect polynomi approxim function highli resili corrector polynomi randomselfreduc complet set bpp subexponenti time simul unless exptim publish proof privat inform retriev pseudorandom gener without xor lemma extend abstract effici local decod procedur errorcorrect code bitvector optim interact quantum commun complex set disjoint quantum lower bound polynomi break on12k1 barrier informationtheoret privat inform retriev quantum entangl commun complex inner product function lower bound quantum cell probe model upper bound commun complex privat inform retriev optim lower bound 2queri local decod linear code exponenti lower bound 2queri local decod code via quantum argument extractor quantum oracl interrog optim lower bound quantum automata random access code quantum complex set membership lower bound linear local decod code privat inform retriev better lower bound local decod code robust pcp proxim shorter pcp applic code ctr richard beigel lanc fortnow william gasarch tight lower bound restrict pir protocol comput complex v15 n1 p8291 januari 2006 sergey yekhanin toward 3queri local decod code subexponenti length proceed thirtyninth annual acm symposium theori comput june 1113 2007 san diego california usa ashwin nayak julia salzman limit abil quantum state convey classic messag journal acm jacm v53 n1 p184206 januari 2006