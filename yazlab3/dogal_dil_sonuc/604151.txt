type system higherord modul present type theori higherord modul account mani central issu modul system design includ transluc applic gener modul firstclass valu type system harmon design element previou work result simpl econom account modular program main unifi principl treatment abstract mechan comput effect languag first provid complet practic formal critic issu modul system design b introduct design languag modular program surprisingli delic complex fundament tension concert project support nation scienc foundat grant number 0121633 itrsysi languag technolog trustless softwar dissemin permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee popl03 januari 1517 2003 new orlean louisiana usa acm 1581136285030001 500 desir separ program compon rel independ part need integr part form coher whole extent design modular mechan independ underli languag 17 larg extent two insepar exampl languag poli morphism gener type abstract requir far complex modul mechan without much work devot design modular program languag earli work clu 19 modula famili languag 34 2 particularli influenti much effort gone design modular program mechan ml famili languag notabl standard ml 23 object caml 27 numer extens variat design consid literatur 21 18 28 31 5 despit perhap substanti effort field remain somewhat fragment clear unifi theori modular yet emerg sever compet design propos often seemingli odd one anoth decis often motiv pragmat consider engin use implement fundament consider semant type abstract relationship design decis complet clear clear account tradeoff whether coher combin singl design goal paper provid simpl unifi formal modular program consolid elucid much work mention build substanti grow bodi work typetheoret account languag structur propos type theori higherord program modul harmon enrich design would suitabl foundat next gener modular languag 11 design issu describ main technic featur languag use review central issu design modul system ml issu extend languag similar express power though tradeoff may differ differ languag control abstract modular achiev use signatur interfac mediat access program compon role signatur allow programm hide type inform select mechan control type propag transluc 11 14 transpar opac limit case phase separ mllike modul system enjoy phase separ properti 12 state everi modul separ static part consist type inform dynam part consist execut code obtain fulli express higherord modul support abstract essenti build phase separ principl definit type equival gener macqueen coin term gener creation new type correspond runtim instanc abstract exampl may wish defin functor symbolt given paramet creat new symbol tabl natur symbol tabl modul export abstract type symbol dynam creat insert use subsequ retriev preclud use symbol one symbol tabl index anoth gener essentialeach instanc hash tabl must yield new symbol type distinct other even appli twice paramet separ compil one goal modul system design support separ compil 14 achiev ensur interact among modul mediat interfac captur inform known client separ compil modul princip signatur princip express signatur modul captur known modul type check may use proxi modul purpos separ compil mani type check algorithm includ one given paper comput princip signatur modul modul firstclass valu modul ml second class sens comput result ordinari runtim comput use treat modul firstclass valu store data structur pass ordinari function argument result 11 24 hidden type introduc local hidden abstract type within scope requir type extern visibl compon avoid mention abstract type avoid problem often stumbl block modul system design sinc express languag best way avoid type variabl 12 type system modul type system propos take account design issu consolid harmon design element previous seen dispar singl framework exampl rather regard gener abstract type altern nongen type make mechan avail languag support gener applic functor admit transluc signatur support separ compil abl accommod modul firstclass valu 24 29 gener achiev simpl accumul featur rather isol key mechan com bine yield flexibl express implement type system modul specif follow mechan crucial singleton propag type share handl singleton signatur variant aspinal stone harper singleton kind 33 32 1 singleton provid simpl orthogon treatment share captur full equat theori type higherord modul system subtyp previou modul system provid abstract full equat theori support singleton 1 consequ none provid optim propag type inform static modul equival semant singleton signatur depend compiletim notion equival modul ensur phase distinct respect defin modul equival mean equival static compo nent ignor runtim aspect subtyp signatur subtyp use model forget type share essenti part signatur match coerciv aspect signatur match drop field special polymorph valu omit sinc requir coercion defin languag puriti impur type system classifi modul express pure effectfre impur effect form ensur proper enforc abstract impur modul incompar may compar equal modul nonproject may type compon project follow impur modul also nonsubstitut may substitut modul variabl signatur abstract seal modul seal signatur impos type abstract 11 regard impur word seal regard pro forma comput effect consist inform idea gener involv gener new type run time moreov ensur seal modul incompar nonproject suffici ensur proper semant type abstract total partial functor labstract level modul functor whose bodi pure said total otherwis partial follow applic pure total functor pure argument pure wherea applic pure partial functor pure argument impur partial functor natur gener mean abstract type result new instanc total functor applic mean equal argument yield equal type result gener functor obtain without resort gener stamp 23 21 weak strong seal sinc seal induc comput effect partial functor may contain seal sub structur significantli weaken util total functor overcom limit distinguish two form effect static dynam two form seal weak strong weak seal induc static effect think occur type check strong seal induc dynam effect think occur execut dynam effect induc partial static effect preserv total existenti signatur manner similar shao 31 type system care craft circumv avoid prob lem everi modul enjoy princip signatur howev requir impos restrict programm lift restrict propos use existenti signatur provid princip signatur none would otherwis exist show existenti signatur typetheoret illbehav 1 typic omit equat miss restrict name form valuabl prevent programm write code whose typeabl would depend equat first place 4 term e signatur modul let 1 ms ms context g gss figur 1 syntax gener restrict use wellbehav set style harper stone 13 propos use elabor algorithm extern languag may incur avoid problem type system packag modul modul system secondclass sens languag modul separ languag term howev follow mitchel et al 24 russo 29 provid way packag modul firstclass valu prior work packag modul typic given existenti type whose closedscop elimin construct make awkward program instead account type gener allow us employ natur openscop elimin con struct wherebi unpackag packag modul engend dynam effect featur combin natur form gener languag modular program would littl use absenc practic implement strategi previou attempt encount difficulti undecid 11 incomplet type check 27 contrast formal lead practic implement program languag rest paper structur follow section 2 present core type system higherord modul includ intuit behind design brief descript decid typecheck algorithm section 3 discuss program import weak strong form seal section 4 explain avoid problem circumv use elabor algorithm section 5 present simpl orthogon extens core system provid support packag modul firstclass valu fi nalli section 6 compar system relat work section 7 conclud technic develop begin technic develop present syntax languag figur 1 languag consist four syntact class term type modul signatur serv type modul languag explicitli includ higherord type constructor kind ordinarili serv constructor type languag role constructor kind subsum modul signatur context bind modul variabl signatur usual consid alphaequival express ident write captureavoid substitut express type three basic type languag product standard function type psst type function accept modul argument signatur return valu type possibl contain usual appear free write psst st convent use depend product signatur class well final modul contain exactli one type say signatur type extract typ fullfeatur languag would support varieti addit type well term term languag contain natur introduct elimin construct recurs function product ad dition modul contain exactli one valu say signatur type valu extract val f appear free e write fix f sste lsse convent form function polymorph function built modul function ordinari function built use modul contain singl valu polymorph function built use modul contain singl type et signatur seven basic signatur languag atom signatur type atom modul contain singl type atom signatur type atom modul contain singl term atom modul written e respect omit type label atom modul clear context trivial atom signatur 1 type trivial atom modul functor signatur p tot ss 1 2 p par ss 1 2 express type functor accept argument signatur 1 return result signatur 2 possibl contain reason two differ p signatur distinguish total partial functor discuss detail conveni take p without superscript synonym p tot appear free 2 write pss 1 2 1 2 structur signatur sss 1 2 type pair modul lefthand compon signatur 1 righthand compon signatur 2 refer lefthand com ponent usual appear free 2 write singleton signatur sm use express type share infor mation classifi modul signatur static equival two modul consid static equival equal modulo term compon type field must agre term field may differ singleton signatur provid primit defin use basic singleton describ stone harper 33 definit signatur contain modul equal signatur given figur 5 signatur sig type type u val end compil figur 2 ml signatur exampl modul modul syntax contain modul variabl atom modul usual introduct elimin construct p signatur except modul introduc stand 1 may appear free appear free 2 omit introduct elimin construct provid singleton signatur singleton introduc elimin rule static semant judg equival belong vice versa remain modul construct strong seal written ms weak seal written ms modul seal either strongli weakli result opaqu opaqu mean client modul may depend detail implement expos signatur distinct strong weak seal discuss detail although higherord type constructor appear explicitli languag faith repres languag unseal modul contain type compon exampl kind repres signatur constructor lat int aint repres modul lst exampl mlstyle signatur structur may express languag appear figur 2 3 compar project two close relat issu crucial design modul system support type abstract 1 modul compar equival anoth modul 2 type compon project modul use type say modul compar iff compar equival anoth modul modul project type compon may project use type expr sion literatur present emphas projectibil iti 11 14 15 structur struct structur struct type string val val end compil figur 3 ml structur exampl simpl analysi properti compar projectibil iti suggest close relat suppos pro jectibl modul signatur typ type sinc type equal equival relat type may compar particular typ anoth project modul signatur sinc typ typ fulli determin effect compar equiva lenc suggest project modul regard compar type check purpos convers compar modul extension equival typ sensibl also project puriti impur design modul system rest semant notion puriti impur induc comput effect motiv design first recal firstclass modul system harper lillibridg 11 impur modul express yield distinct type compon time evalu exampl modul express might consult state world yield differ modul outcom test type compon modul static welldetermin henc admit type express much less compar equiv alenc hand even gener framework pure effectfre modul may safe regard compar project secondclass modul system exampl fact express nevertheless find use classifi modul accord puriti 2 classif semant sens defin judgment calculu rather syntact sens determin sole form express semant approach import correct account type abstract fullfeatur modul languag axiomat puriti impur system base set rule take account type express well syntact form type system conserv assum worst impur modul express rule 2 moreov section 5 introduc mean recreat exampl set make essenti use classif system incompar nonproject even type compon fact static welldetermin see shortli import enforc type abstract well ensur sound presenc firstclass modul addit sinc sound deem pure modul express compar project permiss possibl without violat sound abstract identifi compar project puriti final note modul judg pure base whether type compon welldetermin independ whether term compon comput effect literatur differ account higherord modul provid differ class pure modul exampl harper lil libridg firstclass modul system 11 syntact valu consid pure leroy secondclass modul calculi 14 15 puriti limit syntact categori path harper et al earli phasedistinct calculu 12 modul deem pure mean abstract provid abstract via seal princip mean defin abstract type seal written ms seal prevent client depend ident type compon specifi opaquelywith signatur point view modul equival mean seal modul consid incompara ble see suppos regard compar presum could deem equival sinc underli type compon differ howev sinc modul equival reflex compar must deem equival would mean type system would distinguish two opaqu modul base underli implement violat type abstract signific advantag judgment approach puriti afford natur mean ensur seal modul compar name judg impur amount regard seal pro forma runtim effect even though actual effect occur execut time ensur abstract violat one illustr rule also show section 3 allow type system track runtim gener new type applic gener functor functor standard ml gener sens abstract type result functor gener afresh instanc functor regardless whether argument instanc equival functor object caml howev applic sens preserv equival appli equival argument yield equival result particular abstract type result functor two applic argument continu analog comput effect deem functor whose bodi pure total otherwis partial applic pure total functor pure argument pure henc compar total functor applic sens applic pure total functor two equival pure modul yield equival pure modul applic pure henc compar partial functor hand alway yield impur modul appli therefor respect equival argument result im pure even compar ensur instanc yield distinct result distinguish signatur total applic partial gen er functor total functor p signatur wherea partial functor p par signatur subtyp relat defin everi total functor may regard degener partial functor weak strong seal system identifi applic functor total one gener functor partial one make work howev must refin notion effect seal regard induc runtim effect imposs employ abstract within bodi total func tor render bodi impur may seal entir functor total functor signatur impos abstract ensur export type functor held abstract client functor permit substructur bodi functor held abstract client functor remaind functor bodi solut distinguish two form sealingstrong written ms weak written ms impos abstract sens limit type propag explicitli specifi ascrib signatur regard form seal induc impur howev support use class applic functor distinguish static dynam effect weak seal induc static effect wherea strong seal induc dynam effect signific distinct lie definit total partial functor functor whose bodi involv dynam effect ie dynam impur rule partial henc gener thu strong seal within functor bodi induc gener functor functor whose bodi either pure involv static effect ie dynam pure rule total henc applic ensur applic functor may use abstract within bodi without incur gener behavior methodolog import distinct discuss section 3 dynam effect may thought one occur exe cution wherea static effect one occur type check ing dynam effect suspend insid labstract functor abstract dynam pure howev appli dynam effect insid functor releas applic dynam impur hand static effect occur type check henc suspend l abstract releas applic formal type judgment system written puriti classifi k drawn follow fourpoint lattic point p indic pure henc compar pro jectibl indic dynam puriti indic static puriti w indic wellformed puriti inform henc puriti judgment prove conveni type rule exploit order written meet join lattic p taken bottom w taken top also sometim find conveni use notat p ss 1 2 functor signatur either total partial depend whether figur 4 key type rule key rule summar figur 4 pure modul dynam pure static pure least wellform rule 1 strongli seal modul neither static dynam pure 2 weakli seal modul static pure dynam pure bodi 3 applic functor must dynam pure bodi 5 gener functor restrict 6 applic functor may use gener one 7 variabl pure 4 lambda dynam pure 5 6 applic applic functor pure functor 8 applic gener functor best static pure 9 final puriti modul preserv signatur subsumpt 12 complet set type rule given appendix rule functor applic rule 8 requir functor argument pure functor argument substitut functor codomain produc result signa ture substitut impur modul variabl alway pure turn wellform signatur illform one exampl typ becom illform impur modul substitut altern rule propos harper lillibridg 11 resolv issu induc avoid problem discuss section 4 therefor functor appli impur argument argument must first bound variabl pure similarli project second compon pair restrict pure pair rule 11 restrict need made project first compon rule 10 sinc substitut involv static equival forego discuss frequent made refer notion modul equival without specifi mean key design decis modul calculu defin two compar modul deem equival differ modul system aris differ notion equival pure modul signatur possibl extract type compon type check depend essenti matter type equal must consid typ equal typ simplest answer would regard exactli modul equal naiv gener determin two modul equal suppos f latter equal undecid gener characterist featur second class modul system respect phase distinct 12 compiletim runtim comput properti modul system state type equival must decid independ term equival intuit plausibl sinc secondclass modul system provid mean type compon modul depend term compon happenst result care design see section 5 matter subtl appear base principl defin modul equival equiv alenc type check purpos static equival roughli speak two modul deem equival whenev agre correspond type compon 3 write modul equival judgment g rule static equival atom modul expect one atom type compon must equal atom term compon need sinc gener product new type gener functor notion dynam oper gener functor static compon compar thu pure gener functor alway static equival atom term modul complet set equival rule given appendix asid discuss modul equival refut misconcept firstclass modul gener secondclass modul fact express first secondclass modul incompar firstclass modul obviou advantag firstclass howev sinc type compon firstclass modul depend runtim comput imposs get static modul equival one 3 phase distinct calculu harper et al 12 includ nonstandard equal rule phasesplit modul structur stat dyn consist static compon stat dynam compon dyn static equival amount say stat stat system howev identifi functor structur must use dynam equival instead word one phasesplit modul harper et al 12 consequ firstclass modul propag much type inform secondclass modul singleton signatur type share inform express languag use singleton signatur 33 deriv transluc sum 11 14 18 illustr use singleton signatur express type share appear figur 2 type system allow deduct equival membership singleton signatur vice versa also allow forget singleton inform use subsignatur relat deduct follow use primit rule type system sinc ture follow definit given figur 5 beyond express share singleton use selfifica tion 11 instanc variabl bound signatur given fulli transpar signatur ss fact essenti exist princip signatur type check algorithm note sinc singleton signatur express static equival inform format singleton signatur restrict pure modul thu pure modul selfi fie harper lillibridg 11 leroy 14 singleton signatur complic equival check sinc equival depend context exampl lst int lst obvious inequival signatur ever use subsignatur also given signatur signatur equival sinc return result given permiss argument int exampl illustr context sensit equival provid type equal would hold equival strictli context insensit therebi allow propag addit type inform exampl type typflst int typ flst equal could case contextinsensit regim subtl technic point aris use higherord singleton defin figur 5 suppos f intuit contain modul equival f take member fs domain return thing f formal speak howev canon member signatur f etaexpans lst fs fact obviou f belong ensur f belong singleton signatur type system follow stone harper 33 includ extension type rule use rule f belong pst sf function fs belong sf similar extension type rule provid product possibl need ms figur 5 singleton higher signatur rule could avoid make higherord singleton primit explor metatheoret implic chang sinc modul higherord singleton signatur fulli transpar obvious project compar henc could judg pure even would otherwis classifi impur instanc gener problem recogn benign effect need disturb puriti sinc puriti judgment framework could readili incorpor extens captur situat pursu matter type check type system enjoy sound complet effect type check algorithm algorithm come three main part first algorithm synthes princip ie minim signatur modul second algorithm check subsignatur relationship third algorithm decid equival modul type modul typecheck proce usual manner synthes princip signatur modul check subsignatur intend signatur signatur synthesi algorithm given appendix b correct theorem state main judgment signatur synthesi g k state ms princip signatur ms puriti infer k subsignatur check syntaxdirect easi given algorithm check modul equival modul equival aris two singleton signatur compar subsigna ture relat equival algorithm close base stone harper algorithm 33 type constructor equival presenc singleton kind space consider preclud discuss algorithm full detail algorithm proof appear companion technic report 7 theorem 21 sound g theorem 22 complet g note sinc synthesi algorithm determinist follow theorem 22 princip signatur exist final sinc synthesi algorithm conveni present term infer rule requir one result state realli algorithm theorem 23 effect g decid whether exist k g k signatur symbol sig type symbol val string symbol string symbol val symbol string symbol string val functor symboltablefun symbol struct val tabl string array alloc intern hash tabl arrayarray initi size none fun string symbol lookup insert x fun symbol string case arraysub tabl n none rais fail bad symbol structur figur 6 strong seal exampl 3 strong weak seal gener essenti provid necessari degre abstract presenc effect modul sideeffect alloc storag abstract may demand type gener correspond storag alloc order ensur element type relat local store store anoth instanc consid exampl symbol tabl exampl given figur 6 symbol tabl contain abstract type symbol oper terconvert symbol string equal test presum faster avail string implement creat intern hash tabl defin symbol indic intern tabl intent implement fail except never rais howev depend gener symbol type anoth instanc symboltable2 creat type symboltablesymbol symboltable2symbol consid equal symbolt could ask interpret indic symboltable2 tabl therebi caus failur thu essenti symboltablesymbol symboltable2symbol consid unequ symbol tabl exampl demonstr import strong seal encod gener abstract type state modul gener necessari howev pure function mod ule leroy 15 give sever exampl modul motiv adopt applic functor instanc one may wish implement persist set use order list figur 7 signatur sig type elem val compar elem elem order signatur persist set sig type elem type set val empti set val insert elem set set struct list structur struct val structur structur figur 7 weak seal exampl exhibit pure function setfun functor parameter order element type whose implement abstract set type seal setfun instanti multipl timeseg differ client moduleswith element type use result abstract set type seen interchang system setfun made applic still opaqu weakli seal bodi specif intset1set intset2set equival setfunintordset type wellform setfun applic functor sig natur setfun intord variabl pure recal functor contain weak seal impur must bound variabl use applic astut reader may notic weak seal truli necessari setfun exampl fact one achiev effect code figur 7 leav bodi functor unseal strongli seal functor applic functor signatur bind setfun techniqu employ shao 31 encod applic functor system lack analogu weak seal fail approach work functor bodi fulli transparentin absenc weak seal opaqu substructur would strongli seal prevent functor given applic signatur best exampl need opaqu substructur applic functor provid interpret ml datatyp abstract type 13 standard ml caml datatyp opaqu sens represent recurs sum type expos thu distinct instanc datatyp declar creat distinct type standard ml caml differ howev whether datatyp gener presenc applic functor absent standard ml excel reason datatyp generativenam gener interpret would prevent datatyp appear bodi applic functor would sever diminish util applic functor particularli sinc ml recurs type provid datatyp mechan exampl implement setfun splay tree use datatyp declar defin tree type would requir use weak seal reason strong seal substitut weak seal neither weak seal substitut strong leroy 15 ob serv functorfre code gener simul call weak seal seen framework observ dynam puriti provid extra privileg absenc functor functor howev strong seal necessari provid true gener nevertheless worth note strong seal defin term construct languag weak seal particular defin strong seal use combin weak seal gener functor applic follow exist encod diminish import strong seal made primit languag regardless 4 avoid problem rule type system particularli rule 8 9 11 figur care ensur substitut modul alway pure expens requir functor secondproject argument pure necessari result substitut impur modul wellform signatur ill form thu appli functor impur argument one must letbind argument appli functor result pure variabl similar restrict impos shao 31 harper lillibridg 11 propos altern soften restrict harper lillibridg propos express term includ nondepend type rule without puriti restrict 2 pure rule carri forc depend rule exploit singleton signatur contravari functor signatur 2 impur rule express type rule applic still occur howev exploit rule type checker must find nondepend supersignatur suitabl applic 2 avoid problem 9 18 best way exampl consid signatur obtain supersignatur avoid variabl must forget first compon constant function therefor say second compon equal first compon result particular argument thu type may promot supersignatur give us infinit array choic choic superior obviou none compar sinc f abstract thu minim supersignatur avoid absenc minim signatur problem mean obviou way perform type check type system circumv avoid problem requir argument functor applic secondproject pure therebi elimin need find nondepend super signatur provid let construct oper still appli impur modul shown result type theori enjoy princip signatur achiev howev let construct must label result signatur mention variabl bound otherwis avoid problem rearis essenti requir everi functor applic project involv impur argument label result signatur well lead potenti unaccept syntact overhead practic fortun program systemat rewritten avoid problem describ next 41 elabor existenti signatur consid unannot let express let pure let express given minim signatur 2 1 otherwis left variabl leav scope minim supersignatur 2 mention howev rewrit let express may give signatur sss 1 2 avoid problem aris similarli functor applic fm rewritten mf given signatur sss 1 2 follow harper stone 13 propos use elabor algorithm systemat rewrit elabor take code written extern languag support unannot let well impur functor applic secondproject produc code written type system sinc elabor rewrit modul manner chang signatur also must take respons convert modul back expect signatur wherev requir mean elabora tor must track pair real invent elabor circumv avoid problem elabor use type elabor invent pair circumv avoid problem give signatur use existenti rather intern languag ss 1 2 mean thing sss 1 2 elabor treat two signatur differ elabor expect say functor encount sss 1 2 gener type error howev encount ss 1 2 extract 2 compon elab orat invari ensur alway look expect functor space consider preclud detail elabor algorithm appear companion technic report 7 sens elabor solv avoid problem introduc existenti signatur serv place nonexist minim supersignatur mention variabl light natur question whether need elabor could elimin make existenti signatur primit type system one natur way govern primit existenti introduct elimin rule rule avoid problem could solv least supersignatur 2 mention ss 1 would ss 1 2 unfortun rule particularli first make type check undecid exampl queri lsst hold exist pure type tm ms equal thu decid subsignatur equival queri presenc existenti would hard higherord unif known undecid 10 42 syntact princip signatur argu reason relat separ compil princip signatur express syntax avail programm provid strongest support separ compil programm break program point write interfac express inform compil could determin point strong support appear vital practic sinc system object caml standard ml new jersey higherord modul use success time without princip signatur nevertheless desir properti type system ie intern languag provid syntact princip signatur sinc princip signatur exist syntax avail programm howev elabor extern languag provid syntax existenti signatur appear elabor signatur thought princip signatur extern modul thu say basic type system provid syntact princip signatur extern languag extern languag programm permit write existenti signatur elabor code requir elabor decid whether coerc belong ss 1 2 turn requir elabor produc determin whether exist requir elabor solv undecid higherord unif problem tm equal thu allow programmerspecifi existenti signatur greatest possibl gener would make elabor undecid partial measur may possibl discuss packag modul firstclass valu desir modul usabl firstclass valu use make possibl choos run time effici implement signatur particular data set exampl spars dens represent array howev fulli gener firstclass modul present difficulti static type 18 one practic approach modul firstclass valu suggest mitchel et al 24 propos secondclass modul automat wrap existenti packag 25 obtain firstclass valu similar approach modul firstclass valu describ russo implement moscow ml 29 existentialpackag approach modul firstclass valu built languag write type packag modul packag construct pack elimin packag modul existenti perform use closedscop unpack construct may defin follow pack def unpack e ss compar definit standard encod existenti type bt abtaa main limit existentiallypackag modul closedscop elimin construct observ repeatedli literatur 20 3 18 construct restrict use one unpack e ss e result type may mention consequ function packag modul may depend result type may mention argument defici mitig languag abil write function unpackag secondclass mod ule given depend type psst instead anoth problem closedscop elimin construct term packag type unpack standalon secondclass modul unpack insid enclos term unpack packag modul creat abstract type separ scope packag must unpack earli stage ensur coher among client lead scope invers awkward manag practic desir therefor new modul construct form unpack e coerc firstclass packag e type back secondclass modul signatur follow exampl illustr ad construct carelessli lead unsound modul modul modul note argument functor f atom term modul argument f static equival f given applic signatur x 1 x 2 deem equival even origin modul 1 2 thu f must type term e pack modul unpack e pack ss figur 8 packag modul extens deem gener turn requir unpack construct induc dynam effect packag modul admit improv unpack construct defin core languag constitut simpl orthogon extens type system complic type check syntax type rule extens given figur 8 note closedscop unpack construct defin intuit unpack gener modul unpack arbitrari term whose type compon may depend runtim condit core system present section 2 gener induc strong seal mere pro forma effectth languag support secondclass mod ule provid way type compon modul actual gener run time type system howev treat dynam effect truli dynam thu scale easili handl real runtim type gener enabl extens figur 8 6 relat work harper mitchel moggi 12 pioneer theori phase sep arat fundament achiev maxim type propag higherord modul system nonstandard equat rule identifi higherord modul primit phase split one similar spirit though differ detail notion static modul equival one may view system subsystem seal mechan consequ modul pure macqueen toft 21 propos higherord modul extens origin definit standard ml 22 implement standard ml new jersey compil semant involv twophas elabor process higherord functor reelabor applic take advantag addit inform argument advantag balanc disadvantag inhibit type propag presenc separ compil sinc functor compil separ applic reelabor thorough comparison difficult macqueen toft employ stampbas semant difficult transfer set focus control abstract larg neglect higherord modul harper lillibridg 11 leroy 14 16 introduc close relat concept transluc sum manifest type mechan serv basi modul system revis definit standard ml 1997 23 harper stone 13 formal elabor standard ml 1997 program transluc sum calculu deal avoid problem harper stone reli elabor mechan similar harper stone languag view subsystem functor gener strong seal support leroy introduc notion applic functor 15 enabl one give fulli transpar signatur mani higherord functor leroy formal may seen defin puriti syntact restrict functor applic appear type path must name form one hand restrict provid weak form structur share sens abstract type fxt result appli f modul name x hand restrict prevent system captur full equat theori higherord functor sinc equat express name form 4 togeth manifest type applic functor form basi modul system object caml 27 manifest type formal like transluc sum formal address avoid prob lem consequ lack princip signatur recent russo thesi 28 formal two separ modul languag one close model sml modul system higherord modul system applic functor along line ocaml abandon name form restrict russo two languag view subsystem first support strong seal second support weak seal adopt use existenti signatur address avoid problem although russo also use existenti model gener russo thesi also describ extens sml packag modul firstclass valu extens similar existenti packag approach discuss begin section 5 therefor suffer limit closedscop unpack construct russo defin two languag separ implement higherord modul system experiment extens moscow ml compil 26 combin two languag without distinguish static dynam effect unfortun consequ moscow ml higherord modul system place restrict bodi applic particular one defeat gener gener functor etaexpand applic one exploit uncov unsound languag 6 retrospect clear analysi one convert partial total functor shao 31 propos singl type system modul support applic gener functor roughli speak shao system may view subsystem base exclus strong seal dynam effect support p p par signatur observ section 3 mean bodi applic functor may contain opaqu substructur datatyp shao system like circumv avoid problem section 4 restrict functor applic project pure argument must path system elimin implicit subsumpt amount requir let express annot system seem like elabor techniqu could well appli shao system lift restrict expens syntact princip signatur shao also observ fulli transpar functor may regard applic instanc gener problem recogn benign effect describ section 2 7 conclus type system firstord modul system reason well understood contrast previou work typetheoret higherord modul left field fragment state variou compet design clear statement tradeoff design state field made difficult choos one design anoth left erron impress tradeoff actual exist exampl previou design support sound gener applic functor opaqu subcompon languag seek unifi field provid practic type system higherord modul simultan support key function preced modul system process dispel misconcept tradeoff fulli express gener applic functor therebi elimin dilemma face languag design nevertheless sever import issu modular program go beyond scope type theori chief among structur share origin version standard ml 22 includ notion modul equival sensit dynam well static part modul although notion would violat phase distinct might possibl formul variat system take account dynam equival conserv fashion possibl simul structur share elab orat add abstract type structur serv compiletim name structur howev would mere elabor convent intrins account structur share within type theori recurs modul import direct futur research integr recurs modul 8 5 30 present framework chief difficulti achiev practic type check presenc gener recurs depend signatur isol practic sublanguag avoid problem r type system modular program specif modula3 type system abstract type dot notat sound complet elimin singleton kind recurs modul moscow ml higherord modul un sound type system higherord modul expand version cool modul hot languag bound existenti minim type undecid secondord unif problem manifest type applic functor fulli transpar higherord modul syntact theori type gener share modular modul system transluc sum foundat higherord modul system abstract specif program develop use depend type express modular structur semant higherord functor definit standard ml david mac queen extens standard ml modul subtyp inherit abstract type existenti type type modul recurs structur standard ml transpar modul fulli syntact signa ture singleton kind singleton type decid type equival languag singleton kind program modula2 tr abstract specif program develop abstract type existenti type modulamyampersandndash3 type system higherord modul phase distinct extens standard ml modul subtyp inherit manifest type modul separ compil typetheoret approach higherord modul share applic functor fulli transpar higherord modul bound existenti minim type unit recurs modul transpar modul fulli syntat signatur decid type equival languag singleton kind typetheoret interpret standard ml recurs structur standard ml use depend type express modular structur definit standard ml semant higherord functor sound complet elimin singleton kind firstclass structur standard ml singleton kind singleton type ctr oleg kiselyov chungchieh lightweight static capabl electron note theoret comput scienc entc v174 n7 p79104 june 2007 norman ramsey kathleen fisher paul govereau express languag signatur acm sigplan notic v40 n9 septemb 2005 karl crari sound complet elimin singleton kind acm transact comput logic tocl v8 n2 p8e april 2007 manuel chakravarti gabriel keller simon peyton jone associ type synonym acm sigplan notic v40 n9 septemb 2005 dimitrio vytinioti geoffrey washburn stephani weirich open shut typecas proceed 2005 acm sigplan intern workshop type languag design implement p1324 januari 1010 2005 long beach california usa derek dreyer type system wellfound recurs acm sigplan notic v39 n1 p293305 januari 2004 andrea rossberg gener dynam opac abstract type proceed 5th acm sigplan intern confer principl practic declarit program p241252 august 2729 2003 uppsala sweden derek dreyer robert harper manuel chakravarti gabriel keller modular type class acm sigplan notic v42 n1 januari 2007 daniel k lee karl crari robert harper toward mechan metatheori standard ml acm sigplan notic v42 n1 januari 2007 derek dreyer recurs type gener acm sigplan notic v40 n9 septemb 2005 eijiro sumii benjamin c pierc bisimul dynam seal theoret comput scienc v375 n13 p169192 may 2007 eijiro sumii benjamin c pierc bisimul dynam seal acm sigplan notic v39 n1 p161172 januari 2004 jame j leifer gill peskin peter sewel keith wansbrough global abstractionsaf marshal hash type acm sigplan notic v38 n9 p8798 septemb manuel chakravarti gabriel keller simon peyton jone simon marlow associ type class acm sigplan notic v40 n1 p113 januari 2005 andrea rossberg miss link dynam compon ml acm sigplan notic v41 n9 septemb 2006 owen matthew flatt structur functor modul unit acm sigplan notic v41 n9 septemb 2006 john bill peter sewel mark shinwel rok strnia typesaf distribut program ocaml proceed 2006 workshop ml septemb 1616 2006 portland oregon usa martin sulzmann manuel chakravarti simon peyton jone kevin donnelli system f type equal coercion proceed 2007 acm sigplan intern workshop type languag design implement januari 1616 2007 nice nice franc