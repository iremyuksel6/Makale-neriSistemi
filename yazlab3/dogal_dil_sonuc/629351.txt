asynchron problem simd parallel comput abstracton essenti problem parallel comput simd machin handl asynchron problem difficult unsolv problem mismatch asynchron problem simd architectur propos solut let simd machin handl gener asynchron problem approach implement runtim support system run mimdlik softwar simd hardwar runtim support system name p kernel threadbas two major advantag threadbas model first applic problem irregular andor unpredict featur automat schedul move thread overload processor underload processor second importantli granular thread control reduc system overhead p kernel also abl handl bookkeep messag manag well make lowlevel task transpar user substanti perform obtain maspar mp1 b introduct 11 simd machin handl asynchron problem current parallel supercomput develop two major architectur simd singl instruct multipl data architectur mimd multipl instruct multipl architectur simd architectur consist central control unit mani process unit one instruct execut time everi processor execut instruct advantag simd machin includ simpl architectur make machin potenti inexpens synchron control structur make program easi 4 34 commun overhead low 26 design simd architectur motiv fact import though limit class problem fit simd architectur extrem well 35 mimd architectur base duplic control unit individu processor differ processor execut differ instruct time 15 flexibl differ problem structur appli gener applic howev complex control structur mimd architectur make machin expens system overhead larg applic problem classifi three categori synchron loos synchron asynchron tabl show applic problem three categori 13 ffl synchron problem uniform problem structur time step everi processor execut oper differ data result natur balanc load ffl loos synchron problem structur iter two phase comput phase synchron phase synchron phase processor exchang inform synchron comput load also redistribut phase comput phase differ processor oper independ ffl asynchron problem synchron structur processor may commun time comput structur irregular load imbalanc tabl classif problem structur synchron loos synchron asynchron matrix algebra molecular dynam nqueen problem finit differ irregular finit element region grow qcd unstructur mesh eventdriven simul synchron problem natur implement simd machin loos synchron problem mimd machin implement loos synchron problem simd machin easi comput load must balanc load balanc activ essenti irregular exampl simpl 2 algorithm nbodi simul synchron easi implement simd machin 12 bernuthut algorithm log n nbodi simul loos synchron difficult implement simd machin 3 solv asynchron problem difficult first direct implement mimd machin nontrivi user must handl synchron load balanc issu time could extrem difficult applic problem gener runtim support system linda 2 5 reactiv kernel 27 33 chare kernel 30 necessari solv asynchron problem implement asynchron problem simd machin even difficult need runtim support system support system asynchron particular support system must arrang code way processor execut instruct time take nqueen problem exampl sinc known prior execut time mani process gener larg comput runtim system necessari establish balanc comput effici execut summar discuss tabl ii variou applic problem requir differ program methodolog two essenti tabl ii implement problem mimd simd machin synchron loos synchron asynchron mimd easi natur need runtim support simd natur difficult difficult need runtim support program methodolog arraybas threadbas problem domain synchron applic natur map onto array result arraybas program methodolog problem lend effici program arraybas methodolog mismatch model problem structur solut asynchron problem easili organ aggreg oper data domain uniformli structur natur demand threadbas program methodolog thread individu execut inform exchang happen time loos synchron problem either arraybas threadbas program methodolog appli 12 let simd machin handl asynchron problem make simd machin serv gener purpos machin must abl solv asynchron problem addit solv synchron loos synchron problem major difficulti execut asynchron applic simd machin ffl gap synchron machin asynchron applic ffl gap array processor threadbas program one solut call applicationori approach let user fill gap applic problem architectur approach user must studi problem look specif method solv 7 36 37 39 altern applicationori approach systemori approach provid system support run mimdlik softwar simd hardwar systemori approach superior applicationori approach three reason ffl system usual knowledg architectur detail well dynam state ffl effici develop sophist solut system instead write similar code repeatedli user program ffl gener approach enhanc portabl readabl applic program systemori approach carri two level instructionlevel thread level share underli idea one treat program data simd machin could interpret data like machinelanguag instruct interpret machin instruct cycl mimdlik program could effici execut simd machin 17 instructionlevel approach implement idea directli instruct interpret parallel across processor control signal eman central control unit 41 major constraint approach central control unit cycl almost entir instruct set instruct execut processor may execut differ instruct furthermor approach must insert proper synchron ensur correct execut sequenc program commun synchron could suspend larg number processor final approach unabl balanc load processor unlik produc good perform gener applic propos threadbas model runtim system support loos synchron asynchron problem simd machin threadlevel implement offer great flexibl compar instructionlevel approach least two advantag ffl execut order thread exchang avoid processor suspens load balanc applic problem irregular dynam featur ffl system overhead overwhelm sinc granular control threadbas approach runtim support system name process kernel p kernel p kernel threadbas assign comput threadlevel p kernel abl handl bookkeep ing schedul messag manag well make lowlevel task transpar user 13 relat research exist work solv loos synchron asynchron problem simd machin mostli applic orient 7 36 37 39 region grow algorithm asynchron irregular problem difficult run simd machin 39 merg phase major part algorithm perform two three order magnitud wors counterpart mimd machin result due commun cost lack load balanc mechan author conclud behavior region grow algorithm like asynchron problem difficult character work need develop better model two implement mandelbrot set algorithm 36 molecular dynam algorithm 7 37 contain paralleliz outer loop inner loop number iter vari differ iter outer loop structur occur sever differ problem iter advanc method employ rearrang iter simd execut call simlad simd model local indirect address 36 loop flatten 37 recent studi conduct simul logic circuit simd machin 6 20 major differ work approach handl gener asynchron loos synchron problem instead studi individu problem instructionlevel approach studi number research 8 9 22 25 41 40 mention major restrict approach entir instruct set must cycl execut one instruct step everi processor common method reduc averag number instruct eman execut cycl perform global or determin whether instruct need processor 9 41 might necessari insert barrier synchron point limit degre diverg certain applic barrier end statement well foral statement good idea 8 work includ adapt algorithm chang order instruct eman maxim expect number activ processor 25 besid issu load balanc processor suspens also unsolv problem applic implement system noncommun 41 barrier end program 9 collin discuss commun issu propos scheme delay execut commun instruct 8 similar techniqu use 9 expens oper includ commun howev clear whether method work mani applic depend load imbalanc inevit lead high commun overhead processor suspens summari instructionlevel approach larg interpret overhead techniqu liter transform pure mimd code pure simd code elimin overhead propos 10 perhap work closest approach graphin 17 earli work combin 21 16 work interpret prolog flat ghc 19 23 24 graphin implement mimd simul simd machin achiev simd processor repeatedli cycl entir set possibl instruct work distinguish work term granular control graphin model suffer fine granular author mention commun requir roughli millisecond unaccept long finegrain applic 17 p kernel user control grainsiz process grainsiz well beyond one millisecond thu p kernel implement obtain accept perform besid model gener instead dedic mere function languag graphin model model similar largegrain data flow lgdf model 18 model comput combin sequenti program dataflowlik program activ lgdf model implement share memori machin implement mimd distribut memori machin well 42 30 11 14 show model implement simd distribut memori machin 2 p kernel approach comput model languag comput model p kernel origin chare kernel 30 messagedriven nonpreempt threadbas model parallel comput view collect process turn consist set thread call atom comput process commun via messag atom comput result process messag execut creat new process gener new messag 1 messag trigger atom comput wherea atom comput wait messag atom comput process share one common data area thu process p k consist set atom comput k one common data area process schedul processor atom comput execut processor presum sequenc indic atom comput carri first instead depend order arriv messag figur 1 show gener organ process atom comput common data area gener number process much larger number processor process move around balanc load p kernel runtim support system simd machin built manipul schedul process well messag program written p kernel languag consist mainli common data area process atom comput figur 1 process atom comput common data area collect process definit subroutin definit process definit includ process name preced keyword process follow process bodi shown process procnam f common data area declar entri label1 messag msg1 code1 entri label2 messag msg2 code2 g boldfac letter denot keyword languag process bodi enclos brace consist declar privat variabl constitut common data area process follow group atom comput definit atom comput definit start keyword entri label follow declar correspond messag arbitrari user code one process definit must main process first entri point main process place user program start overal structur p kernel languag differ tradit program languag mainli explicit declar basic unit alloc process b basic unit indivis comput atom comput c commun media me sage fundament structur avail comput carri parallel assist primit function provid p kernel oscreateproc os etc user write program p kernel languag deal creation process send messag detail comput model languag refer 29 follow illustr write program p kernel languag use nqueen problem exampl algorithm use attempt place queen board one row time particular posit valid queen place board posit row column diagon mark invalid queen placement program sketch figur 2 atom comput queeninit main process creat n process type subqueen empti board one candid queen column first row two type atom comput process subqueen parallelqueen responsequeen common data area consist solutioncount responsecount atom comput parallelqueen receiv messag repres current placement queen posit next queen place follow invalid process creat new subqueen seqqueen process place one queen everi valid posit next row atom comput responsequeen process subqueen main count total number success queen configur trigger number time respons expect child process atom comput sequentialqueen invok rest row manipul sequenti granular control exampl two process definit besid process main atom comput share common data area singl process parallelqueen responsequeen atom comput sequentialqueen share common data area atom comput therefor separ process preserv good data encapsul save memori space gener atom comput logic coher share common data area process 3 design implement main loop p kernel system shown figur 3 start system phase includ place process transfer data messag select atom comput execut follow user program phase execut select atom comput iter continu comput complet p kernel softwar consist three major compon comput select commun memori manag 31 comput select fundament differ mimd simd system degre synchron requir mimd system differ processor execut differ thread code simd system p kernel system implement mimd machin atom comput execut next individu decis processor wherea due lockstep synchron simd machin issu becom global decis let assum k atom comput type correspond atom comput definit repres lifetim execut total number atom comput execut far k atom comput dynam distribut among processor iter comput select function f appli select atom comput type k k follow user program phase iter processor activ least one atom comput select type k let function numi p record number atom comput type processor p iter let function acti count number process main entri queeninit messag msg1 f int k read n input oscreateprocsubqueenparallelqueenmsg21kempti board entri responsequeen messag msg3m f print solut solutioncount process subqueen entri parallelqueen messag msg2ijboard f int k invalid row column j diagon ij posit i1k mark valid f ni larger grainsiz els entri responsequeen messag msg3m f process seqqueen f entri sequentialqueen messag msg2ijboard f int k count call sequenti routin recurs gener valid configur figur 2 nqueen program system phase process placement messag transmiss comput select user program atom comput start figur 3 flow chart p kernel system activ processor iter atom comput type select n number processor present three comput select algorithm first one f cyc simpl algorithm algorithm cyclic algorithm basic repeatedli cycl atom comput type howev acti equal zero type skip alway necessari carri k reduct comput acti sinc long first nonzero acti found valu function f cyc determin algorithm similar method use instructionlevel approach processor repeatedli cycl entir set possibl instruct global reduct essenti similar globalor method use reduc number instruct eman execut iter howev instructionlevel approach processor execut exactli one instruct per cycl threadlevel approach processor may execut mani thread per cycl also execut order program fix instructionlevel approach order exchang threadbas approach complet comput shortest time number iter mini mize maxim processor util iter one possibl heurist 900 comput select function ft select k 2 intuit better lead immedi good processor util auction algorithm f auc propos base observ algorithm ii auction algorithm atom comput calcul acti iter atom comput maximum valu acti chosen execut next f auc cyclic algorithm nonadapt sens select made almost independ distribut atom comput way could case processor execut one atom comput type mani processor wait execut atom comput type auction algorithm runtim adapt maxim util case adapt algorithm sophist gener howev experiment result show case cyclic algorithm perform better auction algorithm observ auction algorithm appli near end execut parallel becom smaller smaller program take long time finish low parallel phenomenon degrad perform serious character tail effect propos improv adapt algorithm overcom tail effect retain advantag auction algorithm intend maxim processor util long larg pool atom comput avail hand avail parallel fall certain degre tri exploit larg parallel assign prioriti differ atom comput type atom comput whose execut increas parallel get higher prioriti vice versa prioriti either assign programm automat gener depend analysi algorithm iii prioriti auction algorithm simplic assum atom comput 0 presort accord prioriti 0 highest prioriti ak gamma1 lowest use gaug avail parallel c constant n number processor f pri max 0ik acti larger indic degre avail parallel high auction algorithm appli otherwis among atom comput type one highest prioriti execut next constant c set 05 half processor activ auction algorithm use maxim processor util otherwis prioriti consid favor parallel increas tail effect prevent tabl iii execut time 12queen problem cyclic auction prioriti auction 104 second 111 second 101 second algorithm constantli provid better perform provid cyclic algorithm tabl iii show perform differ comput select algorithm 12queen problem 1kprocessor mp1 32 commun two kind messag transfer one data messag specif address exist process kind process messag repres newli gener process process messag transfer depend schedul strategi use two kind messag handl separ transfer data messag assum processor initi hold 0 p data messag sent end comput phase simd characterist one messag transfer time thu messag transfer step must repeat least real situat even complic time messag transfer collis may occur two messag differ processor destin processor therefor need prevent messag loss due collis let destp destin messag processor p srcq sourc processor q go receiv messag collis two processor p 1 p 2 send messag processor q destp 1 q processor q receiv one say success deliv messag destin gener perform parallel assign oper processor collis happen sendwithoverwrit semant appli collis prevent scheme appli processor p must wait next time compet first transfer data messag may still unsent messag processor p one messag send 0 p 1 everi processor abl send messag first transfer due collis henc long k 0 need continu k k1 dm messag transfer process illustr figur 4 mani optim could appli reduc number time step send messag one let destp 1 destp destp destp figur 4 messag transfer collis notic later transfer like processor activ send messag result low util simd system avoid case requir messag transfer instead attempt send major data messag residu messag buffer sent next iter atom execut model processor fail send messag stall instead processor continu execut long messag queue use theta k measur percentag data messag left k time data transfer thu constant use control number transfer limit theta k algorithm data messag transfer summar figur 5 experi valu determin around 02 figur 6 show exampl 12queen problem mp1 minim execut time reach theta k processor p k p 0 assign destp srcp send data messag els assign theta k processor k p 0 buffer residu data messag figur 5 data messag transfer procedur process placement handl process messag almost data messag except need assign destin processor id process messag assign call process placement random placement algorithm implement p kernel random placement algorithm simpl moder perform algorithm n number processor destp assign follow procedur transfer data messag howev two kind messag differ destp data messag fix wherea process messag vari take advantag abl reschedul process messag destin processor could accept newli gener process resourc execut time figur execut time differ valu 12queen constraint collis reschedul simpli task assign anoth random number destin processor id repeat reschedul process messag assign destin processor id howev better choic offer one two chanc reschedul instead repeat satisfact thu unsuccess schedul process messag buffer similar residu data messag wait next commun phase load balanc strategi call runtim increment parallel schedul implement mimd version p kernel 31 schedul strategi system schedul activ altern underli comput work implement simd machin expect deliv better perform random placement 33 memori manag simd machin massiv parallel processor system one thousand processor could easili run memori result system failur certainli undesir situat ideal system failur avoid unless memori space processor exhaust memori manag provid featur improv system robust avail memori space specif processor becom tight restrict new resourc consumpt releas memori space move unprocess process processor p kernel system implement simd machin use two mark m1 m2 identifi state memori space usag function jp use measur current usag memori space processor p alloc memori space processor p total memori space processor p processor p said normal state 0 jp m1 nearlyful state full state m2 jp 1 emerg state run memori ie nearlyful state need limit new resourc consumpt sinc avail memori space get tight accomplish prevent newli gener process messag schedul thu process messag schedul processor p m1 jp reschedul perform find anoth destin processor full state addit action taken nearlyful state restrict scheme appli data messag address processor p m2 jp defer buffer origin processor wait chang destin processor state although data messag eventu sent destin processor delay send help processor relax memori tight note defer data messag buffer separ count calcul theta k emerg state processor p run memori sever action taken declar failur one clear residu data messag process messag anoth redistribut unprocess process messag previous place processor memori space releas time rescu processor emerg state let system continu 4 perform p kernel current written mpl run 16kprocessor maspar mp1 32k byte memori per processor mpl cbase data parallel program languag test p kernel system use two sampl program nqueen problem gromo molecular dynam program 38 37 gromo loos synchron problem test data bovin superoxid dismutas molecul sod 6968 atom 28 cutoff radiu predefin 8 12 16 total execut time p kernel program consist two part time execut system program sy time execut user program usr system effici defin follow total execut time system effici exampl shown figur 7 04 3 system effici depend ratio system overhead grainsiz atom comput tabl iv show system effici 1kprocessor mp1 high effici result high ratio granular system overhead p kernel execut loos synchron fashion divid iter iter execut consist system program phase user program phase execut time system program vari 8 20 millisecond mp1 averag grainsiz user phase test program 55 330 millisecond system phase everi processor particip global action hand user program phase processor involv execut select atom idl system phase user computation0104030304phas 1 phase 2 phase 3 figur 7 illustr effici comput iter ratio number particip processor n activ total number processor n defin util ut activ exampl util iter 1 figur 7 75 sinc three four processor activ util effici defin follow activ tabl iv system effici sy nqueen gromo 12queen 13queen 14queen 8 12 16 934 922 903 980 986 985 execut time tth iter util effici depend comput select strategi load balanc scheme tabl v show util effici differ problem size prioriti auction algorithm random placement load balanc tabl v util effici sy nqueen gromo 12queen 13queen 14queen 8 12 16 770 892 962 802 873 896 irregular problem grainsiz atom comput may vari substanti grainsiz variat heavili depend irregular problem program partit iter execut time user phase depend largest atom comput among activ processor processor execut atom comput smaller grainsiz fulli occupi time period use index call full measur grainsiz variat atom comput iter pn activ activ user comput time kth particip processor iter exampl full iter 1 figur 7 04 full effici defin activ activ pn activ activ tabl vi show full effici differ problem size nqueen extrem irregular problem substanti grainsiz variat low full effici gromo program loos synchron grainsiz variat small tabl vi full effici sy nqueen gromo 12queen 13queen 14queen 8 12 16 192 180 176 946 961 982 defin overal effici follow full system effici increas reduc system overhead increas grainsiz realist expect low system overhead system overhead domin commun overhead major techniqu increas system effici grainsiz control averag grainsiz atom comput much larger system overhead util effici depend comput select load balanc algorithm algorithm discuss paper deliv satisfactori perform long number process much larger number processor difficult task reduc grainsiz variat determin full effici grainsiz variat depend characterist applic problem howev still possibl reduc grainsiz variat first method select proper algorithm second method select good program partit given applic may differ algorithm solv differ partit pattern may small grainsiz variat may care select algorithm partit pattern result higher full effici overal effici nqueen problem gromo program 1k processor mp1 shown tabl vii compar nqueen problem gromo much higher effici mainli small grainsiz variat tabl vii effici nqueen gromo 12queen 13queen 14queen 8 12 16 138 152 153 744 827 867 tabl viii ix show execut time speedup nqueen problem gromo program respect high speedup obtain gromo program nqueen difficult problem solv fairli good perform achiev tabl viii nqueen execut time speedup mp1 number 12queen 13queen 14queen processor time sec speedup time sec speedup time sec speedup tabl ix gromo execut time speedup mp1 number 8 12 16 processor time sec speedup time sec speedup time sec speedup 1k 133 761 343 867 686 887 8k 253 4001 690 4209 107 5688 5 conclud remark motiv research twofold prove whether simd machin handl asynchron applic problem serv generalpurpos machin studi feasibl provid truli portabl parallel program environ simd mimd machin first version p kernel written cm fortran run 4kprocessor tmc cm2 1991 perform report 32 fortran best languag system program use multipl dimens array indirect address implement queue henc indirect address extrem slow access differ address cm2 cost much 9 1993 p kernel rewritten mpl port maspar mp1 mpl version reduc system overhead improv perform substanti experiment result shown p kernel abl balanc load fairli well simd machin nonuniform applic system overhead reduc minimum granular control acknowledg grate reinhard hanxleden provid gromo program terri clark provid sod data also thank alan karp guy steel hank dietz jerri roth comment would like thank anonym review construct comment research partial support nsf grant ccr9109114 ccr8809615 perform data gather mp1 npac syracus univers r model concurr comput distribut system linda friend hierarch onlogn forc calcul algorithm vector model dataparallel comput linda context data parallel simul use timewarp connect machin evalu parallel languag molecular dynam comput multipl instruct multipl data emul connect machin massiv parallel mimd implement simd hardwar schedul parallel program task onto arbitrari target machin solv problem concurr processor architectur problem portabl parallel softwar system comparison cluster heurist schedul dag multiprocessor microprocessorbas hypercub supercomput data parallel algorithm graphin dualiti simd mimd babb ii david c dap prolog setori approach prolog logic simul massiv parallel architectur simul applic architectur connect machin explor asynchron dataparallel flat ghc implement supercomput massiv parallel implement flat ghc connect machin mimd execut simd comput array processor supercomput reactiv kernel molecular dynam simul superoxid interact superoxid dismutas chare kernel implement multicomput chare kernel runtim support system parallel comput runtim increment parallel schedul rip distribut memori comput solv dynam irregular problem simd architectur runtim support portabl multicomput commun librari atop reactiv kernel think machin corp think machin corp indirect address load balanc faster solut mandelbrot set simd architectur relax simd control flow constraint use loop transform gromo groningen molecular simul softwar solv nonuniform problem simd comput case studi region grow exploit simd comput gener purpos comput concurr execut noncommun program simd processor program aid messagepass system tr ctr nael b abughazaleh philip wilsey xianzhi fan debra hensgen synthes variabl instruct issu interpret implement function parallel simd comput ieee transact parallel distribut system v8 n4 p412423 april 1997 andrea di bla arun jagota richard hughey optim neural network simd parallel comput parallel comput v31 n1 p97115 januari 2005 mattan erez jung ho ahn jayanth gummaraju mendel rosenblum william j dalli execut irregular scientif applic stream architectur proceed 21st annual intern confer supercomput june 1721 2007 seattl washington