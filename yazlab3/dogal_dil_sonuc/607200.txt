parallel mine outlier larg databas data mine new import fast grow databas applic outlier except detect one kind data mine appli varieti area like monitor credit card fraud crimin activ electron commerc everincreas size attribut dimens databas previous propos detect method two dimens longer applic time complex nestedloop nl algorithm knorr ng proc 24th vldb 1998 linear dimension quadrat dataset size induc unaccept cost larg dataseta effici version enl parallel version penl introduc theori improv perform penl linear number processor shown perform comparison enl penl use bulk synchron parallel bsp model great improv verifi experi parallel comput system ibm 9076 sp2 result show good choic mine outlier cluster workstat lowcost interconnect commod commun network b introduct data mine knowledg discoveri task classifi four gener categori depend detect eg associ rule 1 b class identif eg classif data cluster 6 14 17 c class descript eg concept gener 7 11 excep tionoutli detect 12 13 research concentr first three categori exist work outlier detect lie field statist 2 8 although author current depart comput scienc univers maryland colleg park work paper done univers hong kong hung cheung outlier also consid exist algorithm main target algorithm tri remov toler 6 14 17 fact identif outlier appli area electron commerc credit card fraud detect analysi perform statist profession athlet 10 even explor satellit medic imag 12 exampl databas transact contain sale inform transact would involv small amount money item thu typic fault detect discov except amount money spent type item purchas time locat second exampl satellit nowaday use take imag earth use visibl light well electromagnet wave detect target potenti oil field suspici militari base detect except high energi temperatur reflect certain electromagnet wave use locat possibl target simpl algorithm call nestedloop algorithm nl propos 13 howev complex okn 2 k number dimens n number data object number pass dataset linear n real implement perform studi find major cost calcul distanc object though nl good choic dataset high dimension larg number calcul make unfavor cellbas algorithm propos 13 need three dataset pass howev suitabl high dimens time complex exponenti number dimens nl alway outperform cellbas algorithm four dimens 13 paper improv nl high dimension dataset common data warehous one approach improv nl algorithm parallel paper definit outlier origin nl describ next subsect introduct nl improv reduc number calcul result algorithm enl given section 2 section 3 enl parallel reduc execut time sharednoth system section 4 perform improv analyz use bulk synchron parallel bsp model perform studi given section 5 final give discuss relat work section 6 paper mainli focus identif distancebas outlier although parallel algorithm also modifi perform expens step find densitybas outlier 4 relat work densitybas outlier describ section 6 11 distancebas outlier given 13 definit outlier follow given paramet p object dataset dbp doutlier least fraction p object lie greater distanc definit maximum number object within distanc outlier number object let f underli distanc function give distanc pair object object parallel mine outlier larg databas 3 neighbourhood contain set object q 2 within distanc ie notion outlier suitabl situat observ distribut fit standard distribut reader refer 12 gener notion distancebas outlier support statist test standard distribut work densitybas outlier describ section 6 12 assumpt notat nl algorithm algorithm nl 13 blockori nestedloop design block involv one disk io ie may necessari take one disk io read block paper page need one disk io access thu total number page particular dataset constant total number block dataset chang size block nl algorithm design uniprocessor system one local memori one local disk effect cach insignific make assumpt gener accept real system addit disk buffer oper system besid buffer use algorithm disk access sequenti let n number block dataset k dimension n number object dataset p number page contain block number object page let time access page disk io time comput distanc 2 object comp linear dimension 13 origin nl origin nl algorithm 13 clarif describ assum buffer size store dataset b dataset size buffer first divid 2 equal halv call first second array dataset read first second array predefin order object first array distanc object array directli comput count object dneighbourhood maintain algorithm nl 1 fill first array size b dataset block object 2 object first array count number object first array close distanc count nonoutli 3 repeat block compar first array fill second array anoth block save block never serv first array last 4 hung cheung b unmark object first array increas count number object second array close distanc count mark nonoutli 4 report unmark object first array outlier 5 second array serv first array stop otherwis swap name first second array repeat step 2 time complex state okn 2 13 k dimension n number object dataset disk io time consid briefli 13 fact cpu time io time consid detail analysi comput time disk io time given comput time total time calcul distanc pair object upper bound n 2 comp ie number calcul distanc quadrat number object dataset actual number calcul depend distribut data locat data block distanc number turn depend fraction p sinc usual case number outlier small small calcul particular object done count exce result actual number calcul much less n 2 usual within half shown section 5 disk io time sinc dataset divid block total number block read nngamma2ngamma1 number pass dataset n total number page read np 1p note p directli proport buffer size fix buffer size n directli proport n complex 2 exampl 1 follow exampl consid 50 buffer 4 block dataset denot b c ie block contains4 dataset order fill array compar follow 1 b c total 4 block read 2 read requir read b c total 2 block read 3 c c b total 2 block read 4 b b c total 2 block read tabl show order block load block stay two array buffer row show snapshot step 1 step 3 parallel mine outlier larg databas 5 block buffer disk io order b c array 1 array 2 6 l c 9 buffer unchang total number disk io n block total number dataset pass is4 25 enhanc nl nl redund block read comparison section new order propos result reduc comput time disk io time arrang turn block read second array predefin order end seri readi block reach block first array mark done name two array swap order revers repeat block done result enhanc nl enl algorithm describ object dataset count algorithm enl 1 label block readi block either readi done state 2 fill first array size b dataset block object 3 object first array increas count number object first array close distanc count mark nonoutli 4 set blockread order forward 5 repeat readi block without mark done compar first array specifi blockread order fill second array next block b object first array object j second array object j unmark 6 hung cheung increas count count j 1 count mark nonoutli proceed next nonoutli 6 report unmark object first array outlier 7 second array mark done stop otherwis mark block first array done revers blockread order swap name first second array repeat step 3 although time complex enl still okn 2 k dimension n number object dataset cost comput disk io reduc compar nl comput time upper bound total time calcul distanc pair object still linear dimension origin nl algorithm count object first array updat howev enl count object updat comparison thu upper bound number calcul distanc reduc almost half compar nl actual reduct number calcul depend distribut data locat data block distanc number turn depend fraction p comparion perform nl enl shown section 5 simplic upper bound number distanc calcul object block said np p 2 fact need np p np time disk io time dataset divid block total number block read number pass dataset n total number page read fix buffer size n directli proport n disk io time complex nearli half nl exampl 2 exampl 1 extend illustr enl consid 50 buffer 4 block dataset denot b c ie block contains4 dataset order fill array compar follow 1 b c total 4 block read 2 read requir c b total 2 block read parallel mine outlier larg databas 7 3 b b c total 1 block read 4 c c total 0 block read tabl show order block load block stay two array buffer row show snapshot step 2 step 5 block buffer disk io order b c array 1 array 2 buffer unchang total number disk io 1 block total number dataset pass is4 175 3 parallel enl penl parallel enl parallel version enl run sharednoth system actual run processor penl almost reduc enl block read enl replac transfer block among processor commun network major advantag distribut costli comput nearli evenli among processor 31 assumpt notat extend enl penl assumpt notat extend simplic assum sharednoth system node one processor node memori local disk dataset distribut equal size local disk node without overlap commun done messag pass network architectur design node send messag receiv messag time simplic analysi later section make previou assumpt requir strict least requir internod commun possibl among node besid node arrang logic ring node two neighbour node logic arrang mean physic network architectur eg bu affect effect algorithm perform let n number block dataset np total number page dataset k dimension n number object dataset p number page contain block number object page number 8 hung cheung object block n let time comput distanc 2 object comp time internod commun 2 node transfer page data comm time access page local disk io let p number processor node size local memori use disk buffer simplifi algorithm analysi assum local memori buffer size node data local disk number data block local disk integ ie number page dataset np multipl product number processor number page contain block pp 32 algorithm node part dataset local disk number page local data np number object local data n node local memori size divid 3 array array contain block size p page first second array function similarli enl third array use temp buffer store data receiv neighbor node besid count object dneighbor object maintain penl modifi enl basic principl node time block read node local disk distanc calcul done block transfer node neighbor node distanc calcul done use block receiv node anoth neighbour node repeat block pass neighbor node read anoth block local disk repeat disk io oper replac rel fast internod commun huge number calcul distribut node greatli reduc execut time ie respons time algorithm penlnod id x 1 label block readi block either readi done state 2 fill first array block object 3 set blockread order forward 4 set counter b 0 set counter 0 5 repeat readi block compar first array specifi blockread order set counter c 0 object first array increas count number object first array close distanc count mark nonoutli c set b 1 go step f parallel mine outlier larg databas 9 b 6 0 fill second array next block object first array object j second array object j unmark distt increas count 1 otherwis increas count count j 1 count nonoutli revers order execut step g h send data first array neighbor node send data second array neighbor node receiv data neighbor node store temp buffer third array increment counter c 1 swap name second array third array counter continu iter step 5 otherwis go step 5e 6 second array mark done report unmark object first array outlier otherwis mark block first array done revers blockread order swap name first second array repeat step 4 time analysi penl given briefli later detail analysi given use bulk synchron parallel bsp model node oper similar enl except block transfer node comput done thu brief upper bound comput time node node n block local data local disk io time enl execut n block data disk io time node internod commun time node obviou upper bound comput time linear reciproc number processor internod commun time decreas increas number hung cheung processor disk io time quadrat reciproc number processor pleas note p chang size buffer total size local memori fix ie pp constant internod commun time node vari dataset size number processor comput time local disk io time node linear reciproc number processor although upper bound comput time shown actual calcul distribut quit evenli among node nearli linear reciproc number processor shown perform studi section 5 33 exampl follow give exampl execut penl dataset 16 block use four node node four local block 16 block evenli distribut four node four local block node x denot ax bx cx dx order fill array disk io internod commun compar node 0 follow 1 a0 a0 io 3 commun total 4 block read 12 commun 2 d0 d0 read requir nicat b0 io b1 b2 b3 3 commun total 2 block read 9 commun 3 b0 b0 read requir b1 nicat total 1 block read 6 commun 4 c0 c0 read requir c1 c2 c3 3 commun total 0 block read 3 commun node number disk io 1 block number dataset pass is4 175 internod commun 34 time tabl appendix show detail order block load node 0 block transfer node 0 block stay two array buffer node 0 run enl use singl node amount memori node penl total number disk io block total number dataset pass 121 75625 ratio disk io enl penl use 4 node 75625 432 improv signific howev give enl amount memori total sum memori node gain benefit disk io size block larger total number block much less 16 nevertheless still signific improv perform comput time major cost nearli evenli distribut node penl shown section 5 parallel mine outlier larg databas 11 34 optim follow optim penl outer iter step 5 5a 5i 1 approxim first half inner iter 5e 5i reduc redund block transmiss comput exampl section 33 inner iter comput block 0 3 0 3 c 3 skip upper bound cost comput outer iter reduc pnp p therefor upper bound total comput cost reduc therefor computationcostreductionratio ratio reduct upper bound comput cost optim penl pgamma1k2 n number block node exampl section 33 reduct 01 practic larg number local block reduct signific paper refer origin penl algorithm unless specifi simplic implement analysi parallel algorithm theoret analysi use bsp model studi perform real execut algorithm theoret analysi given bsp bulk synchron parallel model 3 use analyz penl algorithm hardwar softwar characterist model match penl platform requir work principl bsp comput consist set processormemori pair commun network deliv messag pointtopoint manner mechan effici barrier synchron processor bsp comput twolevel memori model ie processor physic local memori modul memori nonloc access uniformli effici way penl requir node local memori buffer access block buffer node done synchron commun block transfer done nodetonod manner bsp comput oper follow way comput consist sequenc parallel superstep superstep sequenc step follow barrier synchron point nonloc memori access take effect penl requir barrier synchron block transfer 12 hung cheung superstep processor carri set program thread follow perform number comput step set thread valu held local start superstep ii send receiv number messag correspond nonloc read write request superstep penl perform comput item one two block access disk load new block execut block transmiss simpl model bridg hardwar softwar bsp model provid portabl across divers platform predict effici seen model suitabl penl penl coars granular superstep consist lot distanc calcul follow messag pass 41 cost analysi defin follow variabl l barrier synchron cost ratio time cost local disk io access object ie time local disk io access page time comput distanc two object g ratio time internod commun transfer object ie time internod commun transfer page time comput distanc two object cost barrier ad penl algorithm shown algorithm penlnod id x 1 label block readi block either readi done state 2 fill first array block object page block np object page 3 set blockread order forward 4 set counter b 0 5 repeat readi block compar first array specifi blockread order set counter c 0 set counter 0 object first array increas count number object first array close distanc count mark nonoutli parallel mine outlier larg databas 13 c set b 1 go step f b 6 0 fill second array next block object first array object j second array object j unmark distt increas count 1 otherwis increas count count j 1 count nonoutli f set barrier revers order execut step g h send data first array neighbor node send data second array neighbor node receiv data neighbor node store temp buffer third array set barrier increment counter c 1 swap name second array third continu iter step 5 otherwis go step 6 second array mark done report unmark object first array outlier otherwis mark block first array done revers blockread order swap name first second array repeat step 4 therefor total cost algorithm deriv found appendix b first term comput second one disk io third one commun last one synchron pleas notic time comput upper bound therefor theoret analysi give reliabl valu actual execut time still act good refer comparison enl later block size page size object size constant found dataset size larg n ae pnp ie local block number larg ffl comput cost quadrat dataset size linear reciproc number processor ffl disk io cost quadrat dataset size quadrat reciproc number processor 14 hung cheung ffl commun cost quadrat dataset size linear reciproc number processor ffl synchron cost quadrat dataset size linear reciproc number processor pleas note p chang size buffer total size local memori fix ie pp constant cost still quadrat dataset size dataset size larg n ae pnp ie local block number larg besid ffl comput cost still linear reciproc number processor ffl disk io cost linear reciproc number processor ffl synchron cost linear number processor analysi tell us total memori fix still benefici increas number processor shown major cost comput linear reciproc number processor hand number processor kept unchang buffer size node ie block size p vari comput cost linear proport number page block p thu smaller block size fewer comput necessari besid local block number increas make computationcostreductionratio optim algorithm section 34 becom smaller howev recommend use small buffer p small n ae pnp p effect reduct comput cost small p small besid smaller block size also increas cost disk io commun synchron 42 comparis penl enl compar penl enl given amount memori enl correspond cost ii number page block enl enl buffer divid two array total amount memori 2p 1 penl local buffer divid three array total amount memori 3pp give amount memori penl enl better implement made suffici divid local buffer two array howev later section still choos three array order give advantag sequenti algorithm comparison still show parallel algorithm outperform parallel mine outlier larg databas 15 assum wors case ratio number calcul actual done enl total sum number calcul actual done node penl 2 let f fraction number calcul actual done enl fraction penl 2f enl comput cost penl comput cost cpenlcomp linear number processor thu alway better choic use penl even total buffer size fix perform studi 51 experiment setup implement experi base dataset 248object dataset consist trade index number hksar 1992 1999 march 5 object one four categori import domest export reexport total export four categori equal number object object six attribut index valu yearonchang percentag chang index valu index unit valu yearonchang percentag chang index unit valu index quantum yearonchang percentag chang index quantum sinc reallif dataset quit small want test algorithm larg diskresid dataset gener larg number object simul distribut orgin dataset test distanc defin number outlier restrict within percent object simul real situat program run ibm 9076 sp2 system instal univers hong kong system consist three frame frame consist 16 160 mhz ibm p2sc risc processor individu node local ram 128 mb 256 mb local disk storag 2 gb system file local scratch space node frame interconnect high perform switch three frame also link interfram high perform switch theroret peak perform processor 640 mflop test sequenti program parallel program run dedic mode use loadlevel batch job schedul section 52 nl enl run anoth system sp2 system time limit 10 hour run sun enterpris ultra 450 4 ultrasparcii cpu run 250mhz 1gb ram four 41gb hard disk sp2 order make comparison fair fix total amount memori node penl nl enl abl hold 75000 object number object chosen number block test reason hung cheung result number object block np p nl penl 2 4 8 processor 37500 12500 6250 3125 1563 respect number object 50000 100000 200000 400000 800000 impli number block 2 4 8 16 32 penl 2 3 6 11 22 nl implement three algorithm nl enl penl use c mpi messag pass interfac librari use penl messag pass among multipl processor 15 penl better implement made suffici divid local buffer two array rather three array howev still chose three array simplic order give advantag sequenti algorithm comparison still show parallel algorithm penl outperform note penl node part memori need act count object decreas memori act count decreas p number page block increas total cost howev addit cost small compar improv nl object databas usual contain ten even hundr attribut may integ float point even string size count small compar size object p decreas bit total number object huge undesir hold count memori count store local disk total size count small compar size dataset thu extra disk io time access count affect perform bit implement enl penl count resid disk load requir method good induc extra disk io experi decid defin object six dimens long integ data type order make effect read write count signific howev result show effect minor compar reduct comput cost besid need extra commun transfer count object node contain object disk outlier report soon possibl better way end count gather node outlier report combin count extra commun cost littl compar comput cost chose second method implement final point note comput architectur processor cach processor larger total cach capac thu hit ratio larger perform enhanc besid exist workstat cluster form low cost perform penl rather instal new advanc costli supercomput although experi conduct supercomput result show commuic cost minor thu commun network low cost suffici 52 nl vs enl section compar perform nl enl parallel mine outlier larg databas 17 object number 2000 8000 execut time comput time disk io time calcul number 974467 618697 23095637 17763925 enl execut time nl execut time 07459 08487 figur 1 tabl comparison nl enl object number 32000 128000 execut time comput time disk io time calcul number enl execut time nl execut time 08636 08743 figur 2 tabl comparison nl enl cont figur 3 see enl better nl although improv great moreov tabl figur 1 2 found major cost comput distanc greatli reduc penl show later besid see increas execut time approxim quadrat increas object ie execut time complex 2 indic unlik use nl enl deal larg number object howev penl help reduc time 53 sequenti vs parallel compar perform sequenti program nl parallel program penl figur 4 5 show penl variou number processor outperform nl whatev number object even number processor two perform improv 100 percent said total amount memori given penl nl clear penl alway better choic multiprocessor system cluster workstat avail result nl 400000 800000 object penl 2 processor 800000 object avail execut time exce time limit job sp2 system hung cheung0750852000 8000 32000 128000 object number figur 3 comparison execut time nl enl processor number number object 50000 100000 200000 400000 800000 figur 4 tabl comparison execut time nl penl seconds100100001nl 2 4 8 processor number execut time sec 50000 object 333100000 object 200000 object 222400000 object theta theta theta theta theta 800000 object 44 figur 5 execut time number processor parallel mine outlier larg databas 19 processor number execut cpu io commun synchron figur tabl comparison differ cost nl penl 100000 object second 54 variat processor number section see perform penl relat number processor figur 4 5 see nearli straight line drop steadili almost parallel indic scalabl stabl case execut time almost halv number processor doubl near theoret analysi predict ie execut time approxim linear reciproc number processor increas execut time approxim quadrat number object ie execut time complex 2 note execut time linear dimension thu still prefer databas high dimension 55 comparison comput disk io commun time synchron time section look clearli contribut execut time com putat disk io commun synchron time penl figur 6 show 99 percent execut cost come comput time sinc penl distribut comput oper among processor nearli evenli execut time reduc greatli improv consid focu reduc comput oper hand disk io commun synchron time much minor trend theoret analysi disk io time increas slowli number processor read write count block size smaller number block load transfer larger new block come count old block written count new block read sum number page access processor close matter mani processor use total number page access count increas number processor count read written time thu disk time increas bit commun time synchron time depend much system moment execut eg bandwidth condit commun network 20 hung cheung 6 discuss relat work nl algorithm straight forward method mine outlier databas enl propos reduc comput disk io cost furthermor algorithm penl propos parallel enl analysi show total buffer size system fix comput cost linear reciproc number processor verifi perform studi great improv caus nearli even distribut comput oper among processor perform studi indic 99 percent execut time come comput execut time also linear reciproc number processor result show penl effici compar nl enl improv focus reduc comput oper sinc cost like commun time minor lowcost cluster workstat commod processor interconnect lowcost commun network chosen platform run penl rather much expens supercomput cluster also much cheaper easier build maintain upgrad achiev similar perform nl singl high perform processor system breunig et al introduc definit new kind outlier densitybas outlier investig applic 4 heurist identifi meaning local outlier notion distancebas outlier find first step comput lof local outlier factor materi minptsubnearest neighborhood page 102103 4 modif made parallel algorithm perform step also expens step comput lof instead updat count object dneighborhood object node store temporari minptsubnearest neighborhood object final minptsubnearest neighborhood object obtain combin temporari minptsubnearest neighborhood object calcul node choos parallel nl algorithm instead use penl algorithm simplifi implement reduc disk storag space temporari minptsubnearest neighborhood case node store minptsubnearest neighborhood object block stay first array differ read order block increas number block io comput amost doubl similar search highdimension vector space use vafil method outperform method known 16 detect outlier base vafil approach differ approach nestedloop cellstructur take use vafil consider futur work r mine associ rule set item larg databas outlier statist data scientif comput bulk synchron parallel architetur lof identifi densitybas local outlier trade index number densitybas algorithm discov cluster larg spatial databas nois knowledg discoveri databas attributeori approach outlier parallel algorithm mine outlier larg databas digit money card technolog find aggreg proxim relationship common spatial data mine unifi notion outlier properti comput algorithm mine distancebas outlier larg dataset effici effect cluster method spatial data mine quantit analysi perform studi similaritysearch method hifhdimension space birch effici data cluster method larg databas tr mine associ rule set item larg databas find aggreg proxim relationship common spatial data mine quantit analysi perform studi similaritysearch method highdimension space algorithm mine distancebas outlier larg dataset knowledg discoveri databas effici effect cluster method spatial data mine unifi approach mine outlier digit money card technolog