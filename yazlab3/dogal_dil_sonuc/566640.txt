ray trace programm graphic hardwar recent breakthrough occur graphic hardwar fix function pipelin replac programm vertex fragment processor near futur graphic pipelin like evolv gener programm stream processor capabl simpli feedforward triangl renderingin paper evalu trend programm graphic pipelin explain ray trace map graphic hardwar use simul analyz perform ray cast implement next gener programm graphic hardwar addit compar perform differ nonbranch programm hardwar use multipass implement architectur support branch also show approach applic ray trace algorithm whit ray trace path trace hybrid render algorithm final demonstr ray trace graphic hardwar could prove faster cpu base implement well competit tradit hardwar acceler feedforward triangl render b introduct realtim ray trace goal computergraph commun mani year recent vlsi technolog reach point raw comput capabl singl chip suffici realtim ray trace realtim ray trace demonstr small scene singl generalpurpos cpu simd float point extens wald et al 2001b larger scene share memori multiprocessor parker et al 1998 parker et al 1999 cluster wald et al 2001b wald et al 2001a variou effort way develop chip special ray trace ray trace chip acceler offlin render commerci avail hall 2001 given realtim ray trace possibl near futur worthwhil studi implement differ architectur goal provid maximum perform lowest cost current nvidia corpor tpurcel ianbuck billmark hanrahangraphicsstanfordedu paper describ altern approach realtim ray trace potenti perform cpubas algorithm without requir fundament new hardwar use commod programm graphic hardwar implement ray trace graphic hardwar recent evolv fixedfunct graphic pipelin optim render texturemap triangl graphic pipelin programm vertex fragment stage nearterm next year two graphic processor gpu fragment program stage like gener includ float point comput complet orthogon instruct set capabl demand programm use current hardwar show capabl also suffici us write complet ray tracer hardwar programm stage becom gener hardwar consid generalpurpos stream processor stream process model support varieti highlyparalleliz algo rithm includ ray trace recent year perform graphic hardwar increas rapidli cpu cpu design optim high perform sequenti code becom increasingli difficult use addit transistor improv perform code contrast programm graphic hardwar optim highlyparallel vertex fragment shade code lindholm et al 2001 result gpu use addit transistor much effect cpu thu sustain greater rate perform improv semiconductor fabric technolog advanc converg three separ trend suffici raw perform singlechip realtim ray trace increas gpu programm faster perform improv gpu cpu make gpu attract platform realtim ray trace gpubas ray trace also allow hybrid render algorithm eg algorithm start zbuffer render pass visibl use ray trace secondari shadow ray blur line tradit triangl render ray trace allow natur evolut toward increas realism paper show effici implement ray trace gpu paper contain three main contribut show ray trace map stream process model parallel comput part map ping describ effici algorithm map innermost raytriangl intersect loop multipl render pass show basic ray caster extend includ shadow reflect path trace analyz stream gpubas ray caster perform show competit current cpubas ray cast also show initi result system includ secondari ray believ near futur gpubas ray trace much faster cpubas ray trace guid futur gpu implement analyz comput memori bandwidth requir ray cast gpu studi two basic architectur one architectur without branch requir multipl pass anoth branch requir singl pass show singl pass version requir significantli less bandwidth computelimit also analyz perform textur cach use ray cast show effect reduc bandwidth programm graphic hardwar 21 current programm graphic pipelin applic vertex program raster fragment program display figur 1 programm graphic pipelin diagram modern graphic pipelin shown figur 1 today graphic chip nvidia geforce3 nvidia 2001 ati radeon 8500 ati 2001 replac fixedfunct vertex fragment includ textur stage programm stage programm vertex fragment engin execut userdefin program allow fine control shade textur calcul nvidia vertex program consist 128 4way simd float point instruct lind holm et al 2001 vertex program run incom vertex comput result pass raster stage fragment stage also programm either nvidia regist combin spitzer 2001 directx 8 pixel shader mi crosoft 2001 pixel shader like vertex program provid 4way simd instruct set augment instruct textur unlik vertex program oper fixedpoint valu pa per primarili interest programm fragment pipelin design oper system fill rate approxi mate 1 billion fragment per second programm shade recent innov current hardwar mani limit vertex fragment program simpl incomplet instruct set fragment program instruct set much simpler vertex instruct set fragment program data type mostli fixedpoint input textur output framebuff color typic 8bit per color compon intermedi valu regist slightli precis mani resourc limit program limit number instruct small number regist stage limit number input output eg number output vertex stage constrain number vertex interpol number activ textur number depend textur limit current hardwar permit certain instruct comput textur address certain point within program exampl directx 8 ps 14 pixel shader two stage first textur address stage consist four textur fetch instruct follow eight color blend instruct color comput stage consist addit textur fetch follow color combin arithmet program model permit singl level depend textur singl color valu may written framebuff pass program loop condit branch instruct 22 propos nearterm programm graphic pipelin limit current hardwar make difficult implement ray trace fragment program fortun due interest programm shade mainstream game applic programm pipelin rapidli evolv mani hardwar softwar vendor circul propos futur hardwar fact mani current limit mere result fact repres first gener programm hardwar paper show implement ray tracer extend hardwar model think approxim hardwar avail next year two model base loos propos microsoft directx 90 marshal 2001 3dlab opengl 20 3dlab 2001 target baselin architectur follow featur programm fragment stage float point instruct regist also assum float point textur framebuff format enhanc fragment program assembl instruct includ instruct avail vertex level furthermor allow longer program long enough basic ray trace compon may download singl program longest program order 50 instruct textur lookup allow anywher within fragment pro gram limit number textur fetch level textur depend within program multipl output allow 1 2 float point rgba 4 vector written framebuff fragment pro gram also assum fragment program render directli textur stencil buffer consid enhanc natur evolut current graphic hardwar alreadi mention featur activ consider variou vendor heart effici ray trace implement abil travers acceler structur test intersect ray list triangl abil requir loop construct note architectur includ datadepend condit branch instruct set despit limit program loop condit map baselin architectur use multipass render techniqu present peerci et al 2000 implement condit use techniqu condit predic first evalu use sequenc render pass stencil bit set true fals depend result bodi condit evalu use addit render pass valu written framebuff correspond fragment stencil bit true although algorithm develop fixedfunct graphic pipelin extend use programm pipelin assum addit two hardwar featur make peerci et al algorithm effici direct set stencil bit earli fragment kill similar z occlus cull kirk 2001 standard opengl pipelin stencil bit may set test alpha valu alpha valu comput fragment program written framebuff set stencil bit comput alpha valu requir addit pass sinc fragment program baselin architectur modifi stencil valu directli elimin extra pass anoth import render optim earli fragment kill fragment kill depth stencil test execut fragment program stage fragment program execut fragment pass stencil test stencil bit fals instruct execut textur framebuff bandwidth use except read 8bit stencil valu use combin two techniqu multipass render use larg fragment program control stencil buffer quit effici see ray trace involv signific loop although render pass effici extra pass still cost pass consum extra bandwidth read write intermedi valu textur pass also requir bandwidth read stencil valu thu fewer resourc would use inner loop voxel triangl coalesc singl pass obviou way would add branch fragment process hardwar howev ad support branch increas complex gpu hardwar nonbranch gpu may use singl instruct stream feed sever fragment pipelin simultan simd comput gpu support branch requir separ instruct stream process unit mimd comput therefor graphic architect would like avoid branch possibl concret exampl trade evalu effici ray cast two architec ture one one without branch multipass architectur support arbitrari textur read floatingpoint textur framebuff format gener float point instruct two float point 4vector output branch implement via multipass render branch architectur multipass architectur enhanc includ support condit branch instruct loop control flow 23 stream graphic processor abstract graphic processor evolv includ complet instruct set larger data type appear like generalpurpos processor howev challeng introduc programm without compromis perform otherwis gpu would becom like cpu lose costperform advantag order guid map new applic graphic architectur propos view nextgener graphic hardwar stream processor stream process new idea media processor transform stream digit inform mpeg video decod imagin processor exampl generalpurpos stream processor khailani et al 2000 stream comput differ tradit comput system read data requir comput sequenti stream element element stream record data requir similar comput system execut program kernel element input stream place result output stream sens programm graphic processor execut vertex program stream vertic fragment program stream fragment sinc part ignor vertex program raster treat graphic chip basic stream fragment processor stream model comput lead effici implement three reason first sinc stream element comput independ design add addit pipelin process element stream parallel second kernel achiev high arithmet intens perform lot comput per small fixeds record result comput memori bandwidth ratio high third stream hardwar hide memori latenc textur fetch use prefetch torborg kajiya 1996 anderson et al 1997 igehi et al 1998 hardwar fetch textur frag ment fragment regist place fifo fragment processor start process anoth fragment textur fetch processor return fragment method hide latenc similar multithread alverson et al 1990 work abund parallel stream sum mari stream model allow graphic hardwar exploit par allel util bandwidth effici hide memori la tenci result graphic hardwar make effici use vlsi resourc challeng map ray trace onto stream model comput done break ray tracer kernel kernel chain togeth stream data origin data store textur framebuff 3 stream ray trace section show reformul ray trace stream comput flow diagram stream ray tracer found figur 2 gener eye ray travers acceler structur intersect triangl grid triangl list offset camera triangl triangl list shade hit gener shade ray materi normal figur 2 stream ray tracer paper assum scene geometri repres triangl store acceler data structur render begin typic scenario applic would specifi scene geometri use display list graphic librari would place display list geometri acceler data structur consid cost build data structur sinc may expens oper assumpt impli algorithm describ paper may effici dynam scene second design decis use uniform grid acceler ray trace mani possibl acceler data structur choos bound volum hierarchi bsp tree k tree octre uniform grid adapt grid hierarch grid etc chose uniform grid two reason first mani experi perform use differ acceler data structur differ scene excel recent studi see havran et al 2000 studi singl acceler data structur appear effici appear within factor two second uniform grid particularli simpl hardwar implement access grid data structur requir constant time hierarch data structur contrast requir variabl time per access involv pointer chase code grid travers also simpl highli optim hardwar system grid repres 3d textur map memori organ current support graphic hardwar discuss pro con grid section 5 split stream ray tracer four kernel eye ray gener grid travers raytriangl intersect shad ing eye ray gener kernel produc stream view ray view ray singl ray correspond pixel imag travers kernel read stream ray produc eye ray gener travers kernel step ray grid ray encount voxel contain triangl ray voxel address output pass intersect kernel intersect kernel respons test ray intersect triangl contain voxel intersector two type output raytriangl intersect hit occur voxel ray triangl hit output shade hit occur ray pass back travers kernel search voxel contain triangl continu shade kernel comput color ray termin hit color written accumul imag addit shade kernel may gener shadow secondari ray case new ray pass back travers stage implement ray trace kernel fragment program execut program render screensiz rectangl constant input place within kernel code stream input fetch screenalign textur result kernel written back textur stencil buffer control fragment screensiz rectangl screenalign textur activ 8bit stencil valu associ ray contain ray state ray state travers intersect shad ing done specifi correct stencil test render pass allow kernel run ray particular state follow section detail implement ray trace kernel memori layout scene describ sever variat includ ray cast whit ray trace whit 1980 path trace shadow cast 31 ray trace kernel 311 eye ray gener eye ray gener simplest kernel ray tracer given camera paramet includ viewpoint view direct comput eye ray screen pixel fragment program invok pixel screen gener eye ray eye ray gener also test ray scene bound box ray intersect scene bound box process fur ther miss termin 312 travers travers stage search voxel contain triangl first part travers stage set travers calcul second part step along ray enumer voxel pierc ray travers equival 3d line draw perray setup cost pervoxel raster cost use 3ddda algorithm fujimoto et al 1986 travers step kernel queri grid data structur store 3d textur grid contain null pointer voxel empti pointer null voxel contain triangl case rayvoxel pair output ray mark test intersect triangl voxel implement travers loop multipass architectur requir multipl pass per ray setup done two pass step voxel requir addit pass end pass fragment program must store step paramet use within loop textur must read next pass discuss multipass implement discuss intersect stage triangl textur vertex triangl list textur textur grid z x z x z x z x z x z x z x z x z x v2 z x z x z x z x z x z x figur 4 grid triangl data structur store textur memori grid cell contain pointer list triangl pointer null triangl store voxel grid store 3d textur triangl list store anoth tex ture voxel contain triangl point begin triangl list triangl list textur triangl list consist set pointer vertex data end triangl list indic null pointer final vertex posit store textur 313 intersector triangl intersect stage take stream rayvoxel pair output raytriangl hit perform raytriangl intersect test triangl within voxel hit occur raytriangl pair pass shade stage code comput singl raytriangl intersect shown figur 5 code similar use carr et al 2002 directx 8 ps 14 raytriangl intersector discuss system section 5 triangl overlap multipl grid cell possibl intersect point lie outsid current voxel intersect kernel check case treat miss note reject intersect way may caus ray test triangl multipl time differ voxel possibl use mailbox algorithm prevent extra intersect calcul amanatid woo 1987 mailbox difficult implement multipl ray trace parallel layout grid triangl textur memori shown figur 4 mention voxel contain offset trianglelist textur trianglelist textur contain delimit list offset trianglevertex textur note triangl list textur trianglevertex textur 1d textur fact textur use randomaccess readonli memori repres integ offset 1compon float point textur vertex posit three float point rgb textur thu theoret four billion triangl could address textur memori 32bit integ address howev much less textur memori actual avail current graphic card limit size 1d textur overcom use 2d textur gener find intersect shade hit shadow ray gener shade hit find nearest intersect eye ray gener shade hit find nearest intersect eye ray gener shade hit find nearest intersect eye raysshadow caster ray caster whit ray tracer path tracer b c figur 3 data flow diagram ray trace algorithm implement algorithm depict shadow cast b ray cast c whit ray trace path trace ray trace raysurfac intersect gener l 2 ray l number light scene correspond number shadow ray test two reflect refract ray path trace randomli choos one ray bounc follow feedback path one ray wide list po float4 h float list po trilist float float float return float4 u v id figur 5 code raytriangl intersect proper address translat well segment data across multipl textur travers stage inner loop triangl voxel involv multipl pass ray requir singl pass per raytriangl intersect 314 shader shade kernel evalu color contribut given ray hit point shade calcul exactli like standard graphic pipelin shade data store memori much like triangl data set three rgb textur 32bit per channel contain vertex normal vertex color triangl hit inform pass shader includ triangl number access shade inform simpl depend textur lookup particular triangl specifi choos differ shade ray implement sever flavor ray trace use stream algorithm look ray cast whittedstyl ray trace path trace shadow cast figur 3 show simplifi flow diagram method discuss along exampl imag produc system shade kernel option gener shadow reflect fraction randomli gener ray secondari ray place textur locat futur render pass ray also assign weight final termin contribut final imag may simpli ad imag kajiya 1986 techniqu assign weight ray elimin recurs simplifi control flow ray caster ray caster gener imag ident gener standard graphic pipelin pixel screen eye ray gener ray fire scene return color nearest triangl hit secondari ray gener includ shadow ray previou effort implement interact ray trace focus type comput serv basic implement whit ray tracer classic whittedstyl ray tracer whit 1980 gener eye ray send scene upon find hit reflect model surfac evalu pair reflect refract ray set shadow ray one per light sourc gener sent scene path tracer path trace ray randomli scatter surfac hit light sourc path tracer emul arnold render fajardo 2001 one path gener per sampl path contain 2 bounc shadow caster simul hybrid system use standard graphic pipelin perform hidden surfac calcul first pass use ray trace algorithm evalu shadow shadow cast use replac shadow map shadow volum shadow volum extrem expens comput shadow map tend difficult set proper resolut shadow caster view defer shade pass molnar et al 1992 shadow caster pass gener shadow ray light sourc add light contribut final imag blocker found multipass branch kernel instr memori word stencil instr memori word count r w rs ws count r w gener eye ray 28 0 5 travers intersect shade shadow reflect 26 11 9 9 path tabl 1 ray trace kernel summari show number instruct requir implement kernel along number 32bit word memori must read written render pass r w number memori word read randomaccess textur two set statist shown one multipass architectur anoth branch architectur multipass architectur also show number 8bit stencil read rs write ws kernel stencil read overhead charg ray whether kernel execut 32 implement evalu comput bandwidth requir stream ray tracer implement kernel assembl languag fragment program nvidia vertex program instruct set use fragment program addit instruct describ previous assembl languag implement provid estim number instruct requir kernel invoc also calcul bandwidth requir kernel break bandwidth stream input bandwidth stream output bandwidth memori random access read bandwidth tabl 1 summar comput bandwidth requir kernel ray tracer multipass branch architectur travers intersect kernel involv loop count setup loop bodi shown separ branch architectur allow us combin individu kernel togeth result branch kernel slightli smaller sinc initi termin instruct remov branch architectur permit kernel run togeth within singl render pass use tabl 1 comput total comput bandwidth cost scene r total number ray trace c r cost gener ray c v cost walk ray voxel c cost perform raytriangl intersect c cost shade p total number render pass c stencil cost read stencil buffer total cost associ stage determin number time kernel invok number depend scene statist v averag number voxel pierc ray averag number triangl intersect ray averag number shade calcul per ray branch architectur stencil buffer check c stencil zero multipass architectur must pay stencil read cost ray render pass cost ray tracer variou scene present result section final present optim minim total number pass motiv part delani implement ray tracer connect machin delani 1988 travers intersect kernel involv loop variou strategi nest loop simplest algorithm would step voxel ray encount voxel contain triangl intersect ray triangl ever strategi would ineffici sinc intersect ray encount voxel triangl simd machin like connect machin result low processor util graphic hardwar yield excess number pass result larg number stencil read oper domin perform follow effici algorithm gener eye ray anyactiveray oracleray traverseray els eye ray gener ray tracer enter loop test whether ray activ activ ray requir either travers intersect inact ray either hit triangl travers entir grid pass oracl call oracl choos whether run travers intersect pass variou oracl possibl simpl algorithm run intersect pass ray requir intersect test better oracl first propos delani choos pass perform work done calcul percentag ray requir intersect vs travers experi found perform intersect 20 ray requir intersect test produc minim number pass within factor two three optim simd algorithm perform singl comput per render pass implement oracl assum graphic hardwar maintain small set counter stencil buffer contain state ray total eight counter one per stencil bit would suffici need sinc four state altern could use opengl histogram oper oracl oper implement high perform stencil buffer 41 methodolog implement function simul stream ray tracer multipass branch architectur simul high level simul architectur written c program languag simul comput imag gather scene statist exampl statist includ averag number travers step taken per ray averag number hall outsid soda hall insid forest top forest insid bunni ray cast figur fundament scene statist test scene statist shown match cost model formula present section 32 recal v averag number voxel pierc ray averag number triangl intersect ray averag number shade calcul per ray soda hall 15m triangl forest 10m triangl stanford bunni 70k triangl scene render 1024x1024 pixel raytriangl intersect test perform per ray multipass architectur simul also track number type render pass perform well stencil buffer activ statist allow us comput cost render scene use cost model describ section 3 multipass branch architectur simul gener trace file memori refer stream process textur cach simul cach simul use 64kb directmap textur cach 48byte line size line size hold four float point rgb texel three float point rgba texel wast space execut order fragment program effect cach behavior execut kernel though singl pixel wide graphic pipelin like gpu implement includ multipl parallel fragment pipelin execut concurr thu access interleav architectur specifi level detail therefor abl take effect account cach simul analyz perform ray tracer five viewpoint three differ scene shown figur 6 soda hall rel complex model use evalu realtim ray trace system wald et al 2001b wall made larg polygon furnish made small polygon scene high depth complex forest scene includ tree million tini triangl scene moder depth complex difficult perform occlus cull analyz cach behavior shadow reflect ray use scene bunni chosen demonstr extens ray tracer support shadow reflect path trace figur 7 show comput bandwidth requir test scene comput bandwidth util broken kernel graph clearli show comput bandwidth architectur domin grid travers triangl intersect choos optim grid resolut scene difficult finer grid yield fewer raytriangl intersect test lead travers step coarser grid reduc number travers step increas number raytriangl intersect test attempt keep voxel near cubic shape specifi grid resolut minim grid dimens accept along dimens scene bound box bunni minim grid dimens 64 yield final resolut 98 64 163 larger soda hall forest model minim dimens 128 yield grid resolut 250 198 128 581 128 581 respect resolut allow algorithm spend equal amount time travers intersect kernel outsid insid hall top insid forest bunni ray cast26 ginstruct intersector travers others515gbyt multipass outsid insid hall top insid forest bunni ray cast2ginstruct intersector travers others515 gbyte branch figur 7 comput bandwidth usag scene column show contribut kernel left bar plot comput right bandwidth horizont line repres persecond bandwidth comput perform hypothet architectur scene render 1024 1024 pixel 42 architectur comparison compar multipass branch architectur first investig implement ray caster multipass architectur tabl 2 show total number render pass distribut pass amongst variou kernel total number pass vari 10003000 although number pass seem high total number need render scene convent graphic pipelin mani fewer per object use mani object drawn system pass draw singl rectangl speed geometri process part pipelin factor also evalu effici multipass algorithm recal ray may travers intersect shade done effici pass depend percentag ray process pass scene effici 610 test scene except outsid view soda hall pass breakdown per ray maximum simd total travers intersect travers intersect effici hall outsid 2443 692 1747 4 384 1123 0009 hall insid 1198 70 1124 4 forest top 1999 311 1684 4 137 1435 0062 forest insid 2835 1363 1468 4 898 990 0068 bunni ray cast 1085 610 471 4 221 328 0105 tabl 2 breakdown pass multipass system intersect travers make bulk pass system rest pass come ray gener travers setup shade also show maximum number travers step intersect test per ray final simd effici measur averag fraction ray use work given pass outsid insid hall top insid forest bunni ray cast515gbyt stencil state variabl data structur figur 8 bandwidth consumpt data type left bar multipass right bar branch overhead read 8bit stencil valu shown top state variabl data written read textur pass data structur bandwidth come readonli data triangl triangl list grid cell shade data scene render 1024 1024 pixel viewpoint contain sever ray miss scene bound box entir expect result effici much lower sinc ray never use work rest compu tation although 10 effici may seem low fragment processor util much higher use earli fragment kill avoid consum comput resourc nonstencil bandwidth fragment final tabl 2 show maximum number travers step intersect test perform per ray sinc total number pass depend worst case ray number provid lower bound number pass need multipass algorithm interleav travers intersect pass come within factor two three optim number render pass naiv algorithm perform intersect soon ray hit full voxel requir least factor five time pass optim scene readi compar comput bandwidth requir test scene two architectur figur 8 show bandwidth measur shown figur 7 broken data type instead kernel graph show ex pect bandwidth requir branch architectur read voxel triangl data structur memori multipass architectur convers use bandwidth write read intermedi valu textur memori pass similarli save restor intermedi requir extra instruct addit signific bandwidth devot read stencil buffer extra comput bandwidth consumpt fundament limit multipass algorithm one way reduc number render pass bandwidth consum intermedi valu multipass architectur unrol inner loop present data outsid insid hall top insid forest bunni ray cast shadow reflect forest0515norm bandwidth stencil state variabl voxel data triangl data shade data figur 9 ratio bandwidth textur cach bandwidth without textur cach left bar multipass right bar branch within bar bandwidth consum textur cach broken data type scene render pixel singl travers step singl intersect test perform per ray render pass instead unrol kernel perform four travers step two intersect test test scene reduc total bandwidth usag 50 assum suppress triangl voxel memori refer ray finish middl pass total bandwidth reduct reach 60 time total instruct count requir render scene increas less 10 aggress loop unrol bandwidth save continu total instruct count increas vari factor two scene result indic loop unrol make overhead inher multipass architectur unrol achiev comput bandwidth ratio obtain branch architectur final compar cach behavior two implemen tation figur 9 show bandwidth requir textur cach use bandwidth consumpt normal divid noncach bandwidth report earlier inspect graph see multipass system benefit much textur cach bandwidth use stream data particular either stencil buffer intermedi result sinc data uniqu kernel vocat reus contrast branch architectur util textur cach effect sinc bandwidth devot read share data structur reus studi cach behavior triangl data see 9699 hit rate achiev multipass branch system high hit rate suggest triangl data cach well fairli small work set size summari implement ray caster multipass architectur achiev good balanc comput bandwidth ratio instruct count bandwidth match capabl modern gpu exampl rel extens instruct bandwidth shadow caster 085 115 whit ray tracer 262 300 path tracer 324 406 tabl 3 number instruct amount bandwidth consum extend algorithm render bunni scene use branch architectur normal ray cast cost nvidia geforce3 abl execut approxim 2g instruc tionss fragment processor roughli 8gb memori bandwidth expand travers intersect kernel perform multipl travers step intersect test per pass reduc bandwidth requir scene cost increas comput requir amount loop unrol chang match comput bandwidth capabl underli hardwar comparison branch architectur consum fewer instruct significantli less bandwidth result branch architectur sever computelimit base today gpu bandwidth comput rate howev branch architectur becom attract futur comput bandwidth ratio graphic chip increas introduct parallel fragment pipelin 43 extend algorithm effici ray caster place implement extens shadow cast full whit ray trace path trace quit simpl method util raytriangl intersect loop analyz ray caster implement differ shade kernel gener new ray fed back system figur 3 show imag bunni produc system ray cast extens simul total cost render scene depend number ray trace cach perform tabl 3 show number instruct bandwidth requir produc imag bunni rel ray cast cost use branch architectur path trace bunni render 256 256 pixel 64 sampl 2 bounc per pixel other render 1024 1024 pixel ray cast bunni find valid hit 82 pixel henc 82 primari ray gener secondari ray ray equal one would expect shadow caster consum 82 instruct bandwidth ray caster likewis path tracer would consum 32 time ray caster note instruct usag close expect valu bandwidth consum addit secondari ray cach well eye ray due gener incoher natur last two column figur 9 illustr cach effect secondari ray measur separ primari ray test render insid forest scene two differ style shadow render three light sourc hit produc three shadow ray reflect appli two bounc reflect singl light sourc shade model primit scene multipass render system textur cach unabl reduc total bandwidth consum system stream data destroy local present triangl voxel data branch architectur result demonstr scene secondari ray benefit cach system achiev bandwidth reduct shadow comput howev cach reflect forest reduc requir band width current investig way improv perform system secondari ray section discuss limit current system futur work 51 acceler data structur major limit system reli preprocess step build grid mani applic contain dynam ge ometri support applic need fast increment updat grid build acceler data structur dynam scene activ area research reinhard et al 2000 interest possibl would use graphic hardwar build acceler data structur graphic hardwar could scan convert geometri grid howev architectur studi paper effici oper like raster within fragment processor would need abil write arbitrari memori locat classic scatter oper would move hardwar even closer gener stream processor research assum uniform grid uniform grid ever may fail scene contain geometri empti space mani level detail sinc view textur memori randomaccess memori hierarch grid could ad system current graphic board contain rel small amount memori 2001 typic board contain 64mb scene look requir 200mb 300mb textur memori store scene interest direct futur work would studi hierarch cach geometri commonli done textur trend toward unifi system graphic memori may ultim elimin problem 52 cpu vs gpu wald et al develop optim ray tracer pc simd float point extens wald et al 2001b 800 mhz pentium iii report raytriangl intersect rate 20m intersectionss carr et al 2002 achiev 114m raytriangl inter sectionss ati radeon 8500 use limit fix point preci sion assum propos hardwar ran speed geforce3 2g instructionss could comput 56m raytriangl intersectionss branch architectur comput limit increas instruct issu rate factor four 8g structionss would still use bandwidth avail geforce3 8gb would allow us comput 222m ray triangl intersect per second believ inher parallel natur fragment program number gpu instruct execut per second increas much faster number cpu simd instruct basic feasibl ray trace gpu demonstr interest consid modif gpu support ray trace effici mani possibl immedi suggest sinc ray stream system would effici store stream buffer textur map would elimin need stencil buffer control condit execut stream buffer quit similar fbuffer use multipass render mark proudfoot 2001 current implement grid travers code map well vertex program instruct set thu quit ineffici sinc grid travers similar raster might possibl modifi raster walk grid final vertex program instruct set could optim raytriangl intersect could perform fewer instruct carr et al 2002 independ develop method use gpu acceler ray trace system gpu use acceler raytriangl intersect test system gpu memori use hold state mani activ ray system triangl turn fed gpu test intersect activ ray system differ store scene triangl 3d grid gpu store acceler structur cpu also run entir ray tracer gpu system much effici sinc elimin gpucpu commun bottleneck 53 tile render multipass architectur major memori bandwidth consum save restor temporari variabl sinc stream temporari use bandwidth save due cach unfortun stream variabl access textur displac cacheabl data structur size cach use larg enough store work set includ temporari variabl data structur best way deal problem separ stream variabl cacheabl variabl anoth solut problem break imag small tile tile render complet proceed next tile tile reduc work set size tile size chosen work set fit cach stream variabl displac cacheabl data structur perform preliminari experi along line result encourag 6 conclus shown view programm graphic processor gener parallel comput devic help us leverag graphic processor perform curv appli gener parallel comput specif ray trace shown ray cast done effici graphic hardwar hope encourag graphic hardwar evolv toward gener programm stream architectur mani believ fundament differ architectur would requir realtim ray trace hardwar work demonstr gradual converg ray trace feedforward hardwar pipelin possibl acknowledg would like thank everyon stanford graphic lab contribut idea work thank matt papakipo nvidia thought next gener graphic hardwar kurt akeley review comment kati tillman stay late help edit would like thank hanspet pfister merl addit support work sponsor darpa contract dabt6395c0085 mda90498ca933 ati nvidia soni sun r tr artscceler raytrac system render equat ray trace connect machin pixelflow highspe render use imag composit talisman tera comput system accommod memori latenc lowcost raster prefetch textur cach architectur interact ray trace isosurfac render interact ray trace interact multipass programm shade improv illumin model shade display userprogramm vertex engin fbuffer dynam acceler structur interact ray trace interact distribut ray trace highli complex model ctr edgar velzquezarmendriz eugen lee kavita bala bruce walter implement render cach edgeandpoint imag graphic hardwar proceed 2006 confer graphic interfac june 0709 2006 quebec canada manfr weiler martin krau marku merz thoma ertl hardwarebas ray cast tetrahedr mesh proceed 14th ieee visual 2003 vis03 p44 octob 2224 h du sanchezelez n tabrizi n bagherzadeh l anido fernandez interact ray trace reconfigur simd morphosi proceed confer design autom test europ design forum p20144 march 0307 h du sanchezelez n tabrizi n bagherzadeh l anido fernandez interact ray trace reconfigur simd morphosi proceed confer asia south pacif design autom januari 2124 2003 kitakyushu japan anton l fuhrmann robert f tobler stefan maierhof realtim glossi reflect planar surfac proceed 3rd intern confer comput graphic virtual realiti visualis interact africa novemb 0305 2004 stellenbosch south africa christian hen peter stephenson acceler ray trace height field proceed 2nd intern confer comput graphic interact techniqu australasia south east asia june 1518 2004 singapor pradeep sen mike cammarano pat hanrahan shadow silhouett map acm transact graphic tog v22 n3 juli chihchang chen damon shingmin liu use hardwar zbuffer raster acceler ray trace proceed 2007 acm symposium appli comput march 1115 2007 seoul korea nathan carr jare hoberock keenan crane john c hart fast gpu ray trace dynam mesh use geometri imag proceed 2006 confer graphic interfac june 0709 2006 quebec canada daniel reiter horn jeremi sugerman mike houston pat hanrahan interact kd tree gpu raytrac proceed 2007 symposium interact 3d graphic game april 30may 02 2007 seattl washington victor moya carlo gonzalez jordi roca agustin fernandez roger espasa shader perform analysi modern gpu architectur proceed 38th annual ieeeacm intern symposium microarchitectur p355364 novemb 1216 2005 barcelona spain j stewart e p bennett l mcmillan pixelview viewindepend graphic render architectur proceed acm siggrapheurograph confer graphic hardwar august 2930 2004 grenobl franc jingyi yu jason yang leonard mcmillan realtim reflect map parallax proceed 2005 symposium interact 3d graphic game april 0306 2005 washington district columbia kaoru sugita takeshi naemura hiroshi harashima perform evalu programm graphic hardwar imag filter stereo match proceed acm symposium virtual realiti softwar technolog octob 0103 2003 osaka japan tim foley mike houston pat hanrahan effici partit fragment shader multipleoutput hardwar proceed acm siggrapheurograph confer graphic hardwar august 2930 2004 grenobl franc christoph cassagnabr franoi roussel christoph renaud path trace use ar350 processor proceed 2nd intern confer comput graphic interact techniqu australasia south east asia june 1518 2004 singapor karl e hillesland sergey molinov radek grzeszczuk nonlinear optim framework imagebas model programm graphic hardwar acm transact graphic tog v22 n3 juli karl e hillesland sergey molinov radek grzeszczuk nonlinear optim framework imagebas model programm graphic hardwar acm siggraph 2005 cours juli 31august f losasso h hopp schaefer j warren smooth geometri imag proceed eurographicsacm siggraph symposium geometri process june 2325 2003 aachen germani peiji huang wencheng wang gang yang enhua wu travers field ray trace dynam scene proceed acm symposium virtual realiti softwar technolog novemb 0103 2006 limassol cypru xianfeng gu song zhang peisen huang liangjun zhang shingtung yau ralph martin holoimag proceed 2006 acm symposium solid physic model june 0608 2006 cardiff wale unit kingdom kolb l latta c rezksalama hardwarebas simul collis detect larg particl system proceed acm siggrapheurograph confer graphic hardwar august 2930 2004 grenobl franc acceler structur gpu raytrac proceed acm siggrapheurograph confer graphic hardwar juli 3031 2005 lo angel california chri wyman scott davi interact imagespac techniqu approxim caustic proceed 2006 symposium interact 3d graphic game march 1417 2006 redwood citi california sudipto guha shankar krishnan kamesh munagala suresh venkatasubramanian applic twosid depth test csg render proceed symposium interact 3d graphic april 2730 2003 monterey california nathan cournia chessboard domin programm graphic hardwar proceed 44th annual southeast region confer march 1012 2006 melbourn florida nathan carr jess hall john c hart gpu algorithm radios subsurfac scatter proceed acm siggrapheurograph confer graphic hardwar juli 2627 2003 san diego california ingo wald carsten benthin philipp slusallek distribut interact ray trace dynam scene proceed ieee symposium parallel largedata visual graphic p11 octob 2021 lionel baboud xavier dcoret render geometri relief textur proceed 2006 confer graphic interfac june 0709 2006 quebec canada nolan goodnight cliff woolley gregori lewin david luebk greg humphrey multigrid solver boundari valu problem use programm graphic hardwar proceed acm siggrapheurograph confer graphic hardwar juli 2627 2003 san diego california anthoni sherbondi mike houston sandi napel fast volum segment simultan visual use programm graphic hardwar proceed 14th ieee visual 2003 vis03 p23 octob 2224 yuan zhou michael garland robert haber pixelexact render spacetim finit element solut proceed confer visual 04 p425432 octob 1015 2004 abhinav dayal cliff woolley benjamin watson david luebk adapt frameless render acm siggraph 2005 cours juli 31august nolan goodnight cliff woolley gregori lewin david luebk greg humphrey multigrid solver boundari valu problem use programm graphic hardwar acm siggraph 2005 cours juli 31august timothi j purcel craig donner mike cammarano henrik wann jensen pat hanrahan photon map programm graphic hardwar proceed acm siggrapheurograph confer graphic hardwar juli 2627 2003 san diego california timothi j purcel craig donner mike cammarano henrik wann jensen pat hanrahan photon map programm graphic hardwar acm siggraph 2005 cours juli 31august ingo wald openrtapi acm siggraph 2005 cours juli 31august shihwei liao zhaohui du gansha wu gueiyuan lueh data comput transform brook stream applic multiprocessor proceed intern symposium code gener optim p196207 march 2629 2006 nathan carr jess hall john c hart ray engin proceed acm siggrapheurograph confer graphic hardwar septemb 0102 2002 saarbrucken germani solomon boulo dave edward j dylan lacewel joe kniss jan kautz peter shirley ingo wald packetbas whit distribut ray trace proceed graphic interfac 2007 may 2830 2007 montreal canada v singh silver n cornea realtim volum manipul proceed 2003 eurographicsiee tvcg workshop volum graphic juli 0708 2003 tokyo japan gregori johnson juhyun lee christoph burn william r mark irregular zbuffer hardwar acceler irregular data structur acm transact graphic tog v24 n4 p14621482 octob 2005 jrg schmittler ingo wald philipp slusallek saarcor hardwar architectur ray trace proceed acm siggrapheurograph confer graphic hardwar septemb 0102 2002 saarbrucken germani greg coomb mark j harri anselmo lastra radios graphic hardwar proceed 2004 confer graphic interfac p161168 may 1719 2004 london ontario canada jrg schmittler sven woop daniel wagner wolfgang j paul philipp slusallek realtim ray trace dynam scene fpga chip proceed acm siggrapheurograph confer graphic hardwar august 2930 2004 grenobl franc nolan goodnight rui wang cliff woolley greg humphrey interact timedepend tone map use programm graphic hardwar proceed 14th eurograph workshop render june 2527 2003 leuven belgium ingo wald thiago ize andrew kensler aaron knoll steven g parker ray trace anim scene use coher grid travers acm transact graphic tog v25 n3 juli 2006 nolan goodnight rui wang cliff woolley greg humphrey interact timedepend tone map use programm graphic hardwar acm siggraph 2005 cours juli 31august feng liu scott owen ying zhu robert harrison iren weber web base molecular visual use procedur shader x3d acm siggraph 2005 web program juli 31august naga k govindaraju brandon lloyd wei wang ming lin dinesh manocha fast comput databas oper use graphic processor acm siggraph 2005 cours juli 31august aaron e lefohn joe kniss charl hansen ross whitak stream narrowband algorithm interact comput visual level set acm siggraph 2005 cours juli 31august naga k govindaraju brandon lloyd wei wang ming lin dinesh manocha fast comput databas oper use graphic processor proceed 2004 acm sigmod intern confer manag data june 1318 2004 pari franc jen krger rdiger westermann linear algebra oper gpu implement numer algorithm acm siggraph 2005 cours juli 31august jen krger rdiger westermann linear algebra oper gpu implement numer algorithm acm transact graphic tog v22 n3 juli heiko friedrich johann gnther andrea dietrich michael scherbaum hanspet seidel philipp slusallek explor use ray trace futur game proceed 2006 acm siggraph symposium videogam p4150 juli 3031 2006 boston massachusett mark j harri greg coomb thorsten scheuermann anselmo lastra physicallybas visual simul graphic hardwar proceed acm siggrapheurograph confer graphic hardwar septemb 0102 2002 saarbrucken germani jeff bolz ian farmer eitan grinspun peter schrder spars matrix solver gpu conjug gradient multigrid acm siggraph 2005 cours juli 31august jeff bolz ian farmer eitan grinspun peter schroder spars matrix solver gpu conjug gradient multigrid acm transact graphic tog v22 n3 juli vincent c h michael mccool low latenc photon map use block hash proceed acm siggrapheurograph confer graphic hardwar septemb 0102 2002 saarbrucken germani doug l jame kayvon fatahalian precomput interact dynam deform scene acm transact graphic tog v22 n3 juli r mark donald fussel realtim render system 2010 acm siggraph 2005 cours juli 31august ian buck tim foley daniel horn jeremi sugerman kayvon fatahalian mike houston pat hanrahan brook gpu stream comput graphic hardwar acm transact graphic tog v23 n3 august 2004 ingo wald solomon boulo peter shirley ray trace deform scene use dynam bound volum hierarchi acm transact graphic tog v26 n1 p6e januari 2007 aaron e lefohn shubhabrata sengupta joe kniss robert strzodka john owen glift gener effici randomaccess gpu data structur acm transact graphic tog v25 n1 p6099 januari 2006