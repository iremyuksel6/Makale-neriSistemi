integ multipl overflow detect satur abstracthighspe multipl frequent use generalpurpos applicationspecif comput system system often support integ multipl two nbit integ multipli produc 2nbit product prevent growth word length processor typic return n least signific bit product flag indic whether overflow occur altern processor satur result overflow posit neg represent number paper present effici method perform unsign two complement integ multipl overflow detect satur method significantli less area delay convent method integ multipl overflow detect satur b introduct 11 multipl multipl essenti arithmet oper gener purpos comput digit signal processor highperform system support parallel multipl hardwar variou highspe parallel multipli propos realiz parallel multipli design divid two class array multipli tree multipli array multipli consist array similar cell gener accumul partial product 3 tree multipli gener partial product parallel use tree counter reduc partial product sum carri vector sum vector use fast carrypropag adder sever method develop reduc partial product 1 2 regular structur array multipli facilit implement vlsi technolog delay array multipli howev proport operand length hand tree multipli offer delay proport logarithm operand length main drawback tree multipli irregular interconnect structur make difficult implement vlsi thu tree multipli prefer high perform system array multipli prefer system requir less area new implement optim parallel multipli still activ research area 5 detail descript array tree multipli given next chapter 12 overflow avoid grow word length instruct set architectur highlevel languag requir arithmet oper return result length input operand result integ arithmet oper nbit number repres n bit overflow occur need detect integ multipl method overflow detect also depend whether operand sign unsign integ unsign multipl overflow occur result larger largest unsign nbit number sign integ multipl overflow also occur result smaller minimum represent nbit number two complement multipl also differ fraction integ overflow detect sinc overflow occur two complement fraction number gamma1 multipli gamma1 easi detect overflow multipli two complement fraction import design issu comput architectur decid overflow occur typic overflow result overflow flag set overflow flag use signal arithmet except 9 13 satur gener purpos processor overflow handl set except flag recent implement digit signal process multimedia applic satur result overflow posit neg represent number 11 12 two complement integ gamma2 neg number 2 posit number unsign integ result larg satur 2 14 thesi overview previou studi focuss overflow detect two complement addit 13 multioperand addit 14 fraction arithmet oper 10 gener signeddigit arithmetic15 thesi present effici techniqu integ multipl overflow detect satur exist comput detect overflow integ multipl comput 2nbit product test signific bit see overflow occur method propos thesi calcul n n bit product lead signific reduct area delay chapter 2 present array multipli tree multipli convent method overflow detect chapter 3 introduc new method overflow detect satur unsign integ multipl chapter 4 focus overflow detect satur two complement integ multipl chapter 5 present compon count area delay estim unsign two complement parallel multipli use either convent propos method overflow detect chapter 6 discuss futur work give conclus chapter 2 previou research 21 unsign parallel multipli multipl two nbit unsign number shown figur 21 multipl produc 2nbit product n least signific bit use result overflow occur actual product use n bit word overflow occur product greater equal 2 n convent method overflow detect 2nbit result pro duce done simpli logic ore togeth n signific bit n2 n1 n2 n1 n2 n2 n1 n2b b 1 n1 n2b b 0 figur 21 multipl b v one overflow occur denot logic although calcul 2n product bit detect overflow lead unnecessari area delay comput provid integ multipl overflow detect use approach system requir satur satur least signific product bit comput set product 2 ngamma1 overflow occur 211 unsign array multipli gener array multipli slower tree multipli spite speed disadvantag howev array multipli often use due regular layout low area simplifi design block diagram unsign 8 8 array multipli shown figur 22 diagon figur 22 correspond column multipl matrix figur 21 modifi half adder mha half adder gate modifi full adder mfa full adder gate gate gener partial product full adder half adder add gener partial product sum output connect diagon carri output connect vertic last row adder connect left right gener nmost signific product bit critic path multipli shown dash line sinc almost half latenc due bottom row adder row may replac fast carrypropag adder although decreas overal delay neg impact design regular n n unsign array multipli use n 2 gate n convent method overflow detect requir n signific product bit calcul product bit ore togeth produc overflow flag shown figur 22 convent method satur multipl accomplish ore v p 0 p ngamma1 shown figur 23 mha mha mha mha mha mha mha mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa fa c fa c fa c mfaa 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c mfa mfa ha c fa c fa c fa c figur 22 unsign array multipli convent overflow detect mha mha mha mha mha mha mha mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa fa c fa mfa fa 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c mfa mfa ha c fa c fa c fa c figur 23 unsign array multipli convent satur 212 unsign tree multipli tree multipli three main part partial product gener partial product reduct final carrypropag addit variou reduct scheme develop year two wellknown method multipli tree design propos wallac 2 dadda 1 wallac strategi combin three row partial product bit use 3 2 2 2 counter produc two row dadda strategi lead simpler counter tree requir larger final carrypropag adder hybrid approach two method offer cost speed tradeoff vlsi implement reduct scheme differ number placement counter tree size final carri propag adder tree multipli present thesi use dadda method sinc allow compon count easili determin base n sinc overflow detect method depend reduct strategi similar save expect tree multipli figur 24 show dot diagram 8 8 unsign array multipli dot diagram often use illustr reduct strategi tree multipli 2 techniqu dot repres partial product bit plain diagon line repres full adder cross diagon line repres half adder two bottom row dot diagram correspond sum carri vector combin use final carrypropag adder produc product dadda multipli requir n 2 gate n figur 24 dadda reduct scheme cpa number stage base n shown tabl 21 exampl 24 24 dadda multipli requir seven reduct stage worst case delay path equal delay partial product gener plu delay reduct stage plu delay final carrypropag addit convent method overflow detect tree n gamma 1 2input gate delay tree gate equival dlog 2 ne 2input gate shown figur 25 rang n 43 tabl 21 number stage nbit dadda tree multipliersv101214 pp figur 25 tree 2input gate 22 two complement multipli two complement number b product p valu gammab overflow occur multipl two complement number gener sign partial product shown figur 26 sinc neg weight subtract rather ad make design difficult implement requir adder subtract cell consequ sever techniqu propos handl partial product neg posit weight baughwooley algorithm6 variat 7 8 booth algorithm 16 baughwooley algorithm provid method 1 0 0 1 0 n1 x n1 figur 26 two complement multipl matrix modifi partial product matrix partial product bit posit weight algorithm modifi form often use perform two complement multiplicationb b 1 n1 1 b n2 n2 n1 n2 bn1a n2 n2 figur 27 modifi two complement multipl matrix two complement multipl often realiz use variat baugh wooley algorithm call complement partial product word correct al gorithm implement partial product bit contain complement one ad column n 2n gamma 1 equival take two complement two neg term equat 25 multipl matrix implement shown figur 27 221 two complement array multipli design array multipli use complement partial product word correct algorithm convent overflow detect shown figur 28 design shown figur similar unsign array multipli design figur 22 gate leftmost column replac nand gate last row mfa replac negat modifi full adder nmfa special half adder sha bottom right corner half adder take sum carri bit previou row add 1 cell approxim area delay regular half adder last product bit p 2ngamma1 invert add one column 2n gamma 1 invert p 2ngamma1 effect ad one column 2n gamma 1 carri column ignor figur 28 bottom two row cell consist n xor gate gate dedic overflow detect xor gate identifi whether differ signific product bit p n output xor gate combin determin overflow flag v set logic equat overflow detect flag mha mha mha mha mha mha mfa mfa mfa mfa mfa mfa mha mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa bb 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c fa c fa c fa c nmfa nmfa nmfa nmfa nmfa nmfa nmfa fa c fa c fa c figur 28 two complement array multipl convent overflow detect satur multipl implement ad nbit 2to1 multiplex shown figur 29 two complement multipl product flow satur product determin sign bit b neg overflow occur product satur gamma2 hand posit overflow occur product satur 2 overflow mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa c mfa c c c c mfa mfa mfa mfa mfa mfa mfa mfa mha mha mha mfa c mha mha mha c andpand 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c c fa c fa c fa c nmfa nmfa nmfa nmfa nmfa fa c fa c fa c mfa mfa nbit mux xand figur 29 convent two complement satur occur satur product n least signific bit satur product 222 two complement tree multipli sever techniqu avail implement two complement multipli tree 4 8 figur 27 show dot diagram 8 8 two complement multipli tree use complement partial product algorithm 8 dadda reduct method 1 similar two complement array multipli 2n gamma 2 partial product bit invert one ad column n 2n gamma 1 although seem height two column increas ad one effect advers design signific product bit simpli invert sha add one column n figur 210 dot line indic complement partial product bit circl half adder column 8 sha special half adder n n two complement dadda tree multipli fa 2n gamma 2 bit cpa convent techniqu overflow detect satur two complement tree multipli similar techniqu use two complement array multipli differ tree multipli tend use tree gate rather linear array gate comput overflow flag figur 210 two complement dadda tree multipli chapter 3 overflow detect satur unsign integ multipl 31 gener design approach instead comput 2n bit product method propos thesi comput n least signific product bit separ overflow detect logic shown figur 31 carri column n also use overflow detect circuit main idea behind propos unsign overflow detect method overflow occur partial product bit column n 2n gamma 2 1 overflow detect result operand operand b n n multipli figur 31 block diagram unsign multipl overflow detect carri column n 1 consequ one detect without ad partial product logic equat unsign overflow detect express v overflow flag c th carri column n bit summat correspond logic or bit multipl correspond logic and 32 unsign array multipli overflow detect satur figur 32 show 8 8 multipl matrix demonstr partial product bit use detect overflow propos method partial product use overflow detect b 0 b 0 b 0 b b b b b b b 1357 0 b 1111a b b b b b b b 1357 0 b 2222a b b b b b b b 1357 b b b b ba b 1357 b b b b b b b 1357 b b b b b b b 1357 b b b b b b b 1357 0 b figur 32 8 8 unsign multipl matrix use equat 31 common term logic equat overflow detect use reduc hardwar need detect overflow overflow detect circuit construct use gate shown figur 33 8 8 unsign multipl n n multipli three gate dash line replic time three gate combin form overflow detect ovd cell overflow detect use follow iter equat temporari bit initi valu v temporari overflow bit initi valu shown figur 33 ovd cell take input gener output ovd cell contain one gate one 2input gate one 3 input form unsign multipli propos overflow detect method cell combin unsign array multipli cell use comput p n p 2ngamma1 remov shown figur 34 8 8 unsign array multipli b246 aa 7b c c figur 33 propos overflow detect logic nbit unsign array multipli use propos method overflow detect requir n 2 fa correspond n gate convent method worst case delay path indic dash line figur 34 sinc mfa longer delay ovd cell unsign multipli propos overflow detect logic delay approxim half long unsign multipli convent overflow detect shown figur 33 unsign satur multipl use propos method perform ore overflow bit n least signific product bit shown figur 35 overflow bit 1 produc product n one correspond maximum represent unsign number otherwis product chang requir n gate worst case delay increas one delay mha mha mha mha mha mha mfa mfa mfa mha mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfao 7v 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c mfa ovd ovd ovd ovd ovd cccc ovd c figur 34 unsign array multipli propos overflow detect logic mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mfa mha mha mha mha mha mha mha 7 6 5 4 3 2 1 0 c c c c c c c c c c c c c c c c c c c mfa ovd ovd ovd ovd ovd cccc ovd c figur 35 unsign array multipli propos satur logic 33 unsign tree multipli overflow detect satur unsign tree multipli techniqu use array ovd cell linear delay work well sinc ovd cell would significantli increas multipli worst case delay path instead n 2 partial product bit gener tree gate use determin partial product bit column n 2ngamma1 carri column n one method shown 8 8 multipli figur 36 symbol denot output 2input gate although method requir hardwar overflow detect unsign array multipli overflow detect logic logarithm delay longer contribut significantli critic path n n unsign array multipli use method n 2 n fa sinc delay gate overflow detect less delay partial product reduct stage worst case delay equal delay partial product gener plu partial product reduct plu n gamma 1bit carrypropag addit plu one gate delay includ final carri satur multipl perform method use array multipli overflow bit ore n least signific bit product figur unsign tree multipli propos overflow detect logic chapter 4 overflow satur detect two complement integ multipl 41 gener approach propos method overflow detect two complement multipl detect number consecut bit equal sign bit essenti method count number lead zero operand posit number lead one operand neg exampl 11100101 three lead one 00001001 four lead zero method work number lead zero one indic magnitud operand operand lead zero one smaller magnitud therefor less like caus overflow main issu determin mani lead zero lead one need guarante overflow occur overflow occur block diagram show propos approach shown figur 41 analysi two complement multipl three case depend operand sign operand posit operand neg one posit neg overflow region three case discuss follow section case 1 operand posit let za denot number lead zero operand zb denot number lead zero operand b sinc operand posit nbit integ least one n lead zero express rang operand operand b term number lead zero express overflow detect operand operand b multipli n n figur 41 block diagram propos method two complement multipl overflow detect overflow occur case 1 overflow occur base 42 rang p use 43 overflow guarante occur determin number lead zero b guarante overflow 44 rewritten take base 2 logarithm side give equival thu b togeth less n lead zero overflow must occur similarli overflow guarante occur determin number lead zero b guarante overflow occur equat 48 rewritten sinc gamma2 ngammaz gamma1 gamma2 ngammaz b gamma1 consequ overflow guarante occur take base 2 logarithm side give equival use alway true sinc za 1 zb 1 therefor 413 rewritten thu overflow guarante occur b togeth n lead zero directli determin whether overflow occur examin number lead zero rewrit 43 problem howev solv analyz happen za n result obtain far summar figur 42 overflow overflow undetermin figur 42 overflow region za determin whether overflow occur necessari calcul mani product bit need repres result za n use signific product bit sign bit operand overflow flag set n even maximum product equival n odd maximum product equival thu za alway repres n bit overflow determin simpli examin sign bit p ngamma1 p otherwis overflow occur 412 case 2 operand neg let denot number lead one operand b denot number lead zero operand b sinc operand neg nbit integ least one n lead one express rang b term lead one express gamma2 ngammai gamma1 overflow occur case 2 overflow occur base 422 rang p use 423 overflow guarante occur determin number lead one b guarante overflow occur 424 rewritten sinc valu satisfi also satisfi 425 take base 2 logarithm side 427 give thu neg integ overflow occur operand less lead one use 423 overflow guarante occur take base 2 logarithm side equat 429 give thu overflow guarante occur b togeth lead one directli determin overflow occur seen use 423 give similarli result far shown figur 43 undetermin overflow overflow figur 43 overflow region even maximum result n odd maximum product repres use n bit except occur 413 case 3 sign operand differ let denot number lead one operand zb denot number lead zero operand b neg operand least one n lead zero posit operand b least one n lead one express rang b term lead one zero gamma2 ngammai gamma1 overflow occur case 3 p gamma2 occur p gamma2 base 436 rang p use equat 437 overflow guarante occur equival zb 439 alway true sinc 2 use 437 overflow guarante occur gamma2 equival rang determin whether overflow occur sinc figur 44 show graphic result obtain far case 3 overflow overflow undetermin figur 44 overflow region zb even minimum neg number n odd case product repres use n bit therefor overflow occur p far propos method explain mathemat next section implement overflow logic present 414 overflow detect logic allow posit neg operand use hardwar detect lead zero one sign bit xnore remain bit take gate express logic logic design detect n gamma 1 fewer lead zero lead one includ gate gate use comput ba ngammakgamma2 447 3 preliminari overflow flag gener use xi yi bit product correspond logic and bit summat correspond logic or equat implement use n gamma 2 2input gate gate v 1 one total number lead zero lead one less n case overflow guarante occur addit logic use detect overflow undetermin region case 13 case 1 detect case 2 neither b zero n least signific bit zero case 3 neither b zero detect logic equat 450 454 realiz 9 2input gate 4 invert n gate final overflow flag v gener ore previou flag overflow detect circuit requir 2n gamma gate four invert overflow detect circuit 8bit two complement multipli shown figur 45 46 bb 7 7 7 7 7 7 7 figur 45 logic v 1 8bit multipl 7y least signific z figur detect logic 8bit two complement multipl 415 altern method altern method detect overflow undetermin case instead gener product bit multipli gener product bit detect undetermin case check p n phi p approach shown figur 47 approach work sinc undetermin case follow situat overflow occur 2 case 2 overflow occur one except gener p 3 case 3 overflow occur three case overflow detect 42 two complement array multipli overflow detect satur propos method overflow detect array multipli requir half much hardwar convent method 8bit two complement multipli n n multipli operand detect figur 47 block diagram propos altern method two complement multipl overflow detect propos method overflow detect shown figur 48 x2a cell contain one 2input xor gate one 2input gate x3a cell contain one 3input xor gate one 2input gate x3na contain two 2input xor gate one 2input nand gate two complement array multipli propos overflow detect logic 3input xor gate one 2input xor gate four invert delay multipli approxim equal delay n gamma plu four 2input gate plu three 3input gate actual delay may differ accord variou design decis technolog use overflow detect mfa mfa mfa mfa mfa mfa mfa mfa mfa b 7b mfa 7 5 3 1 aa 4 mfaa 7 6 5 4 3 2 mfa mfa mfa mha mha mha mha mha mha c c c c c c c c c c c c c nand figur 48 overflow detect logic 8bit two complement multipl two complement satur multipl perform use v flag flag use input nbit 2to1 multiplex shown figur 49 neg overflow occur result satur gamma2 posit overflow occur result satur 2 ad satur logic array multipli overflow detect requir addit invert nbit 2to1 multiplexor sinc v alreadi gener overflow detect logic requir addit hardwar delay increas delay 2to1 multiplex plu delay invert overflow detect c c c c c mfa 6 c s7 mfab 432 7 mfa mfa 5 4 2 1 7 6 mfa mfa mfa mfa mfa mfa mfab mfa mfamfa mha mha mha mha mha c c c c c c c c nand mfa nbit mux 6 5 4 3 2 1 07 5 4 2 figur 49 satur two complement array multipl 43 two complement tree multipli overflow detect satur altern method use tree multipli method n1 bit product comput v 1 comput approach first method overflow flag gener use logic equat explain section 415 sinc detect circuit independ multipl process n1 partial product bit need gener consequ gate counter gener reduc partial product bit column n multipl matrix longer need size carrypropag adder reduc n bit sinc least signific product bit use reduct independ strategi use design tree multipli reduct scheme dadda multipli use altern method shown figur 410 diagon line x bottom 3 input xor gate diagon tilda x bottom repres 2input xnor gate xs use denot carri output requir worst case delay main constraint custom design altern design method consid implement overflow detect logic two complement dadda multipli propos overflow detect n gate one nbit cpa worst case delay multipli also less convent techniqu altern methodth worst case delay equal delay reduct stage plu delay n adder plu one 2input gate plu one 2input xor gate plu one 2input gate two complement satur multipl logic dadda tree multipli similar logic array multipli nbit 2to1 multiplex invert ad shown figur 49 except partial product bit p ngamma2 connect overflow detect logic control signal v 2to1 multiplex gener detect logic delay increas delay invert plu delay 2to1 multiplex figur 410 dadda dot product scheme propos overflow detect chapter 5 result 51 area delay estim theoret compon count worst case delay given variou multipli tabl 51 52 tabl 53 tabl u denot unsign sign denot array tree multipli p c denot propos convent tabl 51 tabl 52 give number compon size cpa base operand length n tabl 53 give number type compon worst case delay path propos method reduc number gate fa array multipli reduc number gate fa size cpa tree multipli propos method also reduc delay array tree multipli sinc signific product bit longer calcul multipli number compon type inv nand or2 or3 tabl 51 compon count nbit multipli overflow detect multipli number compon type xor xnor ha fa cpa tabl 52 compon count nbit multipli overflow detect ii multipli number compon worst case delay path type inv or2 xor ha fa cpa tabl 53 worst case delay nbit multipli overflow detect tabl 54 unsign array multipli overflow detect possibl reduc amount logic requir implement detect circuit even propos method use straight forward implement logic equat structur present previou chapter synthesi tool use optim design consequ valu shown tabl 51 52 tabl 53 consid worst case valu optim perform gate level vhdl code variou size array dadda tree multipli gener convent propos method overflow detect vhdl code synthes optim area use lsi logic 06 micron gate array librari leonardo synthesi tool exemplar logic synthesi tool set nomin oper voltag 50 volt temperatur 25 ffi c area estim report equival gate delay estim report nanosecond tabl 54 give area delay estim unsign array multipli compar multipli use convent overflow detect propos multipli 50 53 less area 41 42 less delay tabl 55 unsign dadda tree multipli overflow detect convent propos reduct n area delay area delay area delay tabl sign array multipli overflow detect gain mainli due reduct area delay fa use gener n signific product bit tabl 55 give area delay estim unsign dadda tree multipli compar multipli use convent overflow detect method multipli use propos method approxim 47 less area 23 28 less delay improv due reduc number fa reduc size final carrypropag adder 2n gamma 2 tabl 56 give area delay estim two complement array multipli compar multipli use convent method multipli use propos method requir 38 47 less area 41 tabl 57 sign dadda tree multipli overflow detect tabl 57 give area delay estim two complement dadda tree mul tiplier compar multipli use convent method multipli use propos method 35 44 less area 24 32 less delay chapter 6 conclus futur research 61 conclus overflow detect satur method present thesi significantli reduc area delay array tree multipli multipli size examin area reduc 50 unsign multipli compar convent method propos method also chang regular multipli structur two complement multipli propos method complet independ multipli intern structur featur provid design increas flexibl sinc add overflow detect logic without effect origin design reduct multipli hardwar also lead reduc power dissip propos method reduc delay array multipli 40 50 62 futur research thesi separ present overflow detect satur method unsign two complement parallel multipli import next step develop singl multipli structur perform unsign two complement integ multipl overflow detect satur base input control signal anoth area futur research investig techniqu reduc area overflow detect multipli tree without significantli impact delay research may abl take advantag hybrid structur less delay linear overflow detect structur less area overflow detect tree anoth research area investig reduct power dissip due propos techniqu anticip signific reduct power dissip achiev due reduct multipli hardwar method similar propos method also use arithmet oper need overflow detect multiplyaccumul squar r scheme parellel multipli suggest fast multipli 40 ns 17bit array multipli parallel reduc area multipli reduct scheme optim wallac multipli two complement parallel array multipl algorithm comment two complement parallel array multipl algorithm synthesi comparis two complement parallel multipli comput architectur quant approach second edi tion parallel satur fraction arithmet unit fixedpoint overflow except detect programm highperform iir filter chip overflow indic two complement arith metic overflow detect multioperand addit zero sign overflow detect scheme gener sign arithmet sign binari multipl techniqu tr ctr eya elqawasmeh ahm dalalah revisit integ multipl overflow proceed 4th wsea intern confer softwar engin parallel distribut system p114 februari 1315 2005 salzburg austria eya elqawasmeh ahm dalalah revisit integ multipl overflow proceed 4th wsea intern confer softwar engin parallel distribut system p114 februari 1315 2005 salzburg austria