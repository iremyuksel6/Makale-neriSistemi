gener linear extens fast one import set associ poset cal p set linear extens ecal p paper present algorithm gener linear extens poset constant amort time time oecp ecp fastest previous known algorithm gener linear extens poset run time cdot ecp n number element poset algorithm present first constant amort time algorithm gener natur defin class combinatori object correspond count problem pcomplet furthermor shown linear extens gener constant amort time extens differ predecessor one two adjac transposit algorithm practic modifi count linear extens effici comput p x pair xy time on2 ecal p b introduct one definit adverb fast quick success webster collegi dictionari 1 purpos paper show linear extens partial order set poset gener fast fast fact algorithm faster constant factor furthermor constant involv small algorithm extend practic rang poset extens gener count linear extens great interest comput scientist relat sort schedul problem exampl mani npcomplet oneprocessor schedul problem preced constraint 13 one obviou way solv problem gener linear extens preced constraint pick best extens linear extens also interest combinatorist relat count problem 221 result use effici gener standard young tableau given shape altern permut mani combinatori object view linear extens particular poset given poset p two question natur aris gener question ask whether linear extens ep p effici gener count question ask whether ep size set ep effici determin recent result brightwel winkler 4 count question p complet indic count question may easier gener question give best possibl answer gener question sens algorithm gener ep time complex oep asid small amount preprocess say gener algorithm run constant amort time run time n number object gener case linear extens assum unit cost oracl avail take two poset element b return whether oe b also assum poset element depart comput scienc univers toronto toronto ontario m5 1a4 canada garacsutorontoca research support part nserc research paper took place visit simon fraser univers burnabi canada depart comput scienc univers victoria victoria bc v8w 2y2 canada fruskeycsruvicca research support part natur scienc engin research council canada grant a3379 label particular manner describ later label carri time 2 n element poset asid space use poset amount space requir algorithm constant amort time gener algorithm previous known class combinatori object correspond count problem pcomplet problem gener linear extens poset consid knuth szwarcfit 12 varol rotem 24 kalvin varol 11 paper term topolog sort use instead linear extens effici algorithm appear varol rotem 24 whose time complex given delta ep 11 n number element poset worth note varol rotem algorithm simpl eleg quit effici practic algorithm awar count linear extens arbitrari poset well 25 appear difficult analyz particular class poset seriesparallel bound width effici algorithm count known see exampl bouchitt habib 3 2 strategi definit popular strategi effici gener set combinatori object insist success object list differ small prescrib way list combinatori object properti call gener combinatori gray code exampl binari reflect gray code yield method gener nbit string bit string differ predecessor flip one bit gray code found sever class combinatori object mani describ wilf 26 regard linear extens permut element poset gener variou class permut common close criteria success permut differ transposit two element sometim restrict transposit adjac element wellknown algorithm steinhau 22 johnson 10 trotter 23 provid gray code list n permut n element permut differ predecessor transposit two adjac element thu say n permut gener adjac transposit permut nset correspond linear extens poset n element antichain gener alway possibl gener linear extens poset transposit adjac exampl linear extens poset consist two nontrivi chain n odd 5 6 16 thu linear extens poset figur 1 two 2element chain gener transposit linear extens class poset shown gener transposit see 1815 20 open problem character poset properti even linear extens famili poset gener transposit fast algorithm perform gener may exist basic strategi initi algorithm gener linear extens twice extens flag plu minu algorithm keep track sign extens output plu extens thu sens algorithm fall class gener algorithm gener object actual output introduc terminolog notat poset partial order set p reflex transit antisymmetr relat rp set sp order pair b 2 rp denot p b lead confus simpli b oe b mean b 6 b element minim p element b b oe let minp denot set minim element p oe b exist c sp oe c oe b say b cover let covera denot set element cover element b said incompar 6 b b 6 write akb indic b incompar pair element sp incompar p total order p total order x oe x j j sometim use xn denot p extens p poset q extens p total order call linear extens p let ep denot set linear extens p let ep denot jepj let sigmaep denot fl gammal j l 2 epg height hx element x averag posit occupi linear extens thu minimum element height 1 maximum element height jspj p antichain element height jspj probabl x preced denot p number extens x preced divid total number extens connect sort algorithm desir find pair element x p close 12 sp let pnt denot poset set spnt relat set suppos b incompar element sp relationship element sp b precis suppos c 2 sp c oe c oe b oe c b oe c b call sibl poset p q rp rq antisymmetr let p q denot poset set sp sq relat set transit closur rprq exampl pabc poset set sp fa b cg relat set transit closur rp fa b b cg p say p induc q exampl everi linear extens p oe b oe c therefor say p induc abc element disjoint total order ff fi fl ffi denot poset fffi consid graph ep vertex set two vertic adjac graph whenev correspond linear extens differ singl transposit graph call transposit graph poset p denot gp subgraph gp vertex set contain edg correspond adjac transposit call adjac transposit graph denot g 0 p gener linear extens p adjac transposit equival find hamiltonian path graph gp g 0 p figur 1 show poset transposit graph ff fi linear extens p dff fi denot distanc gp ff fi 0 ff fi denot correspond distanc g 0 p transposit graph bipartit connect partit set gp size hamiltonian cycl graph differ size partit set one hamiltonian path graph thu linear extens p gener transposit ruskey 17 conjectur necessari condit exist hamiltonian path also suffici suggest possibl character 1 2 1 fig 1 poset transposit graph fig 2 graph gp theta k 2 poset whose linear extens gener transposit figur 1 partit set size differ two linear extens poset gener transposit g graph let g theta k 2 graph result take two copi g ad edg correspond isomorph two copi differenti copi g prefix vertic one copi g gamma exampl figur 2 show gp theta k 2 p poset shown figur 1 lemma use later section state follow lemma 21 b sibl p gp proof observ ba linear extens l p transpos b l yield anoth linear extens p therefor oper transpos b linear extens provid isomorph total order gp theta k 2 edg purpos induct show exist hamiltonian cycl consid graph hamiltonian cycl sinc hamiltonian path endpoint adjac 3 graph g 0 p theta k 2 hamiltonian proof g 0 p theta k 2 hamiltonian form basi effici algorithm present next section true certain kind poset call bposet shown 9 r r r r r r r r r r r r fig 3 bposet pruess ruskey 15 result use proof gener case definit 31 bposet poset p whose element partit two disjoint chain x 1 oe x j 1 exampl bposet shown figur 3 note linear extens bposet extens call canon linear extens bposet defin mrx largest index j x k bposet figur 3 7 follow lemma prove 15 lemma 32 let p bposet exist hamiltonian cycl use edg gamma figur 4 show graph g 0 p theta k 2 p bposet shown figur 3 edg correspond isomorph two copi g 0 p omit sake clariti one think travel vertic edg transpos neighbor right travel along horizont edg transpos x 1 one neighbor hamiltonian path gamma shown figur 5 bposet use remaind paper call 2bposet graph similar shown figur 4 aris whenev call typic case oe 1 g 0 p path call atyp case word typic case occur mra 0 atyp case occur theorem 33 everi poset p graph g 0 p theta k 2 hamiltonian proof proof theorem induct jspj base case induct p poset zero one element case g 0 p theta k 2 edg suppos jspj 1 p uniqu minimum g 0 p induct hypothesi g 0 pnfag theta k 2 hamiltonian otherwis let p two minim element b induct hypothesi graph g 0 pnfa bg theta k 2 hamiltonian cycl h 0 replac sign linear extens ff h 0 abff replac linear extens gammaff baff result cycl exactli linear extens b preced element sp r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r gammaay r r r r r r r r r r r r r r r r r r r r r r r r r r fig 4 graph g 0 p theta k2 r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r r fig 5 hamiltonian cycl g 0 p theta k 2 cycl visit linear extens x2spnfabg poset p 0 p extend b cover everi element minp fi poset px bposet lemma 32 hamiltonian path g 0 px fi gammafi substitut occurr fi path h 0 odd even substitut revers path occurr fi call result walk h prove h hamiltonian cycl g 0 p theta k 2 necessari show everi vertex cycl h linear extens p true sinc ep 0 ep henc bposet gener extens p also necessari show linear extens l p l gammal occur exactli h suppos l induc order xy fa bg order bg xyi linear extens p 0 l linear extens bposet everi bposet gener either induc order xy induc order therefor l gammal gener gener ep l gammal gener exactli observ refer lemma 32 preced proof strictli necessari bposet occur 2bposet typic case cycl figur 5 could use atyp case cycl obviou move b right far possibl chang sign move b back left mrb even cycl figur 5 slightli differ use edg aflb gammaaflb cycl use algorithm follow section corollari 34 p poset pair sibl gp hamiltonian proof suppos p pair sibl b theorem 33 g hamiltonian therefor gp hamiltonian henc lemma 21 gp hamiltonian open problem determin whether g 0 p hamiltonian p poset pair sibl 4 algorithm proof theorem 33 construct section present recurs algorithm implicit induct proof algorithm run constant amort time ie gener linear extens poset p take time oep first give overview algorithm use small exampl give gener understand work give detail algorithm proof correct algorithm inplac algorithm maintain array le contain current linear extens maintain variabl isplu keep track sign gamma go one linear extens next make chang array revers sign main procedur use algorithm call genl recurs basic follow path indic figur 5 everi level recurs associ pair minim element current subposet exampl poset shown figur 1 pair minim element pair minim element g pair determin preprocess describ later procedur move switch use chang current linear extens oper o1 time follow sign chang isplu chang transpos call transpos x element left call transpos x element right time new linear extens l p gener call genlei ie time move switch call genlei1 call call genlei1 move possibl way l maintain order depend order point call genlei1 noth exampl start 1 b 1 2 b 2 execut call sequenc genle2 switch2 genle2 poset shown figur 1 lead trace call shown figur 6 follow detail implement reader refer pascal procedur genl figur 8 implement algorithm maintain four global array array le linear extens array li invers array b store element b discuss algorithm b consid fix outset unchang throughout run algorithm array maintain ai alway contain valu leftmost ith pair procedur call linear extens fig 6 trace call sequenc poset figur 1 bi contain rightmost also current sign either plu minu gamma maintain boolean function rightx use determin whether element x move right oper o1 time follow return true bi incompar element right array le return true ai incompar element right array le element right bi describ preprocess success strip pair element element left uniqu minimum element encount simpli delet becom part pair let maxpair index last pair minim element strip p remaind p total order empti preprocess detail figur 7 note maxpair uniqu determin poset depend order element strip p say linear extens l proper order 1 element j b j adjac l l induc order 1 1 maxpair initi linear extens list must properli order maxpair preprocess figur 7 assum right bmaxpair1 fals initi call simpli genl follow procedur call call call sequenc genl maxpair switch maxpair genl maxpair algorithm consist execut preprocess set isplu plu sq 6 q exactli one minim element x begin els begin let two minim element q ai maxpair fig 7 preprocess routin execut call sequenc pascal procedur implement genl given figur 8 prove follow theorem theorem 41 algorithm genl gener linear extens along hamiltonian path g 0 p theta k 2 proof order prove theorem first prove follow proposit proposit 42 let linear extens array le properli order linear extens l 2 ep genlei gener l gammal exactli furthermor last extens gener gamma 1 last extens gener 0 differ transposit igamma1 b igamma1 proof proof proce induct recurs call genle0 noth switch0 chang sign ffia 1 induc p easi confirm algorithm figur 8 strip recurs call switch chang sign simpli follow path indic figur 2 case genle1 find hamiltonian path gamma g 0 q theta k 2 q 2bposet p loss gener sign storag genl invok ff fi fl way preprocess select pair assur p induc could empti mention basic structur algorithm strip recurs call follow hamiltonian path 2bposet indic figur 2 switch transpos linear extens e 0 properli order gamma 1 linear extens call l induct procedur genl begin mrb 0 typic fals right bi begin move bi riht genl i1 mra 0 right ai begin typic true repeat mra move ai riht genl i1 right ai typic begin x 1 mla begin move ai left genl i1 typic odd mrb move ai left els switch i1 x 1 mrb begin move bi left genl i1 fig 8 pascal procedur genl hypothesi call gener sigmaep respect start l end l 0 2 end gammal 2 sinc even number vertic product graph edg even number call genlei1 thu 2 sign final permut unchang rel order igamma1 b igamma1 unchang union sigmaep b let b amaxpair bmaxpair respect suppos call sequenc execut preprocess poset p proposit first call b transpos sigmaep ba gener therefor ep gener theorem prove analyz time complex algorithm assum right switch move implement constant time easili accomplish long invers li le maintain call move switch gener one linear extens observ call genlei gener least two call genlei1 iter whileloop forloop algorithm execut move therebi gener linear extens occas genl recurs call linear extens gener happen per linear extens gener therefor algorithm run constant time per linear extens gener sigmaep suppress linear extens prefix gamma gener ep constant amort time anoth way think preced argument consid underli comput tree intern node recurs call leaf linear extens total amount comput divid node assign constant amount comput sinc intern node least two children number leav greater number intern node therefor total amount comput proport number leav observ gener minu gamma vertic occur algorithm genl suggest treat special case minu gamma vertic omit entir simpli skip next plu vertex done save comput list extens produc success extens differ larg number transposit one want comput number extens comput save comput number vertic level recurs gener extens explicitli ie never move 1 number vertic extens determin mra mra number mra mrb chang uniti one extens next sinc adjac transposit use lead algorithm whose run time oep n gener lower bound attain 1 oe c b 1 oe c element c p n g upper bound attain 1 b 1 maxim well minim 5 gray code linear extens show linear extens list success extens differ adjac transposi tion first show exist list modifi result previou section show set linear extens poset list success extens differ one two adjac transposit let us say order ff extens p delay c thu go show exist delay 2 order ep furthermor list done constant amort time exist delay 3 order difficult show g graph g k denot graph vertex set g edg everi pair vertic connect path length k g word incid matrix g k incid matrix g k arithmet done mod 2 cube g g 3 squar g g 2 poset p delay k order g 0 p k hamiltonian result sekanina 19 cube everi connect graph hamiltonian sinc g 0 p alway connect g 0 p 3 hamiltonian delay 3 order exist graph g 0 p alway 2connect otherwis exist delay 2 order would impli result fleischner 7 state squar everi 2connect graph hamiltonian even though g 0 p gener 2connect poset 2connect transposit graph easi character first consid question transposit graph pendant vertic p consist two disjoint chain g 0 p two pendant vertic p bposet disjoint union two chain g 0 p one pendant vertex otherwis g 0 p pendant vertic lemma 51 everi poset p graph hp 2connect hp pendant vertic may proven show everi pair incid edg hp 4 6 8cycl lemma help us find effici algorithm list delay 2 order ep instead prove appli theorem 33 follow lemma lemma 52 g bipartit g theta k 2 hamiltonian g 2 hamiltonian proof let g bipartit graph n vertic let hamiltonian cycl g theta k 2 v consid sequenc vertic sinc g bipartit g theta k 2 thu vertic vertic one partit set g theta k 2 also vertex u g u 1 u 2 adjac therefor differ partit set g theta k 2 therefor vertex g appear exactli vertic v v i2 either distanc one g distanc two g x therefor hamiltonian cycl g 2 conjectur lemma 52 may extend graph bipartit conjectur 53 g theta k 2 hamiltonian g 2 hamiltonian graph class hs close walk visit everi vertex least time time see 8 14 thu h1 1 class hamiltonian graph observ g theta k 2 hamiltonian g 2 h1 2 consid walk result two copi g identifi convers true g triangl pendant edg ad vertex g 2 h1 2 g theta k 2 hamiltonian theorem 33 show everi poset p graph g 0 p h1 2 gener graph hamiltonian make conjectur conjectur 54 g 2 h1 2 g 2 hamiltonian exampl k 26 show convers conjectur fals proof lemma 52 construct appli construct g 0 p yeild follow result theorem 55 linear extens poset gener delay 2 constant amort time proof run algorithm genl given figur 8 instead suppress linear extens neg sign suppress everi linear extens ie gener list l 1 output list l 1 proof lemma 52 delay 2 list linear extens run time genl ie constant amort time remaind section discuss use algorithm comput use version genl gener extens exactli twice success extens differ adjac transposit predecessor first discuss comput p let us defin xyrun maxim sequenc success extens x preced maintain two array integ call valu sx sum length previou xyrun valu x iter current xyrun start iter exactli one adjac pair say xy transpos occur tth iter sx increment gamma x x set termin algorithm divid 2ep sinc constant amount updat done iter total comput comput hx proceed similar fashion xrun maxim sequenc extens x occupi posit valu sx weight sum length previou xrun x iter current xrun start iter exactli one adjac pair say xy transpos occur tth iter sz increment pz set pz posit z occupi extens termin valu hx sx divid 2ep 6 conclud remark algorithm given section 6 gener linear extens poset constant amort time improv amort time algorithm 11 fastest previous known algorithm refin work present would gener linear extens loopfre algorithm ie constant comput worst case produc new extens current one fulli implement count gener algorithm c found quit effici practic sun sparcstat slc program gener 2702765 extens 12 element fenc poset 42 second extens count euler number count took 17 second 199360981 extens 14 element fenc count 91 second gener 281 second 2674440 extens 2 14 grid gener 83 second extens count catalan number enumer linear extens poset recent shown pcomplet algorithm section 3 constitut first constant amort time algorithm gener natur defin class combinatori object associ count problem pcomplet lead interest question complex gener combinatori object count pcomplet pcomplet problem admit constant amort time gener algo rithm ask question assum initi object suppli part input exampl hamiltonian cycl input would consist graph g hamiltonian cycl g similarli paper assum linear extens input poset intuit exist question difficult npcomplet gener question difficult well answer even formal intuit even exist question easi p mani problem complex gener unknown exampl ideal given input poset gener constant amort time count ideal pcomplet find ideal trivial gener span tree graph constant amort time find span tree count number tree p one discov constant amort time algorithm gener span tree fact interest relationship constant amort time gener algorithm complex exist andor count relat question variou polynomi time complex measur instead constant amort time consid johnson yannakaki papadimitri 9 acknowledg would like thank derek corneil mike fellow carla savag help discuss malcolm smith work figur especi ken wong implement algorithm care read manuscript note ad proof point l babai privat commun easi contriv pcomplet object gener quickli start pcomplet object pump number instanc take union easilycount easilygener numer object exam ple given poset p n vertic consid set fx x ideal pg fx x g set pcomplet count given appropri represent easi gener constant amort time counterexampl twentyfour vertic conjectur 53 54 recent found j van den heuvel privat commun r webster new collegi dictionari combinatori theori calcul invari order set count linear extens gray code restrict densiti hamilton path minim chang algorithm squar everi twoconnect graph hamiltonian gener maxim independ set gener permut adjac transposit gener topolog sort structur program gener topolog sort ar rangement complex machin schedul problem gener hamilton gener linear extens certain poset transposi tion adjac interchang gener combin order set vertic connect graph hamilton path graph linear extens union poset one hundr problem elementari mathemat algorithm 115 perm algorithm gener topolog sort arrang element combinatori comput combinatori algorithm tr ctr scott effler frank ruskey cat algorithm gener permut fix number invers inform process letter v86 n2 p107112 jeanluc baril vincent vajnovszki minim chang list luca string graph theoret consequ theoret comput scienc v346 n2 p189199 28 novemb 2005 j sawada oracl vertex elimin order theoret comput scienc v341 n1 p7390 5 septemb 2005 l chandran l ibarra f ruskey j sawada gener character perfect elimin order chordal graph theoret comput scienc v307 n2 p303317 7 octob karel de loof han de meyer bernard de baet exploit lattic ideal represent poset fundamenta informatica v71 n23 p309321 august 2006 gang wang wenrui gong ryan kastner instruct schedul use maxmin ant system optim proceed 15th acm great lake symposium vlsi april 1719 2005 chicago illinoi usa russ bubley martin dyer faster random gener linear extens proceed ninth annual acmsiam symposium discret algorithm p350354 januari 2527 1998 san francisco california unit state karel bertet jen gustedt michel morvan weakord extens order theoret comput scienc v304 n13 p249268 28 juli larri huston rahul sukthankar rajiv wickremesingh satyanarayanan gregori r ganger erik riedel anastassia ailamaki diamond storag architectur earli discard interact search proceed 3rd usenix confer file storag technolog march 3131 2004 san francisco ca martin charl golumb ron shamir complex algorithm reason time graphtheoret approach journal acm jacm v40 n5 p11081133 nov 1993