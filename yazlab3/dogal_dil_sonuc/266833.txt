cach sensit modulo schedul paper focus interact softwar prefetch bind nonbind softwar pipelin vliw machin first shown evalu softwar pipelin schedul without consid memori effect rather inaccur due stall caus depend memori instruct even lockupfre cach consid also shown penalti stall gener higher effect spill code second show gener bind scheme power nonbind one softwar pipelin schedul final main contribut paper heurist scheme schedul memori oper accord local estim compil time attribut depend graph propos scheme shown outperform heurist approach sinc achiev better tradeoff comput stall time other b introduct softwar pipelin wellknown loop schedul techniqu tri exploit instruct level parallel overlap sever consecut iter loop execut parallel 14 differ algorithm found literatur gener softwar pipelin sched ule popular scheme call modulo schedul main idea scheme find fix pattern oper call kernel steadi state consist oper distinct iter find optim schedul resourc constrain scenario npcomplet problem practic propos base differ heurist strategi key goal scheme achiev high throughput eg 14112018 minim regist pressur eg 96 eg 1015716 none evalu effect memori scheme assum fix latenc memori oper usual correspond cachehit latenc lockupfre cach allow processor stall cach miss howev vliw architectur processor often stall afterward due true depend previou memori oper altern schedul load use cachemiss latenc requir consider instruct level parallel increas regist pressur 1 softwar prefetch effect techniqu toler memori latenc 4 softwar prefetch perform two altern scheme bind nonbind prefetch ing first altern also known earli schedul memori oper move memori instruct away instruct depend second altern introduc code special instruct call prefetch instruct nonfault instruct perform cach lookup modifi regist altern prefetch scheme differ drawback bind scheme increas regist pressur lifetim valu produc memori oper stretch may also increas initi interv due memori oper belong recurr nonbind scheme increas memori pressur sinc increas number memori request may produc increas initi interv besid may produc increas regist pressur sinc lifetim valu use comput effect address stretch higher regist pressur may requir addit spill code result addit memori pressur paper investig interact softwar prefetch softwar pipelin vliw machin first show previou scheme consid effect memori penalti produc schedul far optim evalu take account realist cach memori evalu sever heurist schedul memori oper insert prefetch instruct softwar pipelin schedul contribut stall spill code quantifi case show stall penalti much higher impact perform spill code propos heurist tri trade initi interv stall time order minim execut time softwar pipelin loop final show scheme base bind prefetch effect base nonbind prefetch softwar pipelin schedul use bind nonbind prefetch previous studi 121 4813173 respect among other howev knowledg previou work analyz interact prefetch scheme softwar pipelin techniqu select schedul 1 schedul oper cachehit latenc other cachemiss latenc like scheme propos paper howev select schedul base profil inform wherea method base static analysi perform compiletim addit select schedul consid interact softwar pipelin rest paper organ follow section 2 motiv impact memori latenc may softwar pipelin loop section 3 evalu perform simpl scheme schedul load store instruct section 4 describ new algorithm propos paper section 5 explain experiment methodolog present perform result final main conclus summar section 6 2 motiv softwar pipelin loop via modulo schedul character basic two term initi stage counter former indic number cycl initi success iter latter show mani iter lap way execut time loop calcul given architectur given schedul first term sum call comput time rest paper fix determin compil time stall time mainli due depend previou memori instruct depend runtim behavior program eg miss ratio outstand miss etc order minim execut time classic method tri minim initi interv goal reduc fix part exec minimum initi interv bound resourc recurr lower bound due resourc constraint architectur assum function unit pipelin calcul indic number oper type loop bodi indic number function unit type architectur lower bound due recurr graph comput repres sum node latenc recurr repres sum edg distanc recurr particular data flow depend graph given architectur result ii depend latenc schedul assign oper latenc oper usual known compil except memori oper variabl latenc ii also depend affect spill code introduc schedul paramet fix convent modulo schedul propos use fix latenc usual cachehit time schedul memori instruct schedul instruct minimum latenc minim regist pressur thu reduc spill code hand minimum latenc schedul increas stall time data depend particular oper need data load previou instruct memori access finish yet processor stall data avail figur 1 show sampl schedul data depend graph given architectur case memori instruct schedul cachehit latenc stall time ignor ii sc re ii rec ii re ii re max op arch nop op nfu op ii rec ii rec max rec graph lat rec dist rec usual studi deal softwar pipelin techniqu expect optimist execut time suppos huge obvious optimist estim actual execut time rather inaccur instanc suppos miss ratio n1 load oper 025 eg stride 1 4 element per cach line everi cach miss processor stall cycl call penalti penalti particular memori instruct depend hit latenc miss latenc distanc schedul memori oper first instruct use data produc memori instruct depend n1 n2 penalti 9 cycl stall time assum remain depend produc penalti therefor case actual execut time near twice optimist execut time assum miss ratio 1 instead 025 discrep optimist actual execut time even higher case stall time therefor load mult load add store1357n1 alu mem b data flow depend graph b code schedul c kernel instruct latenc loadstor origin code enddo figur 1 sampl schedul memori refer consid effect stall time could greater discrep optimist estim usual util evalu perform softwar pipelin schedul actual perform could much higher also conclud schedul scheme tri minim stall time may provid signific advantag paper propos schedul evalu compar other use exec metric requir consid runtim behavior individu memori refer requir simul memori system 3 basic scheme schedul memori oper section evalu perform basic scheme schedul memori oper point drawback motiv new approach propos next section alreadi mention previou section modulo schedul scheme usual schedul memori oper use cachehit latenc scheme call cachehit latenc chl scheme expect produc signific amount processor stall suggest previou section approach reduc processor stall insert prefetch instruct everi memori oper instruct schedul distanc equal cachemiss latenc actual memori refer scheme call insert prefetch alway ipa howev scheme may result increas number oper due prefetch instruct also addit spill code therefor may requir ii higher previou approach final altern approach schedul memori oper use cachemiss latenc scheme call earli schedul alway esa scheme prefetch data without requir addit instruct may result increas ii memori instruct recurr besid may also requir addit spill code figur 2 compar perform three scheme specfp95 benchmark two differ architectur detail evalu methodolog architectur given section 5 column split comput stall time figur also shown lower bound execut time opt lower bound correspond execut program memori oper schedul use cachehit latenc minim spill code assum alway hit cach result null stall time lower bound defin optimist execut time section 2 main conclus drawn figur 2 perform three realist scheme far away lower bound gener chl scheme result signific percentag stall time aggress architectur stall time repres 50 execut time program ipa scheme reduc significantli stall time complet due fact program especi tomcatv swim cach interf instruct short distanc therefor prefetch alway effect may collid replac data use besid ipa scheme result signific increas comput time program eg hydro2d turb3d among other esa scheme practic elimin stall time remain stall time basic due lack entri outstand miss tabl use implement lockupfre cach howev scheme increas significantli comput time program like turb3d factor 3 aggress architectur mgrid hydro2d due memori refer recurr limit ii 4 csm algorithm section propos new algorithm call cach sensit modulo schedul csm tri minim comput time stall time term independ reduc one may result increas shown previou section propos algorithm tri find best tradeoff two term csm algorithm base earli schedul select chosen memori oper schedul memori oper use cachemiss latenc hide almost memori latenc shown previou section without increas much number instruct oppos use prefetch instruct howev increas execut time three way may increas regist pressur therefor may increas due spill code perform loop bound memori oper may increas latenc memori oper augment may increas length individu loop iter may increas augment cost prolog epilog figur 2 basic scheme perform chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt020610 normal loop execut time tomcatv swim su2cor hydro2d mgrid turb3d specfp95chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt chl ipa esa opt020610 normal loop execut time tomcatv swim su2cor hydro2d mgrid turb3d 1257 3084 simpl architectur b aggress architectur ii ii rec two main issu csm algorithm reduct impact recurr ii minim stall time problem cost prolog epilog handl comput two altern schedul focu minim stall time ii howev one reduc impact prolog epilog expens increas stall time wherea care prolog epilog cost depend number iter loop effect one chosen core csm algorithm shown figur 3 algorithm make use static local analysi addit issu order determin latenc consid schedul individu instruct local analysi base analysi present 19 divid three step reus analysi comput intrins reus properti memori instruct propos 21 goal determin kind reus exploit refer loop five type reus determin none selftempor selfspati group tempor groupspati interfer analysi use initi address refer previou reus analysi determin whether two static instruct alway conflict cach besid selfinterfer also taken account consid stride exhibit static instruct refer interfer refer figur 3 csm algorithm function csmsinnerloop il return schedul recurrencesingraph els endif niter upperbound return sch1 els return sch2 endif endfunct function computeschedminreceffectgraph g return schedul re foreach recurr r g ii rec r ii endif endforeach return computeschedulingg endfunct function minimizerecurrenceeffectrec r int ii return integ orderinstructionsbylocalityr ii rec r ii endwhil return endfunct figur 4 schedul loop recurr enc consid type local even exhibit type reus volum analysi determin refer exploit reus displac cach base comput amount data use refer loop analysi conclud refer expect exhibit local reus interfer includ volum data consecut reus lower cach size initi two data depend graph node edg gener differ latenc assign node grph1 memori node tag accord local analysi tag cachehit latenc exhibit type local cachemiss latenc otherwis grph2 memori node tag cachemiss latenc schedul minim impact recurr ii comput graph use function computeschedminreceffect shown figur 4 first step function chang latenc memori oper insid recurr limit ii cachemiss cachehit ii limit resourc constrain recurr node modifi chosen accord local prioriti order start one exhibit local second step comput actual schedul use modifi graph step perform softwar pipelin schedul propos literatur final minimum number iter upperbound ensur sch2 better sch1 comput main differ two schedul cost prolog epilog part lower sch1 bound depend comput schedul result local analysi calcul estim execut time schedul sch1 chosen execut time given schedul estim stall time estim penalti calcul explain section 2 missratio estim local analysi way sch1 prefer sch2 use schedul accord local chl achiev minimum sc order take account possibl poor local loop 5 perform evalu csm section present perform evalu csm algorithm compar perform basic scheme evalu section 3 also compar alter est est stall est niter penalti op op mem penalti latmiss cycleus cycleprod op mem nativ bind earli schedul nonbind insert prefetch instruct prefetch scheme 51 architectur model vliw machin consid evalu perform differ schedul algorithm model two architectur order evalu differ aspect produc schedul execut time stall time spill code etc first architectur call simpl compos four function unit integ float point branch memori cachemiss latenc first level cach 10 cycl second architectur call aggress two function unit type cachemiss latenc 20 cycl function unit fulli pipelin except divid squar root oper model first memori level correspond 8kb lockupfre directmap cach line 32 byte 8 outstand miss featur model architectur depict tabl 1 model architectur two reason processor stall instruct requir operand avail yet eg read second level cach b memori instruct produc cach miss alreadi 8 outstand miss 52 experiment framework local analysi schedul task perform use ictineo toolset 2 ictineo sourc sourc translat produc code sentenc semant similar current machin instruct translat code lowlevel represent appli classic optim depend graph innermost loop construct accord particular prefetch approach instruct schedul instruct latenc machin model simpl aggress integ branch fu 1 2 float point memori cach size 8 kb div sqrt pow 12 line size outstand miss 8 control memori latenc 110 120 branch 2 number regist 32 call return 4 tabl 1 model architectur use softwar pipelin algorithm particular softwar pipelin algorithm use experi report hrm 15 shown effect minim ii regist pressur result code instrument gener trace feed simul architec ture program run first 100 million memori refer perform figur shown section refer innermost loop contain part program measur memori refer insid innermost loop repres 95 memori instruct consid benchmark statist innermost loop quit repres whole section program differ prefetch algorithm evalu follow specfp95 benchmark tomcatv swim su2cor hydro2d mgrid turb3d restrict evalu fortran program sinc current ictineo tool process fortran code 53 earli schedul section compar csm algorithm scheme base earli schedul memori oper scheme use alway cachehit latenc chl ii use alway cachemiss latenc esa iii schedul instruct type local use cachehit latenc schedul remain one use cachemiss latenc later scheme call earli schedul accord local esl differ algorithm evalu term execut time split comput stall time stall time due depend lack entri outstand miss tabl figur 5 see result simpl aggress architectur benchmark column normal chl execut time seen csm algorithm achiev comput time close chl scheme wherea chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csms020610 normal loop execut time tomcatv swim su2cor hydro2d mgrid turb3d 1593 1371 chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csm chl esa esl csms020610 normal loop execut time tomcatv swim su2cor hydro2d mgrid turb3d simpl architectur b aggress architectur figur 5 csm algorithm compar earli schedul stall time close esa scheme result best tradeoff comput stall time program recurr limit initi interv therefor esa scheme increas comput time instanc hydro2d turb3d benchmark csm method minim effect expens slight increas stall time tabl 2 show rel speedup differ schedul respect chl scheme averag altern schedul outperform chl scheme usual one use softwar pipelin schedul howev program mainli turb3d esa esl schedul perform wors chl due increas ii caus recurr csm algorithm achiev best perform benchmark simpl architectur averag speedup 161 aggress architectur 247 tabl 3 compar csm algorithm optimist execut time opt defin section 3 use lower bound execut time also show percentag execut time processor stall seen simpl architectur csm algorithm close optimist bound caus almost stall aggress architectur perform csm wors opt stall time repres 10 total execut time notic howev optimist bound could quit actual minimum execut time tabl 4 compar differ scheme use chl algorithm refer point scheme show increas comput time decreas stall time seen schedul memori oper use cachemiss latenc affect initi interv stage counter result increas comput time column denot dcomput repres increment comput time compar chl schedul scheme calcul stall time due depend elimin schedul memori instruct use cachemiss latenc default spill code schedul use cachehit latenc therefor may caus stall although unlik spill code usual store follow load address sinc usual close otherwis spill code hardli reduc regist pressur load caus stall interfer memori esa esl csm esa esl csm tomcatv 234 228 257 392 341 556 su2cor hydro2d 113 100 145 113 100 278 mgrid 115 100 117 112 100 119 turb3d 062 073 118 027 033 142 geometr mean 136 122 161 148 115 247 tabl 2 rel speedup dcomput stall refer store column denot stall repres percentag stall time caus chl algorithm avoid scheme calcul see tabl 4 csm algorithm achiev best tradeoff comput time stall time reason outperform other esa scheme best one reduc stall time expens larg increment comput time 54 insert prefetch instruct order reduc penalti caus memori oper altern earli schedul memori instruct insert prefetch instruct provid mani current instruct set architectur eg touch instruct powerpc 5 new scheme introduc addit spill code sinc increas regist pressur particular lifetim valu use comput effect address increas sinc use optcsm stall optcsm stall su2cor 0972 192 0873 1117 hydro2d 0978 018 0962 184 mgrid 0998 turb3d 0951 254 0709 1954 geometr tabl 3 csm compar opt schedul esa esl csm esa esl csm dcomput stall dcomput stall dcomput stall dcomput stall dcomput stall dcomput stall su2cor 1048 10000 1015 254 1009 9590 1215 9767 1060 409 1018 9327 hydro2d 1308 9999 1008 379 1021 9962 2532 9985 1067 484 1020 9898 mgrid 1023 9989 0999 359 1001 9968 1469 8758 1030 519 1337 8757 turb3d 1184 9435 1055 8575 1184 9435 7222 9821 5948 8759 1134 7248 geometr tabl 4 increment comput time decrement stall time relat chl stall chl stall prefetch ordinari memori instruct also increas initi interv due addit memori instruct evalu three altern scheme introduc prefetch instruct insert prefetch alway ipa ii insert prefetch refer without tempor local even exhibit spatial local accord static local analysi ipt iii insert prefetch instruct without type local ipl first scheme expect result stall requir mani addit instruct may increas ii ipt scheme select ad prefetch instruct howev add unnecessari prefetch instruct refer spatial local instruct spatial local caus cach miss new cach line access cach ipl scheme conserv sens add less number prefetch instruct figur 6 compar total execut time csm schedul abovement prefetch scheme figur normal chl schedul csm scheme alway perform better scheme base insert prefetch instruct except mgrid benchmark aggress architectur latter case ipa scheme best one perform csm close among scheme insert prefetch instruct none outperform other gener depend particular program architectur best one among differ one prefetch scheme outperform chl scheme gener ie perform figur figur 6 gener lower 1 case may even wors chl gener wors scheme base earli schedul compar bind figur 5 nonbind figur scheme observ bind prefetch alway better three first benchmark scheme similar per simpl architectur b aggress architectur figur 6 csm algorithm compar insert prefetch instruct ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csms020610 normal loop execut time tomcatv swim su2cor hydro2d mgrid turb3d ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csm ipa ipt ipl csms020610 normal loop execut time tomcatv swim su2cor hydro2d mgrid turb3d formanc next two benchmark last one nonbind prefetch outperform bind scheme understand reason behavior prefetch scheme present addit statist aggress architectur tabl 5 show percentag addit memori instruct execut csm algorithm scheme base insert prefetch instruct csm algorithm addit instruct due spill code wherea scheme due spill code prefetch instruct see tabl except ipl scheme mgrid benchmark prefetch scheme requir much higher number addit memori instruct expect increas number memori instruct ipa scheme highest follow ipt ipl final csm tabl 6 show increas comput time decreas stall time scheme base insert prefetch instruct relat chl scheme neg number indic stall time increas instead decreas see tabl 6 comput time increas prefetch scheme sinc larg number addit instruct may impli signific increas ii loop memori bound stall time gener reduc reduct less csm scheme see tabl 4 program mgrid one prefetch base scheme ipa outperform csm algorithm howev differ slight remain program perform csm scheme overwhelmingli better ipa scheme tabl 7 show miss ratio differ prefetch scheme compar miss ratio nonprefetch scheme chl see gener scheme insert memori prefetch produc highest reduct miss ratio howev insert prefetch instruct remov cach miss even scheme insert prefetch everi memori instruct ipa due cach interfer prefetch instruct 1there spill code simul part program csm insert prefetch instr ipa ipt ipl su2cor hydro2d 212 5549 3994 285 mgrid 4990 5926 5657 750 tabl 5 percentag addit memori refer prefetch data use quit common program tomcatv swim instanc two memori refer interfer cach close code like two prefetch correspond schedul memori refer case least one two memori refer miss spite prefetch besid prefetch memori instruct schedul revers order ie instruct schedul b prefetch b schedul prefetch memori instruct miss summar two main reason bad perform scheme base insert prefetch instruct compar csm scheme increas comput time due addit prefetch instruct spill code alway effect remov stall caus cach miss due interfer prefetch instruct ipa ipt ipl dcomput stall dcomput stall dcomput stall tomcatv 1396 2328 1060 6714 1073 1942 su2cor 1454 7448 1269 8220 1090 325 hydro2d 1608 8487 1086 8681 1003 416 mgrid 1311 8832 1267 3544 1030 537 turb3d 1874 6891 1787 7390 1497 8260 geometr tabl 6 increment comput time decrement stall time scheme base insert prefetch instruct chl ipa ipt ipl su2cor 2543 235 568 2155 hydro2d 1957 133 504 1880 mgrid 646 057 291 535 turb3d 1068 211 239 264 geometr tabl 7 miss ratio chl differ prefetch scheme 6 conclus interact softwar prefetch softwar pipelin techniqu vliw architectur studi shown modulo schedul scheme use cachehit latenc produc mani stall due depend memori instruct simpl architectur stall time repres 32 execut time 63 aggress architec ture thu ignor memori effect evalu softwar pipelin schedul may rather inaccur compar perform differ prefetch approach base either earli schedul memori instruct bind prefetch insert prefetch instruct nonbind prefetch seen provid signific improv gener howev method base earli schedul outperform base insert prefetch main reason wors perform latter method increas memori pressur due prefetch instruct addit spill code limit remov shortdist conflict miss propos heurist schedul algorithm csm base earli schedul tri minim comput stall time algorithm make use static local analysi schedul instruct recurr shown outperform rest strategi instanc compar approach base schedul memori instruct use cachehit latenc produc code 16 time faster simpl architectur 25 time faster aggress architectur former case also shown execut time close optimist lower bound r tr softwar pipelin effect schedul techniqu vliw machin softwar prefetch data local optim algorithm circular schedul architectur softwarecontrol data prefetch design evalu compil algorithm prefetch lifetimesensit modulo schedul balanc schedul evolut powerpc architectur iter modulo schedul minim regist requir resourceconstrain rateoptim softwar pipelin optimum modulo schedul minimum regist requir compil techniqu data prefetch powerpc stage schedul hypernod reduct modulo schedul predict loadstor instruct latenc decompos softwar pipelin static local analysi cach manag swing modulo schedul ctr jess snchez antonio gonzlez instruct schedul cluster vliw architectur proceed 13th intern symposium system synthesi septemb 2022 2000 madrid spain enric gibert jess snchez antonio gonzlez effect instruct schedul techniqu interleav cach cluster vliw processor proceed 35th annual acmiee intern symposium microarchitectur novemb 1822 2002 istanbul turkey jess snchez antonio gonzlez modulo schedul fullydistribut cluster vliw architectur proceed 33rd annual acmiee intern symposium microarchitectur p124133 decemb 2000 monterey california unit state enric gibert jess snchez antonio gonzlez local schedul techniqu memori coher cluster vliw processor distribut data cach proceed intern symposium code gener optim feedbackdirect runtim optim march 2326 2003 san francisco california javier zalamea josep llosa eduard ayguad mateo valero twolevel hierarch regist file organ vliw processor proceed 33rd annual acmiee intern symposium microarchitectur p137146 decemb 2000 monterey california unit state enric gibert jess snchez antonio gonzlez interleav cach cluster vliw processor proceed 16th intern confer supercomput june 2226 2002 new york new york usa javier zalamea josep llosa eduard ayguad mateo valero modulo schedul integr regist spill cluster vliw architectur proceed 34th annual acmiee intern symposium microarchitectur decemb 0105 2001 austin texa alex alet josep codina jess snchez antonio gonzlez graphpartit base instruct schedul cluster processor proceed 34th annual acmiee intern symposium microarchitectur decemb 0105 2001 austin texa enric gibert jesu sanchez antonio gonzalez distribut data cach design cluster vliw processor ieee transact comput v54 n10 p12271241 octob 2005 javier zalamea josep llosa eduard ayguad mateo valero softwar hardwar techniqu optim regist file util vliw architectur intern journal parallel program v32 n6 p447474 decemb 2004