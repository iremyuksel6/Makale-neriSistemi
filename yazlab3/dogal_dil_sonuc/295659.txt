finitari fair fair mathemat abstract multiprogram environ fair abstract detail admiss fair schedul distribut environ fair abstract rel speed processor argu standard definit fair often unnecessarili weak replac stronger yet still abstract notion finitari fair standard weak fair requir enabl transit postpon forev finitari weak fair requir everi comput system unknown bound k enabl transit postpon k consecut time gener finitari restrict finf given fair requir fi union ohgrregular safeti properti contain f adequaci propos abstract shown two way suppos prove program properti assumpt finitari fair multiprogram environ program satisfi properti fair finitest schedul distribut environ program satisfi properti choic lower upper bound speed time processor benefit finitari fair twofold first proof rule verifi live properti concurr program simplifi wellfound induct natur number adequ prove termin finitari fair second fundament problem consensu faulti asynchron distribut environ solv assum finitari fair b introduct interleav semant provid eleg abstract way model concurr comput approach comput concurr system obtain let step one enabl process execut atom instruct interleav comput system satisfi properti properti hold implement program independ whether task multiprogram processor schedul polici use whether system distribut speed differ processor furthermor interleav model simpl reduc concurr nondetermin preliminari version paper appear proceed ninth ieee symposium logic comput scienc pp 5261 1994 leav bell laboratori lucent technolog z support part onr yip award n000149510520 nsf career award ccr9501708 nsf grant ccr9504469 afosr contract f496209310056 arpa grant nag2892 contract 95dc324a interleav abstract adequ prove safeti properti system safeti properti form someth bad never happen exampl mutual exclus howev usual suitabl prove guarante properti guarante properti form someth good eventu happen exampl termin gener live properti tradit approach establish guarante properti requir fair comput instead comput satisfi properti intuit fair mean individu process ignor forev sinc reason implement system whether multiprogram multiprocess expect fair prove program satisfi properti assumpt fair follow properti hold possibl implement program theori specif verif use differ form fair well understood see exampl lps82 fra86 mp91 fair two major drawback first mathemat treatment fair verif semant complic requir higher ordin second fair weak yield suitabl model faulttoler distribut comput illustr celebr result fischer lynch paterson standard fair assumpt process reach agreement asynchron distribut system even one process fail quot paper flp85 result show problem distribut consensu solv practic rather point need refin model distribut comput better reflect realist assumpt processor commun time propos one refin model introduc notion finitari fair argu finitari fair 1 suffici abstract captur possibl implement context multiprogram context distribut comput 2 suffer either two aforement disadvantag associ standard notion fair justif finitari fair fair requir specifi subset f set possibl way schedul differ process program let us first consid multiprogram environ task schedul singl processor schedul meet given fair requir f program whose languag ie set comput contain f languag program safeti properti ie close limit furthermor schedul finitest languag regular thu captur finitest schedul implement f suffic consid countabl union regular safeti properti contain f sever popular definit f strong fair weak fair etc lps82 fra86 everi choic f obtain finitari version finf union regular safeti properti contain f case weak fair f show finitari version finf particularli intuit f prohibit schedul postpon task forev finf also prohibit schedul bound mani consecut time task postpon gener fair requir f regular live properti afk88 show finitari version finf still live regular let us consid distribut environ task execut concurr differ processor finitari fair correspond assumpt execut speed processor stay within certain unknown fix bound formal distribut system model transit system impos lower upper time bound transit hmp94 show time transit system satisfi properti choic lower upper time bound iff underli untim transit system satisfi properti finitari weak fair correspond theorem establish adequaci finitari fair distribut system addit provid method prove properti time system whose time known priori summar finitari fair abstract detail fair finitest schedul detail independ speed time processor bound drift parametr definit finitari fair also lend gener comput fair comput version comf fair assumpt f countabl union recurs safeti properti contain f multiprogram environ comput fair abstract detail fair comput schedul distribut environ comput fair abstract independ speed processor whose drift bound recurs function benefit finitari fair verif address problem verifi program satisfi properti finitari fair assumpt finf sinc finf regular specifi tempor logic howev obstacl verif finitest program show program satisfi temporallog specif finf iff satisfi specif f mean finitest program move finitari fair call chang verif algorithm gener program proof rule verifi live properti simplifi use finitari fair suppos wish prove program termin prove comput program termin one typic identifi rank variant function state program natur number rank decreas everi transit program method complet prove termin fair comput first may rank function decreas everi step standard complet verif rule rather reli rank function never increas guarante decreas eventu lps82 fra86 purpos one need identifi socal help transit caus rank function decreas second induct natur number complet prove fair termin one may resort induct ordin higher show prove termin program finitari weak fair reduc prove termin comput transform program transform program use new integ variabl unspecifi initi valu repres bound mani consecut time enabl transit may postpon sinc termin comput transform program prove use strictli decreas rank function natur number reason finitari fair conceptu simpler reason standard fair distribut consensu central problem faulttoler distribut comput consensu problem requir nonfaulti process distribut system agre common output valu psl80 although consensu reach asynchron model one process fail flp85 practic consensu achiev distribut applic use construct like timeout suggest asynchron model standard fair assumpt use abstract studi faulttoler one propos solut problem consid unknowndelay model also call partial synchron model fix upper bound rel speed differ compon bound known priori dls88 aat97 rw92 asynchron model finitari fair assumpt abstract formul unknowndelay model particular prove asynchron model finitari fair assumpt admit waitfre solut consensu toler arbitrari number process failur show finitari fair substitut time assumpt solut aat97 inform motiv bound fair introduc gener definit finitari fair section 3 applic sec tion 4 5 begin motiv finitari version weak fair intuit concept bound fair consid follow simpl program p 0 boolean variabl x integ variabl initi repeat x x forev k repeat program p 0 consist two process one transit transit l complement valu boolean variabl x transit r increment valu integ variabl comput p 0 infinit sequenc state start initi state everi state obtain predecessor appli one two transit purpos exampl schedul infinit word alphabet fl rg comput p 0 correspond schedul specifi order transit taken comput two process p 0 execut either multiprogram distribut environ multiprogram multiprogram environ two process p 0 schedul singl processor schedul set possibl schedul one typic requir schedul fair shut one two process forev formal schedul fair iff contain infinit mani l transit infinit mani r transit schedul fair iff contain fair schedul set fair schedul restrict set comput program p 0 correspond fair schedul p 0 satisfi properti oe iff everi comput p 0 whose schedul f1 satisfi oe instanc fair assumpt f1 program p 0 satisfi properti fair comput valu x true infinit mani state valu even infinit mani state note comput p 0 correspond unfair schedul satisfi formula oe 1 thu fair assumpt necessari establish program p 0 satisfi properti oe 1 fair requir f1 abstract admiss reallif schedul name schedul transit eventu nonprobabilist reallif schedul howev finitest therefor must put bound eventu consid instanc roundrobin schedul schedul transit l r altern roundrobin schedul replac fair assumpt f1 much stronger assumpt f 1 contain two schedul lr rl f 1 program p 0 satisfi properti impli properti oe 1 call f 1 1bound schedul gener posit integ k kbound schedul never schedul one transit k time row formal schedul kbound k 1 iff contain neither subsequ l k1 r k1 schedul kbound iff contain kbound schedul similar definit consid jay88 let f k set kbound schedul assumpt f k kbounded cours suffici abstract k easi build fair finitest schedul kbound let us say schedul bound iff kbound posit integ k schedul bound iff contain bound schedul clearli everi fair finitest schedul bound order prove properti program implement suffic prove properti bound schedul set bound schedul restrict set comput program p 0 correspond bound schedul p 0 satisfi properti oe iff everi comput p 0 whose schedul f satisfi oe call f finitari restrict fair assumpt f1 three observ f immedi first finitari version f proper subset f1 particular schedul fair unbound therefor belong second set f finitest schedul countabl union fair finitest schedul third f live properti sens stepwis schedul paint corner afk88 everi finit word fl rg extend bound schedul 1 sinc finitari fair assumpt f stronger fair assumpt f1 program may satisfi properti f consid exampl properti state predic powerof2 true state iff valu power 2 comput p 0 satisfi oe must case transit l schedul powerof2 hold follow everi posit integ k subsequ length greater k contain r transit schedul belong f henc program p 0 satisfi properti oe f hand easi construct fair schedul satisfi oe show p 0 satisfi oe f1 multiprocess distribut environ two process p 0 execut simultan two processor speed two processor may differ one typic requir nonfaulti processor transit consum finit amount time fair requir f1 abstract admiss reallif processor name complet transit eventu fair assumpt f1 unnecessarili weak assum transit l execut processor requir least time l time u l two unknown ration number l u l u l l 0 similarli transit r also note set f captur random schedul given random schedul choos everi step one two transit equal probabl probabl result schedul f 0 hand probabl result schedul f1 1 execut processor ii requir least time r 0 time u r r irrespect size four time bound integ k 1 k delta l u r k delta r u l comput correspond kbound schedul follow finitari fair adequ abstract speedindepend processor note finitari fair adequ speed differ processor drift apart without bound case later gener notion finitari fair finitari fair 31 set infinit word languag alphabet sigma subset set sigma infinit word sigma instanc set comput program languag alphabet program state regular languag regular iff recogn buchi automaton nondeterminist finitest machin whose accept condit modifi suitabl accept infinit word buc62 class regular languag robust mani altern character see tho90 overview theori regular languag particular set model formula proposit linear tempor logic ptl regular languag gpss80 set comput finitest program regular languag set f1 section 2 fair schedul alphabet fl rg regular languag 23 l 23 r set f k kbound schedul everi k 1 safeti live languag pi sigma let pref pi sigma set finit prefix word pi languag pi safeti properti limitclos iff infinit word w finit prefix w pref pi w 2 pi ads86 everi safeti properti pi fulli character pref pi sinc program execut step step set comput program safe languag alphabet program state safeti properti regular iff recogn buchi automaton without accept condit properti defin temporallog formula form 2 p p past formula ptl safe regular everi k 1 set f k section 2 kbound schedul regular safeti properti languag pi live properti iff pref everi finit word extend word pi set f1 section 2 fair schedul regular live properti topolog character consid cantor topolog infinit word distanc two distinct infinit word w w 0 12 largest nonneg integ w close set cantor topolog safeti properti dens set live properti regular languag lie first twoandahalf level borel hierarchi everi regular languag f oeffi g ffioe 2 also tempor character first twoandahalf level borel hierarchi mp90 let p past formula ptl everi formula form 2 p defin fset everi formula form 3 p gset everi formula form 23 p g ffi set everi formula form 32 p f oe set exampl set f1 fair schedul g ffi set 32 finitari restrict languag readi defin oper fin finitari restrict finpi languag pi countabl union regular safeti languag contain pi definit finitari restrict everi languag f oe also definit finpi pi follow theorem state properti oper fin theorem 1 let pi pi 0 languag 1 2 fin monoton pi ae pi 0 finpi ae finpi 0 3 fin distribut intersect finpi proof first two follow immedi definit fin sinc pi pi 0 contain pi well pi 0 monoton prove inclus definit fin exist regular safeti properti 1 class safeti properti close intersect class regular languag henc 1 regular safeti properti sinc w follow proposit formal claim made exampl section 2 also show finitari restrict regular languag necessarili regular proposit 2 let f1 set fair schedul section 2 let f set bound schedul f finitari restrict f1 neither regular safe proof recal f union regular safeti properti contain f1 f k regular safeti properti f k ae f1 henc consid regular safeti properti g contain f1 suppos g accept buchi automaton mg alphabet fl rg without loss gener assum everi state mg reachabl initi state everi state accept state sinc g safeti properti wish prove mg k state g f k suppos word w mg accept w w contain consecut symbol type say l thu sinc mg k state follow 2 first level borel hierarchi consist class f close set class g open set second level class g ffi countabl intersect open set class f oe countabl union close set third level class f oeffi countabl intersect f oe set class g ffioe countabl union g ffi set state mg path initi state label w 0 l 0 k cycl contain whose edg label l impli mg accept word w fair schedul contradict inclus g f1 observ k 1 schedul l k extend word f k henc impli f close limit f safeti properti prove f regular suppos f regular closur properti regular languag set unbound fair schedul also regular know g nonempti contain schedul properti regular languag follow g contain word w two finit word contain least one l one r symbol mean contradict assumpt w 62 f word although f countabl union safeti properti defin ptl f neither safeti properti defin ptl defin f tempor logic one would need infinitari disjunct gener oper fin preserv live also may happen pref howev appli regular properti live preserv theorem 3 pi regular languag pref proof sinc finpi pi pref monoton pref finpi pref pi prove inclus pref pi pref finpi suppos pi regular languag sigma consid w 2 pref pi regular pi follow word w 0 2 pi w 2 finit word languag contain singl word w 0 regular safe contain pi henc immedi lead follow corollari corollari 4 pi regular live properti finpi live observ languag f1 regular live henc f also live pref mean execut program fair requir f like origin requir f1 satisfi finit number step oper fin illustr typic languag 9k everi subsequ length k pg 9k everi subsequ k ps qg 33 transit system standard fair finitari fair concurr program includ sharedmemori messagepass program model transit system mp91 transit system p tripl q set state finit set transit q 0 q set initi state state q 2 q assign valu program variabl transit 2 binari relat state q 2 state q transit let set successor q comput q transit system p infinit sequenc state q 0 2 q 0 0 transit 2 q set comput p set pip safe languag q q finit pip regular transit enabl ith step comput q iff q nonempti taken ith step q iff q loss gener assum set program variabl contain everi transit 2 boolean variabl enabl boolean variabl taken let schedul alphabet sigma finit set interpret boolean variabl sigma power set set fenabl taken j 2 tg given comput q p schedul oeq q project q schedul alphabet set schedul p safeti properti sigma fair requir f transit system p languag finit schedul alphabet sigma fair requir restrict set allow comput program gener f regular live properti afk88 requir live ensur execut program fair requir satisfi finit number step particular requir weak fair wf p set infinit word w everi transit 2 infinit mani integ 0 taken 2 w transit enabl forev without taken specifi follow requir wf regular live requir strong fair sf p set infinit word w everi transit 2 infinit mani step infinit mani step transit enabl infinit often without taken stronger requir weak fair sf ae wf specifi formula weakfair requir wf g ffi set strongfair requir sf neither g ffi f oe lie f oeffi g ffioe sinc set regular finitari restrict finwf finsf belong f oe live corollari 4 next theorem gener proposit 2 show finitari restrict weak strong fair coincid appropri notion bound fair defin schedul weaklykbound nonneg integ k iff transit p enabl k consecut step without taken integ 0 integ j enabl 62 w j schedul weaklybound weaklykbound k 0 similarli schedul w stronglykbound iff transit subsequ w contain k distinct posit enabl contain posit taken integ schedul stronglybound stronglykbound k 0 theorem 5 let p transit system transit set weak strong fair requir wf sf infinit word w sigma w w 2 finsf iff w stronglybound proof consid weak fair set weaklykbound schedul fix k defin formula wf stand disjunct takenen follow set weaklyk bound schedul safe regular k 0 thu everi weaklybound schedul consid regular safeti properti g contain wf suppos g accept buchi automaton mg alphabet sigma without loss gener assum everi state mg reachabl initi state everi path mg accept path suffic prove mg k state everi schedul g weaklykbound suppos let us say symbol sigma weaklyunfair transit contain enabl contain taken assumpt word w accept mg transit w contain k consecut symbol weaklyunfair sinc mg state follow cycl mg whose edg label symbol weaklyunfair impli mg accept schedul weaklyfair contradict inclus g wf observ exampl program p 0 section 2 rg proposit enabledl true everi state fair requir f1 equal wf sf impli corollari 6 p transit system least two transit finwf finsf neither regular safe comput q transit system p fair respect fair requir f write pi f p set fair comput p specif phi transit system p set infinit word alphabet q transit system p satisfi specif phi fair requir f iff pi f p phi prove p satisfi phi fair assumpt f p satisfi phi implement f prove p satisfi phi finitari restrict finf p satisfi phi finitest implement f section 4 show prove latter conceptu simpler prove former 34 time transit system time finitari fair standard model realtim system place lower upper time bound durat delay hmp94 mmt91 sinc exact valu time bound often known priori desir design program work possibl choic time bound long realiz timingbas model unknown delay differ often appropri asynchron model standard fair dls88 aat97 rw92 show unknowndelay model equival asynchron model finitari fair realtim program model time transit system hmp94 time transit system p u consist transit system two function u set transit set q0 posit ration number function associ transit lower bound 0 function u associ upper bound u interleav semant transit system extend time transit system label everi state comput realvalu time stamp time sequenc infinit nondecreas unbound sequenc real number consist given comput q underli transit system p requir transit enabl continu least time taken must stay enabl continu longer time u without taken note transit enabl state q n n j taken state q n continu enabl time sequenc consist comput q iff everi transit 2 lower bound taken 2 q j step taken 62 q upper bound enabl 2 q k step k k j taken 62 q k step k time comput q time transit system p u consist comput q p togeth consist time sequenc first compon time comput p u untim comput p u write pi u p set untim comput p u gener pi u p strict subset pip time inform u play role fair name role restrict admiss interleav enabl transit q finit like pip pi u p also regular ad94 necessarili safe time comput requir check system satisfi specif refer time untim comput suffic check system satisfi untim specif phi time transit system p u satisfi specif phi iff pi u p unknowndelay model know bound function u rather wish prove transit system p satisfi specif phi possibl choic bound function wish prove union u pi u p contain phi follow theorem show order verifi system unknowndelay model suffic verifi system finitari weak fair union u pi u p set pi finwf p theorem 7 let p transit system set transit let wf weak fair requir p let q comput p q 2 pi finwf p iff function u q0 q 2 pi u p proof consid weaklybound comput q 2 pi finwf p theorem 5 nonneg integ k schedul correspond q weaklykbound let bound function defin consid time sequenc increas 1 everi step clear lower bound requir trivial satisfi sinc q weaklykbound transit enabl k consecut step henc k taken thu consist requir satisfi q time comput p u impli prove convers suppos q 2 pi u p choic u let time sequenc q time comput p u let nonzero minimum lower bound u finit maximum upper bound u let number transit n let k integ k nu claim schedul correspond q weaklykbound suppos transit 0 enabl taken state q everi step q taken 0 hold transit 0 sinc k nu follow transit 0 taken 0 hold u distinct state q q ik sinc 0 assumpt satisfi lower bound requir impli violat upper bound requir consist contradict conclus q weaklykbound henc q 2 pi finwf p point lower bound although arbitrarili small nonzero upper bound finit necessari justifi univers quantifi choic bound function also point reason timingbas model specif bound function ie reason time computationscan significantli complic untim reason hmp94 analysi show therefor verif specif refer time conceptu simpler unknowndelay model knowndelay model 35 gap finitari standard fair definit finitari fair replac given languag pi union regular safeti properti contain pi definit seem satisfactori practic obviou mathemat gener first observ uncount union safeti properti contain pi pi safeti properti howev defin program obtain comput restrict compi pi take countabl union recurs safeti properti contain pi languag recurs iff languag ture machin clearli compi captur possibl implement pi finitest typic fall strictli finpi pi comput fair howev two advantag finitari fair name simpler verif rule solvabl consensu problem also altern finpi compi captur implement pi limit comput power recal sampl program p 0 section 2 everi schedul finpi bound unknown fix long transit postpon suppos let bound vari call schedul linearli bound iff bound allow increas linearli time everi bound schedul linearli bound schedul linearli bound bound gener given function fn natur number schedul w ofbound iff exist constant k two transit l r appear least subsequ w n w finitari fair o1fair moreov fair requir f obtain strict hierarchi stronger fair requir ff ff union ofbound schedul contain f algorithm present section 5 modifi solv distribut consensu fair requir ff fix comput choic f 4 applic program verif consid problem verifi program satisfi specif finitari fair assumpt 41 model check program variabl rang finit domain set program state finit problem verifi finitest program satisfi temporallog specif call model check autom tool model check success use check correct digit hardwar commun protocol ck96 examin effect finitari fair algorithm underli tool untim system consid finitest transit system p state set q set pip comput p regular safeti properti sinc q finit choos schedul alphabet q let f q regular fair requir let phi q regular specif given say ptl formula buchi automaton verif question problem languag inclus p satisfi phi f iff pip problem solv algorithm involv languag regular assum finitari fair need check languag inclus pip howev obviou check finf necessarili regular corollari 6 follow theorem show finitest verif finitari fair reduc verif standard fair theorem 8 regular languag pi 1 pi 2 proof finpi suppos pi 1 pi 2 nonempti sinc pi 1 pi 2 regular contain word w languag contain singl word w safe regular contain pi 1 henc w 2 finpi 1 also finpi 1 impli finpi 1 nonempti corollari obtain model check finitari fair continu use algorithm develop deal standard fair corollari 9 finitest program p set q state regular fair requir regular specif phi fair assumpt f iff satisfi phi fair assumpt finf proof want show let g languag pip assumpt p finitest pip regular sinc phi also regular g pip empti theorem time system consid finitest time transit system p u set q state suppos specif refer time given regular specif phi q verifi p u satisfi phi want check inclus pi u p problem solv construct buchi automaton recogn languag pi u p ad94 method applic bound function u fulli specifi parametr verif problem bound map fulli specifi ahv93 bound view paramet valu paramet known requir satisfi certain linear constraint 1 parametr verif problem specifi 1 finitest transit system 2 regular specif phi 3 set lu consist pair u function q0 verif problem check everi choic u 2 lu result time transit system p u satisfi specif phi defin u2lu pi u p want check pi lu p theorem 8 togeth theorem 7 impli parametr verif problem decid set lu consist function pair p finitest transit system phi regular parametr verif problem check inclus pi lu p phi decid parametr verif problem gener undecid class lu constrain allow choic bound map ahv93 instanc lu requir parametr verif problem undecid 42 proof rule termin turn verif program finitest sinc safeti specif prove independ fair assumpt need concern live specif limit prove termin program equival prove specif form 3 p state predic p finitari weak fair straightforward extend propos method verif arbitrari temporallog specif finitari version weak strong fair total termin versu termin system standard method prove termin sequenti determinist program adopt prove comput nondet minist transit system p termin call total termin p essenti need identifi wellfound domain w oe rank variant function program state w rank decreas everi program transit exampl consid rule lps82 rule prove total termin find rank function ae q wellfound domain w oe state predic t2 state q q figur rule complet prove total termin comput transit system p termin iff rule applic lps82 furthermor alway suffici choos set n natur number wellfound domain w consid requir weaklyfair comput p termin call termin p rule obvious sound prove termin complet problem may rank function decreas everi program transit standard solut identifi rank function never increas guarante decreas eventu decreas caus socal help transit whose occurr ensur weakfair requir exampl consid rule j lps82 rule j prove termin find rank function ae q wellfound domain w oe set r state predic one transit 2 let r union r 2 show state q q 0 2 q transit transit enabl q enabl q rule j complet prove termin weaklyfair comput transit system p termin iff rule j applic complet howev longer hold requir wellfound domain set n natur number transit system transfinit induct ordin higher need prove termin exampl present method prove termin finitari fair comput let us consid exampl consid transit system p 1 figur 1 state program p 1 given valu two variabl locat variabl rang f0 1g data variabl x nonneg integ initi four transit e 1 shown figur want prove weaklyfair comput p 1 termin initi transit e 1 e 2 continu enabl fair e 2 ensur eventu e 4 enabl long x posit decrement x time fair e 4 ensur figur 2 transform program finp 1 eventu result termin prove termin formal appli rule j wellfound domain choos set nfg natur number togeth ordin choos r e 1 r e 3 empti set state x belong r e 2 belong r e 4 1 rank function defin ae0 x transit e 1 e 3 leav rank unchang e 2 e 4 caus decreas reader check five premis j1j5 rule j inde satisfi notic bound number step p 1 termin unbound nondetermin make mathemat treatment fair difficult prove termin p 1 finitari weak fairnessthat prove finitari termin p 1 conceptu simpler recal everi comput finwf integ k transit enabl continu k step without taken theorem 5 follow finitari weak fair p 1 must termin within bound number step bound depend unknown constant k captur intuit transform program p 1 introduc two auxiliari variabl b c initi valu variabl b unspecifi nonneg integ program transit chang valu integ variabl c use ensur transit enabl b step without taken thu obtain new program finp 1 figur 2 origin program p 1 termin finitari weak fair assumpt finwf iff comput transform program finp 1 termin thu reduc problem prove finitari termin p 1 problem prove total termin simpl rule induct natur number suffici prove finitari termin state finp 1 tupl x c b appli rule choos set r set reachabl state 0 x c b 2 r iff b rank function map r natur number defin ae0 c reader check everi transit appli state r caus rank function decreas notic transform program finp 1 infinit mani initi state given initi state termin within bound number step consequ finp 1 suffer problem caus unbound nondetermin tradeoff prove termin p 1 total termin finp 1 clear rule j use former complex rule use latter program finp 1 complex finitari transform program let us consid gener transform given transit system consist transit finitari transform finp transit system p obtain introduc new integ variabl b transit new integ variabl c thu state space finp q theta n m1 initi valu b arbitrari initi valu c 0 thu set initi state finp q 0 theta n theta f0g everi transit 2 transit system finp contain transit fin 1 2 3 1 follow theorem establish transform fin togeth simpl rule sound complet proof method finitari termin theorem 11 transit system p termin finitari weak fair iff comput transit system finp termin proof suppos program finp nontermin comput q consid project q 0 q statespac p transit rule finp clear q 0 also comput p valu bound variabl b stay unchang throughout q let k furthermor c k invari comput q 1 sinc transit c increment time enabl taken follow comput q 0 weaklykbound henc p weaklyfair nontermin comput convers consid weaklyfair nontermin comput q p theorem 5 q weaklykbound k defin sequenc q 0 statespac finp follow 0 q 0 j maximum nonneg integ n transit j enabl taken state q n 0 easi check sinc q weaklykbound transit j enabl taken state q c consequ q 0 nontermin comput finp thu languag pi finwf p finitari weakfair comput transit system p project languag pifinp transform program finp known given transit system p fair requir f exist transit system p 0 requir uncount mani state transform program p 0 one initi state everi fair comput f yield proof principl wellfound induct n adequ 5 applic distribut consensu consid consensu problem sharedmemori model atom oper allow share regist read write formal consensu problem defin follow n process boolean input valu 2 f0 1g process decid valu v 2 f0 1g execut statement decidev model failur introduc special transit fail process transit fail enabl share regist initi 1 2 xr 3 yr 4 xr 5 els skip od 7 r r 8 fi 9 od 10 decideout figur 3 consensu assum finitari weakfair program process p input process p yet decid valu p take transit fail transit disabl p stop particip solut consensu problem must satisfi agreementthat two process decid conflict valuesand validitythat process decid valu v v equal input valu process apart two safeti requir want nonfail process decid eventu waitfreedom assert process p eventu either decid valu fail thu process must prevent anoth process reach decis algorithm must toler number process failur implicit fair assumpt asynchron model weakfair requir wf program transit except newli introduc fail transit known even program satisfi three consensu requir weakfair assumpt wf flp85 la87 hand consensu solv unknowndelay model assum upper bound delta memoryaccess time bound unknown process priori solut requir work valu delta aat97 show consensu algorithm aat97 unknowndelay model solv fact consensu finitari weakfair requir finwf algorithm shown figur 3 algorithm proce round use follow share data structur infinit twodimension array x 2 bit infinit array whose element valu 0 1 decis valu ie valu process decid written share bit initi valu addit process p local regist v contain current prefer decis valu local regist r contain current round number process round r prefer v bit xr v never set 1 consequ process decid valu v round r furthermor process decid valu v round r yr never set conflict valu v everi process reach round prefer v round ensur agreement see aat97 detail proof easi check process initi input v process ever decid v impli requir valid possibl two process conflict prefer round r resolv conflict round r proceed round r conflict prefer happen find yr first line 3 one proce choos prefer next round line 7 one finish assign yr finitari fair requir ensur behavior repeat everi round everi finitarili fair comput bound k everi process neither fail termin take step least everi k step round number exce unknown bound k process execut loop process forc take least one step suffic ensur termin theorem 12 program figur 3 satisfi requir agreement valid wait freedom finitari fair assumpt finwf contrast program satisfi waitfreedom standard fair assumpt wf also observ algorithm use potenti unbound space therefor finitest program result section 4 impli algorithm use fix number bound regist solv consensu finitari fair theorem 13 two process algorithm use finit memori satisfi requir agreement valid waitfreedom finitari fair assumpt finwf equival unknowndelay model unknowndelay model dls88 consist distribut process commun via messag deliveri time messag bound known priori establish bound number processfailur toler consensu protocol variou fault model bound establish use finitari weakfair similar observ appli result session problem unknowndelay model rw92 acknowledg notion similar kbound fair fix k defin sever place jay88 notion bound fair seem part folklor know publish account thank lesli lamport amir pnueli fred schneider gadi taubenfeld sam toueg pointer literatur help discuss r theori time automata safeti without stutter apprais fair languag distribut program parametr realtim reason defin live decis method restrict secondord arithmet consensu presenc partial synchroni imposs distribut consensu one faulti process tempor analysi fair tempor proof methodolog time transit system commun synchron parallel comput memori requir agreement among unreli asynchron process time constrain automata hierarchi tempor properti tempor logic reactiv concurr system reach agreement presenc fault impact time session problem automata infinit object verif concurr program automatatheoret framework tr fair safeti without stutter consensu presenc partial synchroni hierarchi tempor properti invit paper 1989 automata infinit object tempor logic reactiv concurr system impact time session problem parametr realtim reason theori time automata tempor proof methodolog time transit system imposs distribut consensu one faulti process computeraid verif formal method timeadapt algorithm synchron reach agreement presenc fault tempor analysi fair imparti justic fair timeconstrain automata extend abstract design synthesi synchron skeleton use branchingtim tempor logic commun synchron parallel comput