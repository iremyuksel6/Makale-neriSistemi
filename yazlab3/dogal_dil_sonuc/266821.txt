improv accuraci perform memori commun renam processor continu exploit instructionlevel parallel greater demand place reduc effect memori access latenc paper introduc novel modif processor pipelin call memori renam memori renam appli regist access techniqu load instruct reduc effect delay caus need calcul effect address load preced store data fetch memori renam allow processor specul fetch valu produc data reliabl determin without need effect address work extend previou studi data valu depend specul memori renam ad processor pipelin renam appli 30 50 memori refer translat overal improv execut time 41 furthermor improv seen across memori segmentsinclud heap segment often difficult manag effici b introduct two trend design microprocessor combin place increas burden implement memori system aggress wider instruct issu higher clock speed instruct push pipelin per cycl proportion increas process memori oper account approxim 13 instruct time gap processor dram clock speed dramat increas latenc memori oper cach univers adopt reduc averag memori access latenc aggress outoford pipelin execut along nonblock cach design employ allevi remain latenc bypass stall instruct unfortun instruct reorder complic necess calcul effect address memori oper wherea depend registerregist instruct identifi examin operand field memori depend determin much later pipelin effect address calcul result mechan specif load store eg mob pentium pro 1 requir resolv memori depend later pipelin enforc memori access semant date effect solut deal ambigu memori depend requir stall load earlier unknown store address exist approach howev overli conserv sinc mani load stall await address store depend result increas load instruct latenc reduc program perform paper propos techniqu call memori renam effect predict memori depend store load instruct allow dynam instruct schedul accur determin load commenc execut addit reorder independ memori ref erenc flexibl develop improv dynam schedul achiev tech niqu memori renam enabl load instruct retriev data effect address calcul achiev identifi relationship load previou store instruct gener data new mechan employ use identifi associ storeload pair address valu bypass normal address mechan term memori renam come similar approach abstract operand specifi perform regist renam 7 paper examin characterist memori refer stream propos novel architectur modif pipelin enabl specul execut load instruct earli pipelin address calcul true depend elimin particular true depend support complex address calcul use access program data shown signific impact overal perform much 41 speedup experi present remaind paper organ follow section 2 examin previou approach specul load instruct section 3 introduc memori reorder approach specul load execut evalu regular memori activ order identifi success strategi execut load specul section 4 show one possibl integr memori renam outoford pipelin implement section 5 provid perform analysi cycl level simul tech niqu section 6 state conclus identifi futur research direct work background number studi target reduct memori latenc austin sohi 2 employ sim ple fast address calcul earli pipelin effect hide memori latenc achiev target simpl baseoffset address mode use refer global stack data dahl okeef 5 incorpor address bit associ regist provid hardwar mechan disambigu memori refer dynam allow compil aggress place frequent referenc data regist file even alias may present dramat reduc number memori oper must execut lipasti shen 8 describ mechan valu load instruct predict base previou valu load instruct work use load valu predict unit hold predict valu along load classif tabl decid whether valu like correct base past perform predictor observ larg number load instruct bring valu time time specul use data valu last load instruct depend resolv abl remov depend critic path specul accur use approach abl achiev speedup execut 3 simpl implement 16 infinit resourc perfect predict sazeid vassiliadi smith 10 use address specul load instruct remov depend caus calcul effect address enabl load instruct proceed specul without address operand effect address comput particular load instruct remain constant global variabl refer final moshovo breach vijaykumar sohi 9 use memori reorder buffer incorpor data depend specul data depend specul allow load instruct bypass preced store ambigu depend resolv greatli increas flexibl dynam instruct schedul find memori instruct readi exe cute howev specul bypass violat true depend load store instruct flight state machin must restor point load instruct misspecul instruct load must abort reduc number time misspecul occur predict confid circuit includ control bypass allow confid mechan differ use valu predict locat depend pair store load instruct instead base confid histori load instruct refer predict ad multiscalar architectur execut perform improv averag 510 approach specul extend valu predict depend predict perform target specul load instruct earli architectur pipelin renam memori oper memori renam extens processor pipelin design initi load instruct earli possibl combin depend predict valu predict achiev greater perform possibl either techniqu alon basic idea behind memori renam make load instruct look like regist refer therebi process load similar manner difficult achiev memori refer instruct unlik simpl operand specifi use access regist requir effect address calcul depend analysi perform elimin need gener effect address critic path access load data perform load specul use program counter pc load instruct index retriev specul valu similar approach use lipasti shen valu predict except memori renam perform indirectli load instruct en counter pc address associ load ldpc use index depend tabl call storeload cach determin like produc data gener store instruct recog valu file storeload cach specul load data figur 1 support memori renam nize data referenc load instruct like produc singl store instruct data last execut store retriev valu file access valu file entri perform specul without need know effect address load store instruct instead valu file index uniqu identifi associ storeload pair mechan describ next section store instruct also use storeload cach locat entri valu file like referenc futur load store load instruct pair determin refer locat map valu file index figur 1 show overview memori renam mechan approach advantag pro ducerconsum relationship exist load proceed earli pipelin effect address calcul proceed usual memori oper retriev valu dcach done valid specul valu brought valu file data load dcach match valu file specul success process continu unfett valu differ state processor must correct order memori renam improv processor perform may prudent includ predict confid mechan capabl identifi specul warrant valu predict depend predict use histori base scheme identifi specul like succeed unlik valu renam chose identifi stabl storeload pair instead reli static valu refer see advantag use producerconsum relationship confid mechan analysi shown spec95 benchmark program compil gnu gcc ver sion 262 gnu ga version 25 gnu gld version 25 maximum optim o3 loop unrol enabl funrollloop fortran code first convert c use att f2c version 19940927 experi perform extend version simplescalar 3 tool set tool set employ simplescalar instruct set virtual mipslik architectur 6 tabl 1 benchmark applic descript bench instr load valu addr prod mark mil mil local loc loc go 548 157 25 28 62 gcc 264 97 compress 35 13 15 37 50 li 956 454 24 23 55 tomcatv 2687 772 43 48 66 su2cor hydro2d 967 250 mgrid 4422 1625 42 sever approach improv process memori oper exploit regular refer stream regular found stream valu load memori effect address calcul perform depend chain creat store load instruct tabl 1 show regular found differ characterist memori traffic first three column show benchmark name total number instruct execut total number load forth column show percentag load execut con stant near constant valu percentag shown often load instruct fetch data valu two success execut measur valu local shown tabl surpris number load instruct execut bring valu last time averag 29 spec integ benchmark 44 specfp benchmark surpris much regular exist valu reus percentag cover third load column 5 show percentag load execut refer effect address last time show regular effect address reus final column show percentag time produc valu remain unchang success instanc load instruct mean store instruct gener data load see relationship far stabl even valu transfer chang differ memori locat use transfer relationship sourc store load remain stabl statist led us use depend pair store load instruct identifi specul would profit 4 experiment pipelin design support memori renam pipelin must extend identifi storeload commun pair promot commun regist commun infrastructur verifi specul forward valu recov pipelin specul storeload forward unsuccess follow text detail enhanc made baselin outoford issu processor pipelin overview extens processor pipelin loadstor queue entri shown figur 2 41 promot memori commun regist memori depend predictor integr front end processor pipelin de code storeload cach probe store load index valu file entri assign depend edg access hit storeload cach valu file index return propag renam stage otherwis entri alloc storeload cach instruct addit valu file entri alloc index entri store storeload cach may seem odd alloc entri load valu file howev found simul benefici optim promot constant rare store variabl valu file permit access also benefit faster accur commun synchron addit decod stage hold confid counter renam load counter increment load sourc store predict correctli decrement reset predict incorrectli renam stage pipelin load use valu file index pass decod stage access entri valu file valu file return either valu last store predict depend edg valu process comput ie flight loadstor queue reserv station index return reserv station index return load stall sourc store data written store reserv station renam load complet broadcast result depend instruct regist memori schedul oper specul load result without modif load specul otherwis access memori system renam load valu return memori system compar predict valu valu match load data misspecul occur pipelin recoveri initi unlik load store instruct access valu file retir time store deposit store data valu file memori sy tem later renam load refer valu abl access directli valu file attempt made maintain coher valu file main memori content diverg due exampl extern dma pipelin continu oper correctli incoher detect renam load valu compar actual memori content initi bind store load creat load renam refer data produc renam store explor two approach detect new depend edg simplest approach look renam store forward load loadstor queue forward network ie commun instruct flight edg detect storeload cach entri load updat accordingli slightli capabl approach attach valu file indic renam store data propag indic memori hierarchi approach perform better detect longerliv depend edg howev extra storag valu file indic make approach expens 42 recov misspecul renam load inject incorrect valu program comput correct program execut requir minim instruct use incorrect valu depend instruct reexecut end explor two approach recov pipelin data misspecul squash reexecut recoveri two approach exhibit vari cost complex later see lower cost misspecul recoveri mechan enabl higher level perform sinc permit pipelin promot memori commun regist infrastructur squash recoveri expens perform penalti simplest approach implement approach work throw away instruct misspecul load instruct sinc depend instruct follow load instruct restrict depend instruct reexecut inde met unfortun approach decod renam schedul writeback loadstor queue entri storeload cach valu id conf renam writeback valu file lsq entri lru opt valu id schedul lru logic resv station load store inst specul forward resv station loadstor queue ld pred ldd st std loadstor data stdldd fault loadstor address valu file index loadstor queue ld pred ldd st std specul std forward result nonspecul ldd lsq mem pred nonspec recov loadstor addr commit loadstor queue ld pred ldd st std memori system valu file figur 2 pipelin support memori renam shown addit made baselin pipelin support memori renam solid edg writeback stage repres forward reserv station dash line repres forward loadstor queue also shown field ad shown gray instruct reorder buffer entri throw away mani instruct independ mi specul load result requir mani unnecessari execut advantag approach requir littl support implement today misspecul load may treat misspecul branch reexecut recoveri complex significantli lower cost squash recoveri approach leverag depend inform store reserv station notyet retir instruct permit reexecut instruct depend specul load valu cost approach ad pipelin complex implement reexecut inject correct result misspecul load onto result bu depend instruct receiv correct load result reexecut rebroadcast result forc depend instruct reexecut sinc nontrivi instruct know mani operand regener execut instruct may possibl reexecut multipl time everi regener operand arriv addit depend memori may requir load instruct reexecut accommod depend loadstor queue also recheck memori depend store reexecut reissu depend load instruct addit load may forc reexecut receiv new address via instruct reexecut retir reexecut instruct oldest instruct machin thu receiv regener valu instruct may safe retir section 5 demonstr simul reexecut much less expens approach implement load misspecul recoveri 5 experiment evalu evalu merit memori renam design extend detail time simul support propos design examin perform program run extend sim ulat vari confid mechan misspecul recoveri mechan key system paramet see affect paramet perform 51 methodolog baselin simul detail tabl 2 simplescalar simul suit simul simoutord 3 simul execut userlevel instruct perform detail time simul 4way superscalar microprocessor two level instruct data cach memori simul implement outoford issu execut model simul executiondriven includ execut specul path detect fault tlb miss mispredict model employ 256 entri reorder buffer implement renam regist storag hold result pend struction load store place 128 entri loadstor queue baselin simul store execut operand readi valu spec ul place loadstor queue load may execut prior store address comput valu come match earlier store store queue ie store forward data cach specul load may initi cach miss address hit tlb load subsequ squash cach miss still com plete howev specul tlb miss per mit specul cach access miss tlb instruct dispatch stall instruct detect tlb miss squash commit cycl reorder buffer issu 8 readi instruct commit 8 result inord architect regist file store commit store valu written data cach data cach model fourport 32k twoway setassoci nonblock cach found earli instruct fetch bandwidth critic perform bottleneck mitig problem implement limit variant collaps buffer describ 4 implement support two predict per cycl within instruct cach block provid significantli instruct fetch bandwidth better pipelin resourc util select benchmark look program vari memori system perform ie program larg small data set well high low refer local analyz 10 program spec95 benchmark suit 6 integ code 4 float point suit memori renam experi perform 1024 entri 2way set associ storeload cach 512 entri valu file lru replac detect initi depend edg bind propag valu file indic renam store data toplevel data cach load renam access renam store data valu file index store data cach use updat load storeload cach entri 1 52 predictor perform figur 3 show perform memori depend predictor graph show hit rate 1 due space restrict omit experi explor predictor perform sensit structur size structur size select elimin capac problem predictor allow us concentr effect leverag predict improv program perform 10305070cc1 comp go hydro2d mgrid su2cor tomcatv hit rate hit rate figur 3 memori depend predictor perform memori depend predictor benchmark hit rate comput number load whose sourc store valu correctli identifi probe valu file predictor work quit well predict correctli mani 76 pro gram memori depend averag 62 program unlik mani valu predictor mechan 8 depend predictor work well even better float point program better understand depend predictor find depend local broke correct predict segment refer data resid figur 4 show breakdown correct predict data resid global stack heap segment larg fraction correct depend predict much 70 mgrid 41 overal averag came stack refer result surpris consid frequenc stack segment refer semistat na ture ie load store stack often refer variabl mani time later leverag properti improv perform confid mechan global access also account mani correct predict much 86 tomcatv 43 overal averag final signific number correct predict come heap seg ment much 40 go 15 overal averag better understand aspect program result correct predict profil top load examin sourc store found number common case heap access exhibit depend local exampl typic program construct challeng even sophist regist alloc result signific advanc compil technolog elimin memori access assert hold global ac fetch interfac fetch 4 instruct two cach block per cycl separ two branch instruct cach 32k 2way setassoci latenc branch predictor 8 bit global histori index 4096 entri pattern histori tabl gap 11 2bit satur counter 8 cycl mispredict penalti outoford issu outoford issu 8 oper per cycl 256 entri reorder buffer 128 entri mechan loadstor queue load may execut prior store address known architect regist float point function unit 8integ alu 4loadstor unit 4fp adder 1integ multdiv 1fp multdiv function unit latenc integ alu11 loadstore21 integ mult31 integ div1212 fp adder21 data cach 32k 2way setassoci writeback writealloc latenc fourport nonblock interfac support one outstand miss per physic regist 4way setassoci unifi l2 cach 64 byte block virtual memori 4k byte page fix tlb miss latenc earlierissu instruct complet tabl 2 baselin simul model 10 20 30 40 50 70 80 90 100 cc1 comp go hydro2d mgrid su2cor tomcatv breakdown segment global stack heap figur 4 predictor hit memori segment repeat access alias data alloc regist ffl access loop data loop depend distanc one 3 ffl access singleinst dynam storag eg variabl alloc begin program point immut global pointer discuss section 3 pipelin implement also benefit confid mechan figur 5 show result experi explor efficaci attach confid counter load instruc cess compil must assum alias stack access hand effect regist alloc therebi elimin memori access given processor enough regist 3 note sinc alway predict sourc store last previou one predictor work loop depend distanc greater one even regular access support case current investig tion graph show confid coverag number predictor confid success rate highconfid load coverag fraction correctli predict load without confid cover highconfid predict particular predictor confid coverag shown 6 pre dictor notat use follow xyz x count must reach predictor consid load highconfid load default count increment one predictor correctli predict sourc store valu reset zero predictor fail count increment use opcod load indic access stack pointer z count increment use opcod load indic access global pointer analys show stack global access well behav thu increas coverag without sacrif much confid increment confid counter valu greater one shown figur 5 confid high configur examin much 9902 hydro2d least 6922 experi use confid mechan experi tri increas increment stack global access half confid counter perform best configur usual degrad confid baselin case increment one access coverag improv enough improv program perform coverag vari significantli number program eg compress hydro 2d high coverag other cc1 perl gain higher coverag signific amount confid sacrif anoth interest featur confid measur rel insensit coverag counter threshold confid threshold level rise 2 rein 4coverag load cc1 comp go perl hydro2d507090000 111 211 411 422 844 confid load cc1 comp go perl hydro2d figur 5 confid coverag predictor confid counter 2261014cc1 comp go hydro2d mgrid su2cor tomcatv sq422 sq844 re422 re211 figur perform vari predic torrecoveri configur forc earlier observ memori depend program rel static occur time often occur fashion much program execut 53 pipelin perform predictor hit rate insuffici tool evalu use memori depend predictor order fulli evalu must integr modern processor pipelin leverag predict produc correctli handl case predictor fail figur 6 detail perform memori depend predictor integr baselin outoford issu perform simul experi figur show speedup percent measur cycl execut entir program respect baselin simul four experi shown benchmark figur 6 first experi label sq422 show speedup found depend predictor util 422 confid configur squash recoveri load misspecul experi sq844 experi except 844 confid mecha nism re422 configur employ 422 confid configur util reexecut mechan describ section 3 recov load mi specul final re211 configur also employ reexecut recoveri mechan util lowerconfid 211 confid configur configur squash recoveri 422 confid mechan ie sq422 show small speedup mani program fall short other cc1 saw slowdown 5 littl investig slowdown quickli reveal highcost squash recoveri ie throw away instruct misspecul load often complet outweigh benefit memori renam mani program data misspecul branch mispredict one remedi highcost misspecul permit renam higher confid load experi label sq844 renam higherconfid load configur perform better suffer less misspecul howev exper iment eg cc1 show littl speedup still plagu mani highcost load mi specul better remedi high misspecul recoveri cost lower cost misspecul recoveri mech anism experi label re422 add reexecut support pipelin memori renam support 422 confid mechan design lower misspecul cost allow show speedup experi run much 14 m88ksim averag overal speedup 6 confirm intuit lower cost reexecut measur directli cost squash recoveri reexecut run count number instruct thrown away due load misspecul found overal reexecut consum less 13 execut bandwidth requir squash recoveri word less 13 instruct flight load misspecul depend misspecul load averag addit reexecut benefit refetch decod issu instruct misspecul load given lower cost cost reexecut explor whether speedup would improv also renam lowerconfid load experi label re211 employ reexecut recoveri lowerconfid 211 confid configur configur found better perform experi support benefit reexecut also explor use yet even lowerconfid 111 noconfid 000 config urat howev misspecul rate rise quickli configur perform suffer accordingli experi figur 7 take bestperform configur ie re211 vari two key system paramet see effect efficaci memori renam first experi label fe2 cut peak instruct deliveri bandwidth fetch stage half configur deliv four instruct one basic block per cycl mani experi cut averag instruct deliveri bw nearli half shown result effect memori renam sever attenu half instruct deliveri bandwidth machin becom fetch bottleneck mani experi fetch bottleneck improv execut perform memori renam littl improv perform program especi true integ code fetch bandwidth limit due mani small basic block second experi figur 7 label sf3 increas store forward latenc threefold three cy cle store forward latenc minimumlat cycl two oper commun valu memori baselin experi figur 6 minimum store forward latenc one cycl shown graph perform improv due renam rise sharpli much 41 m88ksim 16 overal sharp rise due increas latenc communicationthrough memori latenc must cc1 comp go hydro2d mgrid su2cor tomcatv figur 7 program perform vari system configur toler consum preciou parallel renam memori access howev may commun regist file potenti zero cycl via bypass result significantli lower commun latenc given complex loadstor queue dataflow analysi requir perform one cycl onecycl store forward sinc address comput may arriv previou cycl design may soon resort larger loadstor queue longer latenc store forward trend make memori renam attract fit conclus evalu grade goal set forth begin paper build renam mechan map memori commun regist commun synchron infrastructur hoist memori commun regist permit accur faster memori commun see success goal measur breakdown commun handl loadstor queue data cach memori commun handl loadstor queue handl flight thu commun benefit renam figur 8 show benchmark fraction refer servic loadstor queue base configu ration label base fraction refer servic loadstor queue pipelin renam support label re422 shown figur signific amount commun handl regist commun frastructur clearli much shortterm commun abl benefit renam support howev number benchmark eg cc1 xlisp tomcatv still nontrivi amount cc1 comp go hydro2d mgrid su2cor tomcatv load base re422 figur 8 percent memori depend servic loadstor queue shortterm commun identifi depend predictor program execut benefit loadstor queue abil quickli comput loadstor depend address avail one goal work improv perform depend predictor virtual shortterm commun captur highconfid predict continu improv perform memori commun goal attain perform loadstor queue becom less import overal program perform sult less resourc devot loadstor queue design implement 6 conclus paper describ new mechan design improv memori perform accomplish restructur processor pipelin incorpor specul valu depend predictor enabl load instruct proceed much earlier pipelin introduc predict confid mechan base storeload depend histori control specul valu file contain load store data effici access without perform complex address calcul simul result valid approach improv memori perform show averag applic speedup 16 intend extend studi number way obviou extens work identifi new mechan improv confid mechan increas applic scheme load instruct explor integr control flow inform confid mecha nism anoth architectur modif improv effici squash instruct effect mispredict start becom import branch predict becom import valu predict lower confid mechan also number instruct directli effect mispredict load valu less branch predict allow greater benefit improv identifi instruct need squash acknowledg final would like acknowledg help haitham akkari offer numer suggest greatli improv qualiti work also grate intel corpor support research intel technolog educ 2000 grant r intel boost pentium pro 200 mhz evalu futur microprocessor simplescalar tool set optim instruct fetch mechan high issu rate reduc memori traffic creg mip risc architectur valu local load valu predict dynam specul synchron data depend perform potenti data depend specul collaps tr mip risc architectur twolevel adapt train branch predict reduc memori traffic creg optim instruct fetch mechan high issu rate zerocycl load valu local load valu predict perform potenti data depend specul myampersandamp collaps dynam specul synchron data depend lookahead processor ctr adi yoaz mattan erez ronni ronen stephan jourdan specul techniqu improv load relat instruct schedul acm sigarch comput architectur news v27 n2 p4253 may 1999 daniel ortega eduard ayguad mateo valero dynam memori instruct bypass proceed 17th annual intern confer supercomput june 2326 2003 san francisco ca usa benchung cheng daniel connor wenmei w hwu compilerdirect earli loadaddress gener proceed 31st annual acmiee intern symposium microarchitectur p138147 novemb 1998 dalla texa unit state georg z chryso joel emer memori depend predict use store set acm sigarch comput architectur news v26 n3 p142153 june 1998 andrea moshovo gurindar sohi specul memori cloak bypass intern journal parallel program v27 n6 p427456 1999 daniel ortega mateo valero eduard ayguad dynam memori instruct bypass intern journal parallel program v32 n3 p199224 june 2004 gokhan memik mahmut kandemir arindam mallik load elimin lowpow embed processor proceed 15th acm great lake symposium vlsi april 1719 2005 chicago illinoi usa jinsuo zhang predict load address acm sigarch comput architectur news v29 n4 septemb 2001 matt yourst kanad ghose increment commit group nonatom trace process proceed 38th annual ieeeacm intern symposium microarchitectur p6780 novemb 1216 2005 barcelona spain anasta misev marjan gusev visual simul ilp dynam ooo processor proceed 2004 workshop comput architectur educ held conjunct 31st intern symposium comput architectur june 19 2004 munich germani sanjay jeram patel mariu ever yale n patt improv trace cach effect branch promot trace pack acm sigarch comput architectur news v26 n3 p262271 june 1998 vlad petric ann braci amir roth three extens regist integr proceed 35th annual acmiee intern symposium microarchitectur novemb 1822 2002 istanbul turkey dean tullsen john seng storageless valu predict use prior regist valu acm sigarch comput architectur news v27 n2 p270279 may 1999 enric morancho jo mara llabera ngel oliv comparison two polici issu instruct specul journal system architectur euromicro journal v53 n4 p170183 april 2007 jian huang david j lilja extend valu reus basic block compil support ieee transact comput v49 n4 p331347 april 2000 andrea moshovo gurindar sohi readafterread memori depend predict proceed 32nd annual acmiee intern symposium microarchitectur p177185 novemb 1618 1999 haifa israel glenn reinman brad calder dean tullsen gari tyson todd austin classifi load store instruct memori renam proceed 13th intern confer supercomput p399407 june 2025 1999 rhode greec daniel ortega mateo valero eduard ayguad novel renam mechan boost softwar prefetch proceed 15th intern confer supercomput p501510 june 2001 sorrento itali jo gonzlez antonio gonzlez potenti data valu specul boost ilp proceed 12th intern confer supercomput p2128 juli 1998 melbourn australia tingt sha milo k martin amir roth scalabl storeload forward via store queue index predict proceed 38th annual ieeeacm intern symposium microarchitectur p159170 novemb 1216 2005 barcelona spain stephen jourdan ronni ronen michael bekerman bishara shomar adi yoaz novel renam scheme exploit valu tempor local physic regist reus unif proceed 31st annual acmiee intern symposium microarchitectur p216225 novemb 1998 dalla texa unit state amir roth andrea moshovo gurindar sohi depend base prefetch link data structur acm sigop oper system review v32 n5 p115126 dec 1998 gabriel loh timestamp algorithm effici perform estim superscalar processor acm sigmetr perform evalu review v29 n1 p7281 june 2001 stone kevin woley matthew frank addressindex memori disambigu storetoload forward proceed 38th annual ieeeacm intern symposium microarchitectur p171182 novemb 1216 2005 barcelona spain peng jihkwon peir qianrong konrad lai addressfre memori access base program syntax correl load store ieee transact larg scale integr vlsi system v11 n3 p314324 june tingt sha milo k martin amir roth nosq storeload commun without store queue proceed 39th annual ieeeacm intern symposium microarchitectur p285296 decemb 0913 2006 glenn reinman brad calder predict techniqu aggress load specul proceed 31st annual acmiee intern symposium microarchitectur p127137 novemb 1998 dalla texa unit state craig b zill gurindar sohi understand backward slice perform degrad instruct acm sigarch comput architectur news v28 n2 p172181 may 2000 pedro marcuello antonio gonzlez jordi tubella specul multithread processor proceed 12th intern confer supercomput p7784 juli 1998 melbourn australia sangyeun cho penchung yew gyungho lee access region local highbandwidth processor memori system design proceed 32nd annual acmiee intern symposium microarchitectur p136146 novemb 1618 1999 haifa israel v krishna nandivada jen palsberg effici spill code sdram proceed intern confer compil architectur synthesi embed system octob 30novemb 01 2003 san jose california usa andrea moshovo gurindar sohi reduc memori latenc via readafterread memori depend predict ieee transact comput v51 n3 p313326 march 2002 sangyeun cho penchung yew gyungho lee decoupl local variabl access wideissu superscalar processor acm sigarch comput architectur news v27 n2 p100110 may 1999 j gonzlez gonzlez controlflow specul valu predict ieee transact comput v50 n12 p13621376 decemb 2001 sangyeun cho penchung yew gyungho lee highbandwidth memori pipelin wide issu processor ieee transact comput v50 n7 p709723 juli 2001 lieven eeckhout koen de bosscher quantifi behavior differ multimedia generalpurpos workload journal system architectur euromicro journal v48 n67 p199220 januari