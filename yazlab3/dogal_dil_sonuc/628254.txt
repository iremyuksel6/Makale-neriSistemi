hash method tempor data extern dynam hash use tradit databas system fast method answer membership queri given dynam set object membership queri ask whether object ident k current state paper address gener problem tempor hash set chang dynam set timestamp membership queri tempor predic find whether object ident k set time present effici solut problem take ephemer hash scheme make partial persist solut also term partial persist hash use linear space total number chang evolut set small ologbnb queri overhead experiment comparison partial persist hash variou straightforward approach like extern linear hash multivers btree rtree show provid faster membership queri respons time partial persist hash seen extens tradit extern dynam hash tempor environ independ ephemer dynam hash scheme use paper concentr linear hash methodolog appli dynam hash scheme well b introduct hash use fast method address membership queri given set object distinguish ident attribut oid membership queri ask whether object oid k set hash appli either main memori scheme data fit mainmemori dkm88 fnss92 databas system data store disk l80 latter form call extern hash en94 r97 hash function map oid bucket everi object hash function comput bucket number object store bucket initi size page discuss assum page hold b object ideal distinct oid map separ bucket howev unrealist univers oid usual much larger number bucket alloc hash scheme b oid map bucket bucket overflow occur overflow dealt variou way includ rehash tri find anoth bucket use anoth hash scheme andor chain creat chain page overflown bucket overflow present find whether given oid hash set trivial simpli comput hash function queri oid visit appropri bucket object set bucket henc hash scheme perfect membership queri answer o1 step one io access page bucket overflow howev complic situat data known advanc worst case queri perform hash larg linear size set sinc oid could map bucket g kollio dept comput inform scienc polytechn univers brooklyn ny 11201 gkolliosparospolyedu v j tsotra dept comput scienc univers california riversid research partial support nsf grant iri9509527 new york state scienc technolog foundat part center advanc technolog program bad hash scheme use nevertheless practic shown absenc patholog data good hash scheme overflow constant averag case queri perform usual bucket size one two page exist one major differ hash index scheme balanc tree b tree c79 use instead answer membership queri take logarithm size time worst case mani applic exampl join comput sd90 hash scheme provid expect constant queri perform one two io prefer worst case logarithm queri perform four io larg balanc search tree static hash refer scheme use predefin set bucket ineffici set allow chang ad delet object set set small number prealloc bucket larg scheme use space need set becom larg small number bucket use overflow becom often deterior scheme perform need dynam hash scheme properti alloc space proport size hash set variou extern dynam hash scheme propos among linear hash l80 variat appear commonli use note even set evolv tradit dynam hash ephemer ie answer membership queri current state set paper address gener problem assum chang set timestamp time instant occur interest answer membership queri state set possess let st denot state collect object set time membership queri tempor predic given oid k time find whether k st term problem tempor hash new queri tempor membership queri motiv tempor hash problem stem applic current well past data interest exampl includ account bill market taxrel social medic financialstockmarket applic applic effici maintain convent databas work term singl usual current logic state instead tempor databas propos sa85 time vari data two time dimens use model realiti name validtim transactiontim j94 valid time denot time fact valid realiti transact time time fact store databas transact time consist serial order transact ie monoton increas implement use commit time transact s94 rest term time tempor refer transactiontim assum everi time st chang addingdelet object could good ephemer dynam hash scheme say linear hash ht map effici overflow oid st collect bucket bt one straightforward solut tempor hash problem would separ store collect bucket bt answer tempor membership queri oid k time need appli ht k access appropri bucket bt would provid excel queri perform take advantag good linear hash scheme ht use space requir prohibit larg n denot number chang ss evolut flash bt disk could easili creat 2 space instead propos effici solut similar queri perform use space linear n term solut partial persist hash reduc origin problem collect partial persist 1 subproblem appli two approach solv subproblem first approach see subproblem evolv subset set base snapshot index tk95 second approach see subproblem evolv sublist whose histori effici kept case partial persist hash scheme observ store evolut ephemer hash effici way enabl fast access ht bt note partial persist fit nice transactiontim databas environ alway increas characterist compar partial persist hash three approach first one use tradit dynam hash function map oid ever creat evolut st solut distinguish among mani copi oid k may creat time proce given oid k ad delet mani time creat copi k associ differ time interv copi hash bucket bucket reorgan solv problem also observ as86 overflow eventu deterior perform especi number copi increas second approach see oidinterv combin multidimension object use rtree store third approach assum b tree use index st make b tree partial persist bgo96 vv97 ls89 experi show 1 structur call persist store access past state dsst89 call partial persist structur evolv appli chang current state partial persist hash outperform three competitor membership queri perform minim space overhead partial persist b tree bgo96 vv97 ls89 technic interest among competitor approach correspond extend ephemer b tree tempor environ like ephemer b tree support worst case logarithm queri time tempor queri open problem whether effici tempor extens exist hash scheme work present answer question posit nontempor environ partial persist hash provid faster index expect queri perform tempor membership queri result reassert conjectur ktf98 tempor problem support transactiontim solv take effici solut correspond nontempor problem make partial persist rest paper organ follow section 2 present background previou work relat tempor index method interest section 3 describ basic snapshot index linear hash descript partial persist hash appear section 4 perform comparison present section 5 conclus open problem research appear section 6 2 background previou work research tempor databas shown immens growth recent year os95 work tempor access method concentr index worst case comparison tempor index appear st97 best knowledg approach address hash problem tempor environ among exist tempor index four special interest paper name snapshot index tk95 timesplit btree tsb ls89 multivers btree mvbt bgo96 multivers access structur mva vv97 simpl model tempor evolut follow assum time discret describ success nonneg integ consid simplic initi empti set time proce object ad delet set object ad ever delet call aliv repres associ object semiclos interv lifespan form starttim endtim object aliv read ie contain duplic delet appli aliv object object ad starttim endtim yet unknown thu lifespan interv initi variabl repres alway increas current time object later delet endtim updat object delet time sinc object ad delet mani time object oid may exist nonintersect lifespan interv ie object aliv differ time state set given time name st collect aliv object time assum evolut store transactiontim databas way chang happen time transact timestamp updat databas variou queri may ask tempor databas common queri puresnapshot problem also denot propos notat tjs98 given time find st anoth common queri rangesnapshot problem rs given time rang oid r find aliv object st oid rang r categor tempor index accord queri answer effici compar perform use three cost space queri time updat time ie time need updat index chang happen set clearli index solv rangesnapshot queri also solv puresnapshot queri rang provid howev indic tgh95 method design address primarili puresnapshot queri need order incom chang accord oid note evolut model chang arriv increas time order unord oid henc method could enjoy faster updat time method design rangesnapshot queri latter order incom chang oid provid fast respons rangesnapshot queri inde snapshot index solv puresnapshot queri io use onb space o1 updat time per chang expect amort sens clr90 hash scheme employ iooptim solut pure snapshot queri correspond number aliv object queri state st rangesnapshot queri three effici method exist name tsb tree mvbt tree mva structur assum exist b tree index st time proce set evolv correspond b tree evolv differ algorithm provid effici store access b tree evolut answer rangesnapshot queri time impli access b tree time search node find oid rang interest conceptu approach take b tree make partial persist dsst89 result structur form graph includ whole histori evolv b tree abl effici access past state b tree log b mvbt mva solv rangesnapshot queri io use onb space updat per chang amort sens clr90 optim solut rangesnapshot queri denot number aliv object updat take place denot answer size rangesnapshot queri ie mani object queri st oid queri rang r mva structur improv mergesplit polici mvbt thu result smaller constant space bound tsb tree anoth effici solut rangesnapshot queri practic space effici mvbt mva guarante worst case queri perform set evolut describ addit new object updat exist object sinc purpos paper assum object delet frequent use mvbt instead tsb 3 basic snapshot index linear hash purpos partial persist hash need fundament snapshot index ephemer linear hash describ next detail descript refer tk95 l80 s88 en94 r97 respect 31 snapshot index method tk95 solv puresnapshot problem use three basic structur balanc tree timetre index data page time pointer structur accessforest among data page hash scheme timetre accessforest enabl fast queri respons hash scheme use updat purpos first discuss updat object store sequenti data page order ad set particular new object oid k ad set time new record form k creat append data page data page becom full new data page use given instant one data page store accept record acceptor data page time acceptor page creat along page address store time tree acceptor page creat sequenti timetre easili maintain amort o1 io index new acceptor page object addit sequenc data page resembl regular log two main differ 1 way delet updat manag 2 use addit link pointer among data page creat accessforest log b log io object delet ad sequenti rather inplac updat object k delet time record first locat updat k k object record found use oid hash scheme object ad oid address page store object record insert hash scheme object delet hash scheme consult object record locat interv updat object oid remov hash function store one record object suggest time instant record object st may dispers variou data page access page aliv object would requir much io st object may access oa page henc record aliv object must cluster togeth ideal ab page achiev good cluster introduc copi control manner ie way total space remain explain copi procedur need introduc concept page use consid page get full record ie stop acceptor page number aliv record contain record interv end time instant page contain ub aliv record call use time page contain good part answer st puresnapshot queri time abl locat use page time page contribut least ub object answer use paramet u constant tune behavior snapshot index acceptor page special page acceptor page may contain fewer ub aliv record definit also call page use long acceptor page page may give enough answer justifi access still access nevertheless time instant exist exactli one acceptor page let ustarttim uendtim denot page use period ustarttim time page start acceptor page page get full either continu use long page least ub aliv record becom nonus time becam full page less ub aliv record next step cluster aliv record among use page page becom nonus artifici copi occur copi aliv record page current acceptor page timesplit e86 ls89 nonus page behav object mark delet copi aliv record still found acceptor page copi record contain subsequ nonoverlap interv object lifespan copi procedur reduc origin problem find aliv object find use page solut reduc problem facilit accessforest accessforest pointer structur creat logic forest tree among data page new acceptor page append end doublylink list remain list long use data page becom nonus remov list b becom next child page page c preced list ie c left sibl list becam nonus time proce process creat tree nonus data page root use data page list accessforest number properti enabl fast search use page time tk95 show start acceptor page use page found twice mani io practic much less io need find acceptor page balanc timetre search correspond logarithm part queri time practic search fast height balanc tree small store one entri per acceptor page clearli onb main part queri time find use page perform snapshot index fine tune chang paramet u larg u impli acceptor page becom nonus faster thu copi creat increas space also cluster answer smaller number page ie less queri io 32 linear hash linear hash lh dynam hash scheme adjust grace data insert delet scheme use collect bucket grow shrink one bucket time overflow handl creat chain page overflown bucket hash function chang dynam given instant two hash function use scheme specif let u univers oid h 0m1 initi hash function use load set bucket exampl h 0 insert delet oid perform use h 0 first overflow happen first overflow occur occur bucket first bucket lh file bucket 0 split rehash two bucket origin bucket 0 new bucket attach end lh file oid origin map bucket 0 use function h 0 distribut bucket use new hash function h 1 oid next overflow attach new bucket m1 content bucket 1 distribut use h 1 bucket 1 m1 crucial properti h 1 oid origin map h 0 bucket j remap either bucket j bucket jm necessari properti linear hash work exampl hash function h 1 overflow caus addit bucket split linear bucketnumb order variabl p indic bucket split next conceptu valu p denot two hash function may enabl given time appli bucket initi p0 mean one hash function use appli bucket lh file first overflow exampl p1 h 1 introduc suppos object oid k insert second overflow ie p2 first older hash function appli k bucket h 0 k split yet k store bucket otherwis bucket provid h 0 alreadi split newer hash function store bucket h 1 k search oid similar hash function may involv enough overflow origin bucket split mark end split round 0 round 0 p went subsequ bucket 0 bucket m1 end round 0 lh file total 2m bucket hash function h 0 longer need 2m bucket address hash function h 1 note reset 0 new round name splittinground 1 start next overflow 2m bucket introduc hash function h 2 oid oid mod2 2 round last bucket 2m1 split gener round start hash function h oid oid round end bucket split purpos use h call split function h 0 split function h j properti ii oid either h j given time linear hash scheme complet identifi round number variabl p given round variabl p search oid k perform use h otherwis h i1 use round valu p increas one overflow next round i1 start p reset 0 split perform whenev overflow occur uncontrol split let l denot lh file load factor ie current number oid lh file size set b page size number oid r current number bucket file load factor achiev uncontrol split usual 5070 depend page size l br oid distribut l80 practic achiev higher storag util split instead perform overflow occur load factor upper threshold g control split typic achiev 95 util delet set caus lh file shrink bucket split recombin load factor fall lower threshold f two bucket merg togeth oper revers split occur revers linear order practic valu f g 07 09 respect 4 partial persist hash first describ evolvingset approach base snapshot index evolv list approach follow 41 evolvingset approach use partial persist tempor hash problem reduc number subproblem effici solut known assum ephemer linear hash scheme one describ section 3 use map object st st evolv time hash scheme function time let lht denot linear hash file time two basic timedepend paramet identifi lht name pt paramet round number time valu paramet pt identifi next bucket split interest properti linear hash bucket reus round i1 start doubl number bucket round first half bucket sequenc sinc new bucket append end file let b total denot longest sequenc bucket ever use evolut st assum b total consist bucket 012 let bt sequenc bucket use time observ impli bt prefix b total addit consid bucket b j sequenc b total observ collect object store bucket time proce state bucket b j time name b j set oid store bucket let denot number oid b j state somehow reconstruct bucket b j answer tempor membership queri oid k time answer two step 1 find bucket b j oid k would map hash scheme 2 search content b j k found first step requir identifi hash scheme use time evolut hash scheme lht easili maintain record form pt append array h instant valu andor pt chang given hash function use identifi simpli locat insid timeord h logarithm search second step impli access b j obviou way would store b j time b j chang explain earlier would easili creat quadrat space requir updat per chang would also suffer sinc io store current state b j would proport bucket current size name observ evolut bucket b j note state chang evolv set ad delet oid chang timestamp time instant occur time ephemer linear hash scheme may appli rehash procedur remap current content bucket b j bucket b j new bucket b r assum rehash occur time result move v oid b j b r evolut b j b r rehash view delet respect addit v oid time ie delet addit timestamp time correspond object evolut figur 1 show exampl ephemer hash scheme two differ time instant simplic 2 figur 2 show correspond evolut set evolut variou bucket time addit oid 8 bucket 3 caus first overflow rehash content bucket 0 bucket 0 bucket 5 result oid 15 move bucket 5 bucket 0 evolut chang consid delet 5 addit oid 15 instant b j avail search content oid k perform linear search process lower bound io sinc mani page least need store b j similar tradit hash queri oid translat search page bucket search also linear continu oid found bucket page search therefor need method given reconstruct b j effort proport io sinc everi bucket b j behav like set evolv time snapshot index tk95 use store evolut b j reconstruct b j requir effici thu conclud given evolv set partial persist hash answer tempor membership queri oid k time almost queri time effici plu small overhead separ ephemer hash scheme exist st good ephemer hash scheme st would requir expect o1 io answer membership queri mean averag bucket b j use st would limit size equival correspond page practic one two page perspect partial persist hash reconstruct b j io expect o1 small overhead incur persist hash due fact store whole histori ss evolut singl state st array h store entri everi time page overflow occur even chang new oid addit number overflow upper bound onb henc array h index page search take io identifi hash function appropri bucket b j pinpoint time must search timetre associ bucket overhead impli search bound n j correspond number chang record bucket bucket bucket b figur 1 two instant evolut ephemer hash scheme time split occur map bucket 3 caus overflow bucket 0 rehash use h 1 log histori practic expect n chang ss evolut concentr first b total bucket sequenc simpli prefix sequenc alway use assum ss histori record first bucket n j behav therefor search b j timetre rather fast logarithm overhead proport number chang n common characterist queri time tempor index use partial persist mvbt mva tree answer tempor membership queri oid k time io note mvbt logarithm bound contain two search first appropri btree index st found fast search similar identifi hash function bucket search persist hash second logarithm search mvbt find k tree index st logarithm size st instead persist hash find oid k expect o1 io figur 2 detail evolut set time additiondelet respect chang assign histori three bucket shown hash scheme figur 1 assum addit oid 8 caus first overflow move oid 15 bucket 0 bucket 5 seen delet addit respect record store bucket histori also shown exampl t25 oid 10 delet set updat lifespan oid correspond record bucket 0s histori 10 1 10 1 25 evolut set time 10 1 15 9 oid lifespan record bucket 0s histori 10 1 15 9 21 oid lifespan evolut bucket 0 10 1 25 15 9 21 oid lifespan 3 4 13 17 oid lifespan record bucket 3s histori 3 4 13 17 oid lifespan evolut bucket 3 13 17 oid lifespan oid lifespan record bucket 5s histori 15 21 oid lifespan evolut bucket 5 15 21 oid lifespan 8 21 8 21 411 updat space analysi proceed analysi updat space characterist partial persist hash suffic show scheme use onb space o1 amort expect updat process per chang deriv clearli array h satisfi space bound next show space use bucket histori also bound onb recal n correspond total number real object additionsdelet set ss evolut howev rehash process move object among bucket bucket histori move seen new chang delet oid previou bucket subsequ addit oid new bucket must thu shown number move due rehash still bound number real chang n purpos use two lemma lemma 1 n overflow occur least nb1 real object addit need proof proof base induct number overflow 1 creation first n1 overflow least b1 oid addit need happen oid map bucket hold b oid bucket start one empti page 2 assum n first overflow nb1 real object addit need 3 must prove first overflow need least n1b1 oid addit assum true ie oid addit enough show contradict result assumpt accord 2 first n n1 overflow need nb1 real object addit henc b1 remain oid addit creat extra overflow consid page last overflow occur bucket page exactli one record less would overflow nth overflow could achiev one less oid page overflow need least b oid addit ie remain b1 enough n1th overflow result contradict lemma prove note page nth overflow occur need consid page space addit oid one oid alreadi sinc overflow occur bucket could achiev less oid q previou lemma lower bound number real oid addit n overflow next lemma upper bound total number copi due oid rehash happen overflow lemma 2 n overflow creat nb1 oid copi proof use induct number overflow 1 first overflow creat b1 oid copi happen first overflow occur oid bucket remap new bucket delet record remap b1 oid still store histori origin bucket 2 assum n first overflow nb1 oid copi 3 must shown first n1 overflow creat n1b1 oid copi use contradict henc let assum true ie first n1 overflow creat copi let n1b1x number consid last n overflow sequenc overflow 2 impli overflow alreadi creat nb1 oid copi henc least b1x addit copi creat first overflow howev contradict sinc 1 first overflow creat copi q readi prove basic theorem space updat theorem 1 partial persist hash use space proport total number real chang updat amort expect o1 per chang proof assum simplic set evolv ad oid oid addit creat new record overflow henc copi delet creat overflow overflow occur linear hash proce round first round variabl p start bucket 0 end round reach bucket m1 point 2m bucket use copi remap oid first round creat sinc overflow occur lemma 1 2 impli must least mb1 real oid addit copi construct copi place last bucket next round variabl p start bucket 0 extend bucket 2m1 p reach bucket 2m1 2m new overflow new overflow impli must least 2mb1 new real oid addit 2mb1 copi creat addit also mb1 copi oid first round purpos second round seen regular oid copi oid copi second round origin oid copi creat first round copi second round repres delet record correspond bucket henc maximum number copi second round 2mb1 total number copi c total creat ith round 012 upper bound repres copi per round equival ith round total number real oid addit total lower bound equival ii ii deriv exist posit constant const sinc total bound total number chang n prove partial persist hash o1 expect amort updat per chang note real chang occur direct appropri bucket structur snapshot index updat o1 expect time rehash care examin rehash bucket caus singl real oid addit one creat overflow result bunch copi made new bucket wors whole current content rehash bucket sent new bucket howev use space bound prove sequenc n real chang creat copi extra work equival o1 amort effort per real chang q 412 optim issu optim perform partial persist hash involv load factor l ephemer linear hash use paramet u snapshot rt denot size evolv set number bucket use clearli good ephemer linear hash scheme tri equal distribut oid among bucket henc averag size oid bucket b j satisfi total mb 1 2mb 1 total mb 2 k c total total const l one advantag snapshot index abil tune perform use paramet u index distribut oid b j among number use page sinc use page except acceptor page contain least ub aliv oid oid occupi page actual lu ideal would like answer snapshot queri contain singl page plu probabl one acceptor page good optim choic keep conceptu load l give measur size bucket aliv oid time aliv oid store data page snapshot index recal artifici copi happen number aliv oid data page fall ub point remain ub1 aliv oid page copi new page keep l u expect aliv oid split page copi singl page minim number io need find hand use paramet u affect space use snapshot index return overal space persist hash scheme mention section 3 higher valu u impli frequent time split ie page copi thu space henc would advantag keep u low impli even lower l return lower l would mean bucket ephemer hash fulli util low l caus set st distribut bucket may fulli occupi first requir seem contradictori howev purpos partial persist hash low l still accept recal low l appli ephemer hash scheme whose histori partial persist hash observ accumul even though singl time instant b j ts may fulli util whole time evolut mani object oid map bucket count partial persist scheme total number chang accumul per bucket due bucket reus bucket gather mani chang creat larg histori bucket thu justifi use partial persist scheme find regard optim verifi experiment result appear next section 42 evolvinglist approach element bucket b j also view evolv list lb j aliv oid observ consist way bucket search ephemer hash ie linearli bucket content belong list practic bucket expect one two page long access bucket state b j reduc reconstruct lb j equival evolv list oid made partial persist l u bucket b j first creat empti page assign list lb j list page two area first area use store oid record size b r b r b second area size accommod extra structur array nt explain shortli first oid k ad bucket b j time record k append first list page addit oid insert creat record insert list page append need oid k delet bucket record list found serial search among list page endtim updat logic delet snapshot index need notion page use page call use long contain least v aliv object last page list otherwis nonus page follow discuss assum except last page list use page becom nonus oid delet bring number aliv oid page threshold last page turn use nonus get full record event caus oid insert time page total number aliv oid less l page becom nonus otherwis continu regular use page last page get full new last page ad list find state b j equival find use page lb j use two extra structur first structur array ft j time provid access first use page lb j entri array ft j form time pid pid page address first use page list chang new entri pid new first use page append ft j array implement multilevel pagin index sinc entri ad increas time order find remain use page lb j everi use page must know next use page list achiev second structur implement insid everi list page particular structur form array store page area size b r let nta array insid page array maintain long page use entri nta also form time pid pid correspond address next use page use page use period page next use page chang mani time nta becom full assum scenario happen time let c use page page page artifici turn nonus even still v aliv record replac copi page call process artifici sinc caus oid insertiondelet page rather due chang page ahead new page aliv record empti nt new entri ad ntc pid first entri nt pid use page page use list page page nt array full time process artifici turn use page nonus propag way top list reach first use page list copi creat array ft j updat howev happen often figur 3 show exampl array nt ft j maintain need artifici creation copi page faster queri process ntc array enabl find next use page c variou time instant assum moment new copi page creat instead nta allow grow avail area page addit page last entri ntc would still point page locat next page c time would lead page serial search among page array nta need clearli approach ineffici use page front page chang often use artifici copi guard similar situat next use list page time interest found one io techniqu gener backward updat techniqu use tgh95 special care need page turn use nonus due oid delet figur 3 exampl evolut use page list lb j b correspond ft j nt array page nt array shown exampl bb entri sinc page front page chang often nta array fill time 6 artifici copi page creat array nta array ntc also updat artifici creat new page f f f f b artifici entri insert page achiev good answer cluster aliv oid page merg aliv oid sibl use page sibl exist creat one two depend number aliv oid new use page new use page may full record oid ie futur oid insert accommod result new oid insert list use page serial search new oid ad first use page found space b r area accommod detail describ appendix answer tempor membership queri oid k time appropri bucket b j oid would map hash scheme must found part evolvingset approach reconstruct state bucket b j perform two step first use first use page lb j found search array ft j correspond search timetre bucket evolvingset approach search bound remain use page lb j thu oid b j found locat nt array subsequ use page instead evolvingset approach use access forest snapshot index sinc use page except last list lb j least v aliv oid answer oid b j found addit io space use evolvinglist structur j b two differ evolvinglist evolvingset approach first updat use snapshot index remain constant evolv list whole current list may search ad delet oid second natur reconstruct b j differ evolvinglist reconstruct start top list page evolvingset reconstruct start last page bucket may affect search given oid depend whether place near top near end bucket 5 perform analysi compar partial persist hash pph linear hash particular atempor linear hash discuss later mvbt rtree implement experiment setup describ 51 data workload 52 find 53 51 method implement experiment setup set size page hold 25 oid record b25 oid record follow form oid starttim endtim ptr first field oid second start time third end time oid lifespan last field pointer actual object may addit attribut log first discuss atempor linear hash alh clarifi alh ephemer linear hash whose evolut partial persist hash observ store rather linear hash scheme treat time anoth attribut scheme simpli map object bucket use object oid consequ see differ lifespan oid copi oid implement alh use scheme origin propos litwin lin80 split function use hash divis function h get good space util control split employ lower upper threshold name f g valu 07 09 respect anoth approach atempor hash would scheme use combin oid starttim endtim attribut howev approach would still problem alh tempor membership queri exampl hash starttim help queri time instant starttim multivers btree mvbt implement base bgo96 fast updat mvbt use buffer store page path last updat lru buffer replac polici use buffer updat advantag sinc updat direct current btree small part whole mvbt structur experi set buffer size 10 page origin mvbt use buffer queri howev fair comparison method measur queri perform mvbt invalid buffer content previou queri thu measur queri perform independ order queri execut final origin mvbt process answer queri start root array everi time array identifi root btree time ie search queri start even though root increas time small enough fit main memori thu count io access search root snapshot index page mvbt aliv long least q aliv record number aliv record fall q page merg sibl call weak version underflow extrem page alreadi b record aliv new record ad page split page overflow condit need special handl first timesplit happen like copi procedur snapshot incorpor structur mvbt requir number aliv record new page qe e predetermin constant constant e work buffer guarante new page split merg least e new chang valu q e b possibl must satisfi constraint detail refer bgo96 implement set 4 directori page mvbt format data page partial persist hash implement setevolut pph listevolut pphl approach approach observ ephemer linear hash lht whose load lt lie f01 g02 array h identifi hash scheme use time kept mainmemori io access count use structur similar keep root array mvbt main memori experi size array h never greater 15 kb unless otherwis note pph implement variou valu use paramet u also examin sinc entri timetre associ bucket half oid record size timetre page hold 50 entri pphl implement space oid record b r hold 20 record valu v set equal 5 sinc mean page list use long number aliv oid page greater equal 5 remain space list page size 5 oid record use page nt array similarli timearray nt array entri half size ie page hold 10 nt entri reason page ft j array hold 50 entri rtree method use two implement one interv ri twodimension space anoth point threedimension space rp ri implement assign oid lifespan interv one dimens use oid one lifespan interv new oid k ad set time record k ptr ad rtree data page oid k delet record updat k ptr directori page includ one attribut per record repres oid rang rp implement similar format data page assign separ dimens starttim endtim object lifespan interv henc directori page record seven attribut two oid starttim endtim one pointer updat rtree implement use buffer 10 page keep page path lead last updat mvbt buffer use queri phase 52 workload variou workload use comparison workload contain evolut dataset tempor membership queri evolut specif workload defin triplet wueq u univers oid set uniqu oid appear evolut set e evolut set collect queri set queri correspond oid k evolut start time 1 finish time maxtim chang given evolut first gener per object oid merg first object oid k number k differ lifespan object evolut chosen choic n k made use specif random distribut function name uniform exponenti step normal whose detail describ next section starttim lifespan oid k gener randomli pick n k differ start point set 1 maxtim endtim lifespan chosen uniformli starttim lifespan starttim next lifespan oid k sinc lifespan oid k disjoint final whole evolut e set creat merg evolut everi object anoth mix lifespan also creat evolut pick starttim length lifespan use poisson distribut call poisson evolut tempor membership queri queri set q specifi tupl oidt number queri q k everi object oid k chosen randomli 10 20 thu averag form kt queri tupl correspond time instant select use uniform distribut set 1 maxtim maxtim set 50000 workload workload describ distribut use gener object lifespan number differ oid total number chang evolut n object addit delet total number object addit nb total number queri 53 experi first behavior implement test use basic uniform workload number lifespan per object follow uniform distribut 20 40 total number distinct oid number real chang object addit henc averag number lifespan per oid nb refer workload uniform30 number queri 115878 figur 4a present averag number page access per queri method pph method best perform two page per queri alh approach use queri io 15 time exampl larger bucket creat mvbt use twice mani io pph approach sinc tree travers per queri ri use io per queri mvbt mainli due node overlap larger tree height ri structur relat total number oid lifespan mvbt correspond number aliv oid time specifi queri problem node overlap even greater queri perform rp tree figur 4a truncat fit graph rp use averag 44 io per queri experi rp aliv oid endtim caus cluster togeth even though differ oid overlap extend oid dimens well observ elsewher ktf98 transactiontim lifespan maintain effici plain rtree figur 4b show averag number io per updat best updat perform given pph method mvbt second best updat perform larger pph sinc mvbt travers tree updat instead quickli find locat updat element hash updat ri follow larger mvbt sinc size tree travers relat oid lifespan size mvbt tree travers relat number aliv oid time updat alh pphl use even larger updat process alh lifespan oid thrown bucket thu creat larg bucket search serial updat pph l nt array implement insid page limit actual page area assign store oid thu increas number page use per bucket rp tree use even larger updat process due bad cluster common endtim space consum method appear figur 4c alh approach use smallest space sinc store singl record per oid lifespan use control split high util f g valu pph method also good space util pph close alh pphl use space pph nt array implement reduc page util rtree method follow rp use slightli less space ri pagin interv put bound rectangl demand point note similarli alh r method use singl record per oid lifespan addit space mainli averag rtree page util 65 mvbt largest space requir twice space alh figur 4 queri b updat c space perform implement uniform workload b c alh pph pphl mvbt ri rp10305070 avg number io per update50001500025000alh pph pphl mvbt ri rp number pages50150alh pph pphl mvbt ri rp avg number io per queri pph method summari pph best overal perform similarli comparison ephemer hash btree mvbt tree behav wors tempor hash pph tempor membership queri alh slightli better pph space requir even though significantli rtree base method much wors pph three perform criteria consid effect lifespan distribut approach compar use four addit workload name exponenti step normal poisson workload number distinct oid number queri 115878 similar n 05m paramet exponenti workload gener n k lifespan per oid use exponenti distribut probabl densiti function mean 30 total number chang 487774 total number object addit 245562 307 step workload number lifespan per oid follow step function first 500 oid 4 lifespan next 500 8 lifespan ie everi 500 oid number lifespan advanc 4 workload 34 normal workload use normal distribut paramet poisson workload first lifespan everi oid gener randomli time instant 1 500 length lifespan gener use poisson distribut mean 1100 next start time given oid also gener poisson distribut mean valu 500 workload 31 main characterist poisson workload number aliv oid time vari small number larg proport u ie time instant number aliv oid hundr time instant almost distinct oid aliv figur 5 present queri updat space perform new workload simplic ri method present among rtree approach uniform load rp use consist queri updat ri similar space result resembl previou uniform workload pph approach best overal perform use slightli space minim space alh pphl queri perform compar space pph use much updat note figur 5a queri perform ri truncat fit graph averag ri use 10 13 per queri exponenti step normal poisson workload respect similarli figur 5c space mvbt truncat mvbt use 26k 29k 25k 355k page respect workload effect number lifespan per oid test use eight uniform workload vari averag number lifespan use differ oid number queri 115k paramet shown follow tabl result appear figur 6 queri perform atempor hash deterior nb increas sinc bucket becom larger figur 6a pph pphl mvbt method queri perform independ nb three method nb lifespan given oid appear differ time instant thu interfer queri perform ri much higher truncat fig 6a interestingli ri queri perform decreas gradual nb increas 126 io 94 io ri cluster improv nb increas record key pph outperform method updat perform figur 6b queri updat pph pphl mvbt basic independ nb better cluster increas nb updat ri gradual decreas contrast increas nb impli larger bucket size updat alh increas space method increas nb chang n per evolut tabl 1 alh lower space follow pph mvbt steeper space increas nb valu 80 100 mvbt use 68k 845k page effect number distinct oid use evolut examin consid three variat uniform workload number distinct oid u 5000 8000 tabl 1 workload n nb nb figur 5 queri b updat c space perform alh pph pphl mvbt ri method use exponenti step normal poisson workload 8k oid n 05m nb 30 b c exponenti normal poisson103050 avg number io per queri alh pph pphl mvbt step exponenti step normal poisson10305070 avg number io per updat alh pph pphl mvbt ri40001200020000 number page exponenti normal poisson step figur queri b updat c space perform alh pph pphl mvbt ri method use variou uniform workload vari nb b c 100103050avg number io per query1030507090 avg number io per updat avg number lifespan per oid nb number page alh pph pphl mvbt alh pph pphl mvbt 12000 respect workload similar averag number lifespan per distinct oid nb 30 paramet appear tabl 2 result appear figur 7 queri perform pph pphl independ u contrast increas mvbt ri ri use 104 12 13 io per queri reason increas oid store tree structur thu increas structur height evid ri oid appear tree theori alh also independ univers size u slight increas alh figur 7a due control split polici constrain alh given space util similar observ hold updat perform final space method increas n increas tabl 2 experi pph method appear competit perform among solut mention section 412 pph perform optim set use paramet u figur 8 show result basic differ valu u expect best queri perform occur u greater maximum load observ ephemer hash experi maximum load 02 assert figur 8a queri time minim 03 updat similarli minim figur 8b us 02 sinc point aliv oid compactli kept page updat easier smaller us aliv oid distribut page increas updat process figur 8c show space pph us maximum load aliv oid distribut among data page henc page becom nonus contain less aliv oid thu less copi made result smaller space consumpt use optim space pph made similar alh expens increas queryupd perform 6 conclus open problem paper address problem tempor hash equival support tempor membership queri timeevolv set effici solut term partial persist workload n nb queri figur 7 queri b updat c space perform alh pph pphl mvbt ri method use variou uniform workload vari u b c avg number io per queri alh pph pphl mvbt alh pph pphl mvbt alh pph pphl mvbt avg number io per updat number page number distinct oid u thousand hash pph present queri updat scheme behav separ ephemer dynam hash scheme avail everi state assum set time howev method still use linear space hash oid variou bucket time pph reduc tempor hash problem reconstruct previou bucket state two flavor partial persist hash present one base evolvingset abstract pph one evolvinglist pphl similar queri compar space perform pph use much less updat method compar straightforward approach name tradit atempor linear hash scheme two rtree implement multivers btree experi show pph robust perform among approach partial persist hash seen extens tradit extern dynam hash tempor environ methodolog independ ephemer dynam hash scheme use paper consid linear hash appli dynam hash scheme well variou open interest problem figur 8 queri b updat c space perform pph uniform workload vari valu use paramet u b c avg number io per queri pphs205215225235 avg number io per updat pph u110001300015000numb page pph tradit hash use speed join comput current investig use tempor hash speed tempor join ssj94 anoth problem extend tempor membership queri time interv find whether oid k state set interv discuss paper assum tempor membership queri linear transactiontim evolut interest investig hash branch transact environ lst95 acknowledg would like thank b seeger kindli provid us r mvbtree code part work perform vj tsotra sabbat visit ucla would thu like thank carlo zaniolo comment hospit r perform evalu tempor databas manag system asymptot optim multivers btree rtree effici robust access method point rectangl ubiquit btree introduct algorithm dynam perfect hash upper lower bound make data structur persist fundament databas system nonoblivi hash rtree dynam index structur spatial search consensu glossari tempor databas concept design access method bitempor databas linear hash new tool file tabl address lha scalabl distribut data structur access method multivers data histor queri along multipl line time evolut tempor realtim databas survey databas manag system prentic hall timestamp commit taxonomi time databas tradeoff process complex join queri via hash multiprocessor databas machin branch tempor index structur effici evalu validtim natur join comparison access method timeevolv data effici manag timeevolv databas extens notat spatiotempor index queri snapshot index iooptim access method timeslic queri effici multivers access structur tr ctr huanzhuo ye hongxia luo kezhen song huali xiang jing chen index move object base 2 n index tree proceed 6th confer 6th wsea int conf artifici intellig knowledg engin data base p175180 februari 1619 2007 corfu island greec sy chien v j tsotra c zaniolo effici scheme manag multiversionxml document vldb journal intern journal larg data base v11 n4 p332353 decemb 2002