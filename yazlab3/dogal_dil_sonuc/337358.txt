inheritancebas techniqu build simul proof increment paper present techniqu increment construct safeti specif abstract algorithm descript simul proof show algorithm meet specificationsth techniqu build specif algorithm allow child specif algorithm inherit parent two form increment modif interfac extens new form interact ad parent interfac b special subtyp new data restrict effect ad parent behavior descript combin interfac extens special constitut power express increment modif mechan describ chang overrid behavior parent although may introduc new behaviorconsid case increment modif appli parent specif parent algorithm proof child algorithm implement child specif built increment upon simul proof algorithm implement specif new work requir involv reason modif requir repetit reason origin simul proofth paper present techniqu mathemat term automata techniqu alreadi use model valid fullfledg group commun system see 26 methodolog result experi summar paper b introduct formal model valid softwar system major challeng size complex iti among factor could increas widespread usag formal method improv costeffect scalabl cf 20 22 current softwar engin practic address problem build complex system use increment develop techniqu base objectori approach believ success effort system model valid also requir increment techniqu enabl reus model proof paper provid framework reus proof analog complementari reus provid objectori softwar engin method olog specif present techniqu increment construct safeti specif abstract algorithm descript simul proof algorithm specif simul proof one import techniqu prove properti complex system proof exhibit simul relat refin map abstract func tion formal descript system specif 13 24 29 techniqu present paper evolv experi context largescal model valid project success use techniqu model valid complex group commun system 26 implement c interact two servic develop differ team group commun system act middlewar provid tool build distribut applic order use varieti applic group commun system provid servic divers semant bear mani similar yet differ subtl way model divers servic system valid algorithm implement ser vice reus model proof essenti order make task feasibl exampl allow us avoid repeat fivepag long correct proof algorithm provid basic semant prove correct algorithm provid sophist semant correct proof sophist algorithm comparison two half page long describ experi project well methodolog evolv section 6 approach reus specif algorithm inherit use increment modif deriv new compon specif algo rithm call child exist compon call parent specif present two construct modifi exist compon 1 allow child special parent reus state readonli fashion ad new state compon readwrit constrain set behavior parent correspond subtyp view inherit 8 show observ behavior child subsum cf 1 possibl behavior parent make special analog substitut inherit 8 particular child use anywher parent use special subject section 3 2 child also deriv parent mean interfac signatur extens case state parent unchang child may includ new observ action found parent new paramet action exist parent new action paramet hidden behavior child exactli behavior parent interfac extens present section 5 interfac extens combin specializa tion correspond subclass extens form inherit 8 provid power mechan increment construct specif algorithm consid follow exampl parent defin unord messag servic use send recv primit produc total order messag servic special parent way recv possibl current messag total order next introduc safe primit inform sender messag deliv ere first extend servic interfac includ safe primit special enabl safe action case messag actual deliv special extens construct appli specif level algorithm level way preserv relationship specif algorithm main technic challeng address paper section 4 provis formal framework reus simul proof especi special construct consid exampl figur 1 let specifica tion abstract algorithm descript assum proven implement use simul relat r p assum special specif yield new child specif 0 time special algorithm construct algorithm 0 support addit semant requir 0 figur algorithm simul specif r p reus build simul r c child 0 child 0 simul simul rp inherit inherit prove 0 implement 0 would like reli fact alreadi proven implement avoid need repeat reason would like reason new featur introduc 0 0 proof extens theorem section 4 provid mean increment build simul proof manner simul proof 13 lend natur support interact theorem prover proof typic break mani simpl case base differ action check hand help interact theorem prover increment simul proof break similar fashion present increment modif construct context io automata model 30 32 basic model review section 2 io automata wide use formul formal servic definit abstract implement reason eg 6 9 11 12 14 15 21 24 28 31 import featur io automaton formal strong support composit exampl hickey et al 24 use composit approach model verif certain modul ensembl 19 largescal modularli structur group commun system introduc inherit io automaton model vital order push limit project verif individu modul verif entir system experienc work project 26 program model languag base io automata formal ioa 17 18 defin intend exploit ioa framework develop ioabas tool support techniqu present paper valid code gener stata guttag 36 recogn need reus manner similar suggest paper facilit reason correct subclass given correct superclass known suggest framework defin program guidelin supplement framework inform rule may use facilit reason ing howev address inform reason provid mathemat foundat formal proof furthermor 36 restrict context sequenti program encompass reactiv compon paper mani work eg 1 6 10 23 25 33 formal dealt inherit semant distinguish contribut provis mathemat framework increment construct simul proof appli formal notion inherit two level specif algorithm section present background io automaton model base 30 ch 8 model system compon describ statemachin call io automaton transit automaton associ name action classifi input output intern input output action model compon interact compon intern action extern unobserv formal io automaton consist interfac signatur siga consist input output intern action set state statesa set start state starta statetransit relat subset statesa thetasiga thetastatesa transa action said enabl state automaton transit form input action enabl everi state execut automaton altern sequenc state action begin start state success tripl allow transit trace subsequ execut consist sole automaton extern action io automaton model defin composit oper specifi automata interact via input output action io automata conveni present use preconditioneffect style style type state variabl initi valu specifi set state start state transit group action name specifi use pre block precondit state action enabl eff block specifi prestat modifi effect execut atom yield poststat simul relat reason automaton interest externallyobserv behavior reflect trace common way specifi set trace automaton allow gener use abstract io automata gener legal set trace implement automaton satisfi specif trace also trace specif automaton simul relat commonli use techniqu prove trace inclus definit 21 let two automata extern interfac relat r statesa theta statess simul satisfi follow two condit 1 initi state initi state 2 rt 2 2 rt reachabl state respect 0 step exist execut fragment trace follow theorem emphas signific simul relat proven 30 ch 8 theorem 21 two automata extern interfac r simul tracesa tracess simul relat techniqu complet finit trace inclus shown use simul relat conjunct histori propheci variabl 2 35 special construct captur notion subtyp io automata sens trace inclus allow creat child automaton special parent automaton child read parent state add new readwrit state compon restrict parent transit special construct defin oper parent automaton accept three addit paramet state extens new state compon initi state extens initi valu new state compon transit restrict specifi child addit new precondit effect modifi new state compon parent transit defin special construct formal definit 31 let automaton let n set state call state extens let n 0 nonempti subset n call initi state extens let tr statesa theta n theta siga theta n relat call transit restrict action tr specifi addit restrict child place state n enabl specifi new state compon modifi result child take step involv specializean defin automaton 0 follow notat 32 use follow denot parent compon tj n denot new compon ff execut sequenc 0 ffj p denot sequenc obtain replac state ff tj p also extend notat set state set execut sequenc exemplifi use special con struct figur 2 present simpl algorithm automaton write cach implement sequentiallyconsist regist x share among set process p process access local cach p regist x initi default valu v 0 write p v request propag v x cach p respons read p v read request return valu v ps local cach p without ensur current thu process p respond read request valu x least current last valu previous seen p necessarili uptod one figur 3 present atom writethrough cach au tomaton atom write cach special write cach special automaton maintain addit boolean variabl synch p process p order restrict behavior parent respons read request return latest valu x trace automaton indistinguish system singl share regist cach gener transit restrict denot type preconditioneffect code union follow two set ffl tripl form tj n mention code 0 ie 0 figur writethrough cach automaton automaton write cach signatur input write p v read output read p v synch p state transit cach p intern synch p eff cach p input read req p output read p v pre figur 3 atom writethrough cach automaton automaton atom write cach modifi write cach state extens initi true transit restrict eff synch q intern synch p eff synch p true output read p v pre synch p true restrict transit involv read req p ac tion figur 2 exampl note new state compon tj n chang state satisfi new precondit place 0 state result appli new effect theorem 31 say everi trace special automaton trace parent automaton section 4 demonstr prove correct automata present use special oper done increment step top correct proof parent theorem 31 0 child automaton 1 execsa 2 proof 31 1 straightforward induct length execut sequenc basi 2 definit starta 0 induct step 0 step 0 step definit 2 follow part 1 fact siga altern notic trace inclus impli theorem 21 fact function map state 2 simul map 0 formal introduc allow code reus also show section proof reus mean increment proof construct start exampl prove gener theorem exampl proof reus revisit share regist exampl section 3 present parent specif sequentiallyconsist share regist describ simul prove implement write cach automaton present previou section deriv child specif atom share regist special parent specif final illustr proof automaton atom write cach implement child specif construct increment parentlevel simul proof figur 4 present standard specif sequentiallyconsist share regist x interfac seq consist regist cach specif maintain sequenc histx valu store x execut write p v request append v end histx respons read p v read request allow return valu v store x sinc p last access x nondetermin innat part sequenti consist specif keep track last access index last p histx argu automaton write cach figur 2 satisfi specif exhibit simul relat r r relat state write cach state seq consist regist follow 2 r 2 integ shistx step write cach initi state involv read p v simul figur 4 sequenti consist share regist specif automaton automaton seq consist regist signatur input write p v read output read p v state last p transit eff append v histx last p input read req p output read p v choos pre last p eff last p step seq consist regist initi involv read p v choos hi p hi p number whose exist impli simul relat r step write cach involv read v action simul step seq consist regist respect action straightforward prove r satisfi two condit simul relat definit 21 interest actual proof reus ie avoid need repeat purpos illustr proof reus present figur 5 specif atom share regist special seq consist regist child restrict allow valu return read p v current valu x restrict nondeterminist choic index latest valu histx figur 5 atom share regist specif automaton atom regist modifi seq consist regist transit restrict output read p v choos pre want reus simul r prove automaton atom write cach implement atom regist sinc atom regist extend state seq consist regist simul relat need extend work gener one may need extend simul relat captur impl mentat state relat new state ad specif child prove r also simul relat child algorithm atom write cach child specif atom regist show two thing first show initi state atom write cach relat initi state atom regist gener prove theorem 41 need check new variabl ad specif child need show initi state implement exist relat assign initi valu new variabl exampl sinc atom regist add new state get properti free second need show whenev r simul step seq consist regist step still valid transit atom regist impli theorem 41 check new precondit place atom regist transit seq consist regist still satisfi extens simul relat pre serv sinc exampl atom regist add new state variabl need show first condit whenev read p v choos simul atom regist new precondit hold recal read p v choos simul atom regist chosen hi p simul work need prove alway possibl choos hi p histx follow immedi ad precondit atom write cach requir read p v occur synch p true follow simpl invari invari proven straightforward induct invari 41 reachabl state atom write cach true tcach p proof extens theorem present theorem lay foundat increment proof construct consid exampl illustr figur 1 simul relat algorithm specif given want construct simul relat r c special version 0 automaton special version 0 specif automaton theorem 41 prove relat r c construct supplement r p relat r n relat state 0 state extens introduc 0 relat r n relat everi initi state 0 initi state extens 0 satisfi step condit similar one definit 21 involv transit restrict relat 0 theorem 41 let automaton 0 child automaton let automaton 0 child automaton simul let r n relat r c defin term r p r n simul 0 0 r c satisfi follow two condit 1 2 exist state sj nr n sj n 2 reachabl state 0 reachabl state 0 sj p step 0 exist finit sequenc ff altern state action 0 begin end state 0 satisfi follow condit ffj p execut sequenc e ff trace proof 41 show r c satisfi two condit definit 21 1 consid initi state 0 fact simul must exist state sj pr p sj p start properti 1 must exist state sj n consid state r c definit also start theta n 0 use fact start 0 def 31 2 first notic assumpt state relat r c impli 2 r c properti 2c 2d impli 0 next show ff execut sequenc right trace inde everi step ff consist transs 2a consist tr 2b therefor definit def 31 everi step ff consist word ff execut sequenc 0 start state r c end state r c trace practic one would exploit theorem follow simul proof parent automata alreadi provid correspond execut sequenc parent specif everi step parent al gorithm typic case execut sequenc pad new state variabl correspond step child algorithm thu condit 2a 2c 2e theorem 41 hold se quenc condit check 2b 2d ie everi step execut sequenc consist transit restrict tr place 0 valu new state variabl 0 final state execut relat poststat child algorithm note state special version theorem 41 case three automata 0 let 0 version would use know algorithm simul specif would like prove also simul child 0 statement proof special version theorem 41 except child 0 must substitut 0 tj p fact given special version theorem 41 follow corollari relat fht g simul relat 0 special theorem appli automata 0 0 interfac extens formal construct alter interfac automaton extend new form interact technic reason conveni assum interfac everi automaton contain empti action ffl statetransit relat contain empti transit ie automaton interfac extens automaton defin use interfac map function translat new child interfac origin parent interfac new action ad child map empti action ffl parent child state start state parent statetransit child consist parent transi tion renam accord interfac map particular statetransit includ step chang state involv new action map ffl definit 51 automaton 0 interfac extens automaton statesa exist function f call interfacemap 1 1 f function f map nonffl action 0 ffl new action ad 0 also allow manytoon 2 f preserv classif action input output intern 2 input action f 6 ffl f also input action likewis output intern action 3 notat 52 let 0 interfaceextens interfacemap f ff execut sequenc 0 ffj f denot sequenc obtain replac action alpha f collaps everi transit form ffl likewis fi trace 0 fij f denot sequenc obtain replac action fi f subsequ remov occurr ffl follow theorem formal intuit set execut trace interfaceextend automaton equival respect set parent automaton modulo interfacemap proof straightforward induct use definit 51 notat 52 theorem 51 let automaton 0 interfac extens interfacemap f let ff sequenc altern state action 0 let fi sequenc extern action 0 1 ff 2 2 interfac extens follow special modif result combin correspond notion modif subclass extens 8 result child special parent behavior introduc new function specif special interfaceextend automaton may add transit involv new state compon new interfac gener definit parentchild relationship follow 1 interfacemap similar strong correspond 38 definit 53 automaton 0 child automaton 0 special interfac extens theorem 51 enabl use proof extens theorem theorem 41 parentchild definit child action translat parent action use interfac map definit 51 6 practic experi increment proof section describ experi design model complex group commun servic see 26 framework present paper exploit describ interest model methodolog evolv experi project group commun system gcss 3 37 power build block facilit develop faulttoler distribut applic gcss typic provid reliabl multicast group membership ser vice task membership servic maintain list current activ connect process deliv inform applic whenev chang output membership servic call view reliabl multicast servic deliv messag current view member tradit gc develop concentr primarili make system use realworld distribut applic data replic eg 16 highli avail server eg 5 collabor comput eg 7 formal specif correct proof seldom provid mani suggest specif complic difficult understand shown ambigu 4 recent challeng task specifi semant servic gcss becom activ research area io automaton formal recent exploit specifi reason gcss eg 9 11 12 15 24 28 howev suggest io automatonstyl specif gcss use singl abstract automaton repres multipl properti system compon present singl algorithm automaton implement properti thu mean provid reason subset properti often difficult follow part algorithm implement part specif paper dealt prove correct individu servic layer fullfledg system 26 model fullfledg exampl span entir virtual synchron reliabl group multicast servic provid specif formal algorithm descript correspond actual c implement also simul proof algorithm specif employ clientserv present virtual synchron group multicast client interact extern membership server virtual synchron group multicast client implement use approxim 6000 line c code server 27 develop anoth develop team also use roughli 6000 line c code group multicast servic also exploit reliabl multicast engin implement third team 34 use 2500 line c code sought model new group multicast servic manner would match actual implement one hand would allow us verifi algorithm specif hand order manag complex project hand found need employ objectori approach would allow reus model proof would also correspond implement turn would reus code data structur 26 use io automaton formal inheritancebas increment modif construct present paper specifi safeti properti group commun servic specifi four abstract specif automata captur differ gc properti began specifi simpl gc provid reliabl fifo multicast within view next use new inheritancebas modif construct special specif requir also process move togeth one view anoth deliv set messag former special specif also captur self deliveri properti requir process deliv messag fourth automaton specifi standalon properti without inherit augment view deliveri special inform call transit set 37 proceed formal algorithm implement specif first present algorithm withinview reliabl fifo multicast provid five page long formal simul proof show algorithm implement first specif next present second algorithm extens special first one second al gorithm restrict parent behavior accord second specif ie ad restrict process move togeth one view anoth deliv set messag former addit second algorithm extend servic interfac convey transit set ad new function provid client transit set per fourth specif exploit theorem 41 abl prove second algorithm implement second specif therefor also first one two page without need repeat argument made previou five page proof separ prove algorithm meet fourth specif final extend special second algorithm support third properti exploit theorem 41 order prove final algorithm meet third specif henc four specif mere two half page long proof current continu work group commu nicat increment extend system describ 26 new servic semant use techniqu model methodolog special allow children introduc behavior permit parent allow chang state variabl par ent howev model algorithm 26 one case saw need child algorithm modifi parent variabl dealt case introduc certain level nondetermin parent therebi allow child resolv special nondetermin later particular algorithm implement second specif describ sometim need forward messag process although forward need parent forward messag would store buffer messag howev messag buffer variabl parent child allow modifi solv problem ad forward action would forward arbitrari messag parent automaton parent store forward messag appropri messag buffer child restrict arbitrari messag forward accord algorithm liken methodolog use abstract method pure virtual method objectori methodol ogi sinc nondetermin left parent hook prospect children specifi forward polici might need experi use methodolog make proof complic 7 discuss describ formal approach increment defin specif algorithm incorpor inheritancebas methodolog increment construct simul proof algorithm specif techniqu elimin need repeat argument origin system prove correct new system success use methodolog specifi prove correct complex group commun servic 26 plan experi methodolog order prove complex system present techniqu mathemat term io automata furthermor formal present paper syntax increment modif consist continu evolut ioa program model languag sinc ioa develop practic program framework distribut system one goal incorpor inheritancebas modif techniqu approach proof reus ioa program languag toolset 17 18 futur plan also includ extend proofreus methodolog construct allow child modifi state variabl parent futur plan includ ad abil deal multipl inher itanc work aim formul extend formal specif techniqu would use practic softwar develop acknowledg thank paul atti steve garland victor luchangco jen palsberg help comment suggest r theori object exist refin map acm 394 formal specif group membership ser vice fault toler video ondemand servic objectori approach verifi group commun system middlewar support distribut multimedia collabor comput introduct objectori program ming adapt total order multicast protocol toler partit denot semant inherit correct dynam primari configur group commun servic data refin modelori proof method comparison specifi use partion group commun ser vice fast replic state machin partition network foundat compon base system ioa languag specifi optim layer commun protocol formal method develop high assur comput system work group report gener railroad cross case studi formal verif realtim system need practic formal method wrapper semant objectori program languag state specif proof ensembl layer inherit smalltalk80 denot definit clientserv approach virtual synchron group multicast specifica tion clientserv orient algorithm virtual synchron group membership wan multicast group commun base loadbalanc replic data servic gener abstract function distribut algorithm robust emul share memori use dynam quorumacknowledg broadcast introduct putoutput automata object closur abstract semant objectori languag implement reliabl datagram servic lan environ prove correct respect nondeterminist safeti specif modular reason presenc subclass group commun specif comprehens studi io automaton model oper system primit tr object closur abstract semant objectori languag inherit smalltalk80 denot definit exist refin map prove correct respect nondeterminist safeti specif denot semant inherit correct modular reason presenc subclass introduct objectori program 2nd ed specifi use partition group commun servic dynam viewori group commun servic eventuallyserializ data servic distribut algorithm theori object data refin wrapper semant objectori program languag state multicast group commun base loadbalanc replic data servic dynam primari configur group commun servic specif proof ensembl layer need practic formal method robust emul share memori use dynam quorumacknowledg broadcast fast replic state machin partition network formal method develop high assur comput system clientserv approach virtual synchron group multicast optim layer commun protocol fault toler video demand servic clientserv orient algorithm virtual synchron group membership wan ctr sarfraz khurshid darko marinov daniel jackson analyz annot languag acm sigplan notic v37 n11 novemb 2002 keidar roger khazan nanci lynch alex shvartsman inheritancebas techniqu build simul proof increment acm transact softwar engin methodolog tosem v11 n1 p6391 januari 2002