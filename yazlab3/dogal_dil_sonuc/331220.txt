tight bound prefetch buffer manag algorithm parallel io system abstractth io perform applic multipledisk system improv overlap disk access requir use appropri prefetch buffer manag algorithm ensur use block access retain buffer paper answer sever fundament question prefetch buffer manag distributedbuff parallel io system first deriv prove optim algorithm pmin minim number parallel io second analyz pcon algorithm alway match replac decis wellknown demandpag min algorithm show pcon becom fulli sequenti worst case third investig behavior onlin algorithm multipledisk prefetch buffer manag defin analyz plru parallel version tradit lru buffer manag algorithm unexpectedli find competit ratio plru independ number disk final present practic perform algorithm randomli gener refer string result confirm conclus deriv analysi worst case input b introduct increas imbal speed processor io devic result io subsystem becom bottleneck mani applic use multipl disk build parallel io subsystem advoc increas io perform system avail 5 highperform system incorpor form io parallel perform improv overlap access sever disk use judici prefetch buffer manag algorithm ensur use block access retain buffer parallel io system consist independ disk disk buffer access parallel data comput spread among disk unit block block unit retriev disk comput character comput sequenc order sequenc block refer model access read prefetch read data block need comput research partial support grant schlumberg foundat research partial support nsf grant ccr9303011 natur mechan increas io parallel comput demand diskresid block data concurr data block prefetch disk parallel held buffer need requir discard block buffer make space prefetch block natur question aris condit worthwhil discard bufferresid block make room prefetch block use time later futur decid discard block replac polici use choos block replac paper answer sever fundament question prefetch buffer manag parallel io system question address optim prefetch buffer manag algorithm good algorithm propos earlier sequenti singl disk system context obtain sever interest result inform state precis state section 2 find prove optim algorithm pmin minim number parallel io contrast recent result prefetch obtain cpudisk overlap 4 effici algorithm find optim polici known secondli show pcon algorithm attempt optim number io disk poor parallel perform final investig behavior semionlin algorithm use parallel io concept semionlin algorithm consid paper captur dual requir prefetch need futur knowledg onlin behavior futur knowledg defin analyz plru semionlin version tradit least recent use lru buffermanag algorithm find perform plru independ number disk contrast pcon perform degrad proport number disk contrast singledisk system sequenti io issu studi extens eg 2 6 formal studi issu parallel io context sequenti set number block io use perform metric scale averag block access time provid estim io time contrast multipl disk case direct relationship number io io time sinc depend io parallel attain goal minim number io done disk minim parallel io time conflict tradit buffer manag algorithm singledisk system gener focus minim number io parallel context may use perform greater absolut minim disk oper isol number io disk allow larg number overlap rest paper organ follow section 11 summar relat work section 2 develop formal model summar main result section 31 deriv tight upper bound pcon algorithm section 32 prove optim pmin section 33 analyz perform semionlin algorithm plru 11 relat work singledisk system buffer manag page problem algorithm studi 2 6 11 sever polici lru fifo longest forward distanc etc propos analyz longest forward distanc 2 polici minim number page fault therefor call min algorithm polici use demand io determinist replac ie fetch block referenc buffer choic replac block determinist random replac algorithm eg see 8 beyond scope paper sequenti case well known 11 prefetch reduc number io requir sleator tarjan 11 analyz competit ratio onlin page algorithm rel offlin optim algorithm min show lru perform penalti proport size fast memori onlin algorithm worst case much better fundament result extend sever way often includ model allow differ form lookahead 3 1 9 7 work deal question buffer block evict contrast situat addit question aris fetch block evict cao et al 4 examin prefetch singl disk overlap cpu io oper defin two offlin polici call aggress conserv obtain bound elaps time rel optim algorithm use prefetch obtain io parallel multipl disk use number parallel io elaps io time cost function pmin pcon algorithm analyz gener aggress conserv polici respect howev aggress suboptim model 4 pmin prove optim algorithm model prefetch algorithm multipl disk analyz 10 assum global buffer readonc random data also investig semionlin algorithm use parallel io sinc prefetch involv read block requir futur rel comput progress present natur situat lookahead necessari inspir us defin lookahead version lru plru minimum possibl lookahead one block beyond current buffer known disk 3 find perform plru independ number disk contrast pcon whose perform degrad proport number disk preliminari comput refer block disk order specifi consumpt sequenc sigma block referenc buffer disk check block present buffer consum comput recent breslauer 7 arriv lookahead definit independ sequenti demand context proce refer next block sigma referenc block present disk buffer io known demand io miss block initi disk demand io initi disk system would idl block fetch howev everi demand io disk provid prefetch opportun disk may use read block referenc near futur exampl consid 2disk system hold block 1 2 b disk 1 2 respect strictli demand io would requir four nonoverlap io fetch block better strategi overlap read use prefetch demand io block 1 second disk could concurr prefetch b 1 1 b 1 consum demand io block b 2 made concurr prefetch block 2 number parallel io case two prefetch increas io parallel problem complic finit buffer size everi block read disk previous fetch block correspond buffer must replac prefetch block replac decis made earlier absolut necessari sinc comput continu without prefetch block earli replac choic much poorer replac choic made later sinc comput proce use replac candid may becom avail cours block becom demand block replac defer poor replac result greater number io prematur discard discard block may fetch repeatedli buffer thu tradeoff io parallel achiev use prefetch increas number io requir due poorer replac choic 21 definit consumpt sequenc sigma order block request comput subsequ sigma consist block disk denot sigma comput occur round round consist io phase follow comput phase io phase parallel io initi number block one disk select read select disk block correspond disk buffer chosen replac new block read disk comput phase begin cpu consum zero block present buffer order specifi sigma point next block sigma present buffer round end next round begin block whose absenc forc io known demand block block fetch togeth demand block known prefetch block io phase may also initi comput requir demand block case block fetch prefetch block often refer io phase round io time step io schedul makespan sequenc hf f k set block one disk fetch parallel io time step k makespan schedul number io time step requir complet comput valid schedul one axiom a1 a2 satisfi block must present buffer consum a2 buffer size block disk buffer time optim schedul valid schedul minim makespan among valid schedul normal schedul valid schedul f k 1 k contain demand block sequenti schedul valid schedul block disk fetch order sigma start round let u denot next referenc block sigma current buffer disk defin minblock disk block disk buffer longest forward distanc next refer normal sequenti schedul io step k u 2 f k unless block disk buffer referenc u u 2 f k replac minblock disk u normal sequenti schedul everi io step k u 2 f k provid minblock disk minblock u fetch demand u replac minblock disk u normal sequenti schedul everi io step k u 2 f k unless block disk buffer referenc u u 2 f k among block buffer whose next refer u choos least recent use block replac u notic three schedul defin normal everi io step one disk perform demand fetch rest either perform prefetch idl pmin plru greedi strategi almost alway attempt prefetch next unread block disk situat disk idl everi block buffer referenc block fetch note greedi prefetch may requir make suboptim replac choic result increas number io done disk show howev pmin polici minim io time therefor optim exampl present let block disk 1 2 round disk 1disk 2 cpu pmin schedul round disk 1disk 2 cpu pcon schedul round disk 1disk 2 cpu 9 gammagamma b3b4 b3 plru schedul fig 1 exampl io schedul figur 1 show io schedul use differ polici exampl se quenc entri second third column indic block fetch replac disk round bold ital face block indic demand block prefetch block respect contrast pmin conserv strategi 4 pcon pessimist perform prefetch unless replac best block number io done disk smallest possibl howev minim number io done disk may result serial access perform significantli wors optim algorithm note figur 1 step 4 block fetch disk 2 pcon candid replac time current minblock block b 1 howev b 4 demand block minblock would b 3 take advantag prefetch opportun algorithm must know next unread block sigma requir lookahead upto least one block beyond current buffer replac decis made plru base sole examin current block buffer track referenc next unread block whose next refer next unread block least recent consum block chosen replac candid plru appli sequenc sigma use pmin pcon schedul 12 io step obtain see fig 1 next section quantifi precis perform three algorithm 22 summari result let tpgammamin tpgammacon tpgammalru number io time step requir pmin pcon plru respect let opt number io step requir optim schedul let n denot length sigma also recal number disk size disk buffer block technic result paper follow 1 worstcas ratio makespan pcon schedul correspond optim schedul bound worst pcon serial disk access without increas number io perform disk see theorem 7 2 worstcas bound pcon state tight consumpt sequenc pcon complet serial access see theorem 8 3 pmin optim schedul minim number parallel time step valid schedul see theorem 11 4 worstcas ratio makespan plru schedul correspond optim schedul bound worst plru inflat number io perform disk done serial lru algorithm see theorem 13 5 worstcas bound plru state tight consumpt sequenc plru inflat access disk factor see theorem 14 3 detail result 31 bound pcon begin simpl upper bound tpgammacon let tmin denot maximum number io done sequenti min algorithm singl disk theorem 7 consumpt sequenc tpgammacon opt proof show tpgammacon dtmin dt opt io made pcon disk consumpt sequenc sigma exactli io done sequenti min algorithm disk sequenc sigma henc number io perform disk pcon bound tmin worst none access disk overlap whenc first inequ follow final second inequ follow sinc optim parallel time disk smaller minim number io singl disk ut theorem 8 bound theorem 7 tight proof sketch construct follow four lengthm sequenc b j j th block disk aslo defin sigma follow u n mean n repetit parenthes sequenc argu sigma 1 pmin schedul length 2nm 1 thu tpgammacon opt lower bound 32 optim pmin section show pmin requir minim number parallel io step among valid schedul proof show transform optim schedul opt makespan l pmin schedul makespan schedul ff fi said match time step everi 2 block fetch replac disk two sequenc lemma 10 assum ff valid schedul length w let fl anoth schedul match ff gamma 1 io time step buffer ff fl disk differ one block specif ff block v block u fl block u block v assum v referenc u consumpt sequenc follow refer time gamma 1 construct valid schedul fi length w fi ff match fi fl match time step proof let first time step ff fetch discard either block v u either discard block v fetch block u construct schedul fi follow fi match ff time step w except time step fi fetch replac block fl one follow must occur ff fetch block z 6 u discard block construct fi also fetch block z discard block u ff fetch block u discard block z z also discard block z ff fetch block u discard block fetch discard block three case follow io block buffer sinc fi fetch replac block ff buffer ff fi time step io time step 1 w fi consum block done ff clearli fi satisfi axiom a2 show fi valid schedul show axiom a1 satisfi block consum fi sinc ff fi buffer io io block consum ff time step also consum fi time step first time step io either block u v consum ff sinc ff u buffer till least io hypothesi v consum u henc block x 6 u v consum ff time step sinc buffer ff fi agre except fu v g x also consum fi time step sinc ff valid schedul consumpt fi also satisfi axiom a1 henc fi valid schedul ut theorem11 pmin optim schedul proof let delta andomega denot schedul creat pmin opt algorithm respect success transformomega anoth valid schedul match delta length asomega show pmin schedul optim proof induct induct hypothesi assum time step tomega transform valid scheduleomega match delta time step show toomega t1 discuss transform arbitrari disk time step 1 construct appli disk independ delta andomega match letomega t1 asomega suppos delta andomega differ time step one follow three case must occur 1 consid case separ butomega fetch block let delta fetch block p discard block q 1 sinc delta alway fetch block order referenc p referenc q induct hypothesi delta andomega buffer start time henc io andomega differ one block delta block p block q whileomega q p use lemma 10 ff construct valid scheduleomega t1 matchesomega time step delta time 1 henc induct hypothesi satisfi 1 omega fetch block delta fetch block sinc delta fetch block time step 1 everi block buffer start time step consum block current buffer referenc andomega buffer start time step bring fresh block p must discard block q sinc delta chose retain block q prefer fetch block p either q must referenc p neither p q referenc first case use lemma 10 ff 1 constructomega t1 schedul satisfi induct hypothesi 1 second caseomega t1 asomega except time step omega t1 fetch block sinc buffer andomega t1 agre block except p q two block never referenc block consum byomega time step also consum byomega t1 time andomega fetch differ block suppos delta fetch block p discard block q andomega fetch block discard block z 1 assum q 6 z sinc otherwis buffer ofomega delta differ pair block fp g easili constructomega t1 use lemma 10 ff induct hypothesi delta andomega buffer start time step 1 henc io andomega differ two block specif set block buffer schedul theta first time fetch replac block w 2 fp q zg either discard block q fetch block p z appropri combin see case construct t1 matchesomega time step fetch p discard q follow action delta time step henc io zg one follow occur fflomega fetch block discard q t1 also fetch discard z io fflomega fetch p discard q fetch discard z io bufferomega fflomega fetch z discard q noth step io fflomega fetch t1 also fetch discard p io ffi fzg t1 fetch block time step io fzg fflomega fetch z discard fetch q discard p io bufferomega fflomega fetch p discard block fetch discard block io fflomega fetch z discard block fetch q discard block io consid consumpt made byomega time step t1 notic consumpt sequenc p must preced q z must preced q constraint p follow sinc delta fetch p discard q fetch p prefer constraint z follow sinc delta discard q rather z show toomega t1 buffer io t1 otherwis buffer must differ either pair block fq zg fy pg constructomega t1 concaten prefix step 1 schedul fi construct use lemma 10 describ let ff fl respect schedul consist suffix t1 time step greater equal end io buffer t1 differ fy pg let differ fq zg let appli lemma 10 construct desir sequenc fi omega t1 obtain concaten prefix fi consumpt block inomega t1 follow time step 1 consumpt consumpt determin fi consumpt 1 till valid sinceomega valid schedul andomega t1 andomega match construct block consum valid need show consum block asomega time step p z buffer end io 1 consum p z io time later also sinc q must consum p none block consum io io 1 buffer andomega t1 agre except fp q zg block consum also consum byomega t1 time step conclud proof ut 33 bound plru obtain upper bound worstcas perform plru show bound tight use follow lemma whose proof omit breviti lemma 12 let contigu subsequ sigma refer less distinct block disk consum none block fetch plru theorem13 consumpt sequenc tpgammalru mt opt proof induct assum consumpt made first step pmin done less step plru hold set refer made pmin sinc distinct block consum disk time step pmin sinc plru fetch block u lemma 12 pmin consumpt 1 done addit step ut theorem 14 worstcas bound theorem 13 tight proof sketch show construct sigma two disk b block disk 1 2 respect note first access sigma com mon plru pmin plru make access everi access pmin paper defin model parallel io system answer sever fundament question prefetch buffer manag system found prove optim algorithm pmin minim number parallel io possibl increas number io done singl disk contrast pcon algorithm alway match replac decis wellknown singledisk optim al gorithm min becom fulli serial worst case behavior onlin algorithm lookahead plru analyz perform plru independ number disk similar result shown hold pfifo parallel version fifo lookahead r influenc lookahead competit page algorithm studi replac algorithm virtual storag new measur studi onlin algo rithm studi integr prefetch cach strategi oper system theori competit onlin page lookahead competit page algorithm beyond competit analysi markov analysi multipledisk prefetch strategi extern merg amort effici list updat page rule tr ctr mahesh kallahalla peter j varman analysi simpl random buffer manag parallel io inform process letter v90 n1 p4752 15 april 2004 mahesh kallahalla peter j varman optim prefetch cach parallel io sytem proceed thirteenth annual acm symposium parallel algorithm architectur p219228 juli 2001 crete island greec mahesh kallahalla peter j varman pcopt optim offlin prefetch cach parallel io system ieee transact comput v51 n11 p13331344 novemb 2002 michael penner viktor k prasanna cachefriendli implement transit closur journal experiment algorithm jea 11 2006 kai hwang hai jin roy sc ho orthogon stripe mirror distribut raid iocentr cluster comput ieee transact parallel distribut system v13 n1 p2644 januari 2002