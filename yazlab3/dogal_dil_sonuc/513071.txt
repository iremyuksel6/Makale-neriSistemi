stack queue integr hostil platform comput intens task carri trust limit platform smart card becom necessari compens limit resourc memori cpu speed offload implement data structur avail insecur untrust fast coprocessor howev data structur stack queue ram hash tabl corrupt made behav incorrectli potenti hostil implement platform adversari know choos data structur oper paper examin approach detect violat datastructur invari place limit demand resourc secur comput platform b introduct smart card settop box consum electron form trust hardwar 2 3 16 avail propos 1 applic electron commerc shall refer devic devic typic compos circuit card encas epoxi similar substanc strewn variou electron tamperdetect devic physic design constraint devic includ heat dissip difficulti size often credit card pcmcia low power consumpt requir etc lead particularli credit card format devic exceedingli low data transfer rate mem ori omput resourc resourc limit applic area cash card ident card etc howev gener purpos multiappl card resourc limit signific explor use trust hardwar softwar engin 7 6 see section 6 appear ieee comput societi symposium research secur privaci oakland ca may 1998 pp 198206 context becom necessari store larg amount data form variou data structur stack queue array dynamicstat symbol tabl variou type tree etc data structur fit limit resourc devic howev devic usual use concert larger power presum advers host comput h data structur store h integr assur data structur invari instanc data struc ture invari store digest form signatur within devic data structur oper perform conjunct modif signatur maintain digest form invari approach differ earlier work 4 5 protocol much simpler use o1 memori trust comput transfer o1 amount data push pop oper onlin mode previou approach use ologn trust memori ologn data transfer oper n size stack queue ever previou work 4 5 assum extrem power adversari inform theoret bound follow line work quit differ techniqu applic comput bound adversari paper organ follow section 2 present goal threat relat work section 3 describ protocol stack evalu section 4 describ protocol queue evalu section 5 describ previou work handl random access memori discuss relationship stack queue work section 7 describ extens protocol section 6 describ applic use protocol section present conclud remark background section discuss goal work threat relat work goal work maintain integr stack queue maintain potenti hostil platform also wish manner extens desir properti describ section 7 need make assumpt adversari environ may focu descript secur data structur applic assum channel h authent allow adversari may learn inform channel assum h dishonest need follow protocol assum adversari also submit high level command thu data structur protocol need secur chosen known attack context chosen attack one adversari complet control data oper data structur known attack one attack assum know oper data assum comput bound adversari limit number oper submit data structur amount inform may store number oper requir process data andor fill storag data assum adversari may tri replay data instanc data structur replay may due multipl concurr run protocol lead vulner assum adversari may tri compos new messag use messag fragment session issu beyond scope paper paper address recov corrupt lost data thu attempt replic data structur oper share data structur multipl secur processor also beyond scope paper 21 relat work work follow memori protect investig 4 5 consid problem verifi correct larg memori size n bit maintain allpow adversari p subject updat request origin v limit amount trust memori scheme base merkl signatur tree 12 describ detail section 5 shown p fool v incorrect memori whenev v access less logn bit trust memori also describ implement stack queue 5 stack implement use logh memori access oper stack height h approach also relat differ work lamport 10 onetim password scheme precomput chain hash secret w sequenc w w password fo th idenf session 1 defin w lamport scheme chain decreas useag also use chain digest signatur andor hash protocol howev scheme comput chain differ addit chain grow shrink base chang state data structur approach expect p constant factor faster v use constant number bit trust memori irrespect size stack queue also perform constant number untrust memori oper stack push pop assum signatur scheme collisioncomput resist 2 nd preimag resist goldreich 8 ostrovski 14 give solut oblivi machin machin oblivi sequenc access memori locat equival two program run time work solv differ problem yet reli techniqu protect integr memori eg ostrovski use sequenc number protect ram address method protect integr stack queue 3 stack begin defin stack follow interfac 7 invari propos implement use secur processor trust insecur processor h hostil use follow algorithm action taken shown prefix other ital r 0 random number gener oex signatur datum x trust processor basic protocol ie one trust host repres cryptograph hash function ei ther key unkey public key base digit signatur assum oex collisioncomput resist 2 nd preimag resist assum probabl signatur collis made arbitrarili small chang paramet signatur scheme also assum good sourc random number function start becom avail hardwar devic oex key separ key gener instanc key destroy upon delet key never leav assum authent channel messag stream integr h also entri stack simpl string arrow indic direct transmiss use repres new valu oe data structur oper request h shown doubl quot eg push follow relev operand new select random r init 2r f0 1g l initi stack gener new random sign send h new stack command henceforth signatur oer init use identifi stack pushx h store two top stack push request sent h along current stack signatur new valu stack signatur updat sign string form append push valu current signatur signatur alway retain refer oe top pop top stack oer init error stack underflow error comput oex jj oe top compar store oe bottom top hostil platform maintain stack r init trust host figur 1 resourcelimit secur implement stack oer init comparison fail termin error upon pop h return valu ostens top stack x signatur stack oe top valu push store current stack signatur recomput check shown verifi empti stack claim recomput use local copi r init compar return copi oe delet command reset stack protocol associ signatur held discard stack protocol illustr figur 1 arrow show input comput signatur alway signatur stack maintain devic prior execut push signatur oe stack devic item x need push ith member stack comput new signatur oe i1 shown figur new item x old signatur oe given h stack implement request execut push normal push take one argument sinc use fix length signatur two argument new item old signatur repres singl bit string inclus signatur add constant amount extern storag transmiss overhead oper new signatur oe i1 retain devic memori defens tamper h thu pop command issu h expect return top item x signatur rest stack oe origin signatur oe i1 recomput check valu store infeas h spoof forg valu x oe long retain oe i1 thu stack invari preserv argu detail follow section 31 evalu argu stack integr check protocol work provid signatur scheme use collis resist 2 nd preimag resist stack one work correctli accord standard specif stack specif stack found page 2 9 page 170 nonid stack show flaw pop execut return valu top ideal stack defin incorrect stack one seri return valu differ one would top ideal stack oper definit 3 protocol check stack implement secur incorrect stack alway detect whenev return wrong valu pop present main claim correct stack protocol theorem 1 stack protocol secur long signatur scheme base collis resist 2 nd preimag resist prove theorem first defin notion correct digest stack next argu protocol ensur seri oper omega correct digest ideal stack argu correct digest ideal stack incorrect stack oper h detect definit 4 correct digest stack initi valu 0 item defin follow readi state main claim digest maintain protocol seri protocol alway maintain correct digest ideal stack provid oper correctli accord protocol b underli signatur scheme collis resist 2 nd preimag resist shown induct assum work accord stack protocol given correct digest initi state trivial suppos correct digest oe igamma1 ideal stack first oper two signific case may push pop push pushx comput signatur thu correct definit see descript push protocol 1 induct assumpt pop upon pop h expect return two valu item top stack x signatur rest stack oe r check follow hold sinc assum collis resist 2 nd preimag resist signatur scheme would infeas h find valu x oe r satisfi constraint x oe r inde valu use comput oe origin mean oe correctli digest ideal stack oe r pop execut oper may also delet new either case effect either creat new ind pendent correctli initi digest new stack andor termin current stack instanc even element final claim shown claim establish theorem proven alway store correct digest ideal stack everi sequenc incorrect stack oper alway detect provid underli signatur scheme collis resist 2 nd preimag resist without loss gener assum execut pop assum correctli digest ideal stack operationsomega oe n oper n comput x item current top stack collis resist signatur scheme h feasibl substitut anoth x oe r therefor incorrect stack oper detect via bad signatur 4 queue queue implement keep two item trust memori signatur entir queue includ item use rear queue signatur item remov queue begin brief descript interfac queue queue ht interfac axiomat provid found standard text formal specif guttag horn 9 case stack assum messag h sent authent channel messag stream integr bitstr entri queue simplic new sign key queue instanc newq select random r init 2r fo 1g l case stack gener new random sign send h identifi initi new queue nqq x rear q1 front q hostil platform maintain queue r init trust host remov element r m1 r init figur 2 resourcelimit secur implement queue enqueu comput new signatur sign string form append new item current signatur entir queue signatur sent h along current item signatur also updat current queue signatur enqueu oper comput check nb h say queue empti ensur oe h get dequeu request return item ostens front queue signatur oe front append return item store oe r sign result compar signatur oe front signatur match approv oper ation updat oe r oe front queue protocol illustr figur 2 retain two signatur oe q digest entir queue oe r digest item remov enqueu request updat oe q includ item queue digest h ask store item current digest assum oex repres key cryptograph hash public key signatur upon dequeu request h ask return item front queue x associ sign digest oe front use oe r item valu store trust memori authent dequeu valu signatur repres item ever remov queue compar new oe 0 r valu result sign string obtain append item x claim front queue old signatur oe r follow section examin correct protocol close 41 evalu argu queue protocol detect incorrect oper queue h definit 5 ideal queue one work accord usual lifo disciplin incorrect queue one seri oper dequeu return item one would head ideal queue set oper definit 6 defin incorrect queue one seri return valu differ one would head ideal queue oper definit 7 protocol check queue implement secur incorrect queue alway detect whenev return wrong valu dequeu main claim correct queue protocol theorem 2 queue protocol secur long signatur scheme base collis resist 2 nd preimag resist use notion correct digest well howev case queue two piec digest oe q repres entir histor ical queue includ item ever en queu oe r repres item dequeu see figur 2 definit 8 correct digest queue initi valu current queue q 1 item next de queu item r remov r 1 first item remov r item recent remov consist two signatur oe q oe r comput follow seri protocol alway maintain correct digest ideal queue provid oper correctli accord protocol b underli signatur scheme collis resist 2 nd preimag resist show induct initi claim hold trivial consid queue oper enqueu enqueuex request oe r unchang protocol 2 specifi definit 8 oe q comput follow specifi definit 8 dequeu dequeuex request oe q unchang protocol 2 specifi definit 8 oe r updat describ protocol 2 h return signatur oe 0 r item x follow equal check equal hold assum signatur scheme use desir prop erti set oe r oe 0 r correctli updat oe r note h comput oe 0 r sinc sign key secret assum collis resist 2 nd preimag resist signatur scheme valu given h time x enqueu h return valu check correct digest preserv note way signatur use differ stack protocol stack protocol h return item old signatur ie input signatur algorithm sign yield valu ident digest held case queue h return item output signatur item oe r digest sign togeth match output signatur return h oper delet new creat new independ correctli initi digest new queue andor termin current stack instanc follow claim establish theorem proven 4 alway store correct digest ideal queue everi sequenc oper incorrect queue alway detect provid underli signatur scheme collis resist 2 nd preimag resist assum execut dequeu assum correctli digest ideal queue operationsomega oe q oe r dequeu h return item x new signatur r verifi x item current head queue collis resist signatur scheme cryptograph assumpt h unabl comput signatur h feasibl substitut anoth x oe 0 r therefor incorrect queue oper detect via bad signatur 5 scheme ram tree sever scheme propos literatur handl random access memori ram 5 scheme base merkl signatur tree 12 describ signatur tree discuss tradeoff implement secur stack queue use 51 prior work ram given nbit address space one construct secur ram binari tree 2 n leav 2 n interior node use 2 n1 data element insecur memori array stand insecur bit address select branch binari tree figur 3 show tini ram 4 bit address space node ram unambigu design bit substr address leav store valu ram given com plete nbit address string buggi ram actual valu memori cell address tamper valu adversari deter high probabl store signatur interior node signatur comput follow given interior node address j j n note treat bit string differ index insecur memori array thu 0011 11 accomplish simpl transform bit string integ array index root valu 0 kept address access n valu interior nodes1001000 figur 3 ram address shown 1010 along address path well n addit valu need comput signatur interior node well root valu also access address modifi signatur valu interior node along address path recomput 52 stack queue ram sinc ram gener type memori question natur aris simpli implement secur stack queue use secur ram answer question given specif situat depend set engin design issu main consider use ram number signatur comput time particular leaf valu address binari tree represen tation n signatur comput requir could avoid partit ram larg page reduc effect number signatur comput anoth approach retain certain number page swap page h need would amount secur virtual memori sever complic implement secur page system base ram scheme describ limit program text space devic eg smart card may preclud implement secur virtual memori limit data memori limit amount trust page kept within bandwidth limit forc high penalti page fault decreas page size much increas number signatur comput page fault n bit address space signatur comput page fault signatur check outdat dirti page read recomput upon write anoth page swap anoth set signatur check applic primarili use stack queue mention complic domin stack queue scheme use ever highqual implement virtual secur memori avail would reason use howev author awar implement devic current market unlik secur virtual memori scheme must care implement tune scheme rel simpl built applic programm 6 applic problem check larg data structur limit memorywa motiv new applic softwar tool 7 6 goal work place trust softwar tool static analyz type check er proof checker compilersinstrument etc trust hardwar output tool would attest signatur publickey crypto system one particular applic concern java tm bytecod verif 11 process similar typecheck carri java tm virtual machin jvm program jvm stackori machin typecheck process ensur everi control flow path lead given point jvm program type stack entri com patibl eg object type netsocket never conflat object type circl properti bytecod verif ensur key typesafeti properti core secur polici jvm current process carri browser netscap tm prior execut mobil java tm code applet perfor manc secur configur manag intellectu properti protect advantag claim bytecod verif similar static analysi process conduct trust machin result analysi attest pubickey base cryptograph signatur mobil code bytecod verif algorithm 11 involv inter alia maintain agenda control flow path expand b comput state evalu stack c look type rule variou type instruct maintain symbol tabl variabl resourceintens data usag tax resourc power expen devic anoth applic discuss 6 place proof checker devic necula 13 suggest mobil code carri proof applic safeti properti unfortun proof reveal great deal data structur layout loop invari algorithm vendor may balk reveal intim detail prod uct proof checker devic vendor check proof site bare binari san proof sign devic attest correct proof remain secret yet anoth applic creation trust sign analysi product control depend graph data depend graph slice etc accompani mobil code trust analysi product use secur environ optim sand box 15 mobil code techniqu one suggest form use implement techniqu place trust softwar analysi tool trust hardwar trust hardwar devic expect becom power inher physic design constraint form factor energi usag heat dissip like prevent perform gap convent machin narrow implement techniqu remain applic 7 extens futur work techniqu discuss simpli insur integr stack queue discuss extens futur work address relat issu confidenti key expir data structur share provid confidenti confidenti may concern applic stack queue protocol design allow layer integr confidenti mechan top basic protocol updat key sinc assum comput bound adversari cryptograph key use protect integr data structur limit lifetim reli key beyond lifetim could compromis integr instanc data structur discuss manag key instanc data structur one gener approach replac key obviou complet rewrit temporarili suspend normal usag data structur remov element one instanc data structur add new instanc new key issu aris approach may possibl go directli one stack anoth sinc order element would revers howev problem correct repeat process anoth stack altern oper perform singl pass use queue second gener approach updat key gradual transit one key anoth elimin need data structur unavail key updat multipl signatur use differ key maintain entir structur updat new key share data structur multipl entiti may wish share oper data structur issu involv share data structur concern share recent signatur key associ structur scheme may built top secur quorum scheme howev unclear whether scheme satisfi secur perform requir share data structur area topic futur research 8 conclus describ protocol resourc limit trust comput store stack queue untrust host retain constant amount memori trust machin tahi approach differ earlier work 4 5 protocol much simpler use o1 memori trust comput transfer o1 amount data push pop oper onlin mode previou approach use ologn trust memori ologn data transfer oper n size stack queue howev unlik previou approach use inform theoret bound assum comput limit ad versari present argument show protocol detect attack return incorrect valu 9 acknowledg work greatli benefit result earli discuss dave mcallest ram tree recent discuss philip fong associ ar ray well feedback anonym review confer r javacard 20 applic program inter face mondex magazin check link data structur check correct memori techniqu trust softwar engin cryptograph verif test coverag claim toward theori softwar protect simul oblivi ram larch languag tool formal specif password identif insecur commun java tm virtual machin specif certifi digit signatur effici comput oblivi ram effici softwarebas fault isol secur coprocessor electron commerc applic tr toward theori softwar protect simul oblivi ram effici comput oblivi ram certifi digit signatur languag tool formal specif effici softwarebas fault isol access control signatur via quorum secret share proofcarri code cryptograph verif test coverag claim techniqu trust softwar engin password authent insecur commun java virtual machin specif