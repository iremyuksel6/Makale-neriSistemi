minimum achiev util faulttoler process period task abstractth rate monoton schedul rm polici wide accept schedul strategi realtim system due strong theoret foundat featur attract practic use period task set n task deadlin end task period guarante feasibl schedul singl processor long util factor task set n21n 1 converg 069 larg n analyz schedul set period task schedul rm polici suscept singl fault recoveri action reexecut uncomplet task prioriti rm polici maintain even recoveri condit guarante task miss singl deadlin even presenc fault util factor processor exceed 05 thu 05 minimum achiev util permit recoveri fault expir deadlin task bound better trivial bound 0692 0345 would obtain comput time doubl provid reexecut rm analysi result provid schedul guarante toler varieti intermitt transient hardwar softwar fault handl simpli reexecut addit demonstr perman fault toler effici maintain common spare among set processor independ execut period task b introduct realm realtim comput frequent encount system task requir execut period applic requir common often found exampl process control space applic avion other even extern event trigger task period mani realtim system sampl occurr event period execut associ task time slot reserv sampl rate depend expect frequenc extern event reason aperiod sporad task execut period manner period execut well understood predict varieti schedul polici period realtim system studi schedul polici defin optim schedul feasibl set task polici also system call fixedprior system task fix prioriti prioriti chang run time rate monoton schedul rm proven optim schedul polici schedul set fix prioriti task uniprocessor earliestdeadlinefirst edf optim schedul polici variabl prioriti system note prioriti task differ critic former measur assign task schedul polici facilit schedul wherea latter measur import task defin applic rm wide use practic easili implement preemptiv polici prioriti task assign increas order period task particular prioriti preempt lower prioriti task liu layland prove long util factor task set consist n task less n2 1n gamma 1 task set guarante feasibl schedul uniprocessor 1 bound approach 069 n goe infin howev may exist task set util factor bound still may feasibl schedul stochast analysi breakdown util factor randomli gener task set present 2 problem schedul period task multiprocessor consid 3 4 5 easi demonstr neither rm edf algorithm optim schedul set period task multiprocessor system among fix variabl prioriti algorithm respect 3 fact schedul polici proven optim multiprocessor system anoth issu realtim comput current gain increas attent research fault toler comput introduc great extent critic applic relianc place reduc human intervent minimum situat demand hard realtim process merg catastroph consequ failur difficult imagin fault toler must provid respons system 6 must perform comput success meet deadlin even presenc fault indispens mani applic paper contribut evolv framework design implement respons system goal paper investig issu fault toler system realtim period task employ rate monoton schedul previou work usual address softwar fault task primari altern code 7 offlin schedul strategi consid period task period particular task integr multipl next lower task period altern schedul rm polici first effort made includ maximum number primari execut schedul similar problem schedul altern version program call ghost consid 8 dynam program use perform schedul attempt made minim cost function load balanc scheme present period task set schedul rm 9 neighbor faulti processor ring take task eventu distribut processor howev consider miss deadlin due overload caus task migrat respons fault paper address schedul criterion set period task faulttoler process specif prove minimum achiev util 05 set period task execut environ suscept occurr singl fault recoveri action recomput partial execut task result guarante task meet deadlin even presenc fault util factor task set processor less 05 class fault toler includ intermitt transient hardwar softwar fault addit perman crash incorrect comput fault also handl provid spare perform recoveri subsequ execut task set paper organ follow section 2 provid background explain problem declar assumpt follow section present proof assert minimum achiev util 05 section 4 address practic implement issu conclus given final section background problem statement assumpt mention introduct rm strong theoret foundat wide use practic due simplic rate monoton schedul polici assign prioriti task increas order period consid set n task task describ tupl execut time task period r releas time ie time first invoc task occur thu ng assum task label manner task expect complet comput prior end period thu j th instanc j 1 2 task readi execut time r deadlin complet assum deal hard realtim system aim meet deadlin condit oppos soft realtim system deadlin may miss aim reduc delay paper explicitli mention r assum zero execut task preemptiv ie execut task higher prioriti task k readi execut comput task interrupt remain suspend task k complet execut task continu state suspend provid task higher prioriti wait execut usual assum time swap task neglig account comput time note definit preemption recurs ie task k interrupt task interrupt anoth task still higher prioriti rm fix prioriti polici sinc prioriti task remain static chang cours execut task prioriti assign increas order task period task smallest period assign highest prioriti task largest period lowest call arriv time task instant readi execut ie deadlin next arriv task departur time task defin time instant task complet execut thu arriv time j th instanc task r departur time defin easili depend paramet higher prioriti task util factor u task set defin singl processor system task set said fulli util processor schedul algorithm task set feasibl schedul use algorithm increas caus schedul infeas least upper bound util factor minimum util factor possibl task set fulli util processor 1 also call minimum achiev util 3 task set util factor less minimum achiev util guarante feasibl schedul 1 task set n task minimum achiev util n2 1n gamma 1 n 1 minimum achiev util converg ln2 approxim 069 21 fault classif discuss fault toler necessari consid issu fault assumpt signific impact design system crash fault model processor either oper correctli fault occur respond event intern extern incorrect comput fault assumpt consid processor may fail produc correct result respons correct input issu relat fault diagnosi consensu faulttoler process reader refer 10 addit fault also classifi perman intermitt transient 11 perman hard fault erron state continu stabl intermitt fault occur occasion due unstabl natur hardwar transient fault result temporari environment condit perman fault toler provid spare take task primari processor fault occur intermitt transient fault toler repeat comput 22 analysi problem gener schedul problem concern alloc share resourc multipl process need resourc simultan alloc perform attempt achiev certain prespecifi goal tradit comput goal usual minim total time increas respons time request howev realtim system goal simpli alloc resourc manner deadlin associ task met paper deal schedul task execut resourc processor hard realtim system schedul task guarante complet deadlin realtim system use critic applic necessari system surviv spite fault may aris system unlik nonrealtim system occurr fault subsequ recoveri may permit caus delay imper result comput realtim system meet deadlin even presenc fault thu notion guarante feasibl schedul extend cover random event fault occurr challeng endeavor address nevertheless paper consid fault toler strategi set period task execut rm polici guarante task miss even singl deadlin due occurr fault random moment subject fault assumpt explicitli state therein maintain prioriti rm polici one consid introduc fault toler comput host issu need consid addit alreadi exist mean provid fault toler introduc redund system select appropri level time andor space redund driven requir applic redund provid creat replica level comput usual task level realtim system time redund provid reexecut task multipl number time origin execut reexecut perform singl processor differ processor choic depend fault model assumpt realtim system time redund desir choic provid suffici laxiti deadlin enough spare capac task miss deadlin allow maximum util avail resourc howev deadlin stringent littl laxiti avail space redund choic thu ideal design one effect resolv tradeoff two choic minimum cost overhead incur task guarante meet deadlin fault assumpt spacetim tradeoff fundament design respons comput system result present optim tradeoff provid schedul guarante singl fault environ period task 23 singl fault reexecut task recoveri analyz follow scenario ffl set task execut singl processor task schedul rm polici ffl task independ ffl fault may occur instant ffl interv success fault greater largest period task set ffl fault detect next occurr departur task processor exampl lower prioriti task execut occurr fault time later anoth higher prioriti task suppos preempt first task fault detect higher prioriti task expect depart normal execut ffl recoveri action reexecut partial execut task instant fault detect includ current execut task preempt task ffl task requir meet deadlin even reexecut due occurr fault ffl prioriti rm polici maintain even recoveri maintain prioriti task import sinc rm fix prioriti schedul polici prioriti assign system design time approach simplifi design process design worri assign separ prioriti recoveri analyz effect chang prioriti schedul task set one note stage place restrict kind fault toler architectur system long condit satisfi design result paper valid exampl one consid hardwar perman crash fault recoveri subsequ comput would perform regular execut fault b primari processor fault occur prior time 17 c spare processor figur 1 feasibl schedul presenc fault spare processor hand softwar fault occur recoveri possibl primari processor incorrect comput fault handl fault detect perhap consist check task expect depart addit recoveri program task need one normal execut long comput time less equal comput time primari code two exampl shown figur 1 2 consid task set consist two task period 5 7 exampl assum crash fault processor figur 1 processor state function time shown regular execut figur 1a observ schedul feasibl fault occur figur 1b 1c show state processor spare respect fault occur prior time instant 17 fault occur task 2 could complet restart spare meet deadlin time 21 figur 2a show execut profil two task whose period 5 7 respect howev exampl 2 though schedul feasibl fault occur true fault caus recoveri action taken arriv task 1 time 15 preempt task 2 fault occur prior complet time 17 spare restart execut task start task 1 higher prioriti task task 1 complet time 19 manag meet deadlin time 20 reexecut task 2 start time 19 preempt time 20 arriv next instanc task 1 task 2 miss deadlin time 21 seem obviou exampl certain amount time redund provid recoveri rm schedul criteria u 069 suffici trivial regular execut fault b primari processor fault occur prior time 17 c spare processor figur 2 infeas schedul presenc fault solut reserv enough space task event fault enough spare capac term time task reexecut still meet deadlin sinc worst possibl time fault occur prior complet task amount extra time devot task recoveri addit c thu rate monoton analysi schedul entir task set comput time task assum 2c mean gener case effect minimum achiev util processor 0345 ie half 069 howev situat pessimist appear prove follow section minimum achiev util 05 guarante enough time redund complet recoveri deadlin thu long util factor task set processor less equal 05 task set guarante feasibl schedul presenc singl fault 24 motiv one popular tradit approach design faulttoler system use n modularredund nmr 11 techniqu everi processor provid extra spare spare may hot warm cold realtim system hot spare prefer choic time wast perform recoveri spare said hot synchron perform comput primari processor take primari processor fail fault model incorrect comput byzantin fault may distinct primari spare perform comput vote result mask faulti result assum crash failstop model nmr requir processor duplic toler singl fault number processor faulttoler system 2m number processor origin system system call duplex system toler one fault primari spare fault long one fault affect particular primari spare achiev space overhead equal size origin system ie doubl space resourc space overhead duplex system high mani applic usual desir singl spare group processor processor fail spare substitut place wherea provid singl spare simpl feat nonrealtim system ensur recoveri perform within deadlin easi contribut paper make easi guarante recoveri limit util factor processor 05 u total util factor larg set task number processor need system singl spare du 05e 1 assum crash fault even distribut util factor like significantli less 2 du 069e duplex system interestingli trivial solut ensur recoveri doubl comput time requir requir du 035e nearli requir duplex system addit toler hardwar crash fault major applic result toward toler softwar fault deal greater detail section 4 3 determin minimum achiev util prove minimum achiev util 05 present definit term use proof recoveri defin reexecut partial execut task prioriti rm maintain thu recoveri lower prioriti task higher prioriti task arriv higher prioriti task preempt recoveri lower prioriti task addit fault affect multipl task higher prioriti task perform recoveri action first schedul said feasibl set task task set guarante schedul rate monoton algorithm ie task meet deadlin even recoveri perform due singl fault occur arbitrari instant time set task said fulli util processor task set feasibl schedul increas comput time task set caus schedul becom infeas minimum achiev util minimum util factor everi possibl set task fulli util processor defin critic instant task instant arriv task largest respons time presenc fault schedul set task fulli util processor least one critic instant task respons time period task shall call time interv arriv deadlin task critic period fault occur prior complet task creat maximum delay task lower prioriti task interrupt henc need examin effect fault instant task complet consid number case lead proof theorem minimum achiev util 05 31 case 1 task set one task consid task set compris singl task c case releas time matter observ 1 minimum achiev util task set one task 05 proof obviou sinc c 1 exceed 1 2 c 1 equal valu x occur instant kt 1 44 48 54 55 b recoveri task 2 recoveri task 2 recoveri task 1 figur 3 schedul two task period 6 11 suffici time reexecut task still meet deadlin processor fulli util c import note even task set one task comput time task exceed half valu period ie c n number task set 32 case 2 task set two task begin analysi minimum achiev util case let us consid issu releas time tradit rm analysi worst delay task 2 observ arriv simultan task 1 first arriv task 2 feasibl schedul subsequ arriv also meet deadlin one consid feasibl condit simultan arriv task necessarili true one consid possibl fault exampl consid task set f1 6 45 11g releas time zero consid first arriv would appear task set feasibl schedul processor fulli util shown figur 3a task 1 2 releas simultan sinc task 1 higher prioriti start execut depart begin fault occur prior complet task 2 time instant 55 restart perform recoveri task 1 arriv time 6 preempt recoveri recoveri complet time 11 next arriv task 2 occur howev fault occur time instant 49 schedul infeas shown figur 3b task 2 arriv time 44 preempt task 1 arriv time 48 fault occur prior complet task 1 time 49 task reexecut task 1 recov time time instant 50 recoveri task 2 begin howev next arriv task 1 occur time 54 preempt recoveri task 2 caus miss deadlin time 55 4 unit time avail task 2 recoveri time interv 5054 wherea comput time 45 thu correct valu c 2 fulli util processor c henc analysi consid possibl valu releas time consid set two task arbitrari releas time first consid case 2 15t 1 next consid variou subcas 321 case 2a theorem 1 minimum achiev util 05 set two task satisfi condit proof first prove long util factor less equal 05 feasibl schedul guarante task set give particular instanc processor fulli util util factor 05 observ 1 clear c 1 1 2 within interv r 2 dt 2 1 e arriv task 1 worst possibl scenario task 2 complet preempt arriv task 1 fault occur prior complet task 1 case task 1 2 need execut task 1 meet deadlin sinc c 1 1 2 task 2 meet deadlin follow condit ie 2 tradit rm analysi feasibl condit dt 2 1 faulttoler system task execut worst case scenario occurr singl fault assum util factor task set less equal 05 ie therefor thu feasibl condit given equat 2 guarante equat 5 satisfi thu task set satisfi condit theorem 1 guarante feasibl schedul util factor less equal 05 b c figur 4 model subsequ arriv task consid case c two case processor fulli util sinc increas c 2 first case c 1 second case caus schedul becom infeas case util factor 05 also prove long util factor less equal 05 task feasibl schedul henc 2 15t 1 minimum achiev util 05 2 322 case 2b take follow approach proof proof first show instanc task model arriv first instanc valu releas time r 0and r 0 prove first instanc feasibl schedul possibl valu releas time long util factor less equal 05 ie prove minimum achiev util among task set fulli util processor first instanc 05 also without loss gener assum one r 1 r 2 zero consid figur 4 interest feasibl meet deadlin time instant th instanc task 2 arriv time instant r 2 kt 2 consid variou case r 1 ffl r 2 shown figur 4a th instanc task 2 model first instanc task 2 task set 0g possibl fault execut j th instanc task 1 affect schedul th instanc task 2 ffl r 2 shown figur 4b c th instanc task 2 model first instanc task 2 task set appendix consid possibl case releas time period task case present valu task comput time fulli util processor first instanc task 2 case prove processor fulli util first instanc task 2 util factor greater 05 theorem 2 minimum achiev util set two task satisfi condit 15t 1 05 proof shown subsequ instanc two task first instanc model first instanc releas time prove lemma 314 appendix possibl valu releas time processor fulli util first instanc util factor greater equal 05 henc minimum achiev util set two task satisfi condit 33 case 3 task set n 2 task consid set n task whose util prove induct minimum achiev util set n task 05 let us assum minimum achiev util set task 05 prove also true set n task consid set first n gamma 1 task whose util set n ngamma1 feasibl schedul u thu need consid case u 05 sinc u feasibl schedul assumpt thu need consid feasibl schedul task n 331 case 3a theorem 3 minimum achiev util 05 set n task satisfi condit assum minimum achiev util set task case set two task follow condit repres worst possibl scenario satisfi correspond task set feasibl schedul note revers true ie task set may satisfi follow condit still feasibl schedul ie assum u n 05 therefor thu condit equat 7 guarante whenev 0 thu sum also nonneg equat 7 satisfi task set guarante feasibl schedul thu set n task minimum achiev util 05 n 15t 332 case 3b consid two subcas follow lemma assum set task n fulli util processor note set ngamma1 fulli util processor sinc u 05 add task n set ngamma1 increment comput time till processor fulli util valu comput time c n henc task n least one critic period occurr fault subsequ recoveri caus task deadlin two possibl case worst case instant occurr fault prior complet task n case recoveri sole reexecut task n worst case instant occurr fault prior complet task former case fraction time processor spend execut task critic period task n x dt n e latter case fraction time processor spend normal execut recoveri task critic period task n lemma 1 minimum achiev util 05 set n task satisfi condit e assum minimum achiev util set task 05 construct set 0 task follow util factor u 0 set 0 n ie u 0 consid fault prior complet task c interv critic interv set n time complet task thu last task miss deadlin set 0 infeas schedul sinc assum minimum achiev util set task 05 util factor 0 must exceed 05 howev u u n 05 thu minimum achiev util everi set n task satisfi condit lemma 05 2 prove everi set n task fulli util processor satisfi condit lemma 1 convert anoth set task infeas schedul exampl consid set three task 0g task set fulli util processor task set construct set 0 5g set 0 2 infeas schedul fault occur time prior complet task 2 time instant 2625 enough spare time recov lemma 2 minimum achiev util 05 set n task satisfi condit assum minimum achiev util set task 05 assum set task n fulli util processor sinc set ngamma1 fulli util processor increment comput time task ngamma1 ngamma1 util factor 05 let increas delta let new set 0 util factor u 0 delta easi observ c n 2delta sinc task lowest prioriti task set reduct comput time delta c 0 free least 2delta amount time task n interrupt task amount 2delta reduct delta also free extra delta recoveri thu 05we prove follow theorem gener case theorem 4 set n task minimum achiev util 05 proof theorem 3 lemma 1 2 prove minimum achiev util set n task 05 provid minimum achiev util set task 05 addit theorem true one task shown observ 1 also proven true set two task theorem 1 2 henc induct true n 2 implement issu 41 toler hardwar crash fault consid distribut system common spare spare idl monitor state processor complet instanc task processor send messag spare indic task success complet spare maintain list task system processor execut inform either provid lookup tabl complet time task complet time easili comput onthefli let ccomm maximum commun latenc network task suppos complet time c spare expect confirm time case messag receiv processor declar faulti spare take faulti processor task set initi recoveri rate monoton analysi task set processor commun time overhead reconfigur assum includ comput time task task comput requir c c 0 use analysi techniqu assum commun delay finit bound unreason assumpt practic applic also requir execut code task access spare discuss section 2 space overhead guarante deadlin presenc singl fault duplex system 2 du069 processor howev number processor need system singl spare recoveri du05 1 u total util factor task set assum task set partit util factor evenli distribut tabl 1 show number processor requir scheme differ valu util factor observ provid common spare significantli reduc size system effect pronounc larg valu util factor tabl 1 number processor system comput time doubl rm analysi duplex system system common spare recoveri differ valu util factor u doubl comput duplex system common spare time rm analysi recoveri l u 0345 l u 069 l u 05 5 6 19 7 22 22 15 9 28 28 19 100 291 290 200 42 toler incorrect comput fault caus hardwar fault tripl modular redund tmr system requir toler incorrect comput fault duplex system detect presenc incorrect comput fault result two processor agre third processor requir major result assum correct similar techniqu describ use toler singl incorrect comput fault rather tmr system duplex system spare use case duplex pair detect error spare use perform recoveri number processor requir tmr system 3 du069 wherea number processor requir duplex spare recoveri 2 du05 1 u total util factor entir task set number processor requir scheme shown tabl 2 notic duplex spare requir less space overhead compar tmr system howev benefit larg observ crash fault 43 toler softwar fault intermitt transient hardwar fault believ greatest applic result paper would toward toler softwar fault intermitt transient hardwar fault space hostil industri applic outsid environ condit alpha particl electrostat interfer etc caus transient error addit softwar fault stack overflow oper system etc best handl reexecut limit util factor 05 processor guarante recoveri perform within deadlin even though consid reexecut partial execut task necessari fault affect singl task task reexecut meet deadlin confid reexecut caus task miss deadlin addit recoveri code need tabl 2 number processor tmr system duplex system common spare recoveri differ valu util factor u tmr duplex system system common spare l u 069 l u 05 5 9 42 37 100 435 401 primari code especi true softwar fault altern program desir long time execut recoveri program less equal execut time primari program certain deadlin met 44 toler multipl fault multipl fault toler analysi long interv success fault larger largest period task set assumpt unlimit transient fault toler k perman crash fault toler provid k spare limit util factor processor 05 certain task set k nmr system yield lesser space overhead greater fault coverag would easier implement case 05 069 u util factor entir task set assum task set partit util factor evenli distribut exampl total util use two processor wherea approach would requir three processor gener case provid k common spare would result lesser overhead conclus provid theoret foundat faulttoler process period realtim task schedul rate monoton schedul polici scenario recoveri fault involv restart partial execut task maintain prioriti level rm pol ici show minimum achiev util processor 05 result guarante task meet deadlin even presenc fault util factor processor restrict 05 bound much better maximum util factor 0345 0692 would obtain comput time task naiv doubl rm analysi provid recoveri time result provid framework toler transient intermitt hardwar softwar fault reexecut prefer recoveri techniqu addit result applic toler perman crash incorrect comput fault spare must employ replac faulti processor system show space redund achiev maintain common pool spare case less nmr system contribut paper form import compon evolut respons system concept provid guarante meet deadlin system spite occurr fault integr design faulttoler realtim system critic applic provid simpl criterion ensur feasibl meet deadlin presenc singl fault consider reduc complex encount design lead safer depend use realtim system critic applic r schedul algorithm multiprogram hard realtim environ rate monoton schedul algorithm exact character averag case behavior realtim schedul problem schedul period occur task multipl proce sor note preemptiv schedul period realtim task respons system challeng nineti faulttoler schedul problem schedul task quick recoveri failur diffus model base task remap distribut realtim system consensu problem faulttoler com pute theori practic reliabl system design tr ctr rodrigo santo jorg santo javier orozco least upper bound fault toler realtim system journal system softwar v78 n1 p4755 octob 2005 sylvain lauzac rami melhem daniel moss improv ratemonoton admiss control applic ieee transact comput v52 n3 p337350 march sasikumar punnekkat alan burn robert davi analysi checkpoint realtim system realtim system v20 n1 p83102 jan 2001 frank liberato rami melhem daniel moss toler multipl transient fault aperiod task hard realtim system ieee transact comput v49 n9 p906914 septemb 2000 tarek f abdelzah vivek sharma chenyang lu util bound aperiod task prioriti driven schedul ieee transact comput v53 n3 p334350 march 2004