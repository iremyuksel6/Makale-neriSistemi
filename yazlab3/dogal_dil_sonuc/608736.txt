unifi interprocedur parallel detect paper outlin new way detect parallel interprocedur within program method goe beyond mere depend test embrac method remov depend well name privat induct recognit reduct recognit method base combin techniqu univers form repres memori access within section code linear memori access descriptor techniqu classifi memori locat base access made code memori classif analysi depend test access region test analysi done linear memori access descriptor base intersect oper present algorithm linear memori access descriptor independ declar may exist program subroutin languageindepend make ideal use interprocedur analysi experi indic test highli effect parallel loop contain complex subscript express b introduct modern comput architectur everfast processor make increasingli import parallel compil analysi interprocedur compil parallel intraprocedur con parallel loop leaf node call graph quit often enough oper leaf node make parallel pay loop parallel within share memori model compil parallel highest level call graph parallel possibl overcom parallel loop overhead cost addit interprocedur depend analysi essenti produc spmd messag pass code serial program work support part armi contract dabt6395c0097 armi contract n6600197c8532 nsf contract mip9619351 partnership award ibm kaist seed grant program work necessarili repres posit armi govern c 2000 kluwer academ publish print netherland tradit depend test develop without regard applic across procedur boundari pair memori refer may access memori locat within loop compar memori refer occur discret point within loop thu say method pointtopoint depend test pointtopoint test requir 2 comparison n number memori refer particular array within loop obvious posit within call graph get leav number n grow growth caus interprocedur pointtopoint depend test get unwieldi consider motiv us take dierent approach depend test memori access within program section summar summari intersect determin depend section seri experi found approach reduc number comparison depend test also allow us handl complex array subscript express paper organ follow discuss previou relat work section 2 continu discuss section 3 show summar memori access activ arbitrari program section section 4 describ novel notat practic summar variou complex array access encount mani scientic program section 5 show use access summari store notat perform multiplesubscript interprocedur summarybas depend test evalu eectiv depend test implement polari 4 compil experi actual code perfect spec nasa benchmark suit experiment result present section 6 show test hold promis better detect parallel actual code test 2 previou work 21 intraprocedur depend test pointtopoint depend test method reli equat solv paradigm pair subscript express two array refer site check depend equat attempt made determin whether equat solut subject constraint valu variabl program loop indic gener case system linear relat built solut attempt linear system solver determin memori locat access dierent loop iter two earliest pointtopoint depend test gcd test banerje test 2 practic simpl ecient success determin depend sinc subscript express occur real scientic program simpl howev simplic test result limit instanc eectiv determin depend multidimension array coupl subscript state 9 sever multiplesubscript test develop overcom limit multidimension gcd test 2 test 12 power test 21 delta test test exact commonli occur special case case still conserv omega test 16 provid gener method base set linear constraint capabl handl depend problem integ program problem justment test common problem handl subscript express nonan nonan subscript express occur irregular code subscriptedsubscript access fft code subscript frequent involv 2 result compil transform induct variabl close form inlin expans subroutin solv problem pugh et al17 enhanc omega test techniqu replac nonan term array subscript symbol variabl techniqu work situat howev rang test 3 4 built provid better solut problem handl nonan subscript express without lose accuraci overal rang test almost eectiv omega test sometim outperform due mainli accuraci nonan express 3 one critic drawback rang test multiplesubscript test eectiv handl coupledsubscript 22 interprocedur summar techniqu interprocedur depend test demand new capabl depend test pointtopoint test becom unwieldi across procedur boundari given way depend test use summari access made subroutin idea use access summari depend analysi previous propos sever research balasundaram et al1 tang 18 also rang test though pointtopoint test use summar rang inform variabl obtain abstract interpret program perform accur depend analysi access summari compil need standard notat inform array access summar store depend analyz sever notat develop use depend analysi techniqu notabl triplet notat 3 10 19 set linear constraint 1 7 18 howev indic 11 exist depend analysi techniqu decienc directli traceabl notat use access summar triplet notat simpl work rich enough store possibl access pattern linear constraint gener precis repres access pattern due nonan subscript express requir much complex oper clearli room new depend test new memori access represent overcom limit exist techniqu 23 parallel detect depend test studi exhaust topic adequ address uni method parallel detect nd depend categor easi remov import compil transform eigenmann et al 8 studi set benchmark program determin import compil analys need parallel array privat reduct induct idiom analysi depend analysi nonan subscript express must done presenc strong symbol interprocedur analysi need improv analysi represent techniqu prompt us go back rst principl rethink data depend mean ask whether depend analysi done compil transform mind key contribut paper descript gener interprocedur parallel detect techniqu includ gener depend analysi techniqu describ section 5 call access region test art art multiplesubscript interprocedur summarybas depend test combin privat idiom recognit repres memori locat novel form call access region descriptor ard11 describ section 4 base linear memori access descriptor 14 3 memori classic analysi section formul data depend analysi term scheme classifi memori locat call memori classic analysi mca base order type access within section code method classifi memori locat gener one base abstract interpretation5 6 program may use purpos depend analysi tradit notion data depend base classifi relationship two access singl memori locat oper done read write order access determin type depend data depend arc direct arc earlier instruct sourc later instruct sink access singl memori locat program four type arc determin shown tabl tabl tradit data depend denit depend type input flow anti output earlier access read write read write later access read read write write input depend safe ignor parallel anti output depend also call memoryrel depend remov use memori usual privat memori locat involv flow depend also call true depen denc sometim remov transform origin code techniqu induct variabl analysi reduct analysi 20 gener notion data depend arbitrari section code built return rst principl instead consid singl instruct memori refer point consid arbitrari sequenc instruct indivis memori referenc unit thing requir memori referenc unit execut entir singl processor refer memori referenc unit depend grain definit 1 section code repres indivis sequenti execut unit serv sourc sink depend arc program call depend grain denit depend grain correspond term coars negrain analysi refer use larg small depend grain respect want know whether two depend grain may execut parallel must depend analysi grain sinc singl grain may access memori address mani time must summar access use way relat type order summari produc repres depend arc two grain definit 2 repres depend arc singl depend arc show order two depend grain must execut preserv sequenti semant program singl repres depend arc summar inform would contain multipl tradit depend arc singl instruct medium coarsegrain parallel mani access singl memori locat within depend grain instead keep track depend possibl pair refer refer site grain point topoint test desir repres depend relationship two grain individu memori locat singl repres depend arc mani possibl way summar memori access need analysi desir precis determin way best illustr idea next two section show two way summar access simpl lowprecis readonli summari scheme use writeord summari scheme 31 readonli summari scheme possibl dene repres depend carri depend inform need potenti parallel two grain depend exist pair memori refer two grain neither repres depend exist two access memori locat exist grain must simpli nd way assign aggreg access type group determin repres depend way retain inform need make parallel decis consid two grain execut serial form program one one consist way summar depend singl memori locat two grain determin whether access readonli grain dene depend tabl ii call readonli summari scheme tabl ii one possibl repres depend deni tion readonli summari scheme depend type input flow anti output later readonli figur depend summar readonli summari scheme input depend exist two grain ignor ow depend exist grain gener grain must serial earlier grain later grain flow depend input depend earlier grain later grain flow depend input depend output depend anti depend output depend grain flow depend grain figur 1 depend grain depend whether two grain readonli situat right show case privat later grain elimin output depend anti depend exist grain mean read happen one grain follow least one write output depend mean least one write occur grain anti output depend situat write locat rst access later depend grain would possibl run grain parallel privat variabl later grain howev readonli summari scheme dont keep enough inform summari determin whether write happen rst later grain would miss opportun parallel privat show readonli summar detect depend classifi depend clearli enough allow us elimin depend compil transform deriv better scheme next section 32 writeord summari scheme depend grain loop iter exist special case gener problem singl section code repres depend grain fact use simplifi depend analysi task still use readonli summar loopbas depend test would longer four case two iter either readonli howev abl dierenti anti output depend remov privat case readonli also divid two case one write rst access locat writefirst one read rst access readwrit give three overal class shown tabl iii tabl iii loopbas repres depend tabl access readonli readwrit writefirst depend type input flow antioutput iter read locat depend character input depend ignor iter read locat write variabl privat result depend ignor remov privat call flow depend iter write locat rst valu locat iter start immedi overwritten variabl privat sinc depend remov privat call memoryrel depend sinc privat done memoryrel depend case case signal write rst access need identifi case keep track case locat written rst input ow depend case character read happen rst dierenti whether occur later call writeord summari scheme make sens use writeord summar scheme gener case well loop locat readonli grain would correspond input depend writerst later grain would correspond memori relat depend sinc written rst later grain later grain need wait valu earlier grain other would correspond ow depend illustr tabl iv tabl iv eectiv way classifi depend two arbitrari depend grain use class readonli writefirst readwrit writeord summari scheme later readonli later writefirst later readwrit earlier readonli input antioutput flow earlier writefirst flow antioutput flow earlier readwrit flow antioutput flow readonli summari scheme could serv depend test writeord summari scheme detect depend well provid addit inform necessari remov depend privat transform see section 54 simpl test ad writeord summari scheme collect enough inform allow depend remov induct reduct transform 33 establish order among access know order access crucial writeord summar scheme must establish order access within program program contain straightlin code establish order access would trivial one could simpli sweep program executionord keep track access happen branch statement unknown variabl make dicult show one particular access happen anoth exampl take loop figur 2 write ai happen read ai p q true q true p fals read happen without write happen rst p q valu unrel compil way know order access loop hand compil show p q relat fact q true impli p must also true compil know write happen rst code involv condit branch major tool compil determin order access logic implic facilit use logic implic establish execut order represent memori refer must potenti p f figur 2 logic implic compil determin order access array iloop execut predic attach fact access figur 2 could classi readonli condit fpqg writefirst condit fpg readwrit otherwis definit 3 execut predic booleanvalu ex pression attach represent memori refer speci condit refer actual take place execut predic p denot fpg 34 use summari set store memori locat classifi set memori locat accord access type ad symbol represent appropri summari set definit 4 summari set symbol descript set memori locat chosen use access region descriptor ard describ section 4 repres memori access within summari set repres memori access use writeord summari scheme accord tabl iii requir three summari set depend grain readonli ro readwrit rw writefirst wf 35 classif memori refer memori locat refer program must enter one summari set process call classic program assum seri nest elementari context procedur program languag forc structur program transform form normal process readonli readonli readwrit newwritefirst newwritefirst figur 3 intersect earlier readonli access later writefirst access result readwrit set simpl statement statement loop call statement thu everi point program enclos context enclos context context travers execut order summari set enclos context built recurs calcul summari set enclos context distribut summari set enclos context determin memori locat common summari set intersect oper illustr figur 35 classic take input current state three summari set enclos context ro wf rw three new summari set last enclos context process ro n produc updat summari set enclos context set enclos context absorb way maintain proper classic memori locat exampl memori locat ro enclos context point wf rw newlycalcul enclos context becom rw updat enclos context step classic express set notat shown figur 4 351 program context classic simpl statement classi obviou way accord order read write memori statement within context classi ordinari way except ifcondit p appli execut predic statement block p appli statement els block descriptor els block intersect execut predic ore togeth produc result whole context classifi memori access loop twostep process first summari set singl iter loop must collect scan loop bodi execut order contain symbol form access possibl parameter index loop next summari set must expand ro ro wf ro ro ron ro ro ro rw ro write first memori refer prior code memori refer new code result classifi new references000000000000111111111 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 000000000000 0000 0000 0000 0000 0000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 00000000000000 read read write figur 4 classic new summari set ron wfn rwn exist summari set ro wf rw pictori exampl ad new summari set exist summari set loop index end process set repres locat access entir execut loop expans process illustr follow loop singl iter surround loop locat ai classi writefirst ai expand loop index represent a1100 result summari set loop expand similarli must use basic induct variabl loop index repres number iter unknown expans process make possibl avoid travers backedg loop classic classic call statement involv rst calcul access represent text call statement calcul summari set procedur call match formal actual paramet nalli translat summari set involv call context call context describ ard section 43 4 access region descriptor manipul array access summari depend analysi need notat could precis repres collect memori access brie mention section 2 previou studi 11 gave us clear pictur strength weak exist notat also gave us requir notat meet support ecient array access summar complex array subscript repres accur particular nonan express handl timecrit loop real program often contain array refer nonan subscript notat simplic oper dene complex access could chang simpler form facilit fast accur translat access summari across procedur boundari nontrivi array reshap procedur boundari handl ecient accur notat provid uniform mean repres access memori regardless declar shape data structur sourc code meet requir introduc new notat call access region descriptor detail previou literatur 11 ard deriv linear memori access descriptor introduc 13 14 avoid repetit section brie discuss basic ard necessari describ depend analysi techniqu section 5 41 repres array access loop nest array declar mdimension array referenc program array name follow list subscript express nest loop figur 5 figur 5 mdimension array refer dloop nest implicit notat array subscript function fm translat array refer set oset base address memori refer set loop indic surround nest loop refer set constant determin rule program languag nest loop execut loop index k move set valu subscript function fm gener sequenc oset base address call subscript oset sequenc isol eect singl loop index fm sequenc oset alway precis repres term start valu express repres dierenc two success valu total number valu sequenc exampl consid even nonan subscript express real a0 subscript oset sequenc dierenc two success valu easili express clear dierenc dene express ad ith member sequenc produc 1th member sequenc n member subscript oset sequenc start 2 dierenc success member 2 42 compon ard refer subscript oset sequenc gener array refer due singl loop index dimens access call dimens ard definit 5 dimens ard represent subscript oset sequenc set memori refer contain start valu call base oset dierenc express call stride number valu sequenc repres dimens index take integ valu 0 dimens index bound valu notic access produc array refer nest loop mani dimens loop nest also dimens index dimens may thought normal form actual loop index occur program ard origin construct compil program text addit three express describ ard dimens span express maintain possibl dimens span dene dierenc oset last rst element dimens span use certain oper simplic ard instanc detect intern overlap describ section 44 howev accur subscript express array access monoton singl base oset store whole access exampl array access access pattern memori lmad may seen figur 6 ard array access figur 5 written seri commasepar stride 1 superscript variabl name seri commasepar span 1 subscript variabl name base oset written right descriptor dimens index includ written form lmad need clariti case index dimensionbound written subscript appropri stride 43 interprocedur translat ard use properti ard eas may translat across procedur boundari translat array access inform across procedur boundari dicult declar formal array paramet dier declar correspond actual paramet array access represent depend 3 14 26 ak26i1 j k1 10 3 end end end real a14 figur 6 memori access diagram array nest loop access region descriptor repres declar dimension array face convert represent one dimension anoth array reshap occur alway possibl without introduc complic map function array reshap problem tabl v indic signic array reshap occur mani scientic applic publish 11 tabl v gure entri indic percentag call reshap variou benchmark program perfect spec nasa comput static examin program mention trfd arc2d tfft2 flo52 turb3d ocean mdg bdna tomcatv swim refer memori access represent independ declar dimension array univers represen tation becom procedur independ even languag independ univers represent elimin array reshap problem need translat new form potenti dierent dimension move dierent execut context ard exampl univers represent subroutin call refer base address formal array paramet set whatev address pass actual argument list memori access occur subroutin would repres call routin ard form rel base address whenev desir translat ard formal argument caller context simpli translat formal argument variabl name actual argument name add base oset actual paramet ard formal paramet exampl actual argument fortran code index array call oset begin array actual argument 2i suppos match formal paramet subroutin x z lmad access z x z 10200 access z subroutin x translat call routin lmad would repres term variabl follow 10200 result simpli ad oset renam z notic twodimension access even though declar onedimension 44 properti ard subsect brie describ sever basic properti ard use depend analysi base access summari set definit 6 given ard set stridespan pair call sum span rst k dimens kdimension width ard dene 4401 intern overlap ard process expand ard loop caus overlap descriptor exampl follow fortran doloop i110 j15 ai4j ard inner loop 1 1 ard expand outer loop becom 14 exhibit overlap due outer loop access due outer loop stride far enough get beyond array element alreadi touch inner loop properti may determin notic stride nth dimens greater dimension width ard 441 zerospan dimens dimens whose span zero add data element access pattern impli whenev dimens appear ard possibl manipul ard may safe elimin without chang access pattern repres likewis impli time new dimens may introduc desir stride zerospan without chang access pattern simplic oper exist elimin dimens within ard elimin ard found cover ard creat singl ard repres access sever ard sinc oper need exposit paper describ reader refer 11 14 13 5 access region test section rst describ gener depend analysi method base intersect ard gener method detect data depend two arbitrari section code show simplic gener method access region test work loop parallel show multidimension recurs intersect algorithm ard 51 gener depend test summari set given symbol summari set ro 1 wf 1 rw 1 discuss section 34 repres memori access earlier sequenti execut program depend grain set ro 2 wf 2 rw 2 later grain discov whether locat access grain nding intersect earlier later set consult tabl iv nonempti intersect repres depend grain howev depend may remov compil transform intersect must done variabl intersect empti variabl crossiter depend exist two depend grain follow nonempti ro 1 ro 1 rw 2 repres depend remov privat intersect region rw 1 rw 2 nonempti refer involv either induct form reduct form depend may remov induct reduct transform discuss detail section 54 intersect wf 1 ro 2 wf 1 rw 2 rw 1 ro 2 nonempti repres nonremov depend 52 loop depend test art access region test art use within gener framework memori classic analysi writeord summar mean entir program travers execut order use abstract interpret summari set comput nest context program store ard ard use semant element abstract interpret interpret rule exactli rule describ variou program context section 351 whenev loop encount art appli ard determin whether loop parallel paralleliz remov depend compil transform state section 32 depend test loop iter special case gener depend test describ last section loopbas depend test consid loop iter depend grain mean depend grain summari set expand summari set loop index section 351 crossiter depend notic three way within one lmad two lmad one summari set two summari set 521 overlap within singl ard intern overlap due expans loop index describ section 44 overlap occur indic crossiter depend condit easili check expans ag ard oper requir detect 522 intersect ard within summari set even though two lmad summari set intersect initi expans loop index could caus intersect intersect would repres crossiter depend intersect within ro would input depend summari set need check intern intersect wf rw must done howev figur 7 exampl two write array rst assign summari set overlap two writerst ard initi 0 base oset dierent intersect assum overlap conserv assumpt caus separ assign wf set expans creation dimens index 0 normal ard becom 1 intersect indic depend intersect would found attempt intersect ard within wf figur 7 exampl illustr need intern intersect summari set 523 intersect two summari set three summari set consid loop depend test instead six one depend grain three intersect tri instead eight requir section 51 expans loop index follow intersect must done ro wf ro rw wf rw intersect pair set ro wf rw involv least one read one write oper impli depend 53 loopbas access region test algorithm loop l program summari set ro wf rw art follow expand ard summari set loop index l check intern overlap due loop index l ard wf rw found within wf remov privat found rw remov refer involv either induct reduct form overlap ard note overlap ag reset check nonempti intersect pair ard wf remov privat rw possibl remov induct reduct possibl pair summari set group ro wf rw check nonempti intersect two ard pair contain ard dierent set intersect found note depend move rw nonremov depend found loop may declar parallel wherev uncertainti occur process demanddriven deeper analysi trigger attempt remov uncertainti runtim test gener 54 detect reduct induct pattern state section 23 idiom recognit import parallel program induct reduct involv assign linear recurr structur form dier slightli shown follow repres integ variabl r repres oat point induct oat point express reduct pattern origin present depend compil transform 15 4 remov depend three level test done within writeord summari scheme structur use posit identifi reduct induct 5401 level 1 rst test linear recurr structur assign statement pattern found ard statement mark pass level 1 test plu oper type integ constant oat point express store ard mark idiom type possibl induct integ variabl express integ constant otherwis mark possibl reduct 5402 level 2 intersect ard particular variabl within readwrit summari set part art describ section 522 one mark pass level 1 ard rw variabl pass level 1 idiom type oper fail level 2 ard variabl either readonli writefirst ard possibl reduct fail level 2 ard possibl induct ard exist variabl writefirst fail level 2 otherwis ard pass level 2 5403 level 3 pass level 3 ard mark pass level 2 must mark intern overlap due expans loop index outer loop mean depend due access carri outer loop ard mark pass level 3 consid idiom store type appropri code gener threelevel process nd induct reduct interproc dural interprocedur natur art 55 gener art access region test gener conserv depend test design discern three type depend input ow memoryrel distinguish anti output depen denc purpos consid unimport type depend remov privat transform purpos gener mca mechan use formul mechan appropri summari set produc requir inform much data ow analysi formul solv variou data ow problem section 31 32 show two dierent formul mca depend analysi readonli summari scheme simpli depend test writeord summari scheme provid enough inform test depend also remov depend compil transform 56 loopcarri depend handl art depend within inner loop essenti ignor respect outer loop fact expans loop index intersect portion two ard repres singl ard move rw summari set intersect portion count crossiter depend loop reduc singl ard longer found intersect outer loop intersect due outer loop sole due expans outer loop indic process illustr figur 8 ro j end end wf ro depend ro wf 100502a 100502 expand expand expand 501 100503 loop intersect indic independ ro rw wf figur 8 art handl loopcarri depend 57 multidimension recurs intersect algorithm intersect two arbitrari ard complex probabl tractabl two ard compar stride call strideequival stride one subset stride call semistrideequival quit often true experi similar enough make intersect algorithm tractabl present algorithm intersect figur 9 input two ard properli nest sort dimens 0 k number dimens work 0 k outputlist ard return ard list 0 ard rlist1 ard scalar add listard list ard rlist1 endif return ard list endif c period intersect left remov dimard right k 0 add listard list ard rlist1 r intersect right remov dimard left k add listard list ard rlist2 endif els intersect end remov dimard right k 0 add listard list ard rlist1 endif return ard list intersect remov dimard k new construct return new ard equival ard except without access dimens k new new base oset construct return new access dimens stride span add dimard dimnew new construct return new ard equival ard except new dimens dimnew new new base oset add listard list ard f add ard list ard ard list figur 9 algorithm nding intersect multidimension ard clariti remov intersect two input ard use conserv direct ag use execut predic shown although thing ad algorithm straightforward way algorithm accept two strideequival ard two ard semistrideequival zerospan dimens safe insert ard fewer dimens discuss section 441 make strideequival algorithm also pass conserv direct ag ag two possibl valu underestim overestim tell algorithm result imprecis overestim result enlarg maximum valu likewis underestim caus result reduc minimum valu two ard intersect strideequival result form base conserv direct algorithm take input two ard dimens precis sort ard number dimens work ard left base oset less ard right algorithm compar overal extent dimens ard shown figur 10a extent overlap way safe report intersect empti overlap algorithm call recurs specifi next inner dimens shown figur 10b intersect intersect figur 10 multidimension recurs intersect algorithm consid whole extent two access pattern recurs insid consid next inner dimens b process continu either determin overlap occur innermost dimens reach shown figur 11 make nal determin whether intersect two consid onedimension access result ard intersect return recurs return dimens ad result ard figur 11 multidimension recurs intersect algorithm consid innermost dimens nding intersect simplic descript assum two ard dimens fulli sort dimens one ard correspond dimens 1 1 6 experi access region test advantag test discuss section 1 three way reduc depend analysi intersect oper restrict art handl certain type subscript express coupl subscript problem rang test nonan express problem test use ard provid precis access summari array subscript express test implicitli interprocedur sinc ard may translat precis across procedur boundari separ valu art valu ard instruct consid question whether depend test might power art repres memori access ard notat answer question take exampl omega test mechan omega test dene ane express user omega test must extract linear coecient loopvari valu loop indic etc plu provid set constraint loopvari ard partial role constraint nonan express use way extract linear coecient nonan part techniqu replac nonan part express uninterpret function symbol develop 17 gener enough work situat even use ard omega test could handl nonan subscript express mechan simpli wellden express likewis rang test use ard repres valu rang variabl still would chang basic mechan make singlesubscript test unabl handl coupledsubscript mechan rang test forc consid behavior subscript express due singl subscript time wherea art compar access pattern instead subscript express simpl exampl figur 12 show advantag compar pattern show two loop nest display ident access pattern yet dierent subscript express top access determin independ rang test bottom access j1 j1 figur 12 rang test determin access top loop ind pendent bottom loop art nd independ sinc deal access pattern instead subscript express figur 13 show anoth exampl tfft2 benchmark code neither omega test rang test nd independ real u1 x1 y1 i02m21 u1321m2 end real u1 x1 y1 l01 m12 end real u x i02ml1 k02l11 end end figur 13 simpli excerpt benchmark program tt2 art determin free depend due appar complex nonan express involv yet art nd independ interprocedur topmost loop due relianc simpl intersect oper abil translat ard across procedur boundari power ard simplic oper expos simpl access pattern hidden insid complex subscript express continu develop art need evalu art real program therefor implement preliminari version art polari 4 parallel compil develop illinoi experi ten benchmark code experi observ art highli eectiv program complex subscript express ocean bdna tfft2 tabl vi show summari experiment result obtain time prepar paper care analyt studi conrm art theoret subsum rang test impli art parallel loop rang test even though experi art fail parallel loop flo52 arc2d due sever implement depend problem report 11 number loop addit parallel art small loop timecrit loop contain complex array subscript express previou experi report 13 also show art appli hand increas parallel speedup tfft2 factor 74 cray t3d 64 processor expect tabl vi show neither art omega test rang test make dierenc perform code simpl array subscript express tomcatv arc2d swim tabl vi comparison number loop parallel current version art techniqu rst line show number loop art could parallel rang test could second show number loop rang test could parallel omega test could third show number loop omega test could parallel rang test could loop code parallel ident test data second third line base previou work polari tfft2 trfd mdg flo52 hydro2d bdna arc2d tomcatv swim ocean previou techniqu base access summari show experiment result real program paper 1 18 thu possibl us determin eectiv techniqu would actual program 7 conclus futur work paper present techniqu unifi interprocedur depend analysi privat idiom recognit singl frame work techniqu elimin limit encumb loopbas linear systemsolv data depend paradigm expand notion depend test includ way classifi depend found compil elimin use code transform framework built gener scheme classifi memori locat memori classic analysi base order type access framework reformul use mani purpos readonli writeord summar scheme present mani scheme possibl varieti purpos multidimension recurs intersect algorithm ard introduc allow us calcul precis intersect two strideequival ard algorithm form core depend analysi calcul heurist ad algorithm handl case ard strideequival precis intersect algorithm becom precis data depend analysi becom believ exibl gener aord reformul data depend make use mani purpos within compil futur intend use mca framework analys automat extend interprocedu ralli addit intend formal method analysi term abstract semant element rule within abstract interpret framework r techniqu summar data access use parallel enhanc transform depend analysi symbol analysi techniqu e parallel program polari semant foundat program analysi abstract interpret uni interprocedur array region analys automat parallel perfect benchmark implement interprocedur bound regular section analysi automat parallel distribut memori machin base access region analysi induct variabl substitut reduct recognit polari parallel compil practic algorithm exact array depend analysi nonlinear array depend analysi exact side e gate ssabas demanddriven symbol analysi parallel compil high perform compil parallel comput power test data depend tr interprocedur depend analysi parallel techniqu summar data access use parallel enhanc transform practic depend test practic algorithm exact array depend analysi exact side effect interprocedur depend analysi nonlinear array depend analysi gate ssabas demanddriven symbol analysi parallel compil automat parallel perfect benchmarksmyampersand174 simplif array access pattern compil optim nonlinear symbol data depend test abstract interpret depend analysi parallel program polari effici data depend analysi parallel compil implement interprocedur bound regular section analysi power test data depend interprocedur array region analys symbol analysi techniqu effect automat parallel interprocedur parallel use memori classif analysi ctr paek navarro e zapata j hoefling padua advanc compil framework noncachecoher multiprocessor ieee transact parallel distribut system v13 n3 p241259 march 2002 thi viet nga nguyen franoi irigoin effici effect array bound check acm transact program languag system topla v27 n3 p527570 may 2005