bucket heap list monoton prioriti queue introduc heapontop hot prioriti queue data structur combin multilevel bucket data structur denardo fox heap data structur superior oper bound either structur taken alon use new data structur obtain improv bound dijkstra shortest path algorithm also discuss practic implement hot queue experiment result context dijkstra algorithm show implement hot queue perform well robust implement base heap multilevel bucket data structur b introduct prioriti queue data structur maintain set element support oper insert decreasekey extractmin prioriti queue fundament data structur mani applic typic applic includ graph algorithm eg 14 event simul eg 5 import subclass prioriti queue use applic event simul dijkstra shortest path algorithm 13 class monoton pri work done author visit nec research institut support depart defens partial support nsf award ccr9357849 match fund ibm schlumberg foundat shell foundat xerox corpor queue intuit prioriti queue monoton time key element queue least big key recent element extract queue paper deal monoton prioriti queue unless mention otherwis refer prioriti queue whose oper time bound depend number element queue heap fastest implement heap describ 4 14 19 altern implement prioriti queue use bucket eg 2 7 11 12 oper time bucket base implement depend maximum event durat c defin section 2 see 3 relat data structur heap particularli effici number element heap small bucketbas prioriti queue particularli effici maximum event durat c small furthermor work done bucketbas implement amort element bucket yield better bound number element larg sens heap bucket complement introduc heapontop prioriti queue hot queue combin multilevel bucket data structur denardo fox 11 heap queue use heap instead bucket bucket would spars occupi result implement take advantag best perform featur data structur also give altern insight descript multilevel bucket data structur concurr independ similar descript given raman 17 hot queue relat radix heap rh 1 ahuja et al 2 rh similar multilevel bucket use heap find nonempti bucket get best bound heap oper time rh depend number distinct key heap complic part 2 modifi fibonacci heap 14 meet requir contrast hot queue bound requir anyth special heap use fibonacci heap modif achiev bound rh use heap thorup 19 obtain even better bound sideeffect obtain om implement dijk stra shortest path algorithm improv previou bound sinc thorup bound depend total number element heap rh take immedi advantag data structur believ data structur especi interest work well theori practic preliminari version hot queue data structur 6 perform well practic base experiment feedback modifi data structur practic also develop techniqu make hot queue effici practic compar implement hot queue implement multilevel bucket kari heap context dijkstra shortest path algorithm experiment result show hot queue perform best overal robust either two data structur especi signific multilevel bucket implement dijkstra algorithm compar favor implement algorithm previou studi 7 shown robust mani problem class hot queue implement dijkstra algorithm best theori practic due page limit omit proof detail experiment data full version paper appear 8 preliminari prioriti queue data structur maintain set element support oper insert decreasekey extractmin assum element key use compar element denot key element u aeu unless mention otherwis assum key integr valu element mean key ele ment insert oper add new element queue decreasekey oper assign smaller valu key element alreadi queue bound depend c extractmin oper remov minimum element queue return element denot number insert oper sequenc prioriti queue oper n gain intuit follow definit think event simul applic key correspond process time let u latest element extract queue event insert decreasekey oper queue given event let v element insert queue element whose key decreas event durat aeu denot maximum event durat c applic monoton event durat nonneg monoton prioriti queue prioriti queue monoton applic make definit valid first insert assum initi special element insert queue delet immedi afterward without loss gener assum valu element zero subtract valu element valu paper heap mean prioriti queue whose oper time bound function number element queue assum heap also support findmin oper return minimum element heap call sequenc oper prioriti queue balanc sequenc start end empti queue particular implement dijkstra shortest path algorithm produc balanc oper sequenc paper use ram model comput 1 nonobvi result model use appear 9 attribut b schieber result given two machin word find constant time index signific bit two word differ 3 multilevel bucket section describ klevel bucket data structur denardo fox 11 give simpler descript data structur treat element key basedelta number certain paramet delta consid bucket structur b contain k level bucket k posit integ except top level level contain array delta bucket top level contain infinit mani bucket top level bucket correspond interv choos delta delta consecut bucket top level nonempti need maintain bucket 2 denot bucket j level bi j bucket contain set element way allow constanttim addit delet eg doubli link list given k choos delta small possibl subject two constraint first top level bucket must contain least c definit c key element b belong level bucket second delta must power two manipul basedelta number effici use ram oper word bit constraint mind set delta smallest power two greater equal c maintain key latest element extract queue consid basedelta represent key element u b definit c delta k least signific digit basedelta represent aeu uniqu determin aeu ae number repres k least signific digit aeu respect otherwis denot ith least signific digit basedelta represent denot number obtain delet least signific digit k similarli 1 denot ith least signific digit aeu u denot number obtain delet least signific digit aeu u k level b number k top 1 bottom bucket level number 0 delta gamma 1 let index signific digit aeu differ 1 given u aeu say posit u respect u u insert b insert bi u element b store posit element u bi j except signific digit aeu equal correspond digit u follow lemma follow fact key element queue least lemma 31 everi level bucket bi empti level maintain number element level also maintain total number element b extractmin oper chang valu sideeffect posit element b may chang suppos minimum element delet 2 simplest way implement top level wrap around modulo delta valu chang let 0 valu delet let 00 valu delet definit key element queue delet least 00 let posit least signific digit 0 00 differ differ last digit element b delet posit delet 1 element bucket bi 00 respect 0 exactli whose posit differ respect 00 element longer prefix common 00 0 therefor belong lower level respect 00 bucket expans procedur move element new posit procedur remov element bi 00 put posit respect 00 two key properti bucket expans follow ffl expans bi 00 correct posit respect 00 everi element b move expans move lower level readi describ multilevel bucket implement prioriti queue oper ffl insert insert element u comput posit insert u bi j ffl decreasekey decreas key element u posit follow remov u bi j set aeu new valu insert u describ ffl extractmin need find delet minimum element updat move element affect chang find lowest nonempti level find first nonempti bucket level delet element bi j set aeu return u case old new valu differ last digit element posit remain examin element bi minimum element u bi j set expand bi j return u next deal effici issu lemma 32 given u comput posit u respect constant time iter level find lowest nonempti level ok time use binari search find level olog time even better use power ram model lemma 33 k log c lowest nonempti level b found o1 time see best bound achiev k log c simpl way find first nonempti bucket level go bucket take odelta time lemma 34 find first nonempti bucket level odelta time remark one better 11 divid bucket everi level group size dlog ce group contain consecut bucket group maintain dlog cebit number bit j equal 1 jth bucket group empti find first nonempti group log c time first nonempti bucket group o1 time construct give log c factor improv bound lemma 34 iter construct p time get log p c bound although observ improv multilevel bucket oper time bound small valu k bound optim valu k improv simplifi present use lemma 34 rather improv version rest paper theorem 31 amort bound multilevel bucket implement prioriti queue oper follow ok insert o1 decreasekey proof insert oper take o1 worstcas time assign amort cost k charg move element lower level insert element decreasekey oper take o1 worst case time assign amort cost o1 extractmin oper show worstcas cost ok plu cost bucket expans cost bucket expans proport number element bucket cost amort insert oper except minimum element element examin bucket expans move lower level exclud bucket expans time oper o1 plu odelta find first nonempti bucket complet proof sinc note sequenc oper number insert oper least number extractmin oper balanc sequenc two number equal modifi proof obtain follow result theorem 32 balanc sequenc amort bound multilevel bucket implement prioriti queue oper follow o1 insert o1 decreasekey okc 1k extractmin extractmin bound oc 2 bound c best bound log c log log c obtain log log c e remark klevel bucket data structur use 4 hot queue hot queue use heap h multilevel bucket structur b intuit hot queue data structur work like multilevel bucket data structur except expand bucket contain less ele ment paramet set optim perform anc element bucket copi h process use heap oper number element bucket exce bucket expand analysi charg scan bucket lower level element bucket expans level obtain improv bound klevel hot queue use klevel bucket structur addit special level k 1 need account scan bucket level k two bucket top level nonempti time 1 note queue nonempti least one two bucket nonempti thu bucket scan special level add constant amount work process element found use wraparound level k k activ bucket bucket whose element h one bucket activ time h empti activ bucket denot activ bucket ba b make bucket activ make h heap contain bucket element inact reset heap empti heap element activ bucket bucket h describ detail hot queue need follow definit denot number element bi j ci j given delta say element u rang bi replac least signific digit 0 1 use ram oper check element rang bucket constant time maintain invari rang activ bucket detail descript queue oper follow ffl insert h empti element u insert rang activ bucket insert u b multilevel case otherwis u belong activ bucket ba b insert u h ba b make ba b inact add u ba b expand bucket ffl decreasekey decreas key element u follow u h decreas key u h otherwis let j posit u b remov u j set aeu new valu insert u describ ffl extractmin h empti extract return minimum element h otherwis proceed follow find lowest nonempti level find first nonempti bucket level examin bucket start bi delet element bi j set aeu return u examin element bi delet minimum element u bi j set expand bi j otherwis make bi activ return u correct hot queue oper follow correct multilevel bucket oper lemma 31 observ u h v b h aeu aev lemma 41 cost find first nonempti bucket level amort insert oper okdeltat proof scan one nonempti bucket search first nonempti bucket scan empti bucket level period time prefix includ except last digit remain furthermor scan bucket level nonempti happen higherlevel bucket expand period prefix chang charg bucket scan insert element queue element expand charg k time give desir bound theorem 41 let dn time bound heap insert decreasekey findmin extractmin opera tion amort time hot queue oper follow ok decreasekey txt kc 1k extractmin proof two key fact crucial analysi first fact number element h never exce sinc level account element second fact lemma 41 given first fact theorem 31 bound straightforward fibonacci heap 14 amort time bound ologn give ok o1 olog amort bound queue oper insert decreasekey extractmin respect set log c log c o1 log c amort bound radix heap achiev bound complic thorup heap 19 expect amort time bound give ok o1 expect amort time bound queue oper insert decreasekey extractmin respect ffl posit constant set 3 c olog3 c o1 olog3 ffl c expect amort time similarli theorem 32 get bound balanc sequenc oper theorem 42 let dn time bound heap insert decreasekey findmin extractmin opera tion consid balanc sequenc hot queue oper amort bound oper follow oit insert odt decreasekey ok extractmin use fibonacci heap get o1 o1 amort bound queue oper consid extractmin oper nonconst bound set log c get ologc bound set log c get ologc bound set log c get log c bound remark bound valid n use heap remark consid 1 2level implement although time bound twolevel implement two advantag use less space time bound remain valid wider rang valu c use thorup heap set 3 c expect amort time bound time bound allow us get improv bound dijkstra shortest path algorithm suppos given graph n vertic arc integr arc length rang 0 c run time dijkstra algorithm domin balanc sequenc prioriti queue oper includ insert extractmin oper om decreasekey oper see eg 18 maximum event durat sequenc oper c bound queue oper immedi impli follow result theorem 43 network n vertic arc integr length rang 0 c shortest path problem solv om expect time improv determinist bound om log c 2 hot queue implement base fibonacci heap match determinist bound 5 implement detail previou paper 7 15 describ implement multilevel bucket implement hot queue augment multilevel bucket implement 15 see 15 detail multilevel bucket implement consid klevel hot queue multilevel bucket implement set delta smallest power two greater equal c 1k base analysi section 4 experiment result set maximum size activ bucket c 1k log c e number element activ bucket often small take advantag fact maintain element activ bucket sort list instead heap oper list becom expens point switch heap use kheap work best test see eg 10 implement prioriti queue oper use sort list use doubli link list sort nondecreas order implement design shortest path applic applic number decreasekey oper element activ bucket tend small 16 fact proven random graph element insert list move decreasekey oper tend close begin list differ implement may better differ applic insert oper search element posit list put element posit one start search differ place implement start search begin list start end list point last insert may work better applic extractmin oper remov first element list decreasekey oper remov element list find new posit put element posit implement start search begin list start previou posit element end list place last insert may work better applic bucket becom activ put element list number element bucket 1 heap otherwis code use switch list heap use follow rule suggest satish rao person communica switch insert decreasekey oper examin ativ may work better applic perform wors switch number element list exce 1 6 experiment setup experi conduct pentium pro 166 mhz processor run linux 1368 machin 64 meg memori problem instanc fit main memori code written c compil linux gcc compil version 270 use o6 optim option made effort make code effici particular set bucket array size power two allow us use word shift oper comput bucket array indic full paper report experiment result five type graph two graph type chosen exhibit properti algorithm two extrem one path start vertex vertic tend order thetan one path length order theta1 third graph type random spars graph fourth type construct lot decreasekey oper activ bucket meant test robust implement violat assumpt made section 5 decreasekey oper fifth type graph meant easi hard specif implement specif number bucket level test type graph seven implement ation kari heap k4 klevel bucket k rang 1 3 klevel hot queue k rang 1 3 paramet tune result show best paramet valu test problem famili use previou paper 15 next two section describ problem famili 61 graph typestwo type graph explor grid produc use gridgen gener 7 graph character length x width graph form construct x layer path length order layer well vertic within layer connect vertex correspond vertex adjac layer vertic first layer connect sourc first type graph use long grid constant width 16 vertic test use graph differ length rang 512 32 768 vertic arc length chosen independ uniformli random rang 1 c c vari 1 100 000 000 second type graph use wide grid type graph length limit 16 layer width vari 512 32 768 vertic c long grid third type graph includ random graph uniform arc length distribut random graph n vertic 4n arc fourth type graph type new compar 15 base cycl n vertic number 1 n addit vertex connect gamma 1 distinct vertic length arc j equal 2k 15 k number arc cycl path j fifth type graph includ hard graph parameter number vertic desir number level k maximum arc length c c comput p number bucket level assum implement k level graph consist two path connect sourc vertic path distanc p distanc sourc path 1 0 vertic path occupi first bucket bottom level bin distanc sourc path 2 make vertic occupi last bucket bottomlevel bin addit sourc connect last vertex first path arc length 1 last vertex second path arc length c summari graph type appear tabl 1 62 problem familiesfor graph type examin rel perform implement chang increas variou paramet type modif constitut problem famili famili summar tabl 2 gener famili construct vari one paramet hold other constant differ famili vari paramet use differ constant valu 7 experiment result 2 3level bucket structur robust 7 15 case 2 3level hot queue perform similarli although usual slightli better correspond multilevel bucket structur one level hot queue significantli robust one level bucket robust 2 3level hot queue due shortag space present experiment result hard problem problem separ hot queue multilevel bucket tabl k denot implement h heap bi bucket level hi hot queue level report run time count oper give insight algorithm perform heap implement count total number insert decreasekey oper bucket implement count number empti bucket examin empti oper hot queue implement count number empti oper number insert decreasekey oper activ bucket plot data addit tabul unabl run 1level bucket hot queue implement problem memori limit leav correspond tabl entri blank tabl 3 4 give data hard2 hard 3 famili design hard 2 3level bucket implement respect two element heap time heap implement effici hard problem hot queue implement bucket expand action confin two special top level bucket thu hot queue perform almost well heap except h1 largest valu c could handl run time 15 time greater valu c explan discrep hard2 problem hard b1 b2 expect implement poorli famili similarli bucket implement wors implement hard3 famili conclud remark theori hot queue data structur better heap multilevel bucket data structur experi show result implement robust heap multilevel bucket data structur new heap raman 17 instead thorup heap improv time bound factor log ffl c replac p log log c hot queue seem practic radix heap latter data structur requir bookkeep addit hot queue heap usual contain much fewer element implement take advantag fact 2level hot queue data structur seem robust 3level hot queue usual somewhat faster data structur best applic 3level structur may robust larg valu c valu much smaller reduc sensit paramet activ bucket 1level hot queue may use event simul applic view robust version calendar queue data structur acknowledg would like thank bob tarjan stimul discuss insight comment satish rao suggest adapt strategi switch list heap harold stone use comment draft paper r design analysi comput algorithm calandar queue fast o1 prioriti queue implement simul event set problem shortest path algorithm theori experiment evalu determinist coin toss applic optim parallel list rank introduct algorithm algorithm 360 shortest path forest topolog order note two problem connexion graph fibonacci heap use improv network optim algorithm implement dijkstra algorithm base multilevel bucket expect perform dijkstra shortest path algorithm fast algorithm shortest path sort data structur network al gorithm ram prioriti queue tr ctr mikkel thorup integ prioriti queue decreas key constant time singl sourc shortest path problem proceed thirtyfifth annual acm symposium theori comput june 0911 2003 san diego ca usa stephen alstrup thore husfeldt thei rauh mikkel thorup black box constanttim insert prioriti queue note acm transact algorithm talg v1 n1 p102106 juli 2005 piet van mieghem fernando kuiper concept exact qo rout algorithm ieeeacm transact network ton v12 n5 p851864 octob 2004 klau brengel andrea crauser paolo ferragina ulrich meyer experiment studi prioriti queue extern memori journal experiment algorithm jea 5 p17e 2000 ran mendelson mikkel thorup uri zwick meldabl ram prioriti queue minimum direct span tree proceed fifteenth annual acmsiam symposium discret algorithm januari 1114 2004 new orlean louisiana mikkel thorup integ prioriti queue decreas key constant time singl sourc shortest path problem journal comput system scienc v69 n3 p330353 novemb 2004 haim kaplan robert e tarjan kosta tsioutsioulikli faster kinet heap use broadcast schedul proceed twelfth annual acmsiam symposium discret algorithm p836844 januari 0709 2001 washington dc unit state