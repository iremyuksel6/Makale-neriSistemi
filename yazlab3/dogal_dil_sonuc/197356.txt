powerlist structur parallel recurs mani dataparallel algorithmsfast fourier transform batcher sort scheme prefixsumexhibit recurs structur propos data structur call powerlist permit succinct descript algorithm highlight role parallel recurs simpl algebra properti data structur exploti deriv properti algorithm establish equival differ algorithm solv problem b program grant 003658219 nation scienc foundat award ccr 9111912 1 notabl except recurs descript prefix sum algorithm karp ramachandran12 data structur powerlist propos paper highlight role parallel recurs mani known parallel algorithm fft batcher merg prefix sum embed array hypercub etchav surprisingli concis descript use powerlist simpl algebra properti powerlist permit us deduc properti algorithm employ structur induct powerlist basic data structur recurs employ lisp16 ml17 list list either empti construct concaten element list restrict finit list throughout paper call list linear list length grow 1 result appli basic constructor list structur seem unsuit express parallel algorithm succinctli algorithm process list element describ success element list process propos powerlist data structur suitabl describ parallel algorithm basecorrespond empti list linear casei list one element clearli mani base depend specif element list larger powerlist construct element two powerlist length describ thu powerlist multipl natur length doubl appli basic constructor two differ way powerlist join creat larger powerlist p q powerlist length powerlist form concaten p q q powerlist form success take altern item p q start p restrict p q contain similar element defin section 21 follow exampl sequenc element powerlist enclos within angular bracket oper j call tie zip 21 definit data item linear list theori call scalar typic scalar item base typesinteg boolean etctupl scalar function scalar scalar linear list scalar scalar uninterpret theori mere assum scalar check type compat use sever standard oper scalar purpos illustr notat convent linear list enclos within squar bracket powerlist list length 2 n n whose element similar enclos powerlist within angular bracket h two scalar similar type two powerlist similar length element one similar element observ similar equival relat let denot arbitrari scalar p powerlist u v similar powerlist recurs definit powerlist hsi hp u j v u v exampl h2i powerlist length 1 contain scalar hh2ii powerlist length 1 contain powerlist length 1 scalar h powerlist powerlist length 1 contain empti linear list powerlist length 2 element powerlist length 2 whose element linear list number represent matrix column element outer powerlist anoth represent matrix row element outer powerlist hhhai hbii hhci hdiii represent tree figur 1 powerlist contain two element one left right subtre 22 function powerlist convent write function applic without paranthes confus possibl thu write f x instead fx g x instead gx constructor j bind power bind power lower function applic throughout paper denot scalar p powerlist x either scalar powerlist typic name powerlist variabl p q hhci hdii hhhai hbii hhci hdiii hhai hbii figur 1 represent complet binari tree data leav leaf node powerlist one element nonleaf node powerlist two element name powerlist left right subtre function linear list typic defin case analysisa function defin empti list recurs nonempti list function powerlist defin analog instanc follow function rev revers order element argument powerlist case analysi linear list base length argument powerlist adopt pattern match scheme ml17 miranda24 2 deconstruct argument list compon p q recurs case deconstruct gener use oper j see section 3 definit rev use j deconstruct could use instead defin rev recurs case shown use law section 3 two propos definit rev equival powerlist p scalar function oper scalar outsid theori exampl paper howev use scalar function particularli addit multipl complex number con linear list scalar function f zero scalar argument valu scalar coerc applic f powerlist appli f pointwis element powerlist scalar function f one argument defin 2 miranda trademark research softwar ltd shown scalar function oper two argument often written infix oper function phi p q phi u thu scalar function commut j note sinc scalar function appli recurs element pow erlist effect propag level thu appli matric form elementwis sum 2 23 discuss base case powerlist singleton list empti list empti list equival data structur aris applic consid instanc matrix algorithm base case 1 theta 1 matrix rather empti matrix fourier transform defin singleton list empti list smallest hypercub one node recurs definit powerlist say powerlist either form u v u j v fact everi nonsingleton powerlist written either form uniqu manner see law section 3 simpl way view element l index nbit string increas numer order length l sublist element whose highest bit index 0 q sublist 1 highest bit index similarli u u sublist element whose lowest bit index 0 vs element 1 lowest bit index first may seem strang allow two differ way construct listus tie zip see paper caus difficulti flexibl essenti mani parallel algorithmsth fast fourier transform prominentexploit form construct restrict u v u j v u v similar restrict allow us process powerlist recurs divid conquer divis yield two halv process parallel employ algorithm squar matric instanc often process quarter ing show quarter quadrupl express theori similar restrict allow us defin complet binari tree hypercub squar matric free structur length powerlist power 2 restrict theori somewhat possibl design gener theori elimin constraint sketch outlin section 6 l0 singleton powerlist hxi hyi l1 dual deconstruct nonsingleton powerlist p exist similar powerlist u v l2 uniqu deconstruct p l3 commut j law deriv suitabl defin tie zip use standard function linear list theori one possibl strategi defin tie concaten two equal length list use law l0 l3 definit zip law l1 l2 deriv next altern law may regard axiom relat tie zip law l0 often use prove base case algebra ident law l1 l2 allow us uniqu deconstruct nonsingleton powerlist use either j law l3 crucial law relat two construct oper j gener case henc invari appli proof structur induct constructor play role induct proof proof powerlist induct length depth shape list length len powerlist number element sinc length powerlist power 2 logarithm length lgl use measur formal depth powerlist number level depth depth depth last case sinc u v similar powerlist depth induct proof powerlist order lexicograph pair depth logarithm length instanc prove properti pi hold powerlist suffici prove pihsi last proof step could replac shape powerlist p sequenc natur number depth p n 0 logarithm length p 1 logarithm length element p say r 2 logarithm length element formal definit shape similar depth shape linear sequenc element level similar shape type scalar element defin structur powerlist complet induct proof powerlist may order lexicograph pair depth shape shape compar lexicograph show small algorithm powerlist includ famou exampl fast fourier transform batcher sort network restrict discuss section simpl unnest powerlist depth 0 higher dimension list algorithm matric hypercub taken later section sinc powerlist unnest induct base length suffici prove properti algorithm 41 permut defin function permut element powerlist function rev defin section 22 permut function function appear compon mani parallel algorithm rotat function rr rotat powerlist right one thu rrha b c di hd b ci function rl rotat left rlha b c di hb c ai seem simpl definit rr rl use j deconstruct oper easi show use structur induct rrrl invers amus ident revrrrevrr p powerlist may rotat arbitrari amount k appli success rotat better scheme rotat u v k rotat u v k2 precis function grr given rotat powerlist right k k 0 straightforward show k k 0 p grr k kfold applic rr rotat index class permut function defin transform element indic imagin element powerlist 2 n element associ nbit index indic increas numer order powerlist u j v indic element u 0 highest bit v 1 highest bit u v similar remark appli lowest bit biject h map indic indic defin permut powerlist element index move posit index h consid two simpl index map function correspond permut powerlist use describ shuffleexchang network note indic part theori function rotat index right one posit permut function rs right shuffl associ definit rs may understood follow effect rotat index right lowest bit index becom highest bit therefor rs appli u v element uthos 0 lowest bit occupi first half result powerlist indic 0 highest bit rotat similarli v occupi second half analog function rotat index left one posit induc permut defin ls left shuffl figur 2 show effect index rotat 8element list rs ls figur 2 permut function rs ls defin section 41 trivial see rs ls invers invers function inv defin follow function indic element index b p index b 0 inv p b 0 revers bit string b thu 000 001 010 011 100 101 110 111 inv h b c e f g h h e c g b f h definit inv function aris varieti context particular inv use permut output fast fourier transform network correct order follow proof show typic applic structur induct inv1 invp structur induct p q base ffrom fdefinit invg appli law l0g induct fcommut j g fdefinit invg invr u inv v finductiong inv r inv j inv u inv v fappli definit inv side j g use inv1 structur induct easi establish scalar oper phi last result hold permut function place inv 42 reduct linear list theory4 reduct higher order function two argu ment associ binari oper list reduct appli phi 0 function powerlist defin red phi red phi p j red phi p phi red phi q 43 gray code gray code sequenc n sequenc 2 n nbit string consecut string sequenc differ exactli one bit posit last first string sequenc consid consecut standard gray code sequenc shown figur 3 repres nbit figur 3 standard gray code sequenc n string linear list length n gray code sequenc powerlist whose element linear list standard gray code sequenc may comput function g n 0 scalar function take linear list argument append 0 prefix accord coercion rule powerlist obtain prefix everi element p 0 similarli function rev section 22 44 polynomi polynomi coeffici may repres powerlist p whose j th element p j polynomi valu point n 0 quantiti follow function ep use strategi evalu polynomi p given point hwi singleton powerlist ep return singleton powerlist p q note w 2 pointwis squar w theta higher prioroti anticip fast fourier transform gener ep accept arbitrari powerlist second argument powerlist possibl unequ length let p ep w powerlist length w obtain evalu p element w definit ep given also implement gener sinc ep appli pointwis element 45 fast fourier transform polynomi p complex coeefici fourier transform obtain evalu p certain specif point precis fourier transform ft powerlist p powerlist length given ep function defdin section 44 n logarithm length wn powerlist h 2 n th princip root 1 straightforward comput p ep v p v consist evalu p element v take time sinc wn special form fourier transform comput om log step use fast fourier transform algorithm8 algorithm also admit effici implemnt requir olog step om processor deriv fft algorithm need follow two properti wn n n 0 powerlist u first equat follw fact right half wn 1 left half multipli 2 n sinc 2 n1 th princip root 1 gamma1 second equat straightforward sinc wn powerlist contain success power number fdefinit ftg fsinc w0 singleton definit epg gener case ft p q flet n logarithm length p definit ftg p q ffrom 1 let fdistribut ep second argumentg fdefinit epg fuse 2 replac u 2 wn g fdefinit ftg get formal definit fft write power p powerlist h length p 2m th princip root 1 therefor u power p function power defin similarli ep collect definit fft p clear fft p q comput fft p fft q om sequenti step o1 parallel step use om processor u comput parallel length p therefor fft p q comput om log sequenti step olog parallel step use om processor compact descript fft strike contrast usual descript see instanc chandi misra7 section 613 compact attribut use recurs avoid explicit index element employ j fft illustr need includ j constructor powerlist anoth function employ j inv section 41 invers fourier transform invers fourier transform ift defin similarli fft fact definit ift deriv fft pattern match singleton powerlist hxi comput ift fift fft inversesg gener case comput ift p j q p q let unknown u v form deconstruct chosen easili solv equat gener next take fft side left side p j q ift fft invers replac right side definit fft u v yield follow equat equat easili solv unknown u v w u v note law uniqu deconstruct l2 use deduc first equat solut equat yield follow definit ift 2 divid element given powerlist 2 n th princip root 1 n length p j q fft definit ift includ constructor j implement effici butterfli network complex ift fft 46 batcher sort network section develop elementari result sort discuss two remark sort method due batcher3 find interest prefer oper discuss principl parallel sort henceforth list sort mean element arrang ascend order gener method sort given merg written binari infix oper creat singl sort powerlist elment two argument powerlist section show two differ method implement merg one scheme batcher merg given oper bm anoth scheme given biton sort sort list p q merg appli function bi p j rev q comparison oper l use algorithm oper appli pair powerlist defin 2i th 2i th item p l q p min respect express p l q comput constant time use olen p processor biton sort sequenc number x index ascend descend monoton function bi given appli biton pow erlist return sort powerlist origin item two powerlist u v sort ascend order powerlist u j rev v biton thu u v merg appli bi u j rev v form recurs definit suggest bi implement processor olog n parallel step n length argument powerlist batcher merg batcher also propos scheme merg two sort list defin scheme bm infix oper function bm well suit parallel implement recurs form suggest r bm v bm u comput parallel sinc l appli o1 parallel step use processor n length argument powerlist function bm evalu olog n parallel step rest section develop certain elementari fact sort prove correct bm elementari fact sort consid compar swap type sort method known see knuth13 sort scheme correct iff sort list contain 0s 1s therefor restrict discuss powerlist contain 0s 1s powerlist p let z p number 0s simplifi notat omit space write zp clearli powerlist contain 0s 1s follow properti note condit analog a2 p j q sort simplic a2 compar a2 0 may suggest primari oper parallel sort 2 follow result b1 b2 easi prove prove b3 b2 zp l b3 proof sinc statement theorem symmetr p q assum zp zq p min q p max q sort fdefinit p l qg l q sort 2 correct biton sort show function bi appli biton powerlist return sort powerlist origin element b4 state bi preserv number zero argument list ie lose data b5 state result list sort b4 zbi proof structur induct use b2 2 b5 proof structur induct base straightforward induct let finduct p qg ffrom b4 zbi fappli b3 bi p bi q bi p l bi q sort fdefinit big correct batcher merg show bm merg two sort powerlist manner similar proof bi instead establish simpl relationship function bm bi correct former obviou show rev revers powerlist section 22 p q sort p j rev q biton fact dont prove correct bi follow bip j rev q henc bm q sort contain element p q proof b6 structur induct base let fdefinit revg fdefinit big fdefinit bmg induct let fexpand fdefinit revg fdefinit big finductiong r bm v l bm u fdefinit bmg fuse definit p qg compact descript batcher sort scheme simplic correct proof demonstr import treat recurs parallel simultan ffl7 ffl6 ffl5 ffl4 ffl3 ffl2 ffl1 ffl7 ffl6 ffl5 ffl4 ffl3 ffl2 ffl1 ffl7 ffl6 ffl5 ffl4 ffl3 ffl2 ffl1 ffl7 ffl6 ffl5 ffl4 ffl3 ffl2 ffl1 level 3 level 2 level 1 level 0 ffl0 ffl0 ffl0 ffl0 figur 4 network comput prefix sum 8 element 47 prefix sum let l powerlist scalar phi binari associ oper scalar type prefix sum l respect phi ps l list length l given ps th element ps l obtain appli phi first element l order give formal definit prefix sum later section prefix sum fundament import parallel comput show two known algorithm problem concis repres prove theori zip turn primari oper describ algorithm particularli simpl scheme prefix sum 8 element shown figur 4 figur number node repres processor though physic processor use level initi processor hold list element l connect among processor differ level depict data transmiss level 0 processor 0 6 send data right neighbor th level processor send data processor exist mean receiv data level data transmiss processor updat data r phi r data receiv receiv data level unchang shown complet comput level log 2 len l processor hold th element ps l anoth scheme due ladner fischer15 first appli phi adjac element comput list hx 0 phi x list half mani element origin list prefix sum comput recurs result list hx 0 phi x list contain half element final list miss element element comput appropri element alreadi comput list scheme prefix comput inher recurs formul highlight parallel recurs specif sort network section 46 introduc oper term prefix sum problem defin first postul 0 ident element phi ie 0 phi x powerlist p let powerlist obtain shift p right one effect shift append 0 left discard rightmost element p thu ha b c di p q easi show s1 r phi s2 p q consid follow equat powerlist variabl z l given powerlist equat uniqu solut z di exactli ps l defin ps l uniqu solut de call de defin equat ps l note 1 oper phi necessarili commut therefor rh de may l phi z 2 oper phi scalar commut 3 uniqu solut de prove entir within powerlist algebra similar deriv ladnerfisch scheme given later section 4 adams1 specifi prefixsum problem without postul explicit 0 element phi introduc binari oper phi two similar powerlist p phi q oper phi defin without introduc 0 comput prefix sum function sp simpl prefix sum defin scheme figur 4 sp sp first level figur 4 l phi l comput hx zip two sublist prefix sum two list comput independ zip ladnerfisch scheme defin function lf lf p correct prove correct sp lf show function ps satisfi equat defin function instruct see sp lf deriv easili specif de carri deriv fischerladn scheme illustr power algebra manipul first note p1 proof pshxi ffrom defin equat de pshxig fdefinit g fphi scalar operationg f0 ident phig deriv ladnerfisch scheme given powerlist p q deriv express psp q let r unknown psp q solv ps p q use deg appli law l2 uniqu deconstruct equat conclud lf1 elimin r lf2 use lf1 get use de equat get comput psp q psp q fbi definitiong use lf1 rg defin lf3 exactli definit function lf nonsingleton powerlist also note r elimin lf1 use lf2 g r phi q phi p definit g r phi q phi p use de equat lf4 fact use prove correct sp next correct sp show nonsingleton powerlist l ps proof let ps l psp q given lf4lf3g psq phi p psp phi q flet ps u ps v show u q phi p p phi q q p phi p q fappli definit first termg p q phi p q remark tradit way describ prefix sum algorithm simpl scheme figur 4 explicitli name quantiti com pute establish relationship among let ij comput th processor j th level logarithm length list ae igamma2 oe correct criterion descript consider difficult manipul parallel harder see proof correct requir manipul indic exampl show ladnerfisch scheme even difficult specifi manner algebra method prefer describ uniform oper aggreg data 5 higher dimension array major part parallel comput involv array one dimens array dimens dimens number 0 repres powerlist depth gamma 1 convers sinc powerlist element similar powerlist depth may regard array dimens instanc matrix r row c column may repres powerlist c element element powerlist length r store item column convers matrix may repres powerlist r element element powerlist c element manipul higher dimension array prefer think term array oper rather oper nest powerlist therefor introduc construct oper analog j tie zip along specifi dimens use correspond oper dimens dimens 2 etc definit oper section 52 moment suffici regard j 0 pointwis applic j argument powerlist similarli 0 thu similar power matric b store columnwis ie element column j b concaten b row j 0 b concaten column figur 5 show applic oper specif matric given constructor may defin matrix either figur 5 appli matric matric store column typic matrix format use display though matrix regard powerlist powerlist singleton matrix hhxii similar matric matric analog definit given ndimension array observ length dimens power 2 case pow erlist matrix construct sever differ way say first construct row column vice versa show section 52 note could defin matrix use 0 instead j j dual sens either use construct uniqu deconstruct powerlist j 0 0 also dual show section 52 therefor freeli use four construct oper matric 2 exampl matrix transposit let function transpos matric definit matrix consid three case defin descript function though straightforward introduc possibl inconsist definit 2 theta 2 matrix instanc either last two deconstruct appli obviou result obtain independ order rule appli show function prove result structur induct matrix form hhxii first deconstruct appli henc claim hold next consid matrix last two deconstruct appli matrix form p j appli one step last two rule differ order get fappli last ruleg fappli middl ruleg fappli first middl rule last ruleg induct hypothesi p q etc well defin henc crucial proof fact j j 0 commut reminisc churchross properti term rewrit system commut import discuss next subsect easi show transposit squar power matrix defin deconstruct matrix quarter transpos individu rearrang shown figur 6 transposit function gener matric get function oe transposit squar matric note effect pattern match definit oe q oe v oe u oe figur schemat transposit squar powermatrix 51 pointwis applic let g function map item type ff type fi g 0 map powerlist ffitem powerlist fiitem similarli binari oper op defin two form explicitli use one exampl f 0 function f arbitrari ariti similarli defin observ f 0 appli powerlist length n yield powerlist length n number prime f determin dimens f appli outermost dimens number 0 therefor write instanc without prime simpli zip two list oper pointwis applic also appear backus2 steel hillis23 common special case binari oper op j pointwis applic oper particular write denot z defin definit f 0 conclud f 0 j commut prove f 0 commut theorem 1 f proof prove result unari f gener case similar proof structur induct base f 0 hxi hyi fdefinit f 0 g singleton listsg induct argument commuteg finductiong theorem 2 scalar function f f proof proof structur induct straightforward 2 theorem 3 f g commut f proof structur induct 2 follow result commut deriv theorem 123 follow mn natur number c1 f n c2 6 n c3 c4 scalar function f c1 follow appli induct theorem 1 3 fact f commut c2 follow c1 c3 c1 law l3 theorem 3 c4 c1 theorem 2 52 deconstruct section show powerlist written p q also written u v u v vice versa analog law l1 dual deconstruct analog law l2 show deconstruct uniqu theorem 4 dual deconstruct p q 0 defin exist u v convers u v 0 u v defin exist q prove theorem proof similar theorem given theorem 5 uniqu letomega j natur number proof proof induct result follow law l2 proof similar prove result structur induct p base fdefinit j n1 g use law l2g j finduct ng fdefinit j n1 g use law l2g j finduct length theorem 4 5 allow richer varieti pattern match function def init matrix transposit may employ natur mn construct pattern function defin 53 embed array hypercub ndimension hypercub graph 2 n node n 0 node uniqu nbit label two node neighbor ie edg exactli label differ singl bit therefor everi node n neighbor may repres ndimension hypercub powerlist depth n level except innermost consist two powerlist natur mn use access node one combin dimens conclud exampl show higher dimension structur hypercub easili handl theori given array size claim element place node hypercub dimens 0 1 two adjac data item array place neighbor node hypercub two data item array adjac indic differ exactli one dimens 1 modulo n n size dimens call wrap around adjac embed algorithm work follow array one dimens creat gray code sequenc g see section 43 abbrevi g g place th item array node label g adjac item posit place node g g i1 differ exactli one bit construct idea gener higher dimension array follow construct gray code sequenc dimens independ store item index node g 0 denot concaten bit string definit adjac item differ 1 exactli one dimens k gray code indic ident dimens except k differ exactli one bit dimens k describ function em emb array hypercub given array size 2 m0 theta2 m1 theta2 md permut element array 2 theta 2 theta permut preserv array adjac de scribe algorithm inspir gray code function section 43 follow match scalar p powerlist em p first line rule embed singl item 0dimension hypercub next line simpli say array length 1 dimens embed ignor dimens last line say nonsingleton array embed embed left half dimens 0 revers right half two compon hypercub larger hypercub 6 remark relat work appli uniform oper aggreg data prove extrem power apl9 see backus2 bird4 algebra oper one earliest attempt repres data parallel algorithm preparata vuillemin21 word algorithm perform sequenc basic oper pair data success 2 locat apart algorithm oper 2 n piec data describ sequenc n parallel step form k th step appli parallel binari oper oper pair data 2 n gammak apart show paradigm use describ larg number known parallel algorithm algorithm effici implement cube connect cycl connect structur style program imper easi appli algebra manipul program program paradigm fit well within notat mou hudak19 mou20 propos function notat describ divid conquertyp parallel algorithm notat vast improv preparata vuillemin chang imper style function style program allow succinct express possibl algebra manipul effect program style scientif problem may seen 25 construct similar tie zip though allow unbalanc decomposit list effect method program vector propos blelloch5 6 propos small set vectorscan instruct may use primit describ parallel algorithm unlik method abl control divis list number iter depend valu data item necessari ingredi mani scientif problem jone sheeran10 develop relat algebra describ circuit compon circuit compon view relat oper combin relat given appropri interpret circuit domain kapur subramaniam11 implement powerlist notat prove mani alogrithm paper use induct theorem prover call rrl rewrit rule laboratori base equal reason rewrit rule extend theorem prover similar constraint powerlist constructor state explicitli one fundament problem powerlist notat devis compil strategi map program written powerlist notat specif architectur architectur closest conceptu hypercub kornerup14 develop certain strategi wherebi parallel step program map constant number local oper commun hypercub node combin circuit verif area powerlist notat may fruit employ adams1 prove correct adder circuit use notat ripplecarri adder typic easi describ prove wherea carrylookahead adder much difficult adam describ circuit notat prove equival remark concis fashion obtain succinct descript carrylookahead circuit employ prefixsum function see section 47 powerlist arbitrari length length powerlist restrict form 2 n n 0 could develop simpl theori handl arbitrari length list steel 22 suggest pad enough dummi element list make length power 2 scheme advantag still retain simpl algebra law powerlist anoth approach base observ posit integ either 1 2 theta 2 theta 1 posit integ therefor deconstruct nonsingleton list odd length two list p q element e e either first middl last element instanc follow function rev revers list last line definit appli nonsingleton list odd length list deconstruct two list p q equal length e middl element abus notat appli j three argument similarli function lf prefix sum may defin lf p last line e first element argument list remain portion list without first item deconstruct p q right side line denot list obtain append element e list obtain appli ephi element lfp q use convent e phi list obtain appli ephi element interplay sequenti parallel comput notat propos paper address small aspect parallel comput powerlist prove surprisingli success express comput whose structur independ specif data val ue case instanc fast fourier transform batcher merg prefix sum typic howev parallel sequenti comput interleav fast fourier transform batcher merg repres highli parallel comput binari search inher sequenti parallel search strategi gaussian elimin repres mixtur comput consist sequenc pivot step step appli parallel thu parallel comput may perform certain sequenc sequenc may depend data valu computa tion gener method blelloch5 requir powerlist notat integr languag support sequenti comput particular notat blend well ml17 lisp16 23 mixtur linear list powerlist exploit variou combin sequenti parallel comput powerlist consist linear list compon admit parallel process compon process sequenti linear list whose element powerlist suggest sequenti comput step appli parallel powerlist powerlist allow multidimension parallel comput wherea linear list linear list may repres hierarchi sequenti comput acknowledg paper enrich comment suggest adam al carruth suggest term powerlist jorg cobb edsger w dijkstra car hoar rajeev joshi marku kaltenbach deepak kapur jacob kornerup scott page vijaya ramachandran guy steel jr alex tomlinson evelyn tumlin erni cohen singularli help earli stage research grate austin tuesday afternoon read comment draft manuscript adam kornerup especi comment second draft r verifi adder circuit use powerlist program liber von neumann style sort network applic lectur construct function program vector model dataparallel comput nesl nest dataparallel languag parallel program design foun dation algorithm machin calcul complex fourier seri program languag circuit design rubi autom reason parallel algorithm use powerlist parallel algorithm share memori machin sort search map powerlist onto hypercub parallel prefix comput definit standard ml structur parallel recurs preliminari version algebra model divideandconqu algorithm parallel divacon parallel languag scientif comput base divideandconqu cubeconnect cycl versatil network parallel comput steel jr steel jr overview miranda divideandconqu method solv tridiagon system hypercub massiv parallel comput tr overview miranda parallel program design foundat definit standard ml vector model dataparallel comput parallel algorithm sharedmemori machin introduct parallel algorithm architectur powerlist connect machin lisp parallel prefix comput cubeconnect cycl versatil network parallel comput program liber von neumann style nesl nest dataparallel languag version 26 verifi adder circuit use powerlist ctr jayadev misra deriv parallel string match algorithm inform process letter v85 n5 p255260 march georg ch pflug ladislav halada note recurs parallel structur birg qi factor tree structur linear program comput optim applic v24 n23 p251265 februarymarch gorlatch program divideandconqu skeleton case studi fft journal supercomput v12 n12 p8597 janfeb 1998 ruben gamboa correct fast fourier transform structur proof acl2 formal method system design v20 n1 p91106 januari 2002 ross paterson new notat arrow acm sigplan notic v36 n10 octob 2001 jeanloui giavitto olivi michel declar definit group index data structur approxim domain proceed 3rd acm sigplan intern confer principl practic declar program p150161 septemb 0507 2001 florenc itali christoph herrmann christian lengauer parallel divideandconqu translat nest loop journal function program v9 n3 p279310 may 1999 roberto di cosmo zheng li susanna pelagatti calculu parallel comput multidimension dens array comput languag system structur v33 n34 p82110 octob 2007 gorlatch sat program methodolog skeleton collect oper pattern skeleton parallel distribut comput springerverlag london