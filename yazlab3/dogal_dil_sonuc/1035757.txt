communicationbas prevent useless checkpoint distribut comput useless checkpoint local checkpoint part consist global checkpoint paper address follow problem given set process take basic local checkpoint independ unknown way problem design communicationinduc checkpoint protocol direct process take addit local forc checkpoint ensur local checkpoint useless paper first prove two properti relat integ timestamp associ local checkpoint first properti necessari suffici condit timestamp must satisfi checkpoint useless second properti provid easi timestampbas determin consist global checkpoint gener communicationinduc checkpoint protocol propos protocol deriv two previou properti actual defin famili timestampbas communicationinduc checkpoint protocol shown sever exist checkpoint protocol problem particular instanc gener protocol design gener protocol motiv use communicationinduc checkpoint protocol consist global checkpointbas distribut applic detect stabl unstabl properti determin distribut breakpoint b introduct local checkpoint snapshot local state process global checkpoint set local checkpoint one process consist global checkpoint global checkpoint messag sent process local checkpoint receiv anoth process local checkpoint consist global checkpoint strongli depend flow messag exchang process determin consist global checkpoint fundament problem distribut comput aris mani applic detect stabl properti 5 12 17 determin breakpoint 7 10 20 detect unstabl properti 2 6 11 13 rollback recoveri upon failur occur 8 14 22 etc process independ take local checkpoint risk consist global checkpoint ever form except first one compos initi state caus wellknown unbound domino effect 22 even consist global checkpoint form still possibl local checkpoint never includ consist global checkpoint local checkpoint call useless prevent useless checkpoint thu safe prevent domino effect coordin take local checkpoint requir famili coordin protocol 5 15 process use addit control messag synchron checkpoint activ addit synchron may result reduc process autonomi degrad perform underli applic drawback given rise develop famili communicationinduc checkpoint protocol famili coordin achiev piggyback control inform applic messag control messag synchron ad applic 8 precis process take local checkpoint independ 1 call basic checkpoint protocol direct take addit local checkpoint call forc checkpoint ensur local checkpoint becom useless take forc checkpoint messag deliveri safe strategi prevent useless checkpoint ineffici given set basic checkpoint fewer forc checkpoint taken communicationinduc checkpoint protocol better pro tocol process decid whether take forc checkpoint messag receiv evalu predic predic base local control variabl receiv process control valu carri messag local control variabl manag process code causal depend appear past distinct semant control variabl distinct definit predic give rise differ protocol 1 3 4 14 19 23 24 26 paper present new communicationinduc checkpoint protocol take forc checkpoint possibl ensur local checkpoint useless protocol base zpath zcycl theori introduc netxer xu 21 show useless checkpoint exactli correspond exist zcycl distribut comput model level protocol prevent zcycl 2 oper level sequenc number lamport timestamp associ local checkpoint moreov messag piggyback integ lamport clock valu vector integ checkpoint sequenc number two boolean vector size vector n number process protocol effici 3 past dominofre communicationinduc checkpoint protocol interest featur propos protocol follow one local checkpoint easi determin consist global checkpoint belong moreov propos protocol enjoy nice gener properti reduc size control inform even elimin altogeth protocol 1 exampl detect unstabl properti conjunct local predic process take basic checkpoint time local predic becom true 13 2 manivannansingh classif 18 protocol belong zcf zcyclefre famili 3 consid number forc local checkpoint taken process 4 jm helari mostefaoui r netzer raynal reduc alreadi known protocol 1 19 23 result protocol offer gener effici framework famili dominofre communicationinduc checkpoint protocol paper divid seven section section 2 present model distribut comput provid definit consist global checkpoint defin zpath section 3 present design principl protocol section 4 describ first version protocol prove main properti name given local checkpoint c easi determin consist global checkpoint c belong section 5 reduc size data structur use protocol present improv version final section 6 discuss protocol show reduc exist protocol reduc control inform section 7 conclud paper distribut comput checkpoint zpath 21 distribut comput distribut comput consist finit set p n process fp commun synchron exchang messag assum order pair process connect asynchron reliabl direct logic channel whose transmiss delay unpredict finit note channel requir fifo process run differ processor processor share common memori bound rel speed also fail accord failstop model process execut intern send 4 deliveri statement intern statement involv commun p execut statement sendm put messag channel p p j p execut statement deliverm block least one messag direct p arriv messag withdrawn one input channel deliv p execut intern send deliveri statement model intern send deliveri event process distribut comput sequenti word process p produc sequenc event e sequenc finit infinit everi process p initi local state denot oe i0 local state oe 0 result execut sequenc appli intial state oe i0 precis event e move p local state oe isgamma1 local state oe definit say e ix belong oe js sometim denot let h set event produc distribut comput comput model partial order set b hb denot wellknown lamport happenedbefor relat 16 22 local global checkpoint local checkpoint local checkpoint c record state snapshot process everi local state necessarili record local checkpoint set local checkpoint subset set local state definit 21 commun checkpoint pattern pair b h distribut comput c b h set local checkpoint defin b c ix repres xth local checkpoint process p local checkpoint c ix correspond local state oe x figur 1 show exampl checkpoint commun 4 assum process send messag irisa communicationbas prevent useless checkpoint distribut comput 5 pattern 5 assum process p take initi local checkpoint c i0 correspond oe i0 event checkpoint eventu taken ik1 ik2 ik3 j1 figur 1 checkpoint commun pattern messag sent process p process p j call orphan respect order pair local checkpoint c ix c jy iff deliveri belong c jy deliverm 2 c jy send event belong c ix sendm 62 c ix order pair local checkpoint consist iff orphan messag respect pair exampl figur 1 show pair c k1 c j1 consist pair c i2 c j2 inconsist orphan messag 5 global checkpoint global checkpoint set local checkpoint one process exampl two global checkpoint depict figur 1 definit 22 global checkpoint consist iff pair local checkpoint consist exampl figur 1 show fc i1 c consist global checkpoint due inconsist pair c i2 c j2 global checkpoint fc consist 23 zpath zcycl sequenc event occur p c call checkpoint interv denot ix see figur 1 zpath notion introduc first time netzer xu 21 gener notion causal path messag defin lamport happenedbefor relat precis definit 23 zpath exist local checkpoint local checkpoint b preced b process sequenc messag exist 1 preced sendm 1 process 2 erlier interv sendm i1 3 deliverym q preced b process figur zpath c k0 c i2 two zpath c i2 c k2 definit 24 zpath two consecut messag ff ff1 form zpattern 5 figur use usual spacetim diagram local checkpoint indic black rectangular box local state explicitli indic 6 jm helari mostefaoui r netzer raynal figur 1 see two zpattern definit 25 zpath causal iff includ zpattern ie deliveri event messag except last occur send event next messag sequenc zpath noncaus iff causal zpath one messag trivial causal everi noncaus zpath concaten shorter causal zpath figur 1 noncaus zpath concaten causal zpath 3 definit 26 zpath local checkpoint c ix local checkpoint c ix call zcycl say involv local checkpoint c ix zpath zcycl involv local checkpoint c k2 observ zcycl alway includ zpattern 24 useless checkpoint definit 27 local checkpoint c ix useless iff belong consist global checkpoint follow import character useless checkpoint state 21 theorem 21 netzerxu 1995 local checkpoint c ix useless iff involv zcycl exampl figur 1 c k2 useless zpath zcycl includ c k2 includ zpattern interest reader find proof theorem 21 25 3 design principl protocol set c b checkpoint taken execut comput b h compos basic checkpoint forc checkpoint indic introduct basic checkpoint taken depend applic properti detect protocol rollbackrecoveri protocol forc checkpoint taken communicationinduc checkpoint protocol ensur checkpoint useless aim protocol wish design keep low number forc checkpoint protocol work evalu predic upon everi messag recept possibl take forc checkpoint henc name communicationinduc checkpoint pro tocol predic base past knowledg commun checkpoint pattern forc checkpoint taken prevent zcycl form 31 basic idea checkpoint timestamp mechan checkpoint c let us associ timestamp denot ct consid follow domain timestamp valu set posit integ protocol base follow theorem theorem 31 pair checkpoint c jy c kz zpath c jy zcycl irisa communicationbas prevent useless checkpoint distribut comput 7 proof part suppos zcycl exist c ix c ix zcycl zpath c ix c ix assumpt theorem would impli c ix c ix part zcycl zgraph whose vertic local checkpoint path zpath partial order follow topolog sort local checkpoint requir properti 2 theorem 31 idea underli theorem design protocol manag timestamp take forc checkpoint way timestamp alway increas along zpath zcycl possibl form checkpoint useless assum process p local logic clock lc manag follow classic way 16 ffl take basic forc checkpoint p increas 1 local clock associ new valu checkpoint ffl everi messag timestamp valu sender clock let mt timestamp associ ffl process p receiv messag updat local clock lc maxlc follow classic mechan causal zpath c jy c kz c jy c kz examin case noncaus zpath 32 checkpoint checkpoint given previou timestamp mechan let us consid situat depict figur 2a c jy local checkpoint taken p j send 1 c kz first checkpoint p k taken deliveri 2 send 2 deliveri 1 belong interv constitut zpattern c jy c kz ckz b figur 2 must p take forc checkpoint two case occur case c jy henc zpattern consist assumpt theorem 31 case safe strategi prevent zcycl format consist direct p take forc checkpoint c ix deliv 1 shown figur 2b break longer zpattern strategi implement follow way process p manag boolean array sent 1n order know whether recept messag creat zpattern 8 jm helari mostefaoui r netzer raynal sent k valu true iff p sent messag p k sinc last checkpoint moreov manag array integ min 1n min k keep timestamp first messag sent p k sinc p last checkpoint condit express sent take forc checkpoint c true next section show safe strategi improv sharpen predic caus fewer forc checkpoint taken 33 reduc number forc checkpoint previou strategi util inform p could concern valu local clock process k1 k n let us denot cl k valu p k local clock perceiv p p obtain knowledg classic piggyback techniqu shown section 41 obvious cl percept local clock p approxim cl k lc k consid situat depict figur 2a messag 1 arriv p j creat zpattern messag 2 sent 6 p k follow properti hold cl zpattern consist assumpt theorem 31 let us consid properti p case 1 carri valu lc j 1 sent first relat c jy necessarili hold 1 receiv properti p violat 1 receiv 1 cl k cl k c kz follow prevent format zpattern would violat properti p consequ could possibl inconsist assumpt theorem 31 protocol requir p take forc checkpoint deliv 1 applic 1 cl k cl question determin valu cl k approxim cl k refer let us examin two possibl case ckz ckz b figur 3 cl k lower bound c kz valu cl k brought p causal zpath start p k c kz situat illustr figur 3 precis cl k brought p 1 figur 3a 2 delta 1 figur 3b case cl consequ p take forc checkpoint 1 cl k 6 recal ckz first checkpoint taken pk deliveri m2 irisa communicationbas prevent useless checkpoint distribut comput 9 ii valu cl k brought p causal zpath start p k c kz situat illustr figur 4 precis relev causal zpath 1 figur 4a figur 4b note figur redrawn indic figur 5 causal zpath bring p last valu p k local clock 1 2 delta 1 case cl k c kz exactli correspond pattern describ figur 5 problem p recogn pattern take forc checkpoint occur let c 1 predic describ pattern occurr b figur 4 cl k lower bound c kz ckz figur 5 causal zpath discuss follow previou condit c p test know take forc checkpoint receiv messag 1 refin c 0 sent k cl next section show express predic appropri data structur evalu onlin process 4 first version protocol section present first version protocol directli obtain previou analysi version theorem section 5 provid less costli version protocol 41 data structur addit array sent 1n min 1n previuosli describ everi process p maintain follow data structur array clock process p manag array clock 1n follow mean clock highest valu lc k known p note clock lc requir lc follow array initi manag 7 note clock vector contain lamport timestamp jm helari mostefaoui r netzer raynal ffl take basic forc checkpoint p increment clock 1 definit lc send messag current valu clock append let mclock receiv p j perform follow updat lamport clock statement updat clock use data structur p receiv messag 1 cl thu element c 0 rewritten sent k next two array provid way evalu c 1 array ckpt array vector clock count mani checkpoint taken process ckpt number checkpoint taken p k p knowledg vector clock manag usual way 9 let mckpt valu append sender p ie valu array ckpt send time array taken boolean array use conjunct ckpt evalu c 1 follow mean taken k true iff causal zpath last checkpoint p k known p next checkpoint p causal zpath includ checkpoint manag follow way p take checkpoint set true entri except ith one taken alway remain ffl send messag p append current valu taken let mtaken valu ffl receiv p updat taken follow way order maintain mean docas data structur condit c 1 express follow way consid figur 5 first part condit c 1 state causal zpath name start c ix arriv p c ix1 second part c 1 indic process taken checkpoint along causal zpath irisa communicationbas prevent useless checkpoint distribut comput 11 42 protocol protocol execut process p describ figur 6 s0 s1 s2 describ initi statement execut p send messag statement execut receiv messag respect procedur take checkpoint call time p take checkpoint basic forc indic previous basic checkpoint taken part protocol procedur take checkpoint 8k sent k fals enddo 8k min k 1 enddo clock save current local state copi clock ix checkpoint c ix initi 8k clock k 0 ckpt k 0 enddo taken fals take checkpoint send messag pk sent k sent k true min k clock endif receiv clock ckpt taken p j mclockj lamport timestamp ie mt sent k take checkpoint forc checkpoint clock updat scalar clock lc clock case case figur first version protocol 43 properti protocol follow theorem show consist global checkpoint c associ lamport timestamp follow given local checkpoint c ix timestamp ie c ix easili associ consist global checkpoint belong theorem 41 let lamport timestamp 0 let c global checkpoint c 1x defin follow way 8k c kx k last checkpoint p k c kx k c consist global checkpoint proof suppos c consist c contain pair checkpoint c ix c kz exist messag 2 sent p p k sendm 2 12 jm helari mostefaoui r netzer raynal assumpt c kz p1 construct timestamp c ix consequ ckz ix1 figur 7 messag 2 orphan respect c ix c kz let c ix1 first checkpoint taken p c ix let c kz gamma1 last checkpoint taken c kz see figur 7 assumpt c ix1 assumpt combin p2 give p3 moreov assumpt combin p1 give c kz c ix1 p4 ckz ckz b ikz figur 8 causal noncaus zpath p3 impli two consecut local checkpoint c ix c ix1 clock p name clock increment least two assumpt local checkpoint taken p c ix c ix1 increment occur interv ix1 p receiv least one messag whose timestamp equal c ix1 gamma 1 let 1 first messag deliverm 1 figur 8a c kz contradict p4 thu situat depict figur 8b 1 arriv ffl 2 sent ffl min p4 p j sender conclud 1 clockj min k p6 recal condit c 0 test p know take forc checkpoint receiv sent k arriv shown p5 p6 first two line condit satisfi show case analysi checkpoint necessarili taken p c ix c ix1 contradict hypothesi ffl case clock case 1 receiv maxclock combin p4 get maxclock irisa communicationbas prevent useless checkpoint distribut comput 13 p5 p6 p7 follow p take checkpoint c ix c ix1 contradict hypothesi ffl case clock exist causal zpath c kz c ix1 zpath figur 4b case 1 receiv 1 p8 p5 p6 p8 follow p take checkpoint c ix c ix1 contradict hypothesi ffl case clock case causal zpath 1 start c kz arriv p c ix situat describ figur 4a let 0 messag end 1 receiv p note messag 0 receiv p send 2 case would c kz recept 0 see discuss section 33 sent receiv 0 lamport clock strictli increas along causal zpath name 2 checkpoint taken pattern describ figur 5 detect condit c 1 follow p taken checkpoint c ix c ix1 receiv 0 contradict hypothesi theorem 41 5 improv version protocol section first prove invari protocol invari use simplifi condit c 0 consequ deriv less costli version protocol 51 invari theorem 51 follow assert invari sent k proof let k two given process number must show properti ii sent k execut p end show 1 properti hold p initi base case 2 properti hold event still hold execut induct event consid modifi valu variabl involv properti name take checkpoint send recept messag denot take checkpoint s1 s2 figur 6 respect remind lamport clock properti relat clock clock k alway true consequ messag sent p j mclockj mclockk event trigger action modifi valu variabl x denot x valu event x 0 valu event 14 jm helari mostefaoui r netzer raynal base case sent k initi valu fals properti initi hold induct take checkpoint properti hold begin checkpoint interv sinc array sent reset fals send messag p p k note array clock modifi s1 ffl sent k valu fals first send p k s1 min thu s1 min k clock k clock s1 follow hold s1 ffl sent k valu true first send p k array clock min modifi send follow still hold s1 recept p messag sent p j modifi valu clock clock k arriv forc p take checkpoint ii trivial hold s2 sent reset fals examin case arriv forc p take checkpoint mean condit c 0 protocol satisfi ie sent k fals s2 s2 modifi variabl ii still hold s2 thu examin case one two last term satisfi note impli eas proof use follow notat ck follow assumpt ag hold event ck ck 0 properti lamport clock mck properti lamport clock checkpoint taken must prove relat r c remain true s2 two case consid accord two term assumpt g irisa communicationbas prevent useless checkpoint distribut comput 15 first case g1 mcj get c thu c mcj b reduc c c get maxck 0 maxck thu use success e get maxck conclud replac b c mcj valu defin 1 respect get due mcj maxck mck g2 reduc due c reduc c theorem 51 52 simplifi condit condit use process p decid whether take forc checkpoint receiv messag sent k mclockj min k follow theorem show condit simplifi theorem 52 sent k c 0 j proof let us consid follow set predic j sent k ffl first show c 1 condit c 1 introduc section 32 character situat depict figur 9 messag sent p j termin causal zpath 0 delta 1 delta 2 deltam 1 start 0 arriv p c ix1 3 along zpath process p l taken checkpoint c lz mtakeni true lamport timestamp decreas increas checkpoint taken jm helari mostefaoui r netzer raynal figur 9 c 1 character follow c 1 sent k min k mclockj previou notat ffl use classic logic rule definit c 0 definit due invari e c 1 e independ definit theorem 52 53 reduc size data structur theorem 52 show array min 1n use condit consequ suppress finer analysi show array clock 1n replac singl integ lc plu boolean array greater 1n come follow two observ consid see ffl element array clock use clock ie lamport clock p ffl mclockj mclockk alway true remind mclockj highest clock valu known p j send follow subcondit mclockj mclockk equival mclockj 6 mclockk follow process p array clock 1n replac singl lamport clock lc whose valu equal clock plu boolean array greater 1n whose mean new data structur condit rewritten consequ messag piggyback lamport clock valu boolean array instead array lamport clock valu result protocol describ figur 10 updat integ array clock replac updat boolean array greater process manag clock n checkpoint sequenc number 3 n boolean messag piggyback boolean irisa communicationbas prevent useless checkpoint distribut comput 17 procedur take checkpoint 8k sent k fals enddo save current local state copi lc ix checkpoint c ix initi 8k ckpt k 0 enddo taken fals greater fals take checkpoint send messag pk sent k true receiv lc greaterckpt taken p j mlc lamport timestamp take checkpoint forc checkpoint case case docas enddocas figur 10 final protocol 6 discuss section discuss protocol show provid gener framework exist protocol obtain ffl let us suppress data structur except array sent 1n replac singl boolean sent follow mean sent sent k ie sent true iff messag sent p sinc last checkpoint protocol becom drastic simplifi reduc wellknown russel protocol 23 8 shown figur 11 russel protocol character follow properti consid deliv send checkpoint event behavior process correspond follow regular languag deliv send checkpoint word deliv event follow immedi send event cours protocol may take forc checkpoint never less propos protocol ffl anoth protocol obtain consid subset data structur exampl elimin array ckpt 1n taken 1n obtain protocol character follow condit c 00 8 protocol adapt context mobil comput 1 jm helari mostefaoui r netzer raynal procedur take checkpoint sent fals enddo save current local state local checkpoint initi take checkpoint send messag pk sent true sendm pk receiv p j sent take checkpoint forc checkpoint endif figur 11 russel protocol may take forc checkpoint never less propos protocol requir messag piggyback one integ name mlc valu lc j time p j sent ffl simplifi protocol elimin array sent 1n get follow condit c 000 simplic result protocol shown figur 12 variant protocol describ 4 quasisynchron version propos manivannan singhal 19 9 procedur take checkpoint save current local state copi lc initi take checkpoint send messag pk receiv lc p j take checkpoint forc checkpoint figur 12 variant manivannansingh quasisynchron protocol 9 origin quasisynchron protocol propos 19 differ variant follow way 1 process take basic checkpoint accord local logic period 2 s2 lc updat done part call take checkpoint 3 within procedur take checkpoint variabl lc increas checkpoint basic irisa communicationbas prevent useless checkpoint distribut comput 19 new protocol design consid simplif basic protocol discuss show tradeoff number forc checkpoint taken size control inform piggyback applic messag gener smaller control inform greater number forc checkpoint rais interest question propos protocol optim one ie communicationinduc checkpoint protocol without priori knowledg basic checkpoint taken take fewest number forc checkpoint ensur checkpoint useless optim question remain open problem communicationinduc checkpoint protocol use heurist approach prevent useless checkpoint protocol condit test messag recept safe sens basic checkpoint may remain useless protocol famili describ 26 use experiment result author show protocol reduc rollback distanc less one checkpoint interv per process number forc checkpoint 4 number basic checkpoint propos protocol encompass heuristicbas protocol easi show heurist use 26 weaken condit use propos protocol 7 conclus useless checkpoint local checkpoint part consist global checkpoint paper address follow import problem given set process take basic local checkpoint independ unknown way design communicationinduc checkpoint protocol direct process take possibl addit local forc checkpoint ensur local checkpoint useless protocol gener effici also shown take fewer forc checkpoint exist protocol solv problem improv obtain use control inform compos boolean n number process also shown size control inform reduc even elimin price addit forc checkpoint protocol easili tune desir control informationoverhead perform tradeoff design protocol motiv wide use communicationinduc checkpoint protocol applic requir consist global checkpoint detect stabl unstabl properti rollbackrecoveri determin distribut breakpoint r checkpoint distribut applic mobil comput independ checkpoint concurr rollback recoveri optimist approach distribut dominoeffect free recoveri algorithm determin global state distribut sy tem consist detect global predic distribut checkpoint detect messagepass program survey rollbackrecoveri protocol messagepass system logic time distribut comput system proc 10th ieee int detect strong unstabl predic distribut program detect stabl properti distribut ap plicat effici distribut detect conjunct local predic asynchron comput scheme coordin execut independ design recover distribut process checkpoint rollbackrecoveri distribut system inform process letter low overhead recoveri techniqu use quasisynchron check point breakpoint halt distribut program necessari suffici condit consist global snapshot system structur softwar faulttoler state restor system commun process lazi checkpoint coordin bound rollback propag consist global checkpoint contain given set local checkpoint adapt independ checkpoint reduc rollback propag tr checkpoint rollbackrecoveri distribut system distribut snapshot detect stabl properti distribut applic logic time distribut comput system consist detect global predic necessari suffici condit consist global snapshot distribut snapshot unifi framework specif runtim detect dynam properti distribut comput adapt recoveri mobil environ detect strong unstabl predic distribut program distribut breakpoint detect messagepass program consist global checkpoint contain given set local checkpoint theoret analysi communicationinduc checkpoint protocol rollbackdepend trackabl rollbackdepend trackabl evalu dominofre communicationinduc checkpoint protocol time clock order event distribut system checkpoint distribut applic mobil comput communicationinduc determin consist snapshot onthefli detect conjunct local predic distribut comput lowoverhead recoveri techniqu use quasisynchron checkpoint ctr jiang wu yi luo manivannan enhanc modelbas checkpoint protocol proceed 25th confer proceed 25th iast intern multiconfer parallel distribut comput network p332337 februari 1315 2007 innsbruck austria gyungleen park hee youn yong new approach high perform comput system variou checkpoint scheme journal supercomput v33 n1 p6578 juli 2005 emmanuel anceaum jeanmichel hlari michel raynal track immedi predecessor distribut comput proceed fourteenth annual acm symposium parallel algorithm architectur august 1013 2002 winnipeg manitoba canada adnan agbaria hagit attiya roy friedman roman vitenberg quantifi rollback propag distribut checkpoint journal parallel distribut comput v64 n3 p370384 march 2004 j hlari mostefaoui raynal interv consist asynchron distribut comput journal comput system scienc v64 n2 p329349 march 2002 b gupta k banerje rollforward recoveri scheme solv problem coast forward distribut system acm sigop oper system review v35 n3 p5566 juli 1 2001 jichiang tsai properti rdt communicationinduc checkpoint protocol ieee transact parallel distribut system v14 n8 p755764 august