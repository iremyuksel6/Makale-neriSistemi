chainsplit evalu deduct databas abstractmani popularli studi recurs deduct databas compil one set highli regular chain gener path consist one set connect predic previou studi chainbas queri evalu deduct databas take chain gener path insepar unit evalu howev recurs especi mani function recurs whose compil chain consist infinit evalu function evalu chainsplit evalu split chain gener path two portion evalu immedi evalu portion delayedevalu portion paper necess chainsplit evalu examin point view effici finit evalu three chainsplit evalu techniqu magic set buffer evalu partial evalu develop studi show chainsplit evalu primit recurs queri evalu techniqu differ kind recurs implement effici deduct databas extens exist recurs queri evalu method b introduct regular chain form 8 9 21 interest recurs queri evalu techniqu 2 transit closur algorithm 10 magic set count 1 appli effici evalu compil chain deduct databas howev interest observ recurs especi mani recurs contain function symbol may often evalu appropri differ evalu techniqu chain split evalu like mani research 2 21 assum deduct databas consist three part extension databas edb set data relat ii intension databas idb set hornclaus rule iii set integr constraint ic definit 11 predic said impli predic r r horn claus idb predic r head bodi predic r transit predic r recurs r r r mutual recurs deduct level otherwis r r lower deduct level definit 12 rule linearli recurs bodi contain exactli one recurs predic predic defin deduct level head predic rule nest linearli recurs bodi contain one recurs predic one defin deduct level head predic rule nonlinearli recurs recurs belong two categori definit 13 recurs singl linear recurs predic deduct level everi recurs predic defin one linearli recurs rule possibl nonrecurs exit rule recurs multipl linear recurs predic deduct level everi recurs work support part natur scienc engin research council canada grant opg 3723 research grant centr system scienc simon fraser univers preliminari version paper appear proceed 8th intern confer data engin temp az februari 1992 author school comput scienc simon fraser univers burnabi bc canada v5a 1s6 predic defin one linearli recurs rule least one defin multipl linearli recurs rule possibl nonrecurs rule recurs nest linear everi recurs predic recurs defin one linearli nest linearli recurs rule least one defin nest linearli recurs rule possibl nonrecurs rule recurs nonlinear contain nonlinearli recurs rule recurs functionfre contain function symbol otherwis function bear function exampl 11 rule set f11 12g defin popular functionfre linear recurs sg indic gener rel sibl parent gener rel notat adopt similar datalog 21 recurs compil highli regular compil chain form 9 shown 13 2 parent x denot disjunct parent x parent x ae true parent definit 14 chain length k k 1 sequenc k predic follow properti 1 predic name say p lth p chain denot p l 2 least one ident variabl everi two consecut predic variabl posit first predic j variabl posit second variabl two posit ident ith variabl p l ident jth variabl p l1 everi l 1 l k gamma 1 predic p l call chain predic chain gener path consist sequenc connect predic ie predic contain share variabl unitlength chain trivial chain gener path 0length chain defin tautolog linear recurs nchain recurs posit integ k exist kth expans recurs consist one chain synchron length chain length greater k possibl predic form nontrivi chain singlechain recurs multichain recurs otherwis recurs bound equival set nonrecurs rule compil nchain recurs rewritten form normal linear recurs 9 consist set exit rule one normal recurs rule form 14 x variabl vector c 1 n chain predic notic chainpred c may null sens c predic exit variabl otherwis chain variabl chain predic c rule set f11 12g normal form recurs rule complex variabl connect normal compil process 9 normal greatli facilit systemat analysi recurs bind propag regular previou studi 8 9 show linear recurs compil bound recurs nchain recurs mani kind recurs also compil chain form compil chain form view altern one set normal recurs studi focus chainsplit evalu compil normal recurs 11 chainsplit effici evalu usual singlechain recurs evalu effici transit closur algorithm 10 multichain recurs magic set count 1 2 one may wonder whether queri multichain recurs evalu effici merg multipl chain gener path one appli transit closur algorithm 11 howev sinc multipl path share variabl merg impli iter process crossproduct sever relat correspond path terribl ineffici perform iter evalu crossproduct two databas relat 14 contrast merg multipl chain one may split chain multipl chain evalu split impli nchain recurs evalu sophist n evalu techniqu chainsplit improv perform queri evalu examin exampl exampl 12 suppos recurs scsg samecountri samegener rel defin rule set f15 16 17g definit similar sg 2 except parent pair scsg must born countri birth merg parentsx merg parent x sinc countri connect two parentpred 15 three predic merg one merg parent shown 18 compil deriv singlechain shown 19 countri predic provid weak restrict relat merg parent much smaller crossproduct two parent relat obvious would effici split merg parent two subchain evalu queri 110 magic set method encount problem recurs sinc countri link two parent predic bodi recurs rule bind propag merg nonrecurs predic one 21 deriv magic set requir iter comput crossproductlik relat merg parent easili seen adorn rule 111 112 2 2 parent bf x parent fb 1 scsg bb x parent bf x parent bb 1 scsg bb x 12 chainsplit finit evalu recurs contain function evalu predic chainsplit evalu may play anoth import role transform infinit evalu program finit evalu one facilit analysi function recurs functionpred transform perform map function togeth function variabl predic call function predic function variabl variabl unifi return valu function function ariti n transform predic last argument repres function variabl exampl transform fx similar transform also discuss research 12 15 17 sinc transform map function logic rule functionfre one analysi function recurs perform framework functionfre one notic transform convert constructor predic sinc constructor mainli serv constraint unif process transform mere delay constraint solv unif transform theoret sound howev transform function predic usual repres potenti infinit relat construct correspond termlist construct function con etc comput correspond comput function sum etc relat repres finit edb relat thu evalu function predic still reli correspond function definit facilit compil analysi logic program rule differ form rectifi 21 rule predic p rectifi function rule map correspond function predic functionpred transform head rule ident form exampl 13 function linear recurs append defin rule set 113 114 xjl 1 denot list construct function correspond function predic consx l 1 l repres result list l form take x head l 1 remain result list rule set rectifi f115 116g compil 117 9 con function predic list construct function notic rectifi rule set also normal rule set recurs 9 appendu appendu appendu con con ae true con sinc two con predic connect bodi 116 merg one merg con shown 118 merg u w instanti queri gamma appenda b v b c iter evalu merg con proce success howev one u w instanti evalu merg con proceed sinc encount infinit evalu predic take queri gamma appenda b c w exampl evalu first chain gener path first con consx finit evalu instanti deriv x unfortun second con consx 1 finit evalu instanti howev chain predic merg con split two subchain first subchain evalu first result pass via bodi exit rule 115 instanti second argument second subchain thu recurs finit evalu chainsplit evalu 2 sinc chainsplit evalu may lead effici andor finit queri evalu worthwhil studi chainsplit evalu techniqu remain paper organ follow condit queri requir chainsplit evalu examin section 2 techniqu chainsplit evalu studi section 3 extens chainsplit evalu techniqu complex class recurs examin section 4 discuss summar section 5 chainsplit evalu appli section 1 show chainsplit may sometim lead effici andor finit evalu interest examin condit chainsplit evalu appli discuss base analysi two differ kind chain split efficiencybas chainsplit finitenessbas chainsplit 21 efficiencybas chainsplit chain gener path contain neither function evalu predic chainsplit evalu perform split may lead effici queri evalu plan evalu compon chain togeth ie chainfollow gener decis made base quantit analysi competit queri evalu plan chainfollow vs chainsplit base upon size potenti intermedi relat avail access path cost estim function databas statist 13 18 follow quantit measur introduc discuss definit 21 propag ratio ff xw relat p defin ratio number distinct valu attribut w denot nw attribut x denot nx data relat join expans ratio fi xy join express join attribut variabl vector share predic p q potenti number distinct hx pair gener distinct w join gener formula 22 deriv base follow reason one distinct w valu correspond averag ff wx distinct xs relat p ff wy distinct relat q w join attribut relat p q join two relat pair distinct xs accord definit join thu potenti number distinct hx pair gener w join ff wx theta ff wy notic impli number tupl relat xy p 1 q nw theta fi xy differ w may share hx pair nevertheless fi xy good indic approxim size join relat exampl 21 predic countryx defin exampl 12 suppos correspond data relat birth countryx w bxw let nx 100000 nw 50 propag ratio ff 2000 join expans ratio fi ff wx thetaff indic join two predic birth countryx w birth countryy w may expect gener 4 million tupl distinct w one expect weak bind propag may lead effici process 2 gener suppos compil form nchain recurs 23 one chain gener path form px two predic p q connect via set predic predic pair variabl x igamma1 x link correspond variabl consecut chain gener path chain notat convent p repres relat predic p jp j size relat p measur number tupl relat etc examin chain gener path split evalu efficiencybas chainsplit follow heurist heurist efficiencybas chainsplit follow evalu strategi adopt evalu chain gener path px compil form 23 perform 1 chain evalu evalu exit portion bodi exit rule 2 instanti x 0 0 highli select 3 fi x0y0 1 ffl case 2 otherwis chainsplit evalu perform x 0 0 highli select fi x0y0 ae 1 ffl case 3 otherwis perform detail cost analysi determin whether chainsplit benefit evalu rational chainsplit evalu split chain two connect subchain one evalu first buffer evalu exit portion pass bind buffer chain obvious chainsplit perform chain downchain ie chain evalu evalu exit portion 2 suppos evalu start chain path p instanti proce toward exit portion e chain compil recurs effici evalu import examin size chain relat p x size ie number tupl chain relat benefici similarli x 0 0 highli select evalu entir chain gener path gener larg relat one x 0 0 highli select fi x0y0 ae 1 case 2 merg parent relat exampl 12 chainsplit evalu perform evalu split chain lead rel effici evalu otherwis obviou method chainsplit chainfollow effici case 3 detail cost estim perform compar approxim size cost evalu p 1 vs p 1 accomplish quantit analysi two express incorpor avail access structur databas statist etc 13 2 heurist indic easi judg obviou case whether chainsplit evalu appli base join expans ratio select provid queri constant howev detail quantit analysi perform nonobvi case analysi similar queri plan gener access path select develop studi relat deduct queri process 21 13 present detail studi 22 finitenessbas chainsplit compil function recurs chain gener path may contain function evalu predic defin infinit domain ensur evalu gener answer termin three issu examin 1 finit evalu evalu everi ith formula compil form gener finit intermedi relat 2 chainlevel finit evalu evalu chain gener path gener finit intermedi relat 3 termin evalu gener answer termin finit number iter finitenessbas chainsplit base analysi first two issu justif finit evalu reli queri inform finit constraint finit constraint predic r impli valu attribut x correspond finit set valu r 6 finit constraint strictli weaker function depend studi databas theori 21 hold trivial finit predic sinc edb relat finit argument edb relat satisfi finit constraint function predic fx domain argument finit v must finit matter whether f singl multiplevalu function x specif finit constraint explor specif function mani case one argument function comput valu argument valu function exampl function predic sumxyz argument finit comput two argument finit relationship repres set finit constraint x z z x interest finit constraint z x hold function predic consx z indic list z finit finit number choic x sinc queri constant may bind infinit domain variabl finit one analysi finit evalua biliti incorpor queri instanti inform similar notat use magic set transform 2 21 superscript b f use adorn variabl indic variabl bound finit string bs fs use adorn predic indic bind correspond argument algorithm 21 test finit evalu queri nchain recurs input 1 nchain recurs consist nchain recurs rule set exit rule 2 set finit constraint 3 queri instanti inform output assert whether queri finit evalu ffl initi variabl finit edb predic equival one set constant ffl test finit evalu 1 exit rule set 2 first expand exit rule set rule set obtain unifi nchain recurs rule exit rule set done push queri bind inform rule test propag finit bind iter base follow two finit propag rule 1 finit constraint x 2 ffl return ye everi variabl two set rule test finit finit bind propag otherwis remark 21 algorithm 21 correctli test finit evalu nchain recurs ok 2 time worst case k number predic recurs rational initi queri constant propag variabl edb predic equival one set constant includ queri constant constant bodi rule finit propag finit bind bodi recurs exit rule accord two finit propag rule algorithm everi variabl predic p finit propag p remov list predic test iter least one predic remov list predic test otherwis rule finit evalu sinc initi k predic bodi rule second iter need test predic total number predic test worst case sigma i0 12 thu worst case time complex algorithm ok 2 notic recurs rule exit rule finit evalu recurs finit evalu induct sinc nth iter may treat deriv previou gamma 1 iter finit base relat deriv 2 algorithm 22 finitenessbas chainsplit chain gener path nchain recurs input 1 chain gener path compil nchain recurs 2 set finit constraint 3 queri instanti inform output finitenessbas chainsplit evalu plan compil chain nchain recurs ffl applic algorithm 21 queri finit evalu algorithm 21 return otherwis proceed follow step ffl initi variabl finit edb predic ii equival one set constant ffl propag finit bind chain gener path accord two finit propag rule algorithm 21 everi variabl chain gener path finit finit bind propag chainlevel finit evalu otherwis path split two aport bportion former consist set predic everi variabl finit latter consist remain set predic chain gener path chainsplit evalu perform first evalu subchain form aport bportion evalu exit portion remark 22 algorithm 22 determin correctli whether chainsplit evalu perform base finit evalu chaingener path split rational queri finit evalu iter evalu perform thu step 1 necessari queri finit evalu chain gener path chain gener path split two portion immedi evalu portion buffer portion evalu evalu portion chain exit portion bind obtain must make buffer portion finit evalu otherwis queri finit evalu thu algorithm 2 exampl 22 predic appendu v w 2 possibl queri bind pattern bbb bbf bfb bff fbb fbf ffb fff among eight pattern bff fbf fff finit evalu bbf fbb ffb requir chainsplit remain two requir chainsplit one case present queri bind pattern ffb gamma appendu v b finit evalu variabl exit rule first expand exit rule adorn b bind propag adorn transform bind propag first expand exit rule present 24 notat adorn ffb bbb indic initi adorn ffb chang bbb bind propag append ffbbbb u v w bind propag proce follow 1 u 1 w adorn b accord instanti exit rule queri 2 x 1 w 1 adorn b w b exist finit constraint w 3 v adorn b sinc final 4 u adorn b x b sinc everi variabl rule adorn b bind propag queri finit evalu furthermor algorithm 22 assert chainsplit evalu perform chain gener path w b make consx 1 finit evalu shown con ffb x 1 con bff x 1 therefor chain split two evalu first conspred delay first subchain exit portion evalu adorn normal linear recurs rule written chainsplit form follow append ffb u v w con ffb x 1 con bbf x 1 rewritten rule indic doublecon chain split two subchain one subchain repres consx 1 evalu first consx 1 delay exit rule evalu 2 3 chainsplit evalu techniqu two typic evalu method magic set count 2 evalu nchain recurs without chainsplit appropri modif method applic chainsplit evalu 31 efficiencybas chainsplit magic set evalu exampl 12 show undesir larg magic set could deriv strictli enforc bind propag rule without consider size intermedi relat 21 sinc bind propag rule distinguish strong linkag effect reduc size relev set weak one involv huge crossproduct like relat bind like one countri bf x still pass next subgoal bodi rule via weak linkag obvious restrict enforc confin pass bind via strong linkag effect magic set still deriv effici semina evalu idea efficiencybas chainsplit magic set evalu exampl 31 reexamin magic set evalu queri gamma scsgjohn exampl 12 merg parent chain bind x b propag parent bf x parent fb 1 suppos averag person 2 parent less 5 children 2000 person share countri databas 1 parent bf x x 1 2 2 countri bf x 3 parent fb 1 5 clearli fi 4 000 000 indic weak linkag thu bind propag x 1 1 prohibit via linkag merg parent split two subchain parentx first one evalu first second one delay exit rule evalu bind pass gener parent bf x parent fb 1 bind propag deriv magic set sg recurs semina evalu perform effici 2 join expans ratio use simpl judgement whether particular bind propag anoth subgoal bind propag rel larg number 100 set chainsplit threshold join expans ratio greater threshold bind propag proceed hand rel small number 10 set chainfollow threshold join expans ratio smaller threshold bind propag proce two threshold tune base experiment result system behavior howev join expans ratio greater chainfollow threshold less chainsplit threshold still necessari perform detail quantit analysi base chain characterist databas statist compar rel cost chainfollow vs chainsplit order make appropri decis thu algorithm 31 efficiencybas chainsplit magic set evalu functionfre linear recurs input queri compil functionfre linear recurs output efficiencybas chainsplit magic set queri evalu plan ffl deriv magic set bind propag rule 1 modifi follow join expans ratio hx chainsplit threshold bind propag x chainfollow threshold bind propag x otherwis detail quantit analysi perform determin whether chainsplit benefici ffl base modifi bind propag rule magic set deriv semina evalu 1 perform set relev fact 2 base reason present exampl easi see algorithm 31 deriv effici queri evalu plan method reli blind bind pass without distinct strong linkag weak one 32 buffer chainsplit evalu chainsplit evalu implement anoth techniqu buffer chainsplit evalu split chain gener path two portion evalu 1 aport set predic evalu 2 bportion set predic buffer buffer portion evalu exit portion bodi exit rule evalu variabl valu share b portion buffer evalu aport later use evalu correspond bportion chainmerg process process figur 1 chainfollow vs chainsplit evalu fig 1 show distinct chainfollow evalu b buffer chainsplit evalu chainfollow evalu b treat one merg predic buffer chainsplit evalu aport first evalu share valu buffer evalu exit portion e bportion obtain suffici bind inform thu evalu proce way similar evalu regular multichain recurs except correspond buffer valu patch correspond variabl evalu bufferedport therefor name buffer chainsplit evalu exampl 32 accord discuss exampl 22 gamma appendu v b evalu chainsplit chain gener path consx partit two portion upred consx w predic shown fig 2 evalu essenti pass exit portion deriv first set answer upred finit evalu evalu proce along w predic deriv w buffer w 1 pass exit portion make upred evalu sinc avail deriv thu second set answer similarli evalu may proceed w predic deriv w buffer w 2 pass exit portion make u upred evalu deriv thu third set answer con con con con con figur 2 evalu gamma appendu v b gener follow algorithm present buffer chainsplit evalu singlechain recurs buffer base chainlevel finit evalu evalu effici algorithm easili gener multichain recurs algorithm 32 buffer chainsplit evalu singlechain recurs input queri compil function singlechain recurs output queri evalu plan appli buffer chainsplit evalu suppos chain gener path partit two portion accord avail queri bind evalu portion buffer portion b partit base chainlevel finit evalu evalu effici suppos ith chain gener path compil form b share variabl share variabl u 1st b share variabl w 1st b ffl first suppos queri instanti u 0 ith iter base avail bind u evalu deriv u buffer correspond x valu iter termin satisfi termin condit eg list shrink empti cyclic count method determin termin condit suppos termin kth iter ffl evalu exit portion compil form ffl pass bind obtain process exit portion b base avail bind w buffer x b evalu deriv w igamma1 k gamma ith iter evalu termin kth iter w igamma1 deriv iter 2 remark 31 buffer chainsplit evalu perform algorithm 32 correctli evalu compil singlechain recurs rational algorithm similar count 1 except valu variabl x buffer process evalu portion chain gener path reus process buffer portion notic link two portion recurs would two chain compil recurs count appli sinc evalu portion link correspond buffer portion via x chain gener path necessari buffer x reus evalu buffer portion evalu exit portion buffer portion must finit evalu base finit evalu recurs therefor chainsplit evalu deriv correct complet answer queri process 2 notic termin buffer chainsplit evalu judg care functionfre recurs evalu termin easili acycl data cyclic data method extend way similar cyclic count algorithm 5 function recurs termin often base monoton certain argument 6 partial evalu method also contribut termin chainsplit evalu discuss next subsect 33 chainsplit partial evalu buffer chainsplit evalu everi intermedi valu share split portion chain buffer along deriv path split chain sequenc buffer valu associ deriv intermedi valu evalu buffer portion patch perform pop buffer valu revers sequenc deriv sequenc grow buffer patch could quit costli improv simpl buffer scheme partial evalu perform buffer valu mani function recurs follow instead store sequenc buffer valu sequenc buffer valu evalu much possibl partial evalu valu carri along evalu path partial evalu reduc complex patch buffer valu often facilit push queri constraint judgement termin exampl 33 recurs travel defin rule set f32 33g repres flight sequenc connect flight leav departur citi dep dtime arriv destin citi arr atim total fare equal fare travelf dep dtimearratimefar f lightf dep dtimearratimefar 32 travelf nojl dep dtimearratimefar rule set rectifi f34 35g sum function predic arithmet function con function predic correspond list construct function accord 9 rectifi rule set normal form compil form 36 consist one chain three connect predic flight sum con suppos queri find sequenc connect flight vancouv ottawa depart 8 9 fare less 600 dtime 8 dtime 9 fare 600 37 difficult appli magic set method evalu queri involv function recurs semina evalu termin recurs sinc fare length fnolist keep grow chainbas evalu perform follow sinc queri provid select inform departur end rather arriv end process start departur end departur airport vancouv treat queri constant similarli departur time constraint dtime 8 dtime 9 queri constraint push departur end constraint f 600 push queri process base constraint push principl 6 propag bind departur vancouv normal recurs rule shown travel fbfff l ddt f f light fbfff travel sum bbf con bbf evalu start departur end two function predic sum con finit evalu uninstanti sequenc function predic sum l uninstanti sequenc function predic con buffer chainsplit evalu may proceed buffer sequenc f fno valu buffer gener tupl 2 correspond f 2 buffer reach ottawa correspond buffer valu patch evalu sumf howev prefer partial comput buffer valu evalu buffer predic sumf 1 fno 1 instanti valu 2 buffer predic sumf 2 instanti valu therefor gener partial evalu f light relat evalu comput evalu buffer portion trivial reach ottawa point furthermor sinc lengthl monoton function use determin termin constraint push 6 600 continu search follow intermedi tupl hopeless intermedi tupl prune intermedi result buffer constraint fare 600 transform 600 push iter 2 algorithm 33 chainsplit partial evalu compil function singlechain recurs input compil function singlechain recurs set integr constraint queri predic set queri constraint output queri evalu plan incorpor queri constraint implement chainsplit partial evalu ffl test whether queri finit evalu termin stop inform user ffl determin start end chain process base rel select queri constraint end compil chain appli queri constraint belong end queri instanti reduc size initi set ffl compil chain determin whether chainsplit evalu perform base chainlevel finit evalu evalu effici chainsplit evalu perform determin partit beingevalu portion buffer portion ii partial evalu plan possibl buffer portion partial evalu perform evalu buffer portion partial evalu much possibl use instanti valu leav uninstanti portion buffer carri next stage ffl instanti termin constraint base monoton constraint remain queri constraint push termin constraint chain iter chain evalu 6 2 remark 32 algorithm 33 correctli incorpor queri constraint implement chainsplit partial evalu evalu compil function singlechain recurs rational step 1 necessari sinc queri must finit evalu termin step 2 necessari correct sinc select inform push compil chain initi process 3 step 3 correct sinc chainsplit evalu perform partial evalu explor step 4 correct base studi constraintbas queri process deduct databas 6 2 similar algorithm deriv constraintenforc chainsplit partial evalu multichain recurs 4 chainsplit evalu complex logic program chainsplit evalu confin singl linear recurs sinc similar bind propag rule may suffer kind ineffici andor infinit evalu problem complex class logic program chainsplit appli program well section chainsplit evalu complex class recurs program examin demonstr chainsplit chainfollow two basic recurs queri evalu techniqu 41 evalu nest linear recurs accord definit nest linear recurs everi lower level idb predic nest linear recurs treat like edb predic recurs level still view singl linear recurs thu recurs level normal independ queri analysi perform normal recurs exampl 41 insert sort recurs isort defin follow program 20 nest linear recurs predic insert bodi recurs rule 41 turn defin linear recurs rectifi follow program everi recurs rule normal 9 treat insert like edb predic recurs isort 46 47 normal singlechain recurs recurs insert f48 410g also normal singl chainrecurs queri analysi perform normal recurs level take queri gammaisort5 7 1 exampl analysi proce follow adorn queri predic isort bf queri bind propag lead follow adorn program notat indic builtin predic first argument free second one bound isort bf xxsi con ffb x xs xx isort bf xs zs insert bbf x zs 411 isort insert bbf x zs con bbf x zs 413 insert bbf x zs con ffb x bb con bbf x zs 414 insert bbf x zs con ffb insert bbf x zs con bbf zs zs 415 comparison normal adorn program predic adorn program reorder base analysi finit evalu exampl two predic isort insert normal rule 46 swap adorn rule 411 queri bind propag follow origin order lead nonfinit evalu adorn predic insert bff predic order 411 make everi predic finit evalu sinc two predic consx xs xx insertx zs chain gener path share variabl x chainsplit evalu perform recurs isort bf similarli chainsplit evalu perform recurs insert bbf evalu queri gamma isort5 7 1 proce follow evalu 411 lead buffer xs 7 1 call isort7 1 zs turn lead x 7 buffer xs call isort1 zs 0 lead x also buffer xs call isort zs 00 call execut 412 result zs execut sequenc call buffer valu pop revers sequenc insert1 zs 0 evalu sequenc call perform follow first insert1 zs 0 result zs sinc execut 413 second insert7 1 zs lead zs 1 7 sinc execut 415 turn call insert1 7 zs execut rule 415 third insert5 1 7 call insert5 7 zs cons1 zs lead final answer exampl demonstr chainsplit evalu popular techniqu evalu nest linear recurs similarli shown chainsplit evalu primit queri evalu techniqu multipl linear recurs 42 evalu nonlinear recurs final demonstr chainsplit evalu also primit queri evalu techniqu nonlinear recurs sinc mani nonlinear recurs compil highli regular chain form chain split misnom howev split set connect edb andor lowerlevel idb predic evalu nonlinear recurs share spirit chainsplit evalu linear recurs thu still call chainsplit evalu one exampl examin subsect exampl 42 quick sort recurs qsort defin follow program 20 nonlinear recurs recurs rule 416 nonlinear recurs rule rectifi follow program qsortlittl ls qsortbig bs appendl xbsi treat lowerlevel predic partit append edb predic recurs qsort 421 422 nonlinear recurs wherea lowerlevel recurs partit multipl linear recurs append singl linear recurs queri analysi perform level recurs take queri gamma qsort4 9 5 exampl analysi proce follow adorn queri predic qsort bf queri bind propag lead follow adorn program qsort bf xxsi con ffb x xs xx partit bbff xs x littl big qsort bf littl ls qsort bf big bs con bbf x bs xb append bbf ls xbsi 426 qsort partit bbff xxsyxlsxb con ffb x xs xxsx bb partit bbff xs ls xb con bbf x ls xl 428 partit bbff xxsyxlsxb con ffb x xs xxsx bb partit bbff xs xlsb con bbf x bs xb 429 partit bbff xxsyxlsxb notic transform primit predic lowlevel idb predic rectifi rule 421 connect togeth share variabl howev set connect predic split two portion adorn rule 426 facilit finit evalu similar chainsplit perform adorn rule 428 429 recurs partit chainsplit also perform evalu append bbf similar process demonstr exampl 32 evalu queri gamma qsort4 9 5 proce follow ffl evalu 426 lead qsortlittl ls qsortbig bs ffl evalu partition9 5 4 littl big lead ffl lead evalu partit bbff 5 4 xlsb ffl evalu partit 4 xlsb 0 appli rule 430 deriv turn deriv 432 431 becom ffl evalu qsort ls appli rule 427 deriv ls evalu qsort9 5 bs lead bs 5 9 similar process appli rule 426 final cons4 5 9 4 5 9 append 4 5 9 lead exampl difficult see chainsplit primit frequentlyappli evalu techniqu process mani nonlinear recurs well illustr import chain split evalu evalu nonlinear recurs examin nonlinear recurs form f435 436g let queri form p bf usual bind x pass predic 1 2 via variabl w howev bind pass via w weak lead infinit evalu predic 2 chainsplit perform buffer intermedi valu w delay evalu 2 first evalu first recurs predic p bodi evalu p 2 evalu effici finit avail addit bind w 1 similar chainsplit process perform connect predic b 1 b 2 respect second p bodi thu chainsplit commonli use techniqu evalu nonlinear recurs conclus interest recurs queri evalu techniqu chainsplit evalu investig studi chain split evalu split chain gener path set connect edb andor lowerlevel idb predic two portion evalu immedi evalu portion delayedevalu portion chainsplit evalu appli split reduc size intermedi relat andor transform infinit evalu subprogram finit evalu one studi demonstr chainsplit evalu import queri evalu techniqu especi use mani function recurs whose compil chain consist infinit evalu function necess chainsplit evalu judgement chain need split base chainlevel finit evalu andor evalu effici studi three chainsplit evalu techniqu magic set buffer evalu partial evalu develop magic set chainsplit evalu techniqu block bind propag via unpromis path magic rule rewrit lead deriv effici magic set buffer chainsplit evalu buffer share valu evalu one split subchain patch back buffer valu later evalu partial evalu refin buffer evalu evalu mani buffer function predic possibl reduc cost maintain sequenc buffer valu facilit termin judgement constraint push set frequentlyencount interest exampl analyz studi analysi demonstr chainsplit evalu togeth chainfollow evalu form two primit evalu techniqu evalu differ class recurs furthermor evalu integr exist check constraintbas queri evalu techniqu 6 achiev high perform evalu sophist logic program best knowledg detail studi chainsplit evalu perform previou deduct databas research 4 16 21 23 22 mani deduct databas system project ldl 4 eksv1 23 coral 16 19 etc focus evalu functionfre recurs wherea chainsplit evalu frequent encount function recurs demonstr studi recent studi 4 16 19 extend datalog data model handl function symbol limit extent howev base knowledg chainsplit evalu perform project analysi demonstr larg set logic program differ class recurs implement effici use compilationbas queri analysi optim techniqu origin deduct databas research comparison logic program implement techniqu deduct databas approach deriv effici queri evalu plan base compil normal program transform queri analysi effect complet queri evalu deduct databas independ predic order rule independ order rule fact logic program independ differ queri form flexibl analysi logic program lead power effici queri evalu mechan dataintens logicintens program may repres interest direct toward fulli declar program logic program current implement sophist queri analyz queri evalu part logicbas project 7 logicbas deduct databas system consist two major compon rule compil queri evalu former classifi differ kind recurs compil linear nest linear recurs normal form 9 wherea latter integr chainfollow chainsplit constraintbas evalu techniqu deduct queri evalu preliminari version logicbas system implement unix system use lex yacc c success test mani interest recurs append travel isort nqueen etc queri differ inputoutput mode combin evalu correctli effici recurs independ predic order rule order logic program current implement chainbas queri evalu logicbas confin logic program consist linear nest linear recurs scan exampl program logic program textbook discov major frequentlyus logic program belong categori mani sophist logic program beyond linear nest linear recurs compil highli regular chain form ever similar chainbas evalu techniqu may still appli demonstr analysi quick sort program systemat studi perform analysi evalu complex recurs program may lead gener effici queri analysi evalu techniqu deduct databas logic program system acknowledg author would like express thank ling liu zhaohui xie implement method logicbas project anonym refere construct comment improv qualiti paper r magic set strang way implement logic program amateur introduct recurs queri process strategi bound propag select logic program ldl system prototyp count algorithm cyclic binari queri system prototyp deduct queri evalu asynchron chain recurs automat gener compil form linear recurs effici transit closur algorithm studi transit closur recurs mechan framework test safeti effect comput extend datalog optim logic base languag knowledg data intens applic safeti recurs horn claus infinit relat test effect comput magic program access path select relat databas manag system push constraint select art prolog principl databas knowledgebas system introduct aditi deduct databas system aaai90 workshop knowledg base manag system tr ctr yangjun chen graph travers linear binarychain program ieee transact knowledg data engin v15 n3 p573596 march