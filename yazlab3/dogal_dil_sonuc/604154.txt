interprocedur compat analysi static object prealloc present interprocedur composit algorithm find pair compat alloc site properti object alloc one site live time object alloc site alloc site compat said unitari one object alloc site live given point execut program use result analysi static prealloc memori space object alloc unitari site thu simplifi comput upper bound amount memori requir execut program also use analysi enabl object alloc sever compat alloc site share prealloc memori experiment result show set java benchmark program 60 alloc site unitari static prealloc moreov allow compat unitari alloc site share prealloc memori lead 95 reduct amount memori prealloc site b introduct modern objectori languag java present clean simpl memori model conceptu object alloc garbagecollect heap abstract simpli mani aspect program devel opment complic calcul accur upper bound amount memori requir execut program scenario upper bound especi import includ develop program embed system hard limit amount avail memori estim scope memori size realtim thread alloc object size scope memori 9 paper present static program analysi design nd pair compat alloc site two site compat object alloc one site may live time object alloc site alloc site compat call alloc site unitari alloc site time execut program one live object alloc site therefor possibl static prealloc xed amount space alloc site use space hold object alloc site space usag analys focu nonunitari alloc site analysi use techniqu inspir regist alloc 2 6 reduc amount memori requir hold object alloc unitari alloc site basic approach build color incompat graph node graph unitari alloc site undirect edg two node node compat analysi appli color algorithm assign minim number color graph node subject constraint incompat node dierent color inform enabl compil static prealloc xed amount memori color unitari alloc site gener code bypass standard dynam alloc mechan instead simpli return pointer start static prealloc memori alloc site color object store memori durat lifetim com putat algorithm therefor enabl object alloc compat alloc site share memori result implement analysi show set java benchmark program analysi abl identifi 60 alloc site program unitari alloc site furthermor incompat graph color algorithm deliv 95 reduct amount memori requir store object alloc unitari alloc site attribut high percentag unitari alloc site specic object usag pattern characterist java program mani unitari alloc site alloc except string buer iter object identifi two potenti benet analysi first use simplifi comput amount memori requir execut given program implement memori requir analysi po sibl comput symbol mathemat express amount memori 16 result 16 show preced memori requir analysi analysi present paper use result comput memori requir unitari site separ signicantli improv precis ecienc subsequ memori requir analysi second potenti benet reduct memori manag overhead enabl compil convert heap alloc static alloc analysi reduc amount time requir alloc reclaim memori paper make follow contribut object live analysi present composit interprocedur object live analysi conserv estim set object live program point compat analysi present composit interprocedur analysi nd set compat alloc site object alloc site set share static prealloc memori analysi use result object live analysi implement implement analys mit flex 3 compil use analyz set java benchmark program result show analys abl classifi major alloc site unitari alloc site mani site share memori also implement evalu compil optim transform unitari alloc site use prealloc memori space instead invok standard memori alloc rest paper organ follow section 2 present analysi algorithm section 3 describ implement present experiment result discuss relat work section 4 conclud section 5 2 analysi present given program p goal analysi detect pair compat alloc site p ie site properti object alloc one site live time object alloc site equival analysi identi pair incompat alloc site ie pair site object alloc rst site object alloc second site may live time possibl execut p object live eld method use futur easi prove follow fact fact 1 two alloc site incompat object alloc one site live program point correspond site identifi object live program point analysi need track use object throughout program two complic first abstract problem analysi must use nite abstract reason potenti unbound number object program may creat second part program may read heap refer creat part program use fulledg owsensit pointer analysi would substanti increas time space requir analysi owinsensit pointer analysi 18 5 would provid sucient precis sinc live essenti owsensit properti address complic follow use object alloc site model 13 object alloc given statement model insid node 1 associ statement program label analysi track object point local variabl node whose address may store heap said escap heap analysi conserv assum node unitari ensur set node incompat notic usual java program mani object typic manipul local variabl except iter string buer etc 2 assumpt node escap heap live given program point variabl live program point refer node variabl live wellstudi data ow analysi 2 6 present quick remind variabl v live program point path control ow graph start program point contain denit v end instruct use v analysi process call instruct accu rate exampl need know node return call node escap heap execut invok method reanalyz method call instruct correspond conceptu inlin method would ineci stead use paramet node obtain singl contextsensit analysi result method paramet node placehold node pass actual argu ment analysi process call instruct replac paramet node node sent argu ment henc analysi composit absenc recurs analyz method exactli extract singl analysi result 3 call site instanti result call context particular call site use adject insid make distinct pa ramet node introduc later paper 2 possibl increas precis analyi track one level heap refer similar 8 3 analysi may analyz recurs method multipl time reach xed point figur 1 node abstract figur present summari node abstract use follow notat inod denot set insid node pnode denot set paramet node node denot set node analyz method analysi scope method method transit invok insid node model object alloc scope n lb denot insid node associ alloc site label lb superscript stand insid free variabl n lb repres object alloc label lb current analyz scope paramet node model object receiv argument paramet node n p model object current analyz method receiv ith argument object type 4 analysi two step one analysi rst analysi comput object live alloc site call instruct 5 second analysi use live inform comput incompat pair formul analys system set inclus constraint use bottomup iter xedpoint algorithm comput least set inclus solut constraint given program number node bound number object alloc site number paramet henc constraint mono tonic xed point comput guarante termin rest section organ follow section 21 describ execut analysi small exampl section 22 present program represent analysi oper section 23 describ object live analysi section 24 describ use object live inform comput incompat pair section 25 discuss appli techniqu multithread program 21 exampl consid java code figur 2 program creat link list contain integ 0 9 remov list element satisfi specic condit even number case print string represent remain list program contain six line alloc object two iter line 3a 3b alloc librari code alloc site four line alloc object directli execut new instruct sake simplic ignor object alloc librari exam ple insid node node n 1 repres link list alloc line 1 node n 2 repres integ alloc line 2 etc iter line 3a 3b repres node n 3 alloc site figur 3 present incompat graph exampl 4 ie primit type int char etc 5 object live analysi abl nd live node program point howev ecienc reason produc analysi result relev statement static void mainstr arg static list createlistint size 1 list list new linkedlist 2 integ listaddv return list static void filterlistlist l static string listtostringlist l 4 stringbuff buffer new stringbuff bufferappendvappend 5 return new stringbuff figur 2 exampl code analysi process method bottomup fash ion start leav call graph librari method linkedlistadd shown figur 2 caus paramet node n p 1 paramet escap heap address store list cell createlist call add n 2 argument therefor analysi instanti 2 n 2 detect n escap filterlist paramet node n p list escap heap listiter store refer underli list iter creat listtostr method n 4 live call listiter alloc n point local variabl buffer live call therefor n 4 incompat n 3 n 4 live line 5 n 4 also incompat n 5 n 3 live n figur 3 incompat graph code figur 2 circl repres insid node doubl circl indic node escap heap 3 n 5 compat unitari node name format inform semant local variabl anoth new c creat one object class c creat heap refer return return v normal return method throw throw v except return method node join point figur 4 instruct relev analysi line 5 n 3 n 5 still compat paramet node n p list live line 4 3b 5 therefor n p 1 incompat n 4 n 3 analysi main detect l point n createlist return n paramet filterlist escap heap analysi detect n escap process call listtostr analysi instanti 1 n 1 discov incompat pair hn 4 analysi alreadi determin n escap heap unitari node gener last two incompat pair pure expositori purpos graph color algorithm color n 3 n 5 color mean two iter string alloc program properti two live time henc compil static alloc object memori space 22 program represent work context static compil compil entir code applic applic deploy execut compil provid full ec tive access class emul dynam load class precompil execut support dynam load class unknown compil compil time approach accept class target applic real time softwar embed devic memori consumpt analysi particularli import analyz program consist set method distinguish main method method repres control ow graph cfgm vertic cfgm label instruct compos ms bodi edg repres ow control insid method local variabl var set local variabl method paramet figur 4 contain instruct relev analysi assum analyz program alreadi convert singl static inform ssi form 4 extens static singl assign explain dierenc later sec tion intermedi represent model creation propag except explicitli instruct might gener except preced test except situat detect eg null pointer deref erenc intermedi represent follow java convent alloc initi except ob ject eg nullpointerexcept propag except appropri catch block throw except method block exist notic due semant java program lan guag instruct throw except also potenti object alloc site moreov except object rst class object except caught refer store heap pass argument invok method practic appli optim method contain singl alloc site automat insert except exampl nullpointerexcept arrayindexoutofboundsexcept method may gener catch method detect except jump alloc site alloc except object execut except return method allow interprocedur propag except call instruct label lb two successor normal termin method case except thrown invok method case local gener except except thrown invok method control pass appropri catch block block determin success instanceof test applic block exist except propag caller current method throw instruct throw v unlik throw instruct java languag throw instruct intermedi represent alway termin execut current method note check except subclass javalangerror 6 signic restrict work context static compil know entir code class hierarchi error rais program compil success system eg virtualmachineerror nosuchfielderror etc program rais one rest error eg outofmemoryerror abort case intend behavior particular none benchmark catch kind except next present inform semant instruct figur 4 copi instruct copi 6 java languag except correspond sever error virtual machin program expect handl valu local variabl v1 local variabl v2 phi instruct ssa node appear join point control ow graph ensur use local variabl exactli one reach de nition control arriv phi instruct ith incom edg v copi v new instruct new c alloc new object class c store refer local variabl v call instruct hvn call method name mn object point v1 argument execut invok method termin return instruct return v address return object store vn control ow goe succn lb lb label call instruct otherwis ie except thrown invok method address except object store control ow goe succ lb typeswitch instruct hv1 c correspond java instanceof test check whether class object point v subclass c v split two variabl v1 vs restrict true branch v2 vs restrict fals branch therefor object point v1 instanc c object point v2 typeswitch instruct simpl exampl ssi sigma node v ssi form introduc preserv ow sensit inform acquir test instruc tion ssi thu allow eleg construct predic data ow analys apart variabl split ssi similar ssa form particular ssi convers seem requir linear time practic 4 final store instruct v1 set eld f object referenc v1 point object referenc v2 instruct irrelev analysi particular track heap refer analysi gain addit inform analyz instruct read refer memori howev analyz store instruct need identifi object escap heap assum precomput call label lb correspond call instruct calleeslb set method call instruct may invok analysi work conserv approxim runtim call graph implement use simpli version cartesian product algorithm 1 23 object live analysi consid method labelprogram point lb insid let livelb denot set insid paramet node live lb conserv consid node live lb point one variabl live point v live lb p v p v set node v may point interpret result need comput set eg insid node escap heap execut 7 sake simplic present analysi consid instanc method java term nonstat method ie v1 argument implement handl instanc method static method program abl process call also comput set node normal return rn set except thrown set paramet node may escap heap execut em formal analysi comput follow mathemat object eg inod formul analysi set inclus constraint problem figur 5 present constraint gener method begin method p point paramet node n p copi instruct set v1 point node v2 point accordingli analysi gener constraint p case phi instruct similar new instruct label lb v new c make v point insid node n lb attach alloc site constraint gener return throw add node rn spectiv store instruct v1 caus node point v2 escap heap accordingli node p v2 distribut eg insid node em paramet node typeswitch instruct hv1 v2 c work type lter v1 point node p v may repres object type subtyp c v2 point node p v may repres object type subtyp c figur 5 denot set subtyp ie java sub class c includ c precis determin type typen insid node n lb 0 examin new instruct label lb 0 therefor precis distribut insid node p v1 p v2 know exact type object repres paramet node conserv put node set 9 call instruct hvn vn point node may return invok method possibl calle 2 calleeslb includ node rn p vn note rn parameter result therefor instanti rn use replac paramet node n p node correspond argument v point ie node p v case analog execut invok method may also caus node pass argument escap heap accord ingli analysi gener constraint instanti set em use node result set emhp v1 updat eg em formal gener denit previous mention instanti oper node set contain paramet node n p necessarili 8 use ssi form denit v1 therefor lose precis use instead 9 better solut would consid declar type cp correspond paramet check cp c least one common subtyp method entri p p paramet return return v rn p v throw throw v p v rn mhp v1 let em pnode eg inod typeswitch denot set subclass class c figur 5 constraint object live analysi method comput rn em p v variabl v live relev label also comput set eg insid node escap heap 24 comput incompat pair comput object live inform complet analysi comput global set pair incompat alloc site incg inod inod 10 analysi use set incompat alloc site detect unitari alloc site construct compat class figur 6 present constraint use comput incg alloc site label lb incompat alloc site whose correspond node live lb howev node livelb may paramet node gener incompat pair directli instead method analysi collect incompat pair involv one paramet node set parametr incompat parincm instanti set call similar way instanti recal biject insid node alloc site set node ith argument sent might point notic may contain paramet node caller howev point call graph incompat pair involv insid node pass incg simplifi equat figur 6 method comput entir set incompat pair allincm allincm comput pair contain insid node put global set incompat incg pair contain paramet node put parincm implement algorithm perform separ soon incompat pair gener without need allincm case call instruct two kind incompat pair alreadi mention rst kind pair obtain instanti parincm 8m 2 calleeslb addit node live call ie call incompat node correspond alloc site invok method increas precis treat normal new c livelb fn lb g allincm livelb livesuccn lb allincm livelb livesucc lb ae allincm allincm inod inod incg allincm n inod inod parincm figur constraint comput set incompat pair instruct label lb method condit gener constraint new c lb return n figur 7 constraint comput ae relev instruct condit second column satis correspond constraint third column gener except exit invok method separ let inod set insid node repres object may alloc method execut return normal similarli let ae inod set insid node repres object may alloc invoc return except describ later comput set moment suppos analysi comput start gener incompat pair let succn lb successor correspond normal return call instruct label lb node livelb livesuccn lb incompat node similar relat hold ae comput ae given label lb code method dene predic lb return true path cfgm lb return instruct ie instruct label lb may execut invoc return normal analog dene throw true path lb throw instruct comput predic easi graph reachabl problem method contain insid node n lb correspond new instruct label lb lb return addi tion call instruct label lb code add node possibl calle analog comput ae similar figur 7 formal present constraint comput set ae 25 multithread applic far present analysi context singlethread applic multithread appli cation analysi need examin method transit call main method run method thread may start addit node correspond start thread need mark escap node rest analysi unchang java thread repres thread object alloc heap object escap one thread access anoth must reachabl either thread object static class variabl global variabl call static class variabl java case analysi determin correspond alloc site unitari therefor object alloc unitari alloc site local thread creat escap thread although know two object alloc thread unitari site live given moment multipl live object alloc site dierent thread henc group compat unitari site need alloc one memori slot per thread instead one per program compil gener code time program start new thread prealloc memori space unitari alloc site may execut thread unitari alloc site compil gener code retriev current thread use prealloc memori space unitari site current thread thread termin execut dealloc prealloc memori space threadloc object use space dealloc creat dangl refer bound memori space occupi unitari alloc site need bound number thread simultan execut program given time 26 optim singlethread program previou section consid node escap heap incompat node includ equival consid node live entir program gain addit precis consid node escap live rest program enhanc allow us prealloc even object escap heap alloc site execut section present chang analysi appli idea longer use global set eg instead label lb elb node denot set node instruct label lb may store refer heap set relev label correspond store call call repres node escap execut invok method extend set object live label lb method includ object escap instruct label lb reach lb cfgm livelb v live lb p v chang constraint figur 5 follow store instruct v1 constraint elb gener constraint p vn p addit constraint rule store call longer gener constraint eg unus em instead dene em lb elb em pnode denot set node paramet node also insid node escap heap execut rest analysi unchang new denit livelb ensur node escap heap program point incompat node live futur program point notic object alloc unitari site longer guarante thread local appli prealloc optim describ end section 25 therefor use version analysi singl thread program 3 experiment result implement analysi includ optim section 26 mit flex compil system 3 also implement compil transform memori prealloc compil gener execut properti unitari site use prealloc memori space instead call memori alloc primit memori site prealloc begin program implement current support multithread program describ section 25 measur eectiv analysi use nd unitari alloc site set java program obtain result pentium 4 28ghz system 2gb memori run redhat linux 73 ran compil analysi use sun jdk 141 hotspot mix mode compil gener nativ execut ran machin tabl 1 present descript program benchmark suit analyz program specjvm98 benchmark suit 11 java version olden benchmark suit 12 11 addit analyz jlex javacup 205 raytrac tabl present sever statist indic size benchmark analysi time statist refer user code plu librari method call user code data tabl 2 indic gener time requir perform analysi order magnitud time requir build intermedi represent program except 202 jess 213 javac tabl 3 present number total alloc site unitari alloc site program result show analysi usual abl identifi major site unitari site 14065 alloc site benchmark analysi abl classifi 8396 60 unitari site twelv twenti benchmark analysi abl recogn 80 alloc site unitari tabl 3 also present result alloc site alloc except ie subclass javalangthrow nonexcept rest ob ject javalangstringbu special case non except categori present total number alloc site kind proport site unitari major unitari alloc site benchmark alloc except string buer object 9660 total except alloc site benchmark analysi abl recogn 6602 68 unitari site thirteen twenti benchmark analysi abl recogn 90 except alloc site unitari site 1293 string buer alloc site analysi abl recogn 1190 92 unitari site eight benchmark analysi abl recogn 95 string buer alloc site unitari site tabl 4 present size static prealloc memori area use store object creat unitari alloc site second column tabl present result case unitari alloc site prealloc memori chunk describ introduct paper decreas prealloc memori size signicantli use graph color algorithm allow compat unitari alloc site share prealloc memori area third column tabl present result case compil optim alway use graph color algorithm provid second column comparison purpos 11 except 227 mtrt multithread applic descript specjvm98 benchmark set 200 check simpl program test jvm featur compress file compress tool jess expert system shell 209 db databas applic 213 javac jdk 102 java compil 222 mpegaudio audio le decompress tool 228 jack java parser gener java olden benchmark set bh barneshut nbodi solver bisort biton sort em3d model propag electromagnet wave three dimension object health simul healthcar system mst comput minimum span tree graph use bentley algorithm perimet comput perimet region binari imag repres quadtre power maxim econom ecienc commun power consum tsp solv travel salesman problem use random algorithm treeadd recurs depthrst travers tree sum node valu voronoi comput voronoi diagram random set point miscellan raytrac singl thread raytrac ocial part specjvm98 jlex java lexer gener javacup java parser gener tabl 1 analyz applic applic analyz method bytecod instr size instr ssi convers time analysi time 200 check 208 7962 10353 11 41 compress 314 8343 11869 12 74 jess 1048 31061 44746 53 1012 222 mpegaudio 511 18041 30884 52 159 228 jack 618 23864 37253 116 556 bisort 123 5157 6615 12 29 em3d 142 5519 7497 09 31 health 141 5803 7561 09 32 mst 139 5228 6874 12 30 perimet 144 5401 6904 12 27 power 135 6039 7928 10 32 treeadd 112 4814 6240 08 28 voronoi 274 8072 10969 18 43 raytrac 498 14116 20875 42 230 jlex 482 22306 31354 40 123 javacup 769 27977 41308 58 320 tabl 2 analyz code size analysi time applic alloc unitari site except nonexcept stringbuer site count total unitari total unitari total unitari 200 check 407 326 80 273 92 134 57 44 97 compress 489 155 32 390 28 99 44 38 97 jess 1823 919 50 1130 58 693 38 233 84 222 mpegaudio 825 390 47 625 55 200 24 43 97 228 jack 910 479 53 612 54 298 50 135 99 bisort 234 198 85 177 97 57 47 17 94 em3d 276 235 85 206 98 70 50 20 95 health 276 227 82 202 97 74 42 17 94 mst 257 216 85 194 97 63 44 perimet power 262 213 81 192 97 70 39 15 93 treeadd 227 190 84 170 96 57 46 15 93 voronoi 448 387 86 349 98 99 44 28 96 raytrac 753 318 42 525 44 228 39 43 95 jlex 971 812 84 645 99 326 54 72 86 total 14065 8396 60 9660 68 4405 41 1293 92 tabl 3 unitari site analysi result prealloc memori size applic size byte reduct normal share 200 check 5516 196 96 compress 2676 144 95 jess 17000 840 96 222 mpegaudio 6452 104 98 228 jack 8344 224 97 bh 4604 224 95 bisort 3252 96 98 em3d 3860 200 95 health 3716 96 97 mst 3532 96 97 perimet power 3540 196 94 treeadd 3120 92 98 raytrac 5656 644 89 jlex 13996 1676 88 javacup 20540 1180 94 total 143088 6984 95 tabl 4 prealloc memori size graph color algorithm nd approxim smallest number color two incompat alloc site color color prealloc memori area whose size maximum size class alloc alloc site color implement use dsatur graph color heurist 10 import notic dsatur heurist minim number color nal total size prealloc memori howev appear signic neg eect result number tabl 4 show abl reduc prealloc memori size least 88 case averag reduct 95 theoret prealloc optim may alloc memori origin program prealloc memori area set compat alloc site reserv area entir lifetim program even object alloc attach set compat site reachabl extrem case repres memori area prealloc alloc site program never execut howev data tabl 4 indic practic amount prealloc memori analyz applic quit small compil benchmark memori prealloc optim enabl optim execut n ish normal produc result unoptim version execut specjvm98 olden applic default workload ran jlex javacup lexer parser le compil frastructur instrument alloc site measur mani object alloc program mani object use prealloc memori applic total prealloc object object count 200 check 725 238 33 compress 941 108 11 jess 7917932 3275 0 222 mpegaudio 1189 7 1 228 jack 6857090 409939 6 bh 15115028 7257600 48 bisort 131128 15 0 em3d 16061 23 0 health 1196846 681872 57 mst 2099256 1038 0 perimet power 783439 12 0 treeadd 1048620 13 0 raytrac 6350085 4080258 64 jlex 1419852 12926 1 javacup 100026 16517 17 tabl 5 prealloc object tabl 5 present result measur benchmark least one third object resid prealloc memori correl static number unitari site dynam number object alloc site explain larg dierenc number time dierent alloc site execut gener applicationspec detail tend factor determin dynam number exampl jlex 95 object iter alloc nonunitari alloc site 213 javac javacup use mani stringbuer prealloc 205 raytrac bh use mani temporari object repres mathemat vector etc 4 relat work paper present knowledg rst use pointer analysi enabl static object prealloc research use pointer andor escap analys improv memori manag java program 14 20 7 algorithm focu alloc object call stack research also develop algorithm correl lifetim object lifetim invok method use inform alloc object dierent region 19 goal elimin garbag collect overhead atom dealloc object alloc given region correspond function return research 17 requir programm provid annot via rich type system specifi region object alloc bogda hoelzl 8 use pointer analysi elimin unnecessari synchron java program spite dierent goal pointer analysi mani technic similar analysi analys avoid maintain precis inform object place deep heap bogda hoelzl analysi precis stack alloc object reachabl singl level heap refer analysi attempt maintain precis pointsto inform object reachabl heap hand analysi precis comput live rang object treat except precis particular found predic analysi type switch take type referenc object account necessari give analysi enough precis static prealloc except object analysi aggress aim escap anal ysi escap analysi typic use infer lifetim object alloc specic alloc site contain within lifetim either method alloc one method transit invok alloc method compil transform alloc site alloc object method stack frame instead heap notic analysi provid bound number object alloc alloc site presenc recurs loop may arbitrari number live object singl alloc site arbitrari number object alloc call stack contrast analysi identifi alloc site properti one object live given time addit stack alloc transform may requir compil lift correspond object alloc site method origin contain one transit caller origin alloc method 20 object would pass refer call stack incur runtim overhead 12 static prealloc optim enabl analysi suer drawback compil transform origin alloc site simpli acquir pointer static alloc memori need move alloc site caller origin alloc method combin live incompat analysi use graph color minim amount memori requir store object alloc unitari alloc site similar spirit regist alloc algorithm 6 chapter 11 howev regist alloc algorithm concern live local variabl comput simpl intraprocedur analysi found obtain use live result dynam alloc object signicantli dicult particular found use predic analysi track ow object across procedur boundari identifi signic amount unitari site 5 conclus present analysi design simplifi comput accur upper bound amount memori requir execut program analysi static prealloc memori store object alloc unitari alloc site enabl object alloc compat unitari alloc site share prealloc memori experiment result show set java benchmark program 60 alloc site unitari static prealloc allow compat unitari alloc site share semant equival altern perform method inlin howev inlin introduc set overhead prealloc memori lead 95 reduct amount memori requir site base set result believ analysi automat eectiv elimin need consid mani object alloc site comput accur upper bound amount memori requir execut program also use analysi optim memori manag 6 acknowledg would like thank we beebe scott c ananian use advic implement prealloc optim mit flex compil system 3 viktor kuncak proofread earli draft paper also want thank anonym refere valuabl comment 7 r cartesian product algorithm mit flex compil infrastructur java static singl inform form program analysi special c program languag modern compil implement java escap analysi object orient languag remov unnecessari synchron java realtim speci cation java daniel br data ow analysi softwar prefetch link data structur java softwar cach comput migrat olden analysi pointer structur static determin memori consumpt realtim java thread region infer algorithm composit pointer escap analysi java program tr compil principl techniqu tool analysi pointer structur effici comput static singl assign form control depend graph softwar cach comput migrat olden pointsto analysi almost linear time modern compil implement java region infer algorithm escap analysi java escap analysi objectori languag remov unnecessari synchron java composit pointer escap analysi java program new method color vertic graph regionbas memori manag cyclon data flow analysi softwar prefetch link data structur java cartesian product algorithm ctr oukseh lee kwangkeun yi experi effect automat insert memori reus mllike program proceed 4th intern symposium memori manag octob 2425 2004 vancouv bc canada oukseh lee hongseok yang kwangkeun yi static insert safe effect memori reus command mllike program scienc comput program v58 n12 p141178 octob 2005 samuel z guyer kathryn mckinley daniel frampton freem static analysi automat individu object reclam acm sigplan notic v41 n6 june 2006 darko marinov robert ocallahan object equal profil acm sigplan notic v38 n11 novemb chandrasekhar boyapati alexandru salcianu william beebe jr martin rinard ownership type safe regionbas memori manag realtim java acm sigplan notic v38 n5 may