effici algorithm detect restor minim extens regular restrict resolut given binari resolut proof repres binari tree said iminim resolut reorder gener irregular proof minim extend tseitin regular restrict still retain complet lineartim algorithm introduc decid whether given proof minim algorithm use deduct system avoid redund retain minim proof thu lessen relianc subsumpt gener expens techniqueani irregular binari resolut tree made strictli smaller oper call isurgeri run time linear size tree surgeri result prove new tree nonstrictli gener origin result fewer violat regular restrict furthermor nonminim tree made irregular linear time oper call isplay thu combin splay surgeri effici reduc nonminim tree minim onefin close correspond claus tree recent introduc author binari resolut tree establish sens work provid first lineartim algorithm detect minim perform surgeri claus tree b introduct regular restrict binari resolut 14 state resolut step resolv given liter use deduc claus contain liter word resolut step ancestor claus binari deriv tree extend restrict appli also reorder resolut bring claus step use rotat edg binari tree reorder resolut step requir rotat neither weaken prove increas size tree binari resolut proof made irregular rotat call minim extens regular depend sequenc rotat thu appear expens comput howev character condit check effici examin static tree condit state term histori path binari resolut tree histori path tell stori given liter tail histori path leaf tree tell liter introduc input claus histori path said close node liter resolv away one histori path close node occur anoth histori path two path disjoint say first histori path directli preced preced relat histori path reflex transit closur directli preced histori path preced relat basic understand binari resolut tree behav rotat perform provid simpl condit histori path character one node rotat anoth say visibl one node rotat anoth say support examin histori path static tree decid much accomplish sequenc rotat particular say whether rotat convert regular tree irregular one theorem prover use abil screen proof build retain minim one sinc everi claus nonminim proof subsum claus minim proof theorem prover use minim lessen relianc sub sumption runtim full subsumpt grow number retain claus may becom larg detect minim depend linearli size proof tree typic much smaller instead use minim simpli filter theorem prover convert nonminim proof minim one use oper defin paper consid branch irregular deriv tree make irregular branch contain node given liter resolv contain claus liter occur resolv liter away reappear later remov resolut otherwis reconstruct branch close possibl origin liter appear addit claus construct tree smaller result prove least gener origin one call oper surgeri defin second oper splay rearrang nonminim tree irregular oper run time linear size tree combin oper eventu reduc nonminim tree minim one first section present regular restrict binari resolut tree section introduc surgeri oper irregular binari resolut tree minim binari resolut tree introduc section also discuss rotat set rotat equival tree tree gener given tree sequenc rotat follow sec tion discuss preced relat histori path use defin hold relat node relat hold visibl show nearest common descend two given node hold one one seen ie rotat base condit give effici algorithm decid visibl show theorem prover restrict retain minim proof disregard nonminim one decreas number proof must consid show splay oper effici convert nonminim proof irregular one surgeri convert minim one thu anoth theorem prover effici convert nonminim result minim one desir next section use histori path character support condit one node binari resolut tree must descend anoth sequenc rotat minim surgeri first develop claus tree 5 claus tree tool develop idea autom reason binari resolut tree effici compact data structur implement claus tree second last section show close relat binari resolut tree claus tree thu paper provid first effici algorithm surgeri claus tree close remark relat claus tree binari resolut tree relat work paper extens 13 2 binari resolut tree use standard definit 2 atom liter substitut unifi gener unifi follow claus unord disjunct liter use set notat want multipl occurr liter collaps singl liter automat ical thu claus view multiset atom occur claus c either one disjunct claus claus c subsum claus exist substitut c set multiset variabl renam substitut one everi replac variabl map anoth variabl two variabl map variabl two claus c equal variabl renam exist variabl renam substitut two claus standard apart variabl occur given two parent claus standard apart variabl renam substitut may requir resolv claus c 1 c 2 gener unifi g atom resolv upon 1 set resolv liter g conveni defin map ae liter resolut oper use later defin histori path resolut map resolut oper defin resolut map ae occurr liter c parent claus either atom resolv upon c resolv liter otherwis occurr c resolv reader may miss usual factor oper claus consist appli substitut unifi two liter sign remov one liter oper need binari resolut tree howev sinc claus contain two ident unifi liter resolv upon whenev claus use resolut allow sever liter resolv instead merg resolu tion one type intern node binari resolut tree instead two de nivel use resolut node factor node 3 moreov implement free merg factor liter desir factor may seen optim factor claus use sever resolut step sinc factor done binari resolut deriv commonli repres binari tree drawn root bottom edg join parent node drawn edg child node drawn ancestor descend node defin reflex transit closur parent child relat proper ancestor proper descend node ancestor descend equal node h node tree patht h uniqu path h call tail h head definit 2 binari resolut tree set input claus label binari tree node n tree label claus label denot cln node either two parent claus label result resolut oper claus label parent parent label instanc input claus case resolut atom resolv upon use anoth label node atom label denot aln substitut gener resolut appli label tree claus label root binari resolut tree call result tree resultt binari resolut tree close result empti claus 2 ad abd dbce ebcfg ca bbfg bbfg bfg abe cd efg abc ha b g ah h figur 1 irregular binari resolut tree binari resolut tree figur 1 gg label node n display besid name node separ colon eg node n 4 atom label c claus label b b f g order parent node defin instead label intern node atom one label edg complement liter resolv upon binari resolut tree would becom semant tree leav binari resolut tree would becom failur node semant tree use resolut map ae resolut oper tree trace happen liter occurr claus label leaf tree resolv away clearli liter eventu map atom label intern node claus label root empti case sound resolut claus label leav b ad dac caab ab cd abc b ah h figur 2 surgeri oper 5 figur 1 unsatisfi set thu primarili concern trace histori liter start appear leaf definit 3 histori path let node n occur binari resolut tree n 0 leaf whose claus label contain liter parent n let ae resolut map parent n n let occur cln suppos n n either root child n ae map resolut n atom resolv upon n n histori path histori path said close n n exist n written closep node n n head leaf n 0 tail liter p written headp tailp literalp respect exampl figur 1 c close n 4 two histori path b figur 1 correspond two occurr b 3 close n 6 close one f definit 4 regular binari resolut tree regular exist node n descend n aln occur clm tree figur 1 irregular aln 1 occur cln 4 irregular tree never necessari resolv away twice one could choos leav resolut n 1 leav claus resolut necessari necessari later resolv away done n 5 oper 5 make idea formal new binari resolut tree 0 construct 0 ancestor possibl remov howev leav 0 also leav thu everi histori path 0 correspond histori path convers true sinc histori path 0 exist 0 new sequenc n 0 n defin either n 0 remov n 0 correspond n oper 5 surgeri irregular tree let irregular binari resolut tree path node n 1 root n n first node path whose claus label contain let n igamma1 igamma1 parent n parent occur claus label n 0 sign cln procedur ancestor n 0 0 0 ancestor remov let n k node histori path p n j close k exist histori path 0 contain n 0 correspond histori path close n put igamma1 ancestor 0 new node 0 child n 0 let resolut n 0 defin histori path close n 0 correspond histori path close let histori path correspond p also close n 0 k liter far possibl resolv n 0 n one possibl addit els histori path contain n 0 correspond path close n igamma1 ancestor remov endif endfor note occurr n j never resolv away ie histori path continu root two liter correspond may occur root 0 howev least gener figur 2 show effect surgeri figur 1 surgeri perform use n 4 n j need 0 insist occurr close node ensur result thu n 0 5 close histori path n 0 theorem 6 let irregular binari resolut tree set claus 0 construct oper 5 0 also binari resolut tree 0 smaller result 0 subsum result proof use follow lemma claus c 1 c resolv give claus c 2 subsum c 1 either resolut c 2 c possibl c 2 subsum r 1 possibl result assum liter c resolv first resolut also resolv second furthermor liter c 2 resolv second resolut correspond subsumpt liter c 1 resolv first resolut leaf 0 label leaf therefor 0 defin also intern node defin resolut parent 0 binari resolut tree note cln 0 subsum cln 1 cln 1 contain liter cln 0 except possibl use repeat applic lemma follow cln 0 cln j sinc occur cln j cln 0 result 0 subsum sinc 0 0 sinc node 0 taken follow 0 fewer node 2 theorem 7 complet 14 unsatisfi exist close regular binari resolut tree furthermor smallest close binari resolut tree regular proof unsatisfi exist close binari resolut tree 11 irregular appli oper 5 repeatedli regular process must termin sinc tree smaller step smallest close binari resolut tree regular surgeri appli make smaller close tree 2 figur 3 binari tree rotat 3 minim binari resolut tree rotat edg binari tree common oper exampl avl tree 1 appli binari resolut tree review oper binari tree given binari tree fragment left figur 3 rotat reassign edg tree right figur 3 produc parent c becom child e parent b c becom parent e e child c take child 0 word edg b c c e e f exist replac edg b e e c c f necessari oper 8 edg rotat let binari resolut tree edg c e intern node c parent e c two parent b suppos histori path close e result rotat edg binari resolut tree 0 defin resolv clb cld ale give cle 0 resolv cle cla alc give clc 0 histori path close c close c similarli histori path close e close e 0 also child e exist child c 0 rotat may introduc tautolog claus label intern node instanc alc occur cld cle 0 may tautolog howev claus label root chang corollari 11 prove slightli gener result first also use later definit 9 let 1 2 two binari resolut tree defin set input claus 1 2 close histori path similarli onetoon onto map node 1 2 1 n leaf n leaf label instanc input claus thu natur one one cor respond liter cln cln moreov map liter provid map histori path 1 2 defin start liter input claus variabl renam repres two map also requir histori path p 1 tailp variabl renam 2 everi histori path p 1 p close node n close n thu two binari resolut tree close histori path similarli resolv liter albeit possibl differ order lemma 10 two binari resolut tree 1 2 close histori path similarli result 1 result 2 variabl renam proof note resultt 1 resultt 2 compos entir liter histori path close sinc histori path close liter resolv away also composit mgu 1 2 uniqu variabl renam sinc given node n liter unifi n n variabl renam 2 corollari 11 given binari resolut tree intern node c child e oper 8 gener new binari resolut tree cle variabl renam proof observ oper 8 produc tree close histori path similarli 2 rotat chang order two resolut tree rotat invert rotat histori path close c anoth rotat e c done gener origin tree say two binari resolut tree rotat equival one gener sequenc rotat instanc first binari resolut tree figur 4 produc rotat edg n 4 n 5 figur 1 second tree figur 4 figur 1 rotat figur 4 produc rotat edg 4 n 5 thu tree rotat equival figur 1 rotat equival equival relat surpris rotat equival binari resolut tree must close histori path similarli convers true well theorem 12 two binari resolut tree 1 2 rotat equival close histori path similarli proof sinc one rotat 1 creat binari resolut tree close histori path similarli sequenc rotat creat 2 convers prove induct number intern node suppos 1 2 close histori path similarli must number n intern node sinc number leav rotat possibl theorem hold let n node 1 parent l 1 l 2 leav 2 n proper ancestor l 1 l 2 also leav n close histori path tail l 1 l 2 creat 0 2 rotat edg l 1 l 2 parent n alreadi case let c either parent n let b parent c l 1 l 2 ancestor c neither ancestor parent n n must close histori path parent contradict thu edg c n rotat sinc b contain histori path close n rotat reduc total number nonleaf ancestor n finit number rotat parent n leav call tree 0 let 1 1 leav l 1 l 2 delet let 2 0 2 leav close histori path similarli sinc 1 0 close histori path similarli induct rotat equival sequenc rotat convert 1 also convert 1 0 2 rotat equival 2 focu set rotat equival tree contain irregular binari resolut tree tree set said minim sinc surgeri appli make smaller definit 13 binari resolut tree minim sequenc rotat edg gener tree 0 irregular theorem 14 binari resolut tree nonminim exist minim binari resolut tree 0 smaller result 0 subsum result proof minim appli oper 8 oper 5 regular tree produc tree minim let 0 tree otherwis repeat begin 0 defin process must termin tree get smaller applic oper 5 also old result subsum new result step 2 thu smallest binari resolut tree minim goerdt shown 4 smallest regular binari resolut direct acycl graph dag may exponenti larger irregular binari resolut dag thu consid regular minim binari resolut dag theorem prover may find smallest proof henc may requir infer prove given theorem howev case believ space minim binari resolut dag much smaller space binari resolut dag consider time save restrict minim one similar argument made restrict resolut includ setofsupport hyperresolut 4 check minim determin whether given binari resolut tree minim seem labouri sinc straightforward applic definit done proof theorem 14 check everi possibl sequenc rotat exponenti mani section give effici algorithm determin visibl node rotat decid minim effici definit 15 visibl given binari resolut tree intern node n say visibl n n see exist sequenc rotat descend n otherwis invis n thu node see node rotat although properti defin term rotat possibl inspect static tree without rotat determin visibl visibl comput linear time static properti hold defin one concept preced definit directli preced histori path q p q node common p close node q write p oe q moreov say p preced q sequenc histori path p directli preced p i1 histori path p preced node n n close histori path q p oe q preced relat reflex transit closur directli preced particular histori path preced even though directli preced also note preced defin partial order set histori path case rotat chang preced relat histori path lemma 17 let histori path p preced histori path q binari resolut tree let p imag respect rotat edg c e definit 8 suppos head q c p 0 preced q 0 proof let td subtre root b c respect closep headq one subtre rotat effect whether p q know headq proper descend closep also headq c headq must descend e tailp tailq subtre rotat affect p oe q node q p preced also subtre let p 1 path close node thu p oe p 1 oe q case illustr figur 5 1 tailq tailp close c rotat 1 one node longer close c 0 p 0 oe otherwis tailp td let p 0 denot path b close c rotat p 0 oe p 0 2 tailq tb tailp rotat p 0 oe otherwis tailp td rotat p 0 oe p 0 3 tailq td sinc path close e know tailp thu tailp tb rotat directli hold intern node binari resolut tree first node occur p 1 q 1 ie parent occur say p q hold exist histori path p 1 directli hold node n hold p q hold p q close n also p q hold set histori path say set hold follow theorem relat invis properti depend rotat equival tree held properti check examin one tree interest figur 5 case lemma 17 theorem 19 nearest common descend n hold invis n proof show nearest common descend hold rotat possibl new nearest common descend n hold thu never descend n nearest common descend would node hold case proof forward direct figur 6 let f nearest common descend n let rotat edg c e let node b adjac defin oper 8 let p q hold close f p 1 directli hold p 1 oe p q 1 oe q consid case f 6 e rotat f still nearest common descend n lemma 17 p 0 suppos 6 e rotat still first common node p 0 1 f still hold suppos without loss gener assum p 1 contain c q 1 contain case 1a p 1 contain b rotat p 0 hold e f hold case 1b p 1 contain consid path close c rotat p 0 p 0 hold e f hold suppos consid case case 2 ancestor c n either e ancestor sinc histori path contain c close e 6 c reason p q contain b close e case 2a ancestor path directli preced p q close c hold thu c hold rotat nearest common descend n c c still hold case 2b otherwis ancestor b rotat nearest common descend n e e still hold final consid case case ancestor case 3a n either e ancestor b rotat hold still nearest common descend n case 3b n c ancestor consid path r head b close c rotat nearest common descend n c r 0 directli preced rotat convers suppos held nearest common descend f n descend n therefor visibl f child edg rotat make descend f therefor n assum exist path n case 3a case r r q q q case case 1a case r r case 2a figur 6 case theorem 19 n igamma1 k igamma1 parent n use induct n without loss gener n 0 chosen aln 2 occur cln 0 thu histori path n 0 close n 2 exist ng histori path n igamma2 close n edg n rotat shown rotat 1 figur 7 say n rotat side pathm f closer f theorem hold induct thu path n igamma2 close n j ng n j held f particular n ngamma1 held edg n rotat distanc nearest common descend n theorem hold induct choos smallest j ng n j held f note j 6 1 assumpt histori path k j gamma2 close n j path path n j gamma2 close n j directli hold thu held f contradict definit j therefor path k j gamma2 exist edg rotat illustr rotat 2 figur 7 closer f rotat say n j rotat top pathm f theorem hold induct otherwis consid histori path n j gamma2 close n j one includ anoth includ k j gamma3 n j gamma2 held f rotat mean n j gamma2 held f rotat contradict definit j thu edg n j gamma2 n j rotat result rotat n j rotat either side pathm f closer second induct distanc n j n eventu rotat top side thu distanc f decreas construct sequenc rotat 2 sequenc rotat construct proof theorem 19 rotat visibl node node n see thu tree regular nonminim rotat would make irregular expos nonminim part use surgeri remov nonminim section tree reconstruct minim tree piec left behind unfortun number rotat requir expos non minim may quadrat length path tree sinc tree balanc quadrat size tree worst case later give linear time oper call splay bring visibl node descend next section howev detect avoid nonminim tree rotat 1 side f f rotat 2 top f f figur 7 rotat proof theorem 19 5 minim restrict turn attent theorem prover keep minim binari resolut tree sinc everi nonminim tree subsum minim tree strategi use minim criteria reduc redund lessen relianc subsumpt definit 20 let binari resolut tree atomst falnjn node tgi call set atom subbrt binari resolut tree whose node set consist node call root subbrt ancestor subbrt 0 node 0 visibl root tg call set visibl atom 0 theorem 21 let binari resolut tree consist root node r two subbrt 1 2 minim 1 1 2 minim 2 atom clr atomst 3 4 proof assum minim 1 2 minim would sequenc edgerot would make subbrt irregular sequenc perform would make irregular well henc first condit true second condit fals would irregular immedi assum third condit fals two node whose atom label visibl r henc rotat r without rotat edg 2 descend n make irregular fourth condit symmetr third convers assum minim sequenc rotat creat irregular tree 0 node n descend 1 0 aln occur clm 1 sinc rotat chang clr aln occur result 0 occur clr violat second condit thu aln occur clr descend n n violat first condit assum n differ sinc rotat visibl n theorem 19 held nearest common descend r n thu visibl r therefor alm vist aln atomst 3gammai 2 theorem prover base binari resolut keep minim tree alreadi satisfi first condit theorem 21 newli construct tree sinc minim tree use construct easi check new result contain atom atomst left find easi way calcul atom subbrt visibl root idea procedur 22 node visibl subbrt held root theorem 19 node n need calcul histori path go preced root path go one parent n go n held root otherwis n visibl root procedur call visiblen pn first argument n node tree want know whether held root initi one parent root travers upward becom instanti ancestor parent invari maintain second argument pn set path includ n preced root path parent root preced root simpli whose head parent invari easi establish first place suppos n parent b calcul path pb b preced root start pn remov path go none pb pn path pn need add pb path head b sinc path preced path thu preced root sinc know path pn must go least one parent n assum b parent procedur 22 visibl given node n binari resolut tree set pn histori path preced root tree visn pn return atom label node n visibl root procedur visn pn n leaf return oe let b parent n partit pn pa pb set path go b respect assum without loss gener b chosen pb nonempti let ca cb histori path head b respect pa nonempti n held return els n held visibl return endif third fourth condit theorem 21 requir us calcul done call visr root binari resolut tree r 1 r 2 parent r r set path head r procedur 22 run number set union calcul proport number node tree hash oper principl perform time proport size claus henc vi linear time algorithm fast one could expect implement prototyp theorem prover proposit logic resembl otter9 retain minim binari resolut tree recurs call first condit theorem 21 need wherea proof built otter correspond nonminim tree case implement actual build binari resolut dag instead tree save space import bottomup theorem prover limit space well time note procedur 22 travers entir implicit tree may visit singl store node thu runtim guarante linear size dag prototyp includ anoth restrict discuss 6 ensur set rotat equival binari resolut tree exactli one found 6 restor minim two basic way restor minim binari resolut tree irregular surgeri oper remov non minim binari resolut tree regular nonminim rotat need done make irregular call expos nonminim irregular involv two intern node n resolv upon atom neither descend least one visibl suppos visibl n rotat n one parent becom descend n sinc occur parent claus label surgeri n done proof convers theorem 19 gave quadrat length sequenc oper move visibl node becom descend oper 24 call splay perform linear number rotat relat splay oper 12 binari tree bring node closer root case splay binari resolut tree divid descend two set observ see nonobserv rearrang tree node ancestor leav node descend thu brought close root possibl done way guarante n ancestor surgeri accomplish first step splay determin descend see comput procedur 23 procedur 23 ob given node binari resolut tree p 1 complet set histori path contain one parent p 2 path contain return set proper descend see call observ procedur obsm root return oe els let child k parent let c 1 path p 1 close c 2 path p 2 close let k path contain k hold return els c return fdg obsd k els endif endif invari procedur 23 everi pair path one p 1 p 2 hold ever find descend close member hold see otherwis see maintain invari go close path p need add p path k come k one path preced path contain close path p noth add p either case remov p path close sinc contain oper 24 use code procedur 23 procedur decid resolut reorder new tree parent 1 2 consid stub built upon observ put one two queue q 1 q 2 nonobserv put q 3 along node put queue also put subtre root parent node resolut reconstruct later put q 1 becom descend 1 q 2 becom descend 2 done two subtre join resolut correspond final node q 3 made descend resolut done histori path close node given tree close node construct tree thu result tree close histori path similarli given tree oper 24 splay splay intern node binari resolut tree produc new binari resolut tree 0 descend see 0 oper initi three empti queue initi p 1 set histori path one parent 1 p 2 set histori path parent 2 call splay1m return processq procedur splay1m root return els let child let k parent let c 1 path p 1 close c 2 path p 2 close let k path contain k hold enqueu subtre root k q 3 els c enqueu subtre root k els enqueu subtre root k endif endif resolut must done result binari resolut tree close histori path similari procedur processqt q q empti return els dequeu 1 n q leav q 1 construct 2 resolv 1 make parent n return endif exampl binari resolut tree figur 8 show result perform splay node n 5 second tree figur 4 subtre 1 2 leav label b c h respect descend n 5 4 n 3 n 4 put q 1 4 put q 2 end n 5 result tree nonobserv n 6 put q 3 end n 5 lemma 25 binari resolut tree intern node result 0 splayt binari resolut tree 0 defin set claus size result proof 0 close histori path similarli 2 oper 26 splay surgeri let binari resolut tree contain pair mn node alm aln n see procedur descend n return surgeryn els return endif see splay actual bring n surgeri possibl suppos nearest common descend n thu either n nearest common descend n differ branch n either ancestor k point splay1 also know n see must put one queue q 1 q 2 part q 3 thu tree ad abd dbce ebcfg abe cd efg abc bbf b g bbf g ca bbfg ha ah figur 8 result oper 24 n5 figur 4 rebuilt n put process either q 1 q 2 put q 1 q 2 empti n return exampl splay node n 5 figur 8 n 1 surgeri n 1 done result surgeri shown figur 2 notic exampl also option splay n 1 surgeri n 5 sinc n 1 also visibl n 5 result tree would differ would requir leaf h h result would f thu surgeri alway produc gener result alway produc smaller tree splay surgeri linear number set oper sinc n resolut step n length branch perform surgeri number resolut limit length branch thu effect linear time algorithm 7 support often node visibl anoth rotat descend sometim sequenc rotat bring node anoth case say node support sinc alway beneath support like visib properti depend entir set rotat equival tree section character support term histori path check examin static tree definit 27 support node n binari resolut tree support node everi sequenc rotat ancestor n definit 28 tightli hold two histori path tightli hold node n exist two sequenc histori path directli hold pair head p equal head q j node n tightli hold p q close n tightli hold special case hold two path sequenc head except bottom two turn exact condit one node anoth everi sequenc rotat theorem 29 node n tightli hold n support proof show n tightli hold rotat also afterward thu must descend consid rotat edg c e node b c e defin definit 8 indic imag histori path p rotat p 0 first assum fc eg disjoint fmng rotat head path sequenc distinct must distinct rotat unless new path either sequenc one case new path occur lemma 17 new path introduc tailq case head new histori path pathm n thu head path new sequenc p 0 distinct except headp 0 also still directli held 1 n tightli hold suppos fc eg disjoint fmng case 1 without loss gener let p 1 contain q 1 contain b know p 1 close e sinc rotat possibl suppos first q 1 close e figur 91a rotat c directli held p 0 1 tightli held n suppos q 1 close e figur 91b note must exist q 2 sinc otherwis e hold n q 1 p 1 close rotat possibl cn qm pn qn case 2b case 3a case case 1a case 1b cn pm qn qn case 2a figur 9 case show tightli hold invari rotat case 1 case 2 figur 10 case show support impli tightli hold rotat c directli held p 0 2 still tightli held n case close n either includ figur 92a includ b figur 92b either case rotat n tightli hold sequenc p 0 case assum without loss gener c p 1 q 1 also p 1 figur 93a path head b p 0 oe p 1 rotat sequenc ensur n tightli hold b p 1 figur 93b rotat path p 0 q 0 tightli hold case final either pm q n contain c contain contain c note contain parent b c els rotat possibl rotat b parent e although p 0 one node shorter n tightli hold path p 0 contain rotat chang histori path thu n tightli hold induct length pathm parent n i1 1 parent n rotat edg n possibl unless exist histori path tightli hold close n suppos k 2 first assum case 1 n k support first half theorem n k tightli hold edg n rotat sinc must remain ancestor n must ancestor b rotat shown figur 101 thu path n shorter induct tightli hold new binari resolut tree rotat edg back one see n tightli hold tightli hold invari rotat case cover assum n k support n kgamma1 next assum case 2 n k support n kgamma2 n support n kgamma2 otherwis n k support n kgamma1 support n kgamma2 transit support contradict first half theorem may rotat edg n kgamma2 n kgamma1 may rotat edg n kgamma2 n k sinc n k tightli hold n kgamma2 second rotat n k must remain descend n kgamma1 must shown third binari resolut tree figur 102 thu pathm n shorter induct n tightli hold tightli hold invari rotat n tightli hold also assum n k support n kgamma2 similar argument assum n k support n case edg n 2 rotat pathm n shorter result tree 0 induct n tightli hold 0 sinc tightli hold invari rotat n tightli hold final edg n 2 rotat path parent close n 2 know induct tightli hold n 2 assum p path make assum without loss gener includ q 1 must includ parent n 2 sinc n 2 first node p 1 q 1 common matter parent p 1 path close n 2 contain parent call path q 0 sinc head q 0 distinct head p q j sequenc thu tightli hold path q final theorem relat notion visibl support theorem 30 binari resolut tree node invis node n iff support pathm n proof let nearest common descend n consid path sequenc hold consid least j headp let node p q j close j must exist sinc headpm head path distinct tightli hold thu support sequenc path tightli hold sinc pathm n descend must ancestor nearest common descend n thu path r r 1 r k close thu hold via sequenc 8 relat claus tree result paper develop understood claus tree 5 primarili mean implement claus tree eventu found idea claus tree could express binari resolut tree binari resolut tree simpler way sinc easier implement often claus tree easier use explor new idea particular visibl support read almost directli claus tree wherea properti held tightli held somewhat harder see binari resolut tree use whichev appropri section relat two refer exampl rotat equival binari resolut tree figur 1 4 8 correspond first claus tree figur 11 binari resolut tree figur 2 correspond second claus tree figur 11 reader familiar claus tree note second claus tree figur 11 construct directli first ad merg path atom node surgeri remov subtre beyond tail new merg path correspond binari resolut tree claus tree obviou leav binari resolut tree claus node claus tree label instanc input claus intern node binari resolut tree atom node claus tree histori path binari resolut tree associ liter correspond label edg claus tree also associ liter histori path close correspond edg incid atom node leaf close histori path correspond edg incid close atom node c e f c figur 11 claus tree correspond figur 1 4 8 figur 2 minim claus tree correspond minim binari resolut tree whose result contain two ident atom minim condit claus tree allow legal unchosen merg path legal tautolog path includ leaf leaf path minim binari resolut tree may correspond claus tree legal unchosen leaf leaf merg path legal leaf leaf tautolog path regular condit binari resolut tree requir one node intern final visibl resp support intern node binari resolut tree correspond visibl resp support close atom node claus tree tabl show number correspond notion tabl correspond notion claus tree binari resolut tree claus node leaf node intern atom node intern node edg histori path open leaf atom node liter result clt internaltointern surgeri splay surgeri internaltoleaf surgeri surgeri merg path two histori path close togeth equival class revers equival equival class rotat equival minim leaftoleaf minim visibl intern atom node visibl support intern atom node support path revers structur chang structur chang rotat chang deriv merg set histori path close given node 9 relat past futur work regular one import restrict form use mani theorem prove method relat resolut includ tableau 10 variant model elimination8 permut infer step investig kleen 7 context gentzen sequenc calculu classic intuitionist kleen permut sometim increas size proof interest note defin ancestor relat instanc formula infer allow state instanc formula deduct belong given instanc end sequent analag notion histori path context binari resolut deriv de nivel 3 two type node resolut node two parent factor node one defin four type edg rotat depend type node incid edg disallow rotat factor node parent resolut node case size deriv must increas applic construct resolut game use show variou complet result restrict resolut base order liter de nivel paper show basic properti resolut may expos consid set tree equival modulo permut main contribut paper present minim restrict resolut origin develop term claus tree use well known proof format binari resolut deriv origin motiv implement bottom algorithm construct minim claus tree direct implement base structur definit claus tree done new tree need storag space visibl algorithm cumber remedi problem use notion binari resolut deriv implement new claus tree singl storag cell two parent claus tree proposit logic solv space problem sinc tree use part tree surpris result visibl express easi ly requir linear algorithm use data structur determin explain much claus tree work could use binari resolut tree make access reader familiar resolut task turn difficult discov edg rotat histori path preced relat histori path fundament concept need relat visibl support histori path use hold tightli hold relat retrospect author still believ easier work conceptu claus tree anecdot evi denc graduat cours autom reason given two time second author claus tree binari resolut tree follow claus tree intuit support visibl quit understand use either data structur present develop full theorem prover describ one use minim restrict anoth use splay surgeri improv proof construct resolut redund elimin subsumpt alway import consider theorem prover unfortun minim restrict complet full subsumpt instanc one refut minim binari resolut tree one resolv p pq gener q use back subsumpt remov resolut p q p q done latter resolut part minim binari resolut refut claus former resolut step lead binari resolut tree p resolv two differ node one branch howev discov 6 one retain complet give power minim without give power subsumpt space minim binari resolut tree interest follow reason 1 refut complet 2 extend well known regular restrict resolut 3 contain smallest binari resolut tree 4 nonminim subtre identifi time linear size tree 5 nonminim tree reduc minim one effici r algorithm organizaton inform symbol logic mechan theorem prove resolut game nonlift resolut order regular resolut versu unrestrict resolut claus tree tool understand implement resolut autom reason bottom procedur construct minim claus tree permut infer mechan theorem prove model elimin otter 30 user guid machineori logic base resolut principl extend regular restrict resolut nonlinear subdeduct complex deriv proposit calculu tr