maximum edgedisjoint path problem bidirect tree bidirect tree direct graph obtain undirect tree replac undirect edg two direct edg opposit direct given set direct path bidirect tree goal maximum edgedisjoint path problem select maximumcardin subset path select path edgedisjoint problem solv optim polynomi time bidirect tree constant degre apxhard bidirect tree arbitrari degre everi fix varepsilon 0 polynomialtim 53varepsilonapproxim algorithm present b introduct research disjoint path problem graph long histori 12 recent year edgedisjoint path problem brought focu attent advanc field commun network mani modern network architectur establish virtual circuit sender receiv order achiev guarante qualiti servic connect request accept network must alloc suffici resourc link along path sender receiv edgedisjoint path problem heart aris resourc alloc problem studi maximum edgedisjoint path problem medp bidirect tree network bidirect tree direct graph obtain undirect tree replac undirect edg two direct edg opposit direct bidirect tree network studi intens good model optic network pair unidirect fiber link adjac node 26 medp bidirect tree defin follow given bidirect tree e set p simpl direct path goal find subset p path p 0 edgedisjoint cardin p 0 maxim say algorithm aeapproxim algorithm medp alway output subset edgedisjoint path whose cardin least 1aefract cardin optim solut conflict graph set direct path bidirect tree undirect graph vertex path edg two vertic correspond path intersect ie share edg one view medp bidirect tree maximum independ set problem conflict graph assum given tree root arbitrari node node v let pv denot parent v level node defin distanc root node root level zero say path touch node begin node pass node end node level path minimum level node touch uniqu node path whose level equal level path least common ancestor lca path preliminari version articl appear proceed 9th annual intern symposium algorithm comput isaac98 lnc 1533 page 179188 1998 institut fr informatik tu munchen 80290 munchen germani erlebachintumd z idsia lugano corso elvezia 36 6900 lugano switzerland klausidsiach denot path begin node u end node v u v lca lcau v 11 result first x2 determin complex medp bidirect tree medp solv optim polynomi time bidirect tree constant degre bidirect star max snphard bidirect tree arbitrari degre main result paper summar follow theorem theorem 11 everi fix 0 polynomialtim approxim algorithm maximum edgedisjoint path problem bidirect tree approxim ratio 53 descript algorithm proof claim approxim ratio inde achiev appear x3 x4 discuss result gener weight version problem maximum path color problem 12 relat work path color bidirect tree previou work bidirect tree focus path color problem given set direct path bidirect tree assign color path path receiv differ color share edg goal minim total number color use problem nphard even binari tree 8 24 best known approxim algorithm 11 10 use d53le color l maximum load load edg number path use edg thu lower bound optim solut previou algorithm use 158l color 26 74l color 18 25 worst case special case alltoal path color shown optim number color equal maximum load 14 multicommod flow tree garg et al 13 studi integr multicommod flow problem undirect tree gener medp undirect tree show problem unit edg capac equival medp undirect tree solv optim polynomi time undirect tree edg capac one two prove problem max snphard also present 2approxim algorithm integr multicommod flow tree work consid demand order nonincreas level lca satisfi greedili approxim algorithm adapt medp bidirect tree also give 2approxim main idea lead improv approxim algorithm medp bidirect tree consid path lca simultan instead one one onlin algorithm medp tree medp also studi onlin scenario path given algorithm one one algorithm must accept reject path without knowledg futur request preemption allow easi see determinist algorithm competit ratio better diamet tree case awerbuch et al gave random algorithm competit ratio olog n undirect tree n node 2 algorithm work also bidirect tree improv random algorithm competit ratio olog undirect tree diamet given 3 medp topolog medp studi arbitrari graph algorithm must solv rout problem select problem arbitrari direct graph edg medp recent shown nphard approxim within 12gamma 16 approxim algorithm approxim ratio p known unweight case 20 28 weight case 22 better approxim ratio achiev restrict class graph class edgedisjoint path bidirect tree 3 planar graph contain twodimension mesh network o1approxim algorithm devis 21 2 complex result medp bidirect tree nphard gener prove reduct 3dmatch similar reduct use garg et al prove nphard integr multicommod flow undirect tree edg capac one two 13 omit detail modif straightforward reduc bound variant 3dmatch problem 19 reduct lreduct apreduct impli medp bidirect tree max snphard 27 apx hard 7 show polynomialtim approxim scheme problem nevertheless medp solv optim polynomi time input restrict certain way first consid case maximum degre given tree bound constant optim solut comput dynam program case process node tree order nonincreas level everi node v record possibl subset edgedisjoint path touch v parent note jsj 2 maximum number path contain subtre root v accept addit path node v process valu known children enumer possibl edgedisjoint subset path touch v subset look correspond valu store children v updat valu store v accordingli note polynomi mani subset consid node root node process optim solut easili construct anoth special case solv optim polynomi time case given bidirect tree star ie contain one node degre greater one medp bidirect star reduc maximum match problem bipartit graph follow first assum without loss gener everi given path use exactli two edg star path use one edg add new node star extend path one edg without chang set solut observ everi path use exactli one edg direct toward center one edg direct away center star construct bipartit graph g includ vertex everi edg star ad edg two vertic u v g everi path use edg correspond u v two path edgedisjoint correspond edg g share endpoint set edgedisjoint path correspond match g maximum match g comput polynomi time 17 latter result actual gener star spider spider bidirect tree one node center degre greater two medp bidirect spider solv polynomi time use algorithm maximumweight bipartit match problem subroutin bipartit graph g construct path touch center spider weight edg e g specifi mani fewer path touch center spider accept path correspond e accept detail left reader 3 approxim optim solut fix 0 let instanc maximum edgedisjoint path problem given bidirect tree set 4 erlebach k jansen p direct path denot p arbitrari optim solut given instanc algorithm proce two pass first pass process node order nonincreas level ie bottomup assum algorithm process node v let p v denot subset path u w 2 p intersect path accept algorithm previou node use edg reserv fix algorithm see sake simplic assum without loss gener u otherwis could add addit child v path p v start end v make path start end new child instead everi path use exactli two edg incid v refer two edg top edg p say two path equival use two edg incid v ie top edg set q path lca defin partit q differ equival class path natur way algorithm process node v tri determin path p v whether includ solut path call accept path call reject sometim howev algorithm make decis right away case algorithm leav path intermedi state resolv later possibl path intermedi state undetermin path ii group defer path iii group exclus path iv group 2exclus path refer undetermin path path group exclus path group 2exclus path unresolv path path group defer path defer path statu unresolv path resolv later node first pass second pass algorithm proce topdown accept one path group defer path 31 path intermedi state follow give explan regard possibl group path intermedi state first algorithm sometim leav singl path p p v undetermin state p v one equival class path accept path might caus algorithm miss chanc accept two path smaller level v later henc algorithm could best achiev 2approxim therefor instead accept reject path p v right away algorithm pick one make undetermin path path p v reject undetermin path accept reject later node second situat algorithm accept reject path right away sketch fig 31 follow pair opposit direct edg drawn undirect edg figur situat algorithm decid accept one sever intersect path p v defer decis one accept intersect path call group defer path path group defer path use edg incid v child c v figur edg c v case defer path share edg v c symmetr furthermor defer path use also edg v c 0 connect v child c 0 6 c defer edgedisjoint path bidirect tree 5 e c fig 31 group defer path c c fig 32 possibl configur group exclus path lefthand side situat exclus path block righthand side path use edg algorithm decid creat new group defer path mark edg c v reserv assur path accept node process v use edg leav edg v c 0 children avail reserv edg indic dash arrow fig 31 motiv introduc group defer path follow first reserv edg block one path smaller level could accept optim solut second matter path use edg pv v accept node process v path use one edg v c 0 still least one defer path use particular edg v c 0 algorithm pick defer path second pass process later node first pass algorithm actual treat group defer path like singl accept path use reserv edg defer path group exclus path sketch fig 32 lefthand side group consist one path q call lower path contain subtre root child c v one path p call higher path lca v intersect q one two path accept algorithm pick wrong one choic caus algorithm accept one path optim solut would accept path one two addit path henc algorithm defer decis path accept later node mark 6 erlebach k jansen fig 33 group 2exclus path consist pair independ group exclus path top edg path q intersect p fix fix edg indic dot arrow figur obvious group exclus path follow properti properti e one path touch v use fix edg accept later node either p q still accept two path touch v accept later node block p q accept righthand side fig 32 show two path accept later node block exclus path process later node algorithm tri avoid whenev possibl last type unresolv path sketch figur 33 34 group 2exclus path consist set four path two accept precis first possibl group 2exclus path consist two independ group exclus path fig 33 ie two group exclus path fix edg one group direct toward root fix edg group direct toward leav furthermor two group must either contain disjoint subtre shown fig 33 lower path contain disjoint subtre higher path intersect pair independ group exclus path two fix edg fix edg group second possibl group 2exclus path consist group exclus path contain subtre root child v two path lca v intersect exclus path fix edg way accept p 1 p 2 would block exclus path accept fig 34 two edg mark fix name top edg higher exclus path intersect path lca v top edg lower exclus path intersect path lca v difficult show case analysi group 2exclus path follow properti properti 2e one path touch v use fix edg accept later node two path group 2exclus path still accept two path touch v use fix edg accept later node least one path group 2exclus path still accept process later node algorithm tri avoid accept two path touch v one path group 2exclus path accept edgedisjoint path bidirect tree 7 vfig 34 configur group 2exclus path 32 invari x34 present detail algorithm proce first pass time show approxim ratio achiev algorithm 53 order establish prove induct follow invari maintain invari hold first node process hold time addit node process node v call root process subtre node v alreadi process parent invari everi root v process subtre path subtre accept reject defer except one follow case occur subtre contain one undetermin path path contain subtre accept reject defer edg subtre mark fix ii subtre contain one group exclus path path contain subtre accept reject defer edg mark fix subtre one group exclus path iii subtre contain one group 2exclus path path contain subtre accept reject defer edg mark fix subtre two group 2exclus path accept path edgedisjoint contain reserv edg everi unresolv path edgedisjoint accept path contain reserv edg everi defer path contain exactli one reserv edg reserv edg group defer path path belong defer path p intersect accept unresolv path q level q smaller p invari b let set path alreadi accept algorithm let f set path p whose lca yet process block accept path reserv edg fix edg let number group defer path contain process subtre let u set undetermin path let x union group exclus path group 2exclus path subset f u x edgedisjoint path satisfi follow condit jp j 53 b everi group exclus path contain one path group everi group 2exclus path contain two path group intuit set repres subset p contain edgedisjoint path could still accept algorithm follow properti algorithm accept least 153 fraction path addit 8 erlebach k jansen path alreadi accept output 53 approxim optim solut observ invari satisfi initi easi see descript algorithm invari inde maintain throughout first pass special care must taken prove invari b maintain well 33 second pass invari satisfi root node process joj time still one undetermin path need contain therefor joj 2 f0 1g case one group exclus path contain exactli one path one group 2exclus path contain two edgedisjopint path 2 undetermin path algorithm accept group exclus path algorithm accept one arbitrarili group 2exclus path algorithm accept two edgedisjoint path arbitrarili algorithm accept least joj addit path way result set 0 accept path satisfi ja therefor jp j 53 second pass algorithm process node tree revers order ie accord nondecreas level topdown node v lca least one group defer path accept one path group defer path path edgedisjoint previous accept path alway done due definit group defer path henc number path accept algorithm increas second pass set 00 path accept algorithm end satisfi ja 00 theorem 11 34 detail first pass assum algorithm process node v recal p v p set path lca v intersect previous accept path fix reserv edg let u v set undetermin path contain subtre root children v let x v set path group exclus path group 2exclus path contain subtre root children v follow explain algorithm process node v determin path p v u v x v accept reject defer left put unresolv state observ given set path lca v problem determin maximumcardin subset edgedisjoint path equival solv medp star thu done polynomi time comput maximum match bipartit graph cf x2 whenev use express like comput maximum number edgedisjoint path p v follow impli comput carri employ reduct maximum match use follow properti bipartit graph 2 fact maximum match bipartit graph g cardin impli vertic g everi edg incid least one vertic properti hold arbitrari valu known konig theorem 23 see eg book berg 4 pp 132133 observ child current node v root process subtre invari contain one follow one undetermin path one group exclus path one group 2exclus path let k number children v undetermin path subtre let edgedisjoint path bidirect tree 9 number children v group exclus path let number children v group 2exclus path use express subtre exclus path refer subtre root children v either group exclus path group 2exclus path note one main difficulti lie determin path u v accept reject k bound constant possibl combin accept reject path u v x v tri polynomi time k larg algorithm must proceed differ way order make suffici good decis exact threshold determin k consid larg consequ runningtim algorithm depend constant let f u x denot quantiti defin x32 instant algorithm process node v let f 0 u 0 x 0 0 0 denot respect quantiti right node v process furthermor denot v number path newli accept process v v number group defer path newli creat process v assum set f u x edgedisjoint path satisfi condit b invari b v process everi singl case follow case analysi show construct set 0 satisfi invari b v process 0 obtain replac path remov path insert path requir particular 0 must set edgedisjoint path satisfi 0 f 0 u 0 x 0 therefor path intersect newli accept path reserv edg newli creat group defer path must remov note two path smaller level v path smaller level must use edg v pv pv v path reject algorithm must remov replac new group exclus path group 2exclus path creat 0 must contain one two path respect group condit b invari b maintain furthermor must ensur jo 0 j smaller joj 5 valu jajd increas v v process ie ja impli condit invari b hold also v process ie case 1 2g algorithm tri combin accept reject unresolv path subtre root children v undetermin path two possibl accept reject path group exclus path two possibl accept lower path accept higher path group 2exclus path either four possibl case pair independ group exclus path shown fig 33 page accept lower higher path one group lower higher path group two relev possibl case shown fig 34 page 7 accept lower higher path group exclus path contain group 2exclus path edgedisjoint path among remain two path note accept path group exclus path remain two path block path f two possibl henc need consid third possibl accept two edgedisjoint path group henc number possibl combin bound 2 k 4 o1 combin fl algorithm comput maximum number fl edgedisjoint path p v intersect u fl path u v x v tent accept combin let maximum u taken combin fl note cardin maximumcardin subset edgedisjoint path algorithm noth proce next node otherwis distinguish follow case case 11 case 111 one equival class path pick one say p arbitrarili make undetermin path henc u reject path p v contain path p 0 6 p p v replac p 0 p obtain 0 order ensur j obvious invari satisfi p v one equival class path must edg e incid v share path p v consequ konig theorem make p v group defer path reserv edg e contain one path intersect edg e either path p v path smaller level suffic remov path order obtain valid set 0 get invari satisfi case 112 one child c v undetermin path p lca w subtre possibl algorithm noth leav p undetermin state p v 6 path p v must intersect p edg say edg u w case intersect p edg w u symmetr algorithm pick arbitrari path q p v make fp qg group exclus path fix edg u w henc path p v reject must ensur 0 contain p q order satisfi condit b invari b contain path p v u v properti e either q insert remov one path smaller level contain path p 0 p v u v alreadi path replac p q invari satisfi case 113 1 one child v group exclus path subtre path p v could combin path group exclus path obtain two edgedisjoint path assum must henc algorithm noth node v leav group exclus path intermedi state case 12 2 observ k 2 mani subcas case 12 algorithm yield v 2 contain one path remov path two path smaller level clearli suffici obtain valid set 0 subcas therefor repeat argument everi relev subcas instead discuss case contain two path case 121 subtre root child v contain group 2exclus path must path p v could combin two path x v form set three edgedisjoint path henc algorithm noth node v leav group 2exclus path unresolv state case 122 two children v whose subtre contain group exclus path note case path p v could combin one exclus path subtre obtain set three edgedisjoint path edgedisjoint path bidirect tree 11 e fig 35 case 1231 pv contain two edgedisjoint path lefthand side case 1232 fix edg e direct righthand side fix edg group exclus path point direct ie direct root leav algorithm accept lower path group exclus path higher path reject edg mark fix anymor 0 three path must remov obtain valid set 0 two path group exclus path contain one path smaller level use edg v pv whose direct opposit direct formerli fix edg fix edg group exclus path point differ direct ie one direct toward root one toward leav group repres pair independ group exclus path algorithm creat new group 2exclus path note contain two path new group 2exclus path alreadi contain one path two group exclus path x v due condit b invari b therefor set invari satisfi case 123 one child v group exclus path subtre one child v undetermin path subtre path p v must intersect undetermin path otherwis path p v could combin undetermin path exclus path obtain set three edgedisjoint path case 1231 two edgedisjoint path p v case situat must shown lefthand side fig 35 two edgedisjoint path must intersect group exclus path way block exclus path accept kind path p v algorithm accept lower path group exclus path undetermin path reject path mark fix anymor note combin two edgedisjoint path p v u v x v block least three four top edg path accept algorithm henc contain two path contain one path smaller level intersect path accept algorithm suffic remov three path obtain valid e e fig 36 case 1232 b 1232 c fix edg e differ direct case 1232 path p v intersect edg e undetermin path case 1232 direct e fix edg group exclus path see righthand side fig 35 algorithm accept undetermin path lower path group exclus path path reject edg mark fix anymor contain two path p v use fix edg edg e one path block path accept algorithm path must use edg v pv direct opposit direct e thu suffic remov three path obtain valid set 0 case 1232 b direct e differ fix edg path intersect higher exclus path see lefthand side fig 36 algorithm use x v p undetermin path togeth creat new group 2exclus path consist pair independ group exclus path path p v reject algorithm addit fix edg old group exclus path edg e mark fix note contain one path x v due condit b invari b contain undetermin path path p let contain path p p v replac path either p undetermin path one must possibl contain path p v u v contain path p 0 use edg v pv direct given edg e replac p 0 either p undetermin path one two must possibl contain path p v u v path use edg v pv direct given edg e add either p undetermin path case invari satisfi particular jo case 1232 c direct e differ fix edg path p v intersect higher exclus path see righthand side fig 36 algorithm accept undetermin path lower path group exclus path reject path mark fix anymor contain two path must contain least one two path accept algorithm path use top edg path accept algorithm contain one path smaller level intersect path accept algorithm suffic remov three path order obtain valid set 0 edgedisjoint path bidirect tree 13epe pp c c c pp p c c c fig 37 case 1241 pv contain two edgedisjoint path block exclus path case 124 one child c v group exclus path subtre denot higher lower path group exclus path p q respect assum without loss gener fix edg e 0 group exclus path direct toward root tree shown fig 37 note distinguish case regard maximum number edgedisjoint path p v case 1241 two edgedisjoint path p 1 p 2 p v must intersect exclus path way block accept see fig 37 let p 1 intersect p let p 2 intersect q let c 0 6 c child v p 1 use edg c v v c 0 let c 00 6 c child v p 2 use edg c 00 v v c note c top edg p intersect p 1 e 1 let top edg q intersect p 2 e 2 contain two edgedisjoint path everi path p must either intersect edg e 1 intersect edg e 2 intersect p 1 p 2 latter case possibl c 0 6 c 00 path p v intersect e 1 use edg c v v c 0 path p v intersect e 2 use edg c 00 v v c case p 0 must use shown righthand side fig 37 case 1241 path p v intersect e 1 use edg c v v c 0 path p v intersect e 2 use edg first assum path p v intersect either e 1 e 2 note exactli two equival class path p v case see fig 37 lefthand side algorithm use group exclus path one repres two equival class path p v creat group 2exclus path path p v reject fix edg e 0 group exclus path longer mark fix instead edg e 1 e 2 mark fix contain two path p v x v one must x v due condit b invari b replac path new group 2exclus path otherwis possibl remov path x v one addit path result set contain path p v x v one 14 erlebach k jansen path smaller level touch v path smaller level intersect fix edg new group 2exclus path properti 2e two path new group 2exclus path insert set obtain 0 invari satisfi assum path p 0 2 p v intersect neither e 1 e 2 note must c 0 6 c 00 case p 0 must use edg fig 37 righthand side algorithm accept lower path group exclus path path p 0 reject path edg mark fix anymor note combin two edgedisjoint path block least three four top edg path accept algorithm henc contain two path contain one path smaller level intersect path accept algorithm suffic remov three path obtain valid set 0 case 1241 b least two equival class path p v intersect higher path group exclus path algorithm accept lower path group exclus path make path p v intersect higher path group defer path path p v x v reject edg mark fix anymor reserv edg group defer path top edg share path contain two path p v x v note one two path must x v due condit b invari b two path also block top edg lower path group exclus path henc contain path smaller level intersect lower path contain one path smaller level intersect reserv edg newli defer path suffic remov three path obtain valid set 0 case 1241 c one equival class path p v intersect higher path group exclus path least two equival class path p v intersect lower path group exclus path algorithm accept higher path group exclus path make path p v intersect lower path group defer path path reject edg mark fix anymor reserv edg group defer path top edg share path contain two path note one two path must x v due condit b invari b two path also block edg e 1 henc contain path smaller level intersect e 1 contain one path smaller level intersect reserv edg newli defer path top edg higher path direct toward leav path must use edg pv v suffic remov three path obtain valid set 0 case 1242 p v contain two edgedisjoint path let e edg incid v path p v use edg e case 1242 least two differ equival class path algorithm make path p v new group defer path reserv edg e accept q lower path group exclus path path p reject edg subtre mark fix anymor contain two path p v x v path block two three top edg block algorithm fix edg e 0 group exclus path edg e contain one path smaller level fig 38 case 125 set two edgedisjoint path use four top edg left hand side case 125 b one equival class path use edg e 1 one class use edg e2 righthand side intersect path accept algorithm reserv edg new group defer path suffic remov three path obtain valid set 0 case 1242 b e 6 v c 0 children c 0 6 c v p v one equival class path path p intersect q algorithm accept p 0 q path p v intersect q algorithm accept p arbitrari path p v case path p v x v reject edg subtre mark fix anymor 2 assum contain two path p v x v show suffic remov three path obtain valid set 0 algorithm accept p must also contain p path p v thu block least three four top edg path accept algorithm one path block path accept algorithm assum algorithm accept q observ two path must also use edg e 0 e thu block two four top edg path accept algorithm e e 0 direct contain one path smaller level intersect path accept algorithm path must use edg pv v p v one equival class path path p v x v block three four top edg path accept algorithm suffic remov one path smaller level final consid case p v one equival class path e v c sinc edg e block path smaller level top edg q direct toward leav two path p v x v fact block least mani path smaller level three four top edg path accept algorithm case 125 must two edg incid v path p v use least one two edg konig theorem let e 1 e 2 two edg case 125 possibl set two edgedisjoint path p v use four edg incid v see lefthand side fig 38 exampl algorithm pick two arbitrari edgedisjoint path p v accept reject path p v contain two path p v remov two path suffici obtain valid set 0 use top edg path accept algorithm contain path intersect path accept algorithm follow let set path p v intersect path p v word path p 2 p v p v contain path q edgedisjoint p note case 125 appli follow either path p v n use edg e 1 use edg e 2 must one fig 39 case 125 c configur two group defer path creat equival class path case 125 b one equival class c path p v n use one equival class path p v n use edg e 2 intersect path c see righthand side fig 38 case e 1 e 2 exchang symmetr furthermor note case one equival class c path p v n use edg e 1 one equival class path p v n use edg e 2 intersect path c satisfi condit case 125 algorithm pick path p c arbitrarili accept p make path use edg e 2 intersect p group defer path reserv edg e 2 path p v reject contain two path p v path must also use top edg p newli reserv edg thu remov two path suffici obtain valid set 0 case 125 c one equival class path p v n use one equival class path p v n use edg e 2 case 125 appli algorithm make path p v n use e 1 group defer path reserv edg e 1 path p v n use e 2 group defer path reserv edg e 2 path p v reject note matter path smaller level accept algorithm later still two path one two group newli defer path edgedisjoint path smaller level otherwis case 125 would appli 2 contain two path p v path use e 1 e 2 well remov two path suffici obtain valid set 0 contain path intersect reserv edg newli defer path case 126 one child v undetermin path p subtre let p 0 denot set path p v intersect p begin make simpl observ first p 0 v must contain two edgedisjoint path henc must edg e incid v share path p 0 v second impli maximum number edgedisjoint path p v two must two edg e 1 e 2 incid v everi path p v use least one two edg let lca undetermin path v 0 let c child v whose subtre contain undetermin path possibl v 0 undetermin path use edg v 1 number subcas regard number equival class p 0 v case 126 p 0 v empti let p 1 p 2 denot set path p v intersect p edg v edg v respect note algorithm accept arbitrari path p p one equival class path creat new group defer path p otherwis undetermin path p reject edgedisjoint path bidirect tree 17 v v v v v fig 310 case 127 v two children undetermin path subtre 2 contain two path p v u v remov two path suffici block least mani path smaller level newli accept path newli reserv edg case 126 b p 0 v one equival class path algorithm accept arbitrari path p 0 v undetermin path p path p v reject assum contain two path p v u v contain p must also contain path p 0 v suffic remov two path obtain valid set 0 contain p contain path p 0 must also contain path p v intersect p two path block least three four top edg block algorithm suffic remov two path one path smaller level final contain neither p path p 0 must contain two path p v intersect p differ top edg least one intersect also top edg path suffic remov three path obtain valid set 0 case 126 c p 0 v one equival class path let e edg incid v share path p 0 v algorithm accept undetermin path p creat new group defer path path path p v reject 1 assum contain two path p v u v contain p must also contain path v suffic remov two path obtain valid set 0 contain p contain path p 0 must contain path p v intersect two path block least two three top edg block algorithm suffic remov two path one path smaller level final contain neither p path p 0 must contain two path p v intersect p differ top edg two path block least two three top edg block algorithm suffic remov three path obtain valid set 0 case 127 two children v undetermin path subtre denot undetermin path p q see fig 310 everi path p v must intersect least one undetermin path addit two path p v intersect one undetermin path differ top edg least one must also intersect undetermin path let p 1 p 2 denot set path p v intersect p q respect note case 127 edgedisjoint path p 1 p 2 p v p 1 intersect p top edg e 1 intersect q p 2 intersect q top edg e 2 intersect p e 1 e 2 differ direct ie one direct toward root direct toward leav algorithm make p q p 1 p 2 group 2exclus path consist pair independ group exclus path reject path p v edg e 1 e 2 mark fix contain two path new group 2exclus path alreadi let otherwis possibl replac path path new group 2exclus path obtain 0 case jo case 127 b condit case 127 hold algorithm accept p q reject path p v contain two path p v u v contain p q suffic remov two path contain one p q say p must contain path p v intersect q two path block three four top edg block algorithm contain neither p q must contain two path p v least one two path intersect p q two path block least three four top edg block algorithm path intersect one p q must case one intersect p edg e 1 one intersect q edg e 2 e 1 e 2 direct contain one path smaller level intersect path accept algorithm e 1 e 2 differ direct condit case 127 appli case 13 3 algorithm accept path reject path subtre mark fix anymor maximum number edgedisjoint path contain path p v u v x v furthermor contain two path f use edg v pv pv v two path could possibl block path accept algorithm henc valid set 0 obtain delet path invari maintain case 2 2g case algorithm tri possibl accept reject unresolv path polynomi time instead calcul four candid set edgedisjoint path choos largest obtain two four set employ method remov path arbitrari set edgedisjoint path p v exclus path x v accept addit path remain result set edgedisjoint path x v cardin jsj r number path remov detail method proof present later lemma 31 tool readi describ candid set 1 subset path p v intersect undetermin path u v 1 comput maximum number 1 edgedisjoint path p 0 v 1 obtain take path k undetermin path mani addit edgedisjoint path x v possibl undetermin path least path group 2exclus path x v due properti 2e 2 2 obtain 1 remov r 1 path 2m exclus path accept 2 contain 2m exclus path accord lemma 31 r m3 1 path remov obtain 2 2 still contain k undetermin path addit js edgedisjoint path bidirect tree 19 2 contain k undetermin path u v exclus path 3 3 obtain first comput maximum number 3 edgedisjoint path p v ad mani edgedisjoint path x v u v possibl js 3 j 3 3 contain least path group 2exclus path x v due properti 2e 4 4 obtain 3 remov r 3 path 3 p v 3 2m exclus path accept way 2 obtain 1 accord lemma 31 js 4 j m23 3 algorithm accept path set maximum cardin reject path p v u v x v note v js 2 j maxf3 2g impli 2 v let number path p v contain v intersect least one k undetermin path observ v contain k gamma b 0 2 undetermin path u v note maximum number edgedisjoint path p v 3 maximum number edgedisjoint path p 0 v 1 use jo use jo upper bound jo v j lower bound cardin four set prove least one set satisfi jo suffic remov jo path order obtain valid set 0 impli invari maintain jo follow case case 21 ff 32 v js 3 use 31 v js 4 j bound ratio jo v v case 22 v js 3 use 31 v js 2 j bound ratio jo v v 20 erlebach k jansen c e fig 311 set edgedisjoint path pv case 23 ff 43 31 get jo 2m shown jo hold subcas case 2 complet descript case 2 still explain method remov path 1 3 order obtain 2 4 respect method take arbitrari set edgedisjoint path p v remov path obtain set 0 everi subtre exclus path touch one path 0 motiv caus path group exclus path block two path intersect correspond subtre properti e similarli one path group 2exclus path accept must contain two path p v intersect correspond subtre properti 2e method proce follow consid graph g path vertic edg two path touch child v g maximum degre two consist collect chain cycl note everi edg g correspond child v touch two path interest maxim part chain cycl consist entir edg correspond children v root subtre exclus path follow possibl part cycl path cycl endpoint subtre exclus path ii chain path end one endpoint subtre exclus path intern path endpoint subtre exclus path iii chain path one end one endpoint subtre exclus path path endpoint subtre exclus path iv chain path endpoint subtre exclus path note everi maxim part cycl chain length number path least two contain least one edg method remov path proce follow cycl even length chain handl remov everi path start second path chain cycl odd length handl remov two consecut path one place everi path rest cycl consid exampl depict fig 311 node v eight children name h six c h root subtre exclus path indic edgedisjoint path bidirect tree 21 ea gh ad dc hf fg cb fig 312 graph g repres structur path exclam mark set edgedisjoint path p v sketch graph g obtain set shown fig 312 label vertex g uw correspond path begin subtre root u end subtre root w respect iiv g contain cycl type length three contain path f g gh hf chain type ii length three contain path ad dc cb accord rule given three path would remov two path say f g gh cycl path dc chain length three easi see process alway ensur end contain subtre exclus path one path endpoint subtre henc due properti e 2e fill edgedisjoint exclus path contain exclus path lemma 31 let v node children exclus path let p v set edgedisjoint path let 0 set path obtain remov path accord method describ let proof let number cycl type let 1 length ith cycl denot number chain type ii b length b 1 b denot number chain type iii c length c denot number chain type iv length note number path contain union chain cycl p furthermor consid number children exclus path cover chain cycl obtain p latter inequ ad two inequ obtain p take account p sigma iupsilon c da 2e 23a 2 lemma follow exampl display fig 311 suffici remov 3 35 runningtim algorithm runningtim algorithm polynomi size input fix 0 exponenti 1 let bidirect tree e n node set p contain h direct path path specifi endpoint given arbitrari 0 claim approxim algorithm implement run time detail implement well experiment result report 9 22 erlebach k jansen note choos n still achiev runningtim polynomi size input result algorithm achiev approxim ratio therefor asymptot approxim ratio 53 optim solut contain mani path n must also larg approxim ratio get arbitrarili close 53 4 gener sever gener medp first meaning consid weight version problem path certain weight goal maxim total weight accept path weight version medp still solv optim polynomi time bidirect star spider reduct maximumweight match bipartit graph bidirect tree bound degre minor modif dynam program procedur given x2 anoth gener medp maxpc problem given bidirect tree set p direct path number w color maximum path color maxpc problem comput subset p 0 p w color p 0 goal maxim cardin p 0 maxpc problem equival find maximum induc w color subgraph conflict graph given path studi maxpc motiv admiss control problem allopt wdm wavelengthdivis multiplex network without wavelength convert everi wavelength color use establish set connect provid path correspond connect edgedisjoint number avail wavelength limit 5 weight variant maxpc interest well maxpc weight maxpc solv optim polynomi time bidirect star use algorithm weight version capacit bmatch problem 15 pp 257259 number w color maximum degre bidirect tree bound constant maxpc weight maxpc solv optim polynomi time dynam program similar procedur x2 maxpc nphard arbitrari w bidirect binari tree path color nphard bidirect tree arbitrari degre equival medp case order obtain approxim algorithm maxpc arbitrari number w color techniqu due awerbuch et al 1 employ allow reduc problem w color medp small increas approxim ratio techniqu work maxpc arbitrari graph g discuss tree let instanc maxpc given bidirect tree set p path number w color approxim algorithm arbitrari number w color obtain approxim algorithm 1 one color ie maximum edgedisjoint path problem run w copi 1 give input ith copi bidirect tree set path accept first copi 1 see fig 41 output union w set path output copi 1 path ith set assign color 1 shown algorithm obtain use techniqu approxim ratio ae 1 1 approxim ratio ae even differ color associ differ network topolog ident network applic approxim ratio achiev even bound aew smaller 11 gamma e gamma1a w bound mention journal version 1 view adapt similar result 6 prove easili use fact select p k path algorithm input bidirect tree set p path number w color output disjoint subset p 1 p w p p edgedisjoint begin w begin fig 41 reduct mani color one color run k copi 1 still set least jp among remain path next copi 1 accept least 1aefract number reduct work also weight case sinc optim algorithm medp bidirect tree bound degre 53 approxim algorithm medp arbitrari bidirect tree employ techniqu obtain approxim algorithm bidirect tree bound degre ratio approxim 222 maxpc arbitrari bidirect tree acknowledg author grate stefano leonardi point reduct maxpc arbitrari number color maxpc one color adi rosen inform improv analysi ratio obtain reduct case ident network color suppli preliminari draft journal version 1 r competit non graph hypergraph special issu dens wavelength divis multiplex techniqu high capac multipl access commun system locat bank account optim float analyt studi exact approxim algorithm structur approxim class call schedul tree optim wavelength rout direct fiber tree optim greedi algorithm wavelength alloc direct tree network colour path direct symmetr tree applic wdm rout effici wavelength rout direct fiber tree maximum bound 3dimension match max snpcomplet approxim algorithm disjoint path problem approxim disjointpath problem use greedi algorithm pack integ program note optic rout tree improv access optic bandwidth tree effici access optic bandwidth comput complex improv approxim edgedisjoint path tr ctr thoma erlebach klau jansen implement approxim algorithm weight unweight edgedisjoint path bidirect tree journal experiment algorithm jea 7 p6 2002 r sai anand thoma erlebach alexand hall stamati stefanako call control k reject journal comput system scienc v67 n4 p707722 decemb thoma erlebach klau jansen convers color algorithm maximum weight independ set algorithm discret appli mathemat v148 n1 p107125