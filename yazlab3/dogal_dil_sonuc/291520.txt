comput local consensu tree infer consensu set evolutionari tree fundament problem number field biolog histor linguist mani model infer consensu propos paper present model deriv call local consensu tree set tree cal model propos presum function f call total local consensu function determin everi tripl speci form local consensu tree take show local consensu tree exist construct polynomi time mani fundament problem solv linear time also consid partial local consensu function studi optim problem model present linear time algorithm sever variat final point local consensu approach tie togeth mani previou approach construct consensu tree b introduct evolutionari tree also call phylogeni phylogenet tree speci set root tree leav label distinct element evolutionari histori difficult determin comput difficult optim problem area nphard scientif difficult well sinc rang approach appropri differ type data exist common approach solv problem appli mani differ algorithm given data set differ data set repres speci set look common element set tree return sever method describ literatur deriv one tree set tree paper propos new model call local consensu model base upon function call local consensu rule infer root topolog homeomorph subtre induc tripl speci show local consensu function support part nsf grant ccr9108969 support part aro grant daal03890031pri z support part aro grant daal03890031pri comput polynomi time mani natur form local consensu comput linear time also analyz optim problem base upon partial local consensu rule show mani also solv polynomi time preliminari 21 definit let set speci evolutionari tree also known phylogenet tree simpli phylogeni root tree n leav label distinct element intern node denot ancestor speci arbitrari subset 0 ae denot tj 0 homeomorph subtre induc leav 0 particular specifi tripl fa b cg ae denot tjfa b cg homeomorph subtre induc leav label b c topolog complet determin specifi pair speci among b c whose least common ancestor lca lie furthest away root b pair denot b c said resolv tripl b c binari may happen three pair speci least common ancestor case say unresolv denot topolog b c given tree contain node u v w let lca u v w denot least common ancestor u v w also let u v denot v path u root set input tree ft consensu problem sometim refer profil let b c repres set root subtre leaf set fa b cg local consensu rule function given local consensu rule f set r evolutionari tree flocal consensu exist tree r f tripl r f said total local consensu otherwis f said partial local consensu problem determin flocal consensu exist construct call flocal consensu problem also consid optim version local consensu problem discuss subsequ section set gener machineri look special case need build consensu two tree describ specif local consensu function f produc effici algorithm 22 particular local consensu rule defin binari local consensu optimist local consensu pessimist local consensu problem binari local consensu problem take input two binari tree wherea optimist local consensu pessimist local consensu problem take input two tree necessarili binari exampl total local consensu rule definit 21 local consensu rule f conserv everi tripl fa b cg jfa b cg requir resolv particular profil tree profil resolv fa b cg differ tree necessarili binari local consensu rule interpret unresolv tripl one two distinct way suppos resolut three way split possibl suppos unresolv node repres threeway speciat event depend upon interpret therefor local consensu rule may decid 1 resolv 2 unresolv tripl output resolv ident 1 unresolv call first type local consensu rule optimist second type pessimist defin three consensu rule definit 22 let 1 2 two root binari tree leaf set root tree necessarili binari call binari local consensu 1 2 iff tripl b c jfa b definit 23 let 1 2 two root tree leaf set root tree call optimist local consensu 1 2 iff tripl b c c b c definit 24 let 1 2 two root tree leaf set root tree call pessimist local consensu 1 2 iff tripl b c differ appropri particular type data given definit three model local consensu tree may exist section 3 4 5 give linear time algorithm either construct tree look exist conclud tree exist howev practic biologist linguist need build kind consensu tree therefor consid variant local consensu tree problem alway solut end defin notion relaxedaccord local consensu relaxeddiscord local consensu follow definit 25 let 1 2 two root binari tree leaf set root tree necessarili binari call relaxedaccord local consensu 1 whenev tripl b c differ topolog 1 2 tripl unresolv preserv topolog maxim set tripl 1 2 agre prove exist relaxedaccord local consensu tree suffici show exist tree everi tripl 1 2 disagre unresolv set tree properti partial order base set tripl 1 2 agre whose topolog preserv partial order known nonempti prove exist relaxedaccord local consensu sinc maxim element partial order consensu tree note star topolog leav unresolv tripl 1 2 disagre henc partial order nonempti relaxedaccord local consensu tree alway exist section 6 show tree uniqu definit 26 let 1 2 two root tree necessarili binari leaf set root tree call relaxeddiscord local consensu 1 2 preserv topolog tripl 1 2 agre addit leav unresolv maxim set tripl 1 2 disagre use argument similar one use prove exist relaxedaccord local consensu note 1 preserv topolog tripl 1 agre conclud relaxeddiscord local consensu alway exist section 6 show relaxeddiscord local consensu also uniqu look problem give standard definit avail literatur definit 27 let root tree leaf set given node v 2 v denot lt v set leav subtre v root v also call cluster v repres ff v set ct call cluster encod everi root tree leav label contain singleton entir set ct cluster call trivial cluster defin maxim cluster cluster defin child root allow maxim cluster defin leaf also also defin notion compat set cluster definit 28 set cluster said compat iff exist tree ct follow proposit found 12 proposit 21 set cluster compat iff 8ff g state theorem use later section theorem 21 let 1 2 two root tree leaf set let f conserv local consensu rule flocal consensu tree exist ct compat set proof suppos suppos without loss gener ct compat set proposit 21 9ff 2 ct fi 2 ct 1 ff g pick ff topolog tripl b c 1 c b b c sinc f conserv local consensu rule imposs 2 3 binari local consensu section look binari local consensu problem start restat definit binari local consensu tree let 1 2 two root binari tree leaf set root tree necessarili binari call binari local consensu 1 2 iff tripl b c jfa b 31 character construct show althought binari local consensu two tree may exist exist nice character proposit 31 given binari tree cluster ff ff compat ct iff proof ff 62 ct ff compat ct exist proper refin 0 ct 0 binari tree proper refin 2 lemma 31 let 1 2 root binari tree leaf set f conserv local consensu function flocal consensu tree exist proof previou lemma ct sinc f conserv corollari 31 binari local consensu tree 1 2 exist 1 2 binari ct proof need show ff 2 ct ff 2 ct 1 ff pick ident also resolv tree ct call strict consensu tree particular consensu tree alway exist construct time 6 construct part algorithm binari local consensu tree therefor simpl remain verif strict consensu tree also binari local consensu tree ie tree construct use algorithm 6 satisfi constraint impos upon binari local consensu rule 32 verifi consensu tree binari local consensu tree prove structur lemma help determin whether consensu tree fact binari local consensu lemma 32 let 1 2 root binari tree leaf set let ff cluster intersect let strict consensu tree 1 2 let e 1 e edg respect respect intern node defin cluster ff let speci ff binari local consensu 1 2 1 subtre e binari local consensu subtre e 1 e 2 2 upon replac subtre respect binari local consensu 1 2 proof clearli binari local consensu tree 1 2 condit 1 2 hold convers 1 2 hold binari local consensu tree 1 2 tripl b c incorrectli handl tripl b c e condit 1 handl b c correctli similarli least two e condit 2 handl tripl correctli remain show handl tripl exactli two b c one edg e sinc cluster tripl properli thu binari local consensu 1 2 2 lemma yield obviou divideandconqu strategi determin whether binari local consensu exist next explor pair binari tree possibl binari local consensu star ie tree none trivial cluster definit 31 caterpillar root binari tree one pair sibl leav given leaf label caterpillar root r height h natur order induc leav let hg function gs distanc r speci order increas order 1 ga 1 note pair sibl leav arbitrarili order definit 32 two caterpillar x leaf set said opposit orient iff k k smallest element x contain among k1 largest element vice versa proposit 32 let 1 2 two root binari tree leaf set whose binari local consensu star b sibl pair leav 1 lca b 2 must root 2 proof suppos speci c least common ancestor c least common ancestor b 2 1 jfa b henc binari local consensu 1 2 star 2 lemma 33 suppos 1 2 binari tree leaf set suppos least 5 leav binari local consensu tree star 1 2 must caterpillar proof suppos contradict 1 caterpillar two pair sibl leav b c previou proposit pair must root least common ancestor 2 thu without loss gener c lie left subtre root 2 b lie right subtre root 2 thu follow 2 must two sibl pair p q r one subtre root note 1 least common ancestor p q least common ancestor r root 1 without loss gener let p r lie left subtre root 1 q lie right subtre root x either subtre 1 figur 1 topolog 1 2 respect p q let x speci besid p q figur 1 suppos without loss gener x lie left subtre root 2 consid follow two tripl 2 topolog tripl x p x q r respect show 1 agre least one tripl two case x lie left subtre root 1 topolog tripl x p 1 clearli x p x lie right subtre root 1 topolog tripl x q r 1 x q r thu either case tripl 1 agre tripl 2 binari local consensu star 2 lemma 34 let 1 2 two caterpillar leaf set binari local consensu 1 2 star 1 2 opposit orient caterpillar proof suppos two caterpillar opposit orient ie satisfi two intersect condit let x z three leav let indic order leav 1 respect topolog x z 1 x z look smallest element 2 set must contain z contain x consequ topolog tripl 2 x z star valid binari local consensu convers suppos two caterpillar satisfi intersect condit without loss gener suppos exist least one k k smallest element 2 contain within largest element 1 pick smallest k say x leaf 2 rank k x belong set k largest element 1 pigeonhol principl exist least two leav 2 rank greater k contain set k largest element 1 suppos two leav z 1 jfx impli binari local consensu star 2 b c e f c figur 2 exampl opposit orient caterpillar corollari 32 binari local consensu two tree verifi star linear time 33 binari local consensu tree algorithm 1 use day algorithm produc strict consensu tree nontrivi cluster maintain pointer edg 1 2 give rise cluster 2 travers postord nontrivi cluster found check subtre edg 1 2 caterpillar satisfi condit lemma replac entir subtre singl node belong subtre 1 2 declar binari local consensu tree theorem 31 construct verif binari local consensu done linear time proof day algorithm 6 run linear time also step 2 algorithm take linear time sinc linear number speci reintroduc replac also check caterpillar done time linear number leav caterpillar4 optimist local consensu section look problem find optimist local consensu olc tree two tree defin previou section note optimist local consensu two tree may exist recal definit olc tree let 1 2 two root tree leaf set root tree call optimist local consensu 1 2 iff tripl c b c 41 character olc tree follow lemma character optimist local consensu tree exist theorem 41 let 1 2 two root tree speci set optimist local consensu tree olc exist ct olc ff 2 2 ct 2 ff compat ct 1 ct 2 g proof pick cluster ff 2 look tripl x tripl resolv x z one tree either resolv unresolv tree either case ff 2 ct olc convers pick cluster two case name case ff compat least one ct 1 ct 2 case ff compat ff compat least one ct 1 ct 2 use theorem 21 observ second case pick smallest cluster ff 1 note node v u defin cluster ff 1 ff 2 respect lca 1 2 respect speci ff 9fi smallest cluster 1 2 respect contain ff sinc ff compat ct 1 ct 2 impli ff union cluster least two children v also union cluster least two children u moreov 9a b 2 ff b b thu pick c 2 fi 1 jfa b c topolog given olc b c thu 42 construct phase sinc optimist local consensu rule conserv tree set cluster henc exist tree satisfi ct construct refin 1 reduc contract unnecessari edg thu obtain olc approach take note approach break construct two stage refin contract refin main object refin 1 includ cluster olc explain precis introduc notat lemma previou work enabl us effici definit 41 let v arbitrari node tree children repres set v set fx 1 x denot repv one repres set lemma 41 optimist local consensu tree olc tree 1 2 exist olc jrepv isomorph 2 jrepv proof follow fact 1 jrepv star 2 definit 42 let v node tree children subtre induc fv g refin follow modifi tree 1 initialis postord fashion everi seen v also number children v sinc process done postord fashion say replac subtre v root v follow manner replac nv isomorph copi next replac x subtre 1 root u let tree produc consid node 1 theorem 42 let given suppos olc exist tree produc algorithm describ previou paragraph satisfi ct proof sinc ct olc need show olc jrepv proper refin 2 jrepv fa b cg repv olc jfa b cg would resolv 2 jfa b cg unresolv sinc fa b cg repu 1 jfa b cg also unresolv forc olc also unresolv 2 note reduc problem construct problem discov linear time algorithm howev need abl comput 2 jrepv quickli cite follow result 13 use us case lemma 42 13 given lefttoright order leav tree abil determin topolog tripl leav b c constant time construct tree linear time use lemma need two thing 1 abl determin topolog tripl 2 o1 time 2 node 1 order repres set order consist lefttoright order leav 2 accomplish 1 first preprocess 2 lca queri determin topolog tripl b c simpli compar lca b b c c second requir challeng also handl show comput order repres set time ffl initi node 1 empti label ffl 2 taken lefttoright order leav 2 1 trace path 1 leaf toward root encount either root node alreadi label 2 append order set node path trace includ first node encount alreadi label figur 3 show exampl comput describ b c e b c e b c e c ad rep set w v lefttoright order c b e c r ad rep set u v r iv complet figur 3 exampl show comput repres set node 1 base lefttoright order speci 2 note comput take time sinc node v visit odegv time order produc exactli requir thu node v 2 v 1 defin set leav leaf differ subtre v everi subtre v repres order leav appear lefttoright order 2 thu prove lemma 43 comput 2 jrepu ojrepuj time therefor follow theorem 43 given construct tree ct exist time rest task construct olc contract unneed edg contract simpli go edg check need kept must delet note edg ad refin phase requir need check therefor need check origin tree edg let u v edg repres set u v easili choos three speci b c lcaa lcab c v topolog tripl 2 differ resolv b c know edg u v contract hand 2 jfa b cg either b c b c u v retain optimist local consensu tree olc construct algorithm phase 0 preprocess make copi 0 2 1 2 respect node v tree 0 comput order repres set order lefttoright order tree preprocess tree 0 answer lca queri leav well intern node phase refin 0refin 0 1 postord fashion end ct 0 exist phase ii contract 0contract edg e 2 et 0 1 c e cluster e lie ct 1 thu shown follow theorem theorem 44 algorithm state construct olc two tree 1 2 olc exist analysi run time phase 0 preprocess 18 harel tarjan give time algorithm preprocess tree answer lca queri constant time alreadi shown comput order repres set take time thu preprocess stage take time phase refin 0thi stage involv local refin 0 1 shown cost refin around node v odegv sum node v obtain time phase ii contract edg stage clearli take time theorem 45 construct optimist local consensu tree done linear time 43 verif phase lemma 44 let tree leaf set let obtain sequenc refin follow sequenc edg contract exist function subset v children fv proof defin set cluster therefor subset v children fv v 0 2sv ff v lemma 45 suppos olc 1 2 leaf set contain least 5 speci star iff either one follow hold 1 1 2 opposit orient caterpillar 2 1 2 star proof direct easi see assum olc star contain tripl b c unresolv 2 must also unresolv b c convers whenev 1 resolv b c 2 must differ resolv b c thu either binari case 1 2 binari definit olc coincid definit binari local consensu appeal proof lemma 33 lemma 34 argu 1 2 must opposit orient caterpillar binari show node v 1 children fu node v 0 2 children fu 0 k g ff u pick three speci b c b c unresolv 1 let b c b c must unresolv 2 let v b c claim ff see suppos subtre v contradict assumpt star thu ff next note x child v 1 differ children exist z x z resolv 1 unresolv 2 would contradict fact star establish claim impli nonbinari node v root 1 find two speci b v b v speci c c 6 v cg thu root must three children case mean cluster defin child root contain two speci tripl 1 2 agre thu 1 2 must star 2 verif proce follow phase 0 suppos tree construct refin 1 contract edg result tree modif 2 ie refin 2 use inform 1 contract edg result tree call tree 0 clearli isomorph 0 termin output olc exist know compat set cluster defin uniqu tree know olc exist uniqu character phase 1 phase 0 success verifi comput order repres set everi node w v node w 1 check homeomorph subtre 1 2 induc repw star opposit orient caterpillar neither termin output olc exist 2 identifi parent w say w look repw exclud repres element w call set identifi lca repw 1 2 check speci belong lie lca repw 1 2 termin output olc exist implement step 1 phase use lefttoright order speci 1 comput order repres set rep node shown previou section u 2 v abl quickli comput homeomorph subtre 2 induc speci repu need know order these speci appear lefttoright order 2 associ u new rep set rep u rearrang version speci repu accord order 2 defin specifi 2 node v 2 v closest root 2 repv function limit togeth lefttoright order speci 2 help fill rep set sinc belong rep set node path limit first show comput use algorithm limit show rep set fill initialis visit topdown travers f 2 repv set limit identifi 2 proceed comput rep u follow look lefttoright order speci 2 speci lefttoright order trace path leaf toward root add rep set node encount path termin reach limit note process identifi rep rep done analysi run time isomorph test phase 0 perform use simpl modif treeisomorph test algorithm 1 cost preprocess 1 2 answer lca queri phase 1 implement step 1 phase 1 involv one time cost preprocess identifi rep rep node time step 1 call node w addit time odegrepw taken exploit fact 1 2 preprocess answer lca queri seen step 2 phase 1 take odegw thu total time taken verif phase correct verif procedur theorem 46 pass test olc 1 2 proof need show handl everi tripl properli follow case handl assum pass isomorph test case 1 pass isomorph test 0 tripl b c two tree resolv differ unresolv follow sinc creat refin contract 1 2 action take resolv tripl differ resolut case 2 involv tripl b c topolog b c 1 2 claim first step phase 1 pass topolog tripl b c see suppos b c unresolv b c resolv b c c b look node u v lca b 1 2 respect node w lcaa b c also lcaa b sinc b c unresolv infer f function defin lemma 44 node w contain speci c node w contain either b similar argument look repw comput homeomorph subtre 1 2 induc repw induc tree exist three speci x z x u v 1 2 z charact defin u v thu induc tree tripl x topolog x z induc tree neither star opposit orient caterpillar thu verif process termin output olc exist case 3 involv tripl b c resolv b c one tree unresolv proof case essenti follow line proof case 2 case 4 involv tripl b c unresolv tree claim second step phase 1 pass tripl unresolv see suppos b c resolv b c let lca b c x let lca also suppos without loss gener x parent let 1 child 2 ff 1 let 2 child b 2 ff 2 let z 6 child x c 2 ff z let b c b c look function f 1 f 2 defin lemma 44 v v 1 respect v note cluster defin child u nonempti intersect one ff 1 ff 2 similarli v thu repres chosen ff 1 ff 2 respect least common ancestor u 1 v 2 howev f 1 z 1 v thu repres chosen ff z lie u v 1 2 respect caus us conclud olc exist 2 5 pessimist local consensu recal definit pessimist local consensu two root tree leaf set root tree call pessimist local consensu 1 2 iff tripl b c jfa b 51 character follow theorem character plc tree two tree 1 theorem 51 let 1 2 two tree leaf set pessimist local consensu tree plc 1 2 exist ident equal ct proof pick cluster ff 2 ct sinc ff belong tree look tripl ff tripl resolv x z thu convers pick cluster two subcas 1 ff compat least one ct 1 ct 2 case theorem 21 2 ff compat ct 1 ct 2 case pick node 1 defin smallest cluster contain ff pick tripl b c ff tripl unresolv either 1 2 thu construct phase theorem 51 pessimist local consensu tree exist ident strict consensu tree thu construct pessimist local consensu tree suffic use algorithm 6 strict consensu tree 53 verif phase let 1 2 input tree let strict consensu tree construct use algorithm 6 want abl verifi whether actual pessimist local consensu case star 1 2 alreadi star noth verifi sinc true pessimist local consensu assum case two case consid first either 1 2 say 1 least two children root leav second case 1 2 exactli one child root leaf made observ case appli divid conquer strategi adopt binari local consensu problem lemma 51 suppos 1 2 two tree leaf set 1 least two children root leav let ff 1 ff l maxim cluster 1 maxim cluster 2 pessimist local consensu star iff proof suppos 1 mean 8x lcax 1 root 2 lcax root thu tripl x topolog 1 2 agre thu star suppos defin node leaf look ff k node 1 defin ff k leaf node two case handl either least one speci ff k fi j speci ff k fi j ie ff k ae fi j former case pick speci z ff k fi j also pick two speci x ff agre tripl x name tripl topolog x z tree thu star latter case sinc know fi j 6 pick two speci x ff k anoth speci z gamma fi j 1 2 topolog tripl x z thu star 2 sinc speci belong one maxim cluster tree test done linear time follow lemma handl case 1 2 exactli one child root leaf lemma 52 suppos 1 2 two tree leaf set pessimist local consensu star suppos 1 2 exactli one child root leaf let leav 1 children root let v lca 2 everi child v contain one speci x g moreov pair speci x g least common ancestor x 2 lie path v root proof suppos 9 child v contain least two speci gamma fs g pick x lie child v 2 pick lie differ child v find tree topolog tripl star furthermor 9x lcax 2 lie path v root tripl x would ident topolog tree wouldnt star 2 definit 51 root tree milliped set intern node defin singl path root leaf b c figur 4 exampl milliped g 2 js 1 milliped say let l children root 2 leav look 1 js 1 say either 1 one nonleaf child least two nonleaf children former case appli previou lemma infer milliped later case appli lemma 52 check pessimist local consensu star follow subsect show verifi star input tree milliped 531 verif input tree milliped proof follow lemma straightforward lemma 53 suppos 1 2 two milliped leaf set pessimist local consensu star iff exist tripl tree topolog tripl describ linear time algorithm verifi 1 2 tripl topolog defin order speci 1 use function f distanc root 1 h height 1 2 write union set sequenc 1 height 2 contain exactli speci distanc root 2 replac speci set fs call multiset integ thu get sequenc multiset definit 52 say tripl integ p q r special observ pessimist local consensu 1 2 star iff special tripl p q r exist follow algorithm check plc take input sequenc return fail exist special tripl integ otherwis return pass check plc work scan multiset th iter make use three variabl global min local min temp start th iter global min store smallest integ seen first multiset variabl local min use store smallest integ 9b b 2 local min initialis 1 variabl temp initialis 0 long temp remain 0 local local min store temp store b previous mention realtionship b hold th iter check plc either return fail special tripl exist necessari modifi variabl global min local min temp hold intend valu first multiset sequenc reason store valu start th iter follow 9p p q r special tripl global min togeth q r 2 also special tripl sinc global min p similarli 9p j q 2 l p q r special tripl local min temp r 2 also special tripl describ check plc initialis global local procedur output fail termin pessimist local consensu star output pass otherwis f 2 f scan jaj 2 output fail 2 local global f scan either jaj 2 jbj 1 output fail els global min minm set local min global min global min minm set local min global min 2 global output pass analysi run time check plc run linear time sinc scan constant number time theorem 52 algorithm check plc correct proof induct observ step 1 execut th iter 8j l x follow step 1 execut th iter start iter local thu case global min store smallest integ seen first multiset first multiset special tripl p q r exist q r 2 check plc correctli output fail sinc global min p otherwis two case depend upon valu variabl global min temp local min updat global min hold smallest valu first multiset also local min correctli hold smallest valu exist b store temp b 2 case 0 case global min updat hold minm smallest valu first multiset observ temp updat store nonzero valu never store 0 thu temp set nonzero valu iter 0 iter iter k step 2 execut assum step 2 execut iter 0 assum induct start iter 0 global min store smallest valu first multiset local min store smallest valu exist b store temp b 2 iter 0 easili seen check plc correctli output fail exist special tripl p q r case ensur iter 0 global min store smallest valu first 0 multiset local min store smallest valu exist b store temp b 2 use argument seen check plc give correct output sequenc multiset 2 thu also follow theorem theorem 53 given two milliped 1 2 check pessimist local consensu star linear time 6 relax version local consensu rule seen far output tree satisfi particular rule need exist motiv need look relax version local consensu solut alway exist recal definit relaxedaccord local consensu relax discord local consensu exist solut problem shown section 22 61 relaxedaccord local consensu subsect show relax accord local consensu two binari root tree 1 2 actual strict consensu two tree theorem 61 1 2 two root binari tree relaxedaccord local consensu alway exist ident strict consensu 1 2 proof exist relaxedaccord local consensu tree shown section 2 show tree strict consensu tree suppos exist tripl b c resolv differ 1 2 say b c b c respect say lca 1 neither ff u ff v strict consensu tree thu strict consensu tree leav unresolv tripl differ topolog 1 2 let 0 tree everi tripl b c 1 2 differ 0 unresolv topolog tripl suppos possibl 0 contain cluster intersect set cluster 1 2 let ff cluster suppos without loss gener ff cluster 1 0 pair speci x 2 ff speci z 62 ff topolog x z howev also case 1 1 must also possess cluster ff contradict assumpt thu must exist pair speci speci z 62 ff 1 topolog x z impli relaxedaccord local consensu henc candid 0 relaxedaccord local consensu contain cluster intersect cluster set 1 2 0 contain proper subset cluster intersect set cluster 1 2 exist tripl b c 0 unresolv topolog strict consensu tree resolv topolog agre topolog 1 2 henc strict consensu 1 2 relaxedaccord local consensu 1 2 2 consequ relaxedaccord local consensu construct time use algorithm 6 need verifi tree construct correct 62 relaxeddiscord local consensu relaxeddiscord local consensu rdlc problem requir tripl tree 1 2 agre must topolog preserv consensu tree leav unresolv maxim set tripl 1 2 disagre previous show rdlc exist show uniqu construct rdlc accomplish defin set bcg set root tripl pass algorithm aho et al 2 comput tree exist requir form everi tripl set resolv minimum number addit tripl outsid set algorithm take opn time case p 2 3 use algorithm would result run time 4 obtain speedup 2 algorithm includ verif construct relaxeddiscord tree use fact tree necessarili exist algorithm howev take advantag idea 2 begin briefli describ algorithm work 621 assu algorithm 2 aho et al describ algorithm determin famili constraint least common ancestor relat satisfi within singl root tree describ simpl algorithm give case constraint given root resolv tripl z input algorithm work topdown figur cluster children root recurs algorithm maintain disjoint set initi leav singleton set root tripl x z algorithm union set contain x indic x must lie child root algorithm never union set unless forc recurs call includ constraint speci entir contain compon discov previou call speci seen compon either initi recurs call algorithm determin constraint simultan satisfi simpl algorithm worst case behavior opn p lca constraint underli set n element leav final tree 622 improv algorithm rdlc describ algorithm solv rdlc 2 time sinc 1 consist tripl agre clear tree produc assu algorithm refin tree follow sens child root 1 well repres cluster union cluster repres children root let ff cluster child root 1 let fi cluster child root 2 ff fi union cluster children root fact ff fi nonempti ff fi also union cluster children root show except one special case ff fi fact cluster exactli one child root fi z ff fi z x form tripl within 1 2 henc z would lie child root thu case ff fi cluster child root case ff occur one child root 1 one child root 2 follow lemma show lemma 61 let 1 2 2 tree leaf set let ff 1 ff k cluster defin children root 1 l cluster defin children root 2 case ff occur one one j proof suppos let ff ff fi j sinc ff impli contradict sinc fi j fi j cluster defin children root henc disjoint 2 case ff handl follow identifi lca say u speci similarli lca say v speci gamma fi 1 clearli 2 u descend node defin fi 1 v descend node defin ff node path start node defin fi end node u let cluster defin children path node path similarili identifi cluster defin children node path 1 start node defin ff node v union pair x whenev x lie ff fl whenev lie get partit compon turn exactli cluster present children root character highlevel descript algorithm construct given follow rdlc construct algorithm 1 pair maxim cluster ff 2 recurs comput tree ff fi make root child root 2 cluster ff fi ff comput partit recurs comput tree compon partit make root tree children root run time analysi note algorithm requir explicit verif construct tree sinc fact know tree exist simpli comput mimick effici algorithm 2 would creat n recurs stage show stage implement prove 2 bound case 2 handl time follow build graph vertic label speci ff fi connect vertic ff fl path j vertic find connect compon graph time connect compon comp find homeomorph subtre 1 2 whose leaf set comp recurs subtre task common case describ discuss case 1 handl case 1 import wast time empti intersect consid speci turn label intersect speci lie thu identifi n nonempti intersect let ff fi one intersect need find homeomorph subtre 1 ff fi leaf set show time proport number leav ff fi assum 1 2 preprocess least common ancestor queri also note know lefttoright order leav 1 well 2 given leav lefttoright order also known one induc overal lefttoright order lemma 42 reconstruct topolog tree linear time exactli need show one stage recurs accomplish time overal time algorithm 2 clearli case handl linear time occur one pair children 7 polynomi time algorithm arbitrari local consensu rule show section polynomi time algorithm construct local consensu tree begin discuss case f partial local consensu function lemma 71 aho et al2 let multiset k root tripl leaf set n determin okn log n time tree exist jt homeomorph 2 15 algorithm given problem address 2 case tripl resolv case faster algorithm obtain lemma 72 henzing king warnow 15 let multiset k resolv root tripl leaf set n determin minfok whether tree exist jfa b cg homeomorph root tripl tripl exist theorem 71 let f arbitrari partial local consensu function set k evolutionari tree determin local consensu tree exist construct okn 3 time proof given f tripl determin form f ja tripl f ja restrict form okn 3 time previou lemma determin partial local consensu tree exist construct 25 time total time therefor bound cost comput tripl 2 partial local consensu tree construct okn 3 total local consensu tree comput even faster lemma 73 kannan lawler warnow 13 given oracl answer queri form jfa b cg speci set fa b cg construct 2 tree consist oracl queri exist orn log n time tree degre bound r theorem 72 let f total local consensu function given set k root tree n speci construct okn 2 time flocal consensu tree f exist f alway return resolv subtre comput f okn log n time proof implement oracl determin form homeomorph subtre f tripl b c first preprocess tree answer least common ancestor lca queri constant time use 18 answer queri need ok time 13 need 2 queri 2 addit work total cost okn 2 gener case f degre bound r total cost okrn log n f alway return resolv subtre f binari total cost okn log n 2 8 discuss conclus sever approach taken handl problem resolv multipl solut one approach find maximum subset 0 induc homeomorph subtre subtre call maximum agreement subtree14 10 17 primari disadvantag approach return evolutionari tree entir speci set howev connect problem one local consensu method tree produc relax discord local consensu method contain maximum agreement subtre homeomorph subtre hard see approach take requir resolut inconsist repres singl evolutionari tree entir speci set classic problem area tree compat problem also call cladist charact compat problem7 8 9 tree compat problem say set tree compat tree exist everi tripl resolv resolv problem solv linear time12 19 weak approach practic mani data set incompat therefor necessari abl handl case pair tree resolv tripl differ approach type strict consensu median tree problem model state term unroot tree instead cluster charact ie bipartit speci set use repres tree use charact encod consensu tree measur fit input strict consensu seek tree charact appear everi tree input median tree hand defin metric root tree defin cardin symmetr differ charact set 1 2 given input tree median tree minim p median tree comput polynomi time nice character term charact encod 4 16 6 notion relat version local consensu problem relev local consensu tree alway contain least much inform tree work repres paper extend sever direct note local consensu function local consensu tree set k tree comput time polynomi k mani local consensu tree construct okn time r design analysi comput algorithm formal theori consensu median procedur ntree mitochondri dna sequenc primat tempo mode evolut optim algorithm compar tree label leav optim evolutionari tree comparison spars dynam program numer method infer evolutionari tree effici algorithm infer evolutionari tree determin evolutionari tree maximum agreement subtre set evolutionari tree metric effici algorithm fast algorithm construct root tree constraint complex median procedur binari tree comput maximum agreement subtre fast algorithm find nearest common ancestor tr