constraintbas mode analysi mercuri recent logic program languag mercuri hal requir type mode determin declar predic inform allow gener effici target code detect mani error compiletim unfortun mode check languag difficult one main reason predic mode declar compil requir decid part procedur bind variabl conjunct predic definit reorder enforc behaviour current mode check system limit possibl mode may use keep track alias inform limit abil infer mode sinc infer perform reorder paper develop mode infer system mercuri base map predic system boolean constraint describ variabl produc allow us handl program support exist system b introduct logic program languag tradit untyp unmod recent year languag mer permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee ppdp02 octob 68 2002 pittsburgh pennsylvania usa curi 19 shown strong type mode system provid mani advantag type mode determin declar mercuri program provid use document develop also enabl compil gener ecient code improv program robust facilit integr foreign languag inform gain declar also use mani program analys optimis mercuri mode system describ languag refer manual express allow programm describ complex pattern dataflow ever implement mode analysi system current releas melbourn mercuri compil limit remov much express see 8 particular current mode analys allow construct partial instanti data struc ture case allow fill anoth limit mode infer prevent reorder order limit number possibl examin eect limit hard write mercuri program use anyth basic mode possibl write program certain type data flow well limit way describ current mode analysi algorithm also complic combin sever conceptu distinct stage mode analysi singl pass make modif algorithm eg includ miss function quit dif ficult algorithm also quit ineci analys code involv complex mode paper present new approach mode analysi mercuri program attempt solv problem current system separ mode check sever distinct stage use constraint base approach natur express constraint aris mode analysi believ approach make easier implement extens mode analysi system mercuri overcom limit current system associ program variabl set posi tion correspond node type graph key idea new mode system identifi posit type variabl posit produc ie goal bind part variabl function symbol associ node type graph goal program variabl occur boolean variabl indic whether node graph program variabl bound within goal given boolean variabl describ constraint aris correct mode term boolean constraint repres manipul descript use standard data structur reduc order binari decis diagram robdd allow constraint individu posit dierent data structur obtain much precis analysi current mercuri mode system start 11 consider research mode infer check howev work base assumpt dier least one two signific respect type reorder almost work mode analysi logic program focus untyp languag mainli prolog consequ paper use simpl analysi domain ground free unknown one use pattern code deriv detail programspecif domain eg 3 10 12 analys must sacrific much precis achiev accept analysi time 18 propos fix problem requir type inform use type variabl domain mode analysi sever paper sinc eg 14 17 base similar idea like paper mode infer enc also assum program analyz without reorder therefor use mode describ program execut wherea interest use mode prescrib program execut order insist compil must exact inform instanti state mode analysi system likewis work much simpler domain exampl ground prolog 9 recogn two instanti state relat work mode check concurr logic program languag logic program languag coroutin 1 5 7 emphasi detect commun pattern possibl deadlock constraintbas mode analysi awar mode flat ghc 4 mode flat ghc reli posit claus head guard versu bodi determin unif allow bind variabl significantli simplifi problem constraint gener equa tional reli delay complex case three occurr variabl goal work constraintbas analysi mercuri particular work 20 constraintbas bindingtim analysi notabl similar basic approach use constraint po sition type tree variabl express data flow depend howev bindingtim analysi dierent object mode analysi fact analysi requir result mode analysi avail section 2 give background inform rest paper depend section 3 briefli outlin current approach weak section 4 give simplifi exampl constraintbas system present full system section 5 section 6 show result analysi use select execut order goal conjunct section 7 give preliminari experiment result 2 background mercuri pure declar logic program languag design construct larg reliabl ecient softwar system team programm 19 mercuri syntax similar syntax prolog mercuri also strong modul type mode determin system catch larg fraction programm error enabl compil gener fast code rest section explain main featur mercuri relev paper 21 program definit predic mercuri goal contain atom conjunct disjunct negat thenels simplifi algorithm compil convert definit predic call superho mogen form 19 form predic defin one claus variabl appear given atom clude claus head distinct atom one follow three form paper assum unif neither side variabl appear outsid unif unif meet requir influenc execut program thu delet simplic also assum negat replac ifthenels one replac g g fail true abstract syntax languag deal therefor written atom goal rule order describ variabl becom bound algorithm need abl uniqu identifi subgoal predic bodi code subgoal serv identifi sinc piec code may appear predic definit therefor use goal path purpos goal path consist sequenc path compon use repres path zero compon denot entir procedur bodi goal path p conjunct goal path pcn denot nth conjunct goal path p disjunct goal path pdn denot nth disjunct goal path p ifthenels goal path pc denot condit pt denot part pe denot elsepart definit 1 parent goal path pcn pdn pc pt pe goal path p function parentp map goal path parent definit 2 let g set variabl occur within goal g let g g set variabl nonloc goal g ie occur insid outsid g conveni also defin set goal sinc goal path uniqu identifi goal sometim appli oper goal goal path 22 determinist regular tree grammar order abl express dierent use mode program variabl must abl talk individu part term program variabl abl take valu finit manner use regular tree express tree grammar signatur set pair fn f function symbol n 0 integ ariti f function symbol 0 ariti call constant given signatur set tree herbrand univers denot defin least set satisfi ft1 tn t1 tn simplic assum contain least one constant let v set symbol call variabl set term v denot v similarli defin least set satisfi ft1 tn t1 tn v tree grammar r signatur nontermin set nt finit sequenc product rule form x x nt form fx1 xn fn x1 xn nt tree grammar determinist regular x nt fn one rule form x fx1 xn breviti shall often write tree grammar compress form use x sequenc product rule x t1 x t2 23 type type mercuri polymorph hindleymiln type type express type term languag type vtype type type constructor variabl vtype type paramet type constructor fn type must definit definit 3 type definit fn form v1 vn distinct type paramet f1m1 fkmk tree distinct tree con structorar pair 1 type express involv paramet v1 vn clearli view type definit f simpli sequenc product rule signatur tree nontermin set type vtype order avoid type express depend infinit number type restrict type definit regular 13 essenti regular ensur type grammart defin finit exampl 1 type definit list simpl type abc includ constant b c associ nonparamet type express product rule defin topmost symbol type let type express form ft1 tn let fn type definit form definit 3 defin rulest product rule fv1 vn fv1 vn vtype defin rulest empti sequenc extend notat associ tree grammar type express let grammart sequenc product rule recurs defin oper concaten sequenc product rule remov second later occurr duplic product rule call nontermin set product rule po sition sinc use describ posit term posit root one term subterm also sometim call posit node sinc correspond node type tree exampl 2 consid type listabc correspond grammar listabc abc two nontermin thu two posit grammar listabc abc mode infer check take place type check ing assum know type everi variabl appear program 24 instanti mode instanti describ bind pattern variabl particular point execut program mode map one instanti anoth describ instanti variabl chang execut goal instanti also defin use tree grammar dierenc instanti associ predic involv instanti paramet polymorph modesalthough possibl extens two base instanti free ground repres complet uniniti variabl complet bound term instanti express term inst vinst definit 4 instanti definit g inst form inst gw 1 wn boundg 1 1 w1 wn distinct instanti paramet g1m1 gkmk tree distinct tree constructor instanti express inst free ground vinst associ set product rule rulesi instanti express type expr sion base instanti defin exampl 3 exampl instanti definit inst list skeli bound list skeli defin instanti list skeli variabl instanti must bound either empti list con cell whose first argument instanti given instanti variabl whose tail also instanti list skeli exampl list skelfre describ list element free instanti usual intend use specif type eg list skeli listt normal list function symbol variabl type bound instanti inst non empti skeli boundi list skeli repres kind subtyp variabl whose instanti non empti skelfre bound definit 5 mode f map initi instanti final instanti f common mode shorthand express eg ground ground goal chang instanti state posit free ground said produc bind posit goal requir initi instanti state posit ground said consum posit 3 current mode analysi system mode analysi algorithm current use mercuri compil base abstract interpret abstract domain map program variabl instantia tion mode analysi compil creat separ procedur mode usag predic analys procedur separ start initi instanti state argument given mode declar analysi travers procedur bodi goal determin instanti state variabl point goal travers conjunct conjunct abl schedul need input variabl sucient bound delay tri later goal analys unschedul subgoal comput final instanti state argument match final instanti state mode declara tion procedur determin mode correct see 8 detail although paper talk languag approach mercuri similar system also abl mode infer predic export defin modul use top travers modul howev prevent combinatori explos mode analysi algorithm reorder conjunct perform arriv call assum call predic suppos abl run given variabl bound left mode analysi system sever task must 1 determin produc consum variabl 2 reorder conjunct ensur consum variabl execut produc 3 ensur subtyp constraint met lead complic implement one aim constraintbas approach simplifi analysi split task distinct phase done separ 31 limit two main problem approach first keep track alias informa tion two consequ first without mayalia inform bound node handl uniqu data structur nontrivi manner particular implement compiletim garbag collect second without mustalia inform free node accur mode analysi code manipul partial instanti data structur partial instanti data structur data structur contain free variabl use one want dierent part data structur fill dierent part program exampl 4 consid follow small program pred lengthlistint int mode lengthfre listskelfre det lengthl n pred iotalistint int mode iotalistskelfre ground det goal lengthl 10 iotal 3 length2 construct skeleton list specifi length iota2 fill element list current system unabl verifi mode correct second disjunct iota2 one problem disjunct set alia variabl h first element l initi free variabl instanti h unifi second argument without inform alias h first element l mode checker unabl determin also instanti first element l second problem absenc reorder mode infer prevent mani correct mode detect exampl 5 consid mode infer predic pred append3listt listt listt listt infer find mode app3inininout find mode app3outoutoutin reorder restrict simpli lift without current mode infer algorithm explor arbitrarili larg number mode fact useless sinc look ahead see mode infer call predic use construct desir mode current predic 4 simplifi exampl motiv constraint base mode analysi system avoid problem current system order break mode analysi problem phase first phase determin subgoal produc variabl second use inform determin execut order procedur focu first task return second section 6 eas explan first show simplifi form approach simplifi form requir variabl instanti ie two instanti state recogn free ground requir variabl eventu reach ground state avoid complex aris dierent part variabl bound dierent time part left unbound address complex give full algorithm section 5 41 constraint gener algorithm associ sever constraint variabl program variabl everi program variabl v associ famili constraint variabl form vp vp true v produc goal path p predic bodi explain algorithm use append3 code shown transform compil superho mogen form describ section 21 also ensur variabl appear one argument one functor ad extra unif necessari pred appendlisttlisttlistt appendat b ct examin bodi gener constraint bodi disjunct constraint get simpli specifi variabl nonloc disjunct disjunct produc variabl disjunct must produc variabl disjunct produc variabl disjunct may produc variabl append express constraint 1 2 process disjunct one anoth disjunct conjunct process conjunct algorithm consid variabl occur conjunct one potenti produc variabl nonloc conjunct may produc either insid outsid conjunct variabl share two conjunct may produc one conjunct algorithm gener constraint make sure variabl exactli one produc variabl local constraint say exactli one conjunct must produc variabl variabl non local constraint say one conjunct may produc variabl first disjunct variabl share among conjunct constraint get one say nonloc produc conjunct produc conjunct appear first conjunct first disjunct yield nontrivi constraint intuit lack constraint goal reflect fact use produc test valu second conjunct first disjunct yield one con straint say goal use produc one b c second disjunct gener constraint analog first conjunct nonloc variabl disjunct unlik first contain share local variabl ah ch ct appear two conjunct constraint variabl state variabl must produc exactli one conjunct appear first conjunct second disjunct show handl unif form key understand behavior algorithm case know tri decid two altern either unif take input produc x take x input produc contrari peopl experi real program unif form also use way make bind produc subset howev use unif way requir x input possibl produc outsid unif transform program su perhomogen form make sure unif form fresh variabl right hand side could produc would replac right hand side unif new variabl addit new unif convert unif take x input unif take x input produc variabl right hand side variabl right hand side appear variabl must unbound use unif produc x would creat nonground term sinc simplifi approach consid nonground term case gener extra constraint requir x input goal case ah ah appear elsewher get constraint first say either goal produc variabl right hand side produc none conjunct first second constraint say goal produc variabl left hand side variabl right hand side constraint get analog equat act equat first disjunct gener last conjunct call case recurs call assum call predic scc caller mode 1 mean call produc ith argument predic bodi produc ith argument lead one constraint argument posit conclud set constraint gener algorithm append 42 infer check constraint gener predic use infer mode project onto head variabl constraint set built five dierent solut append five mode b c appendin b c appendin b c appendout b c appendout b c appendin five mode two appendin appendout call princip mode three impli mode exist impli exist princip mode chang mode argument make job predic strictli easier rest pa per assum everi predic set mode downward close mean contain mode pm also contain mode impli pm prac tice compil gener code mode declar princip mode synthes mode caller renam variabl insert extra unif synthesi superhomogen form equival replac append1 2 3 append1 2 x solut also implicitli assign mode primit goal bodi specifi variabl produc exampl solut assign true constraint variabl c c 1 c 1 fals other correspond mode appendininout also show deconstruct ie use field defin ah construct ie bind c new heap cell case valu constraint variabl head variabl uniqu determin valu constraint variabl sometim one set valu assign constraint variabl bodi consist given valu assign constraint variabl head case compil choos assign prefer 5 full mode infer 51 expand grammar consid problem handl program dierent part variabl may instanti assumpt somewhat restrict set allow wellmod program howev found unreason restrict practic come across case typic mercuri program one would want make recurs call dierent mode dierent goal need ensur two distinct posit variabl may dierent instanti haviour way refer separ henc need expand type grammar associ variabl begin empti grammar origin code predic express superhomogen normal form modifi grammar predic bodi first stage mode analysi unif appear definit predic x grammar rule functor fn add rule alreadi occur grammar rule head claus replac occurr program add equat x grammar rule x fb1 bn replac equat process may add equat form one x occur nowher els equat safe remov process unif add copi rule rulest grammar variabl v type exampl 6 superhomogen form usual sourc code append variant aah cah ct appendatbct second claus algorithm replac aah cch ct yield form shown section 4 expand comput append nontermin grammar constitut set posit creat constraint variabl gener constraint predic bodi use nontermin posit well node interchang note nontermin denot toplevel functor everi variabl variabl eg nontermin denot nontoplevel functor well note also nontermin fulfil function one variabl strictli part anoth exampl nontermin ah stand variabl ah first element list bound variabl variabl b c unifi comput path nontermin predic need three boolean variabl posit true posit produc outsid predic b v true posit produc insid predic c v true posit produc somewher either insid outsid predic note v v v definit 6 let pn tupl h1 hn head variabl ie formal paramet predic pn definit 7 expand grammar posit x defin immedi descend x set posit reachabl x gener constraint two variabl alway type need abl refer posit within two variabl correspond eg ah ch denot correspond posit insid c notion correspond use allow two variabl expand dierent extent expand grammar exampl descend nontermin append b even though type unif b nontermin b would correspond well definit 8 expand grammar posit x defin set pair correspond node x x w1x wn conveni also defin pair ntupl x1 definit 9 given expand grammar rule say x parent node node y1 yn 52 mode infer constraint ensur variabl occur one pred icat renam necessari construct expand grammar p program modul com pile next group predic modul stronglyconnect compon scc process scc bottom creat function cscc scc repres boolean constraint gener predic scc remaind section defin cscc constraint function cscc scc conjunct constraint function c pred pn gener predic pn scc ie cscc constraint function infer predic pn constraint function scc ie c inf pn c inf pn may stricter c pred pn pn alon scc predic defin modul deriv c inf mode declar use mechan describ section 53 c pred conjunct two function c struct structur constraint relat variabl goal constraint predic bodi goal c pred ph1 hn defin c struct c goal 521 structur constraint v proposit v bound call v proposit v bound return v proposit v bound predic constraint relat relationship variabl relationship bounded dierent time node reachabl one predic argument variabl bound call node bound return bound call produc within predic bodi node may bound call produc predic bodi node bound call parent node must also bound call similarli node bound return parent node must also bound return c struct v v v exampl 7 append structur constraint ah ah ah ah ah ae ae ae ae ae ch ch ch ch ch ct ct ct ct ct ce ce ce ce ce ah ah ae ae b b ch c ch c ct c ct c ce ct ce ct 522 goal constraint boolean variabl vp path p contain program variabl x v x variabl repres proposit posit v produc goal refer path p constraint gener goal fall two categori gener constraint appli goal type gen constraint specif goal type c goal complet set constraint goal ccomp conjunct two set gener constraint two compon first node reachabl variabl local goal bound return produc goal second c ext say node reachabl variabl v extern goal g ie occur g produc g conjunct definit c ext could variabl predic occur g howev variabl v occur gs parent goal parent c goal constraint wont mention v point creat constraint variabl v g 523 compound goal constraint gener kind compound goal conjunct disjunct ifthenels shown figur 1 case goaltypespecif constraint conjoin complet set constraint subgoal conjunct goal posit produc one conjunct disjunct goal node either must produc disjunct produc disjunct ifthenels goal node produc ifthen els produc either condit branch els branch node may produc condit branch node reachabl variabl nonloc ifthenels must produc condit node reachabl nonloc variabl produc branch must also produc els branch vice versa 524 atom goal due space consider leav discuss higherord term may handl simpl extens modecheck algorithm consid three kind atom goal 1 unif form 2 unif form 3 call form qy1 yn unif form may produc one pair correspond node mercuri allow alias exist unbound node node reachabl variabl involv unif must produc somewher 2 unif goal path p constraint c goal exampl 8 unif append goal path d1 c2 constraint gener 2 goal schedul phase requir node must produc alias anoth node two restrict togeth disallow use partial instanti data structur futur mercuri implement handl consequ would like lift restrict unif form yn path p produc argument y1 yn x must produc somewher either p somewher els constraint c goal exampl 9 unif append goal path d2 c1 constraint gener call qy1 yn constrain node reachabl argument call predic current scc allow recurs call mode caller constraint c goal p qy1 yn vw qni 1 n vwp v w first part ensur call produc posit posit produc predic scc second part ensur call variabl w produc somewher requir bound call call v true v true cant mistakenli use call site produc w exampl 10 recurs call appendatbct goal path d2 c4 append constraint gener first argument call predic lower scc constraint similar must existenti quantifi head variabl possibl call predic dierent mode dierent place within current scc c goal p qy1 vw qni 1 n v wp v w 53 mode declar constraint predic mode declar mode analysi system check declar infer mode inform involv gener set constraint mode declar ensur consist constraint gener predic bodi declar constraint c decl predic set mode declar disjunct constraint c decl mode declar dd c decl constraint c decl mode declar pm1 mn predic ph1 hn conjunct constraint c arg mh argument mode correspond head variabl h c struct h1 hn structur constraint use determin h variabl h h constraint c arg mh argument mode head variabl h conjunct constraint c goal p g1 gn figur 1 constraint conjunct disjunct ifthenels c init h initi instanti state constraint c fin f h final instanti state f constraint c init h initi instanti state head variabl h given w h w constraint c fin h final instanti state head variabl h given c fin c fin ground w h w c fin mode check simpli determin declar mode least strong infer mode declar mode predic pn check whether implic hold doesnt declar mode incorrect given declar mode predic pn use shortcircuit calcul scc sinc use c decl mode infer predic qm call pn exampl 11 given mode definit mode lsg listskelfre ground mode declar give c decl d1 ignor v variabl ah ae b c ch ct ce ah ae b c ch ct ce show c decl d1 c inf append3 6 select procedur execut order gener constraint scc solv constraint constraint solu tion posit consum produc report mode error constraint solu tion solut give mode predic scc set solut thu defin set mode predic need find feasibl execut order mode predic scc algorithm find feasibl execut order take solut input given mode predic correspond sever solut sucient one feasibl order main problem find feasibl schedul mode analys code gener distinct view mean produc posit variabl grammar gener append exampl nontermin ah repres valu variabl ah valu first element variabl forward mode append ah true mode analys consid ah produc caller even execut enter append howev far code gener concern produc ah unif ahat cater diverg view separ notion variabl produc notion variabl visibl definit 10 given expand grammar assign boolean valu constraint variabl predic pn make constraint c inf pn true model c inf pn write c inf pn definit 11 given model c inf pn defin set node produc goal path p produc definit 12 given model c inf pn defin set node consum goal g goal path p formula shown figur 2 unif form say node one side equat consum correspond node side produc due symmetr natur relationship v 1 v 2 correspond w v 1 consum v 2 consum v 1 produc produc also possibl pair correspond node neither produc consum unif mean one two thing subterm x node alreadi bound unif test equal subterm still free creat alia note unif produc either top level node x call assign unif unif form node x consum produc node ever consum reason latter half rule grammar use nontermin eg y1 first subterm x sinc unif mere creat alias correspond subterm x nontermin produc p v w x produc p produc p y1 ynqn c inf qn v w mvd produc p produc p produc p figur 2 calcul node consum posit produc unif produc produc elsewher note unif produc x call construct unif consum x call deconstruct unif call predic q know node actual paramet call model predic analyz say produc call need find model constraint q caus correspond node actual paramet q output sinc first stage analysi succeed know model exist consum node call node actual paramet correspond node formal paramet q requir input compound goal consum node union consum node subgoal minu node produc within compound goal exampl 12 mode append produc consum set conjunct path produc consum d2 c4 ct ce aebb neither disjunct produc posit also con sume therefor order algorithm requir node produc consum would find order accept hand code gener fussi exampl emit code recurs call need know variabl ah store even bound yet need concept visibl definit 13 variabl visibl goal path p variabl head variabl appear predic bodi somewher left p function make visibl need visibl defin figur 3 respect determin whether goal make variabl visibl requir visibl exampl 13 given mode append make visibl need visibl set conjunct path make visibl need visibl algorithm need find conjunct bodi order conjunct produc node come consum variabl made visibl point need visibl travers predic bodi top conjunct construct direct graph whose node conjunct initi graph edg c c j c produc node c j consum graph cyclic mode order fail isnt tri add edg keep graph acycl sort variabl need visibl anywher conjunct also made visibl conjunct two class clear conjunct make visibl isnt variabl fall first class made visibl one conjunct conjunct make visibl also produc top level node forward mode append variabl fall first class variabl made visibl one conjunct ch need visibl conjunct conjunct variabl add edg conjunct make variabl visibl conjunct c j need visibl graph still acycl start search space map map variabl second class conjunct make variabl visi ble look map result acycl graph add link select make visibl conjunct variabl correspond need visibl conjunct also happen conjunct need variabl visibl none goal conjunct make visibl variabl made visibl goal left whole conjunct anoth conjunct enclos one everyth fine isnt order enclos conjunct would alreadi fail conjunct make variabl visibl conjunct whole need visibl map yield acycl graph procedur mode error map algorithm gener two choic make pick acycl graph pick order conjunct consist graph make visiblem p g make visibl pc gc make visibl pt g make visibl pe ge need visiblem need visiblem need visiblem pccte need visibl ppc gpc make visibl p g figur 3 calcul make visibl need visibl node forward mode append consum input predic order constraint produc consum first disjunct visibl constraint either given der second disjunct visibl requir dictat must occur appendat b ct make ah visibl quir leav compil appendat b ct graph complet fix order con junct parallel implement may choos execut sever conjunct parallel although case would worth like implement may choos schedul recurs call last ensur tail cursion old mode analys need program transform separ mode analysi 15 introduc tail recurs predic like 7 experiment evalu analysi implement within melbourn mercuri compil repres boolean constraint reduc order binari decis diagram robdd 2 use highlyoptimis implement schacht 16 shown robdd provid ecient represent logic program analys base boolean domain robdd direct acycl graph common subexpress merg provid ecient canon represent boolean function worst case size robdd exponenti number variabl practic howev bit care worstcas behaviour usual avoid use number techniqu keep robdd small ecient possibl present preliminari result show feasibl analysi time taken test run gateway select 950 pc 950mhz amd athlon cpu 256kb l2 cach 256mb memori run linux kernel 2416 tabl compar time mode check simpl benchmark column label simpl time simpl constraintbas system ground variabl present section 4 column label full full tabl 1 mode check ground simpl full old simpleold fullold cqueen 407 405 17 23 23 crypt 1032 1335 38 27 35 deriv 13166 32541 59 223 551 poli 1348 5245 63 21 83 prime qsort 847 1084 112 7 9 queen 386 381 9 42 42 queri 270 282 11 24 25 tak 204 201 2 102 100 constraintbas system present section 5 column label old time mode check current mercuri mode checker final two column show ratio new old system time millisecond averag 10 run constraintbas analys significantli slower current system partli obtain much inform program thu lot work exampl current system select fix sequenti order conjunct mode analysi order disallow partial instanti data structur wherea constraintbas approach allow possibl order consid build constraint appropri schedul select base execut model con sider exampl argument pass convent eg possibl introduc tail call whether execut sequenti parallel profil show much execut time spent build manipul robdd may worth investig dierent constraint solver propagationbas solver anoth possibl method improv overal analysi time would run old mode analysi first use new analysi predic old analysi fail interest observ dierenc simpl constraint system full system none benchmark requir partial instanti data structur abl analys simpl system case simpl system dierent full system othersparticularli bigger tabl 2 mode check partial instanti check infer infercheck iota 384 472 122 append copytre 150 6174 4116 benchmarksit significantli faster specul bigger benchmark benefit reduc number constraint variabl simpl analysi tabl show time program make use partial instanti mode current mercuri system simpl constraintbas system unabl analys time millisecond averag run iota benchmark program exampl 4 append benchmark classic append3 howev check version valid combin lsg mode declar copytre benchmark small program make structur copi binari tree skeleton element copi new free variabl time check column check program mode declar wherea infer column show time mode infer mode declar remov interest note save analysi time achiev ad mode declar particularli notabl copytre benchmark mode infer abl infer mani mode one declar similarli declar mode append reduc analysi time 210m 8 conclus defin constraint base approach mode analysi mercuri ecient current system mode check abl check infer complex mode current system decoupl reorder conjunct determin produc although describ implement handl mercuri construct higherord constraintbas mode analysi yet handl subtyp uniqu mode plan extend handl featur well explor advanc mode sy tem complic uniqu mode uniqu object store recov data structur polymorph mode boolean variabl repres pattern mode usag circular mode need clientserv program client server process model recurs loop cooper instanti dierent part data structur coroutin manner would like thank australian research council support 9 r direct type annot method experiment evalu gener abstract interpret algorithm prolog diagnos nonwellmod concurr logic program abstract interpret concurr logic languag static infer mode data depend logic program layer mode type synthesi ground prolog deriv descript possibl valu program variabl mean abstract interpret automat deriv mode declar prolog program practic abstract equat system polymorph type system prolog type static analysi applic ground analysi prolog lambdaprolog make mercuri program tail recurs mode analysi domain type logic program system precis mode logic program execut algorithm mercuri tr polymorph type system prolog graphbas algorithm boolean function manipul static infer mode data depend logic program abstract interpret concurr logic languag deriv descript possibl valu program variabl mean abstract interpret experiment evalu gener abstract interpret algorithm prolog type static analysi mode analysi domain type logic program make mercuri program tail recurs model check hal ctr lee naish approxim success set logic program use constrain regular type proceed twentysixth australasian confer comput scienc research practic inform technolog p6167 februari 01 2003 adelaid australia