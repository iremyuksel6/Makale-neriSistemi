analysi orparallel execut model discuss fundament limit orparallel execut model nondeterminist program languag orparallel correspond execut differ nondeterminist comput path parallel natur way repres state parallel execut nondeterminist program mean orparallel tree identifi three import criteria underli design orparallel implement base orparallel tree constanttim access variabl constanttim task creation constanttim task switch term constanttim mean time oper independ number node orparallel tree well size node prove three criteria simultan satisfi orparallel execut model base finit number processor unbound memori discuss detail applic result class logic program languag show result serv use way categor variou orparallel method propos field also discuss suitabl differ orparallel implemen strategi differ parallel architectur b introduct paper explor fundament limit orparallel execut model nondeterminist program languag use term nondet minism automatatheoret sens dont know nondetermin rather sens dont care nondetermin orparallel execut nondeterminist program involv parallel explor multipl search path aris due nondeterminist choic import subclass languag class logic program languag languag execut involv solut goal respect set claus orparallel aris whenev goal uni one claus head case correspond claus bodi execut parallel gener exploit orparallel use way speed solut search problem artici intellig applic symbol comput reason theorem prove natur languag analysi etc natur way repres state parallel execut nondeterminist program mean orparallel tree paper analyz execut model base orparallel tree base analysi upon follow three criteria ideal orparallel execut model 1 cost environ creation constanttim 2 cost variabl access bind constanttim 3 cost task switch constanttim use term constanttim mean time oper independ number node orparallel tree well size node connect criteria might appear remot rst actual deriv three princip oper nondeterminist program system sequenti parallel procedur call involv environ creation assign statement paramet transmiss involv variabl access bind resumpt success failur involv task switch criteria essenti state princip oper orparallel execut model perform ecient ie constanttim would ideal one could satisfi three criteria show paper ideal achiev orparallel model use nite number processor constanttim address memori appreci result consid sequenti execut logic pro gram sequenti execut model view special case orparallel execut model provid constanttim environ creation constanttim variabl access bind constanttim task switch latter oper also known backtrack requir undo bind variabl number variabl constant gener sinc depend upon depth search path might appear orparallel model perform back track henc three criteria satis reason correct nite processor assumpt orparallel tree orparallel task avail processor henc need task switch one make task switch constanttim oper directori tree method hc86 see achiev expens two oper import dierenc sequenti implement orparallel implement must support multipl bind valu variabl multipl bind possibl variabl pass refer procedur call dierent nondeterminist search path aris call assign dierent valu variabl logic program unic play role paramet transmiss multipl bind main caus nonconst time variabl access obviou without addit bookkeep bind applic variabl access arbitrari node orparallel search tree attempt make variabl access constanttim oper lead nonconst overhead oper exampl order facilit constanttim variabl access record bind variabl applic given node node environ creation aect gener nonconst number variabl inform must record fact least one criteria must sacric explain retrospect mani orparallel execut model logic program propos literatur a88 ak90 b84 c87 dlo87 hc83 hc86 h87 k86 l84 t89 w84 w87a three criteria provid natur scheme classifi variou orparallel method propos literatur name accord proper subset criteria satisfi treatment gener dhd warren w87b examin orparallel method especi variant argonn model dlo87 sri model w87a well hausman ciepielewski hc86 examin sever variat directori tree method hc83 studi encompass orparallel method base orparallel search tree three criteria brie mention work research w87a h87 hc86 main contribut work lie state criteria present form ii prove criteria satis togeth iii use basi classic remaind paper organ follow section 2 introduc essenti concept terminolog orparallel model form denit remark section 3 prove main result aid lemma consid possibl way solv problem show one criteria fail case section 4 discuss detail result context logic program section 5 use result basi classifi sever orparallel execut model nalli section 6 present brief summari conclus 2 notat terminolog keep paper selfcontain provid section denit technic term also introduc notat use later section denit nondeterminist program queri nondeterminist program set procedur denit form head bodi head form idpar procedur id may appear head one procedur denit syntact categori par stand possibl empti list formal param eter assum without loss gener refer paramet callbyrefer queri form procedur bodi consist sequenc statement either procedur call assign formal paramet remark follow assumpt made simplifi discuss aect technic result declar variabl given domain data valu also left unspeci ii nest procedur denit free nonloc variabl appear procedur denit iii control structur ifthenels etc absent denit singleassign properti variabl bound nondeterminist comput path remark gener wellknown singleassign properti nondeterminist languag suce restrict attent case sinc result easier prove without restrict 21 orparallel tree follow denit n stand possibl innit set node orparallel tree v possibl innit set variabl set domain term valu p set processor set memori locat multiprocessor system let ps denot powerset set jsj cardin denit orparallel tree local environ orparallel tree given nondeterminist program queri tree node associ continu local environ 1 root node tree queri associ continu set variabl appear queri local environ 2 nonroot node n creat result choos dierent procedur denit execut rst call bodi ns parent node continu node n consist statement bodi chosen procedur denit follow statement rst call parent n statement assum interpret environ n b local environ ln n set variabl present chosen procedur denit l remark node orparallel tree need number children node ie branch factor node ii branch factor bound constant determin program iii assum unbound suppli variabl variabl denit uniqu renam call set variabl two local environ disjoint one anoth denit two node n 1 orparallel tree say n lie path root tree either n 1 n 1 closer root n 2 latter case say n remark partial order ii sometim write n instead n denit global environ global environ gn node n orparallel tree union set variabl local environ lie path root tree n v 2 lxg remark assum n 1 sinc may introduc one distinct dummi variabl local environ node denit owner node access node bind node variabl v local environ node n 1 uniqu owner node v dene n 2 subset n call access node v access node n 3 subset access node call bind node v character term partial function speci bind node variabl v global environ node n due singleassign properti state earlier function b satis requir node unden bv set bind node mg remark access node variabl v valu v access bind node variabl v valu assign v ii character orparallel tree term owner bind access node base observ three basic oper perform variabl environ creation variabl bind variabl access iii everi bind node access node sinc variabl must access bound ie variabl bind special case variabl access proposit 1 uniqu properti bind node variabl v two distinct bind node n 1 lie path root proof let n 1 two distinct bind node ie n 1 suppos deriv contradict denit bind node n 1 bv henc bv n 2 bv n 2 sinc bind node henc n 1 contradict end proof corollari bind node variabl given global environ uniqu exist denit valu cell valu variabl v local environ node n 1 set valu cell v valu cell memori locat use store valu v creat correspond bind node use partial function vc v n dene valu cell v global environ node n function vc satis requir vcv unden ov 2 onetoon correspondencey set bind node v set valu set valu speci partial dene valu v global environ node n bind node v ov valv unden b ov valv unbound c valv remark note valu cell alway refer cell alloc v local environ owner node v rather valu cell memori cell alloc hold bind gener bind node ii function valv n describ algorithm would abl predict valu given variabl particular environ even variabl get bound denit condit bind condit variabl bind variabl v said uncondit either bv ov branch factor everi node ov exclud bind node v one case variabl v said uncondit bound otherwis bind said condit v refer condit bound variabl condit variabl denit complet orparallel tree complet orparallel tree one 1 leaf node l continu l either empti success leaf node rst call l process due unden procedur failur leaf node 2 nonleaf node n child node present orparallel tree correspond procedur denit program use execut rst call ns continu remark incomplet orparallel tree one leaf nonleaf node extend creat child node ii possibl complet orparallel tree given queri program nontermin 22 comput model assum model comput unbound number memori locat access constanttim assum nite number processor ie jp j nite cooper assum two ident bind gener dierent bind node distinguish say use tag construct orparallel tree creat children node long tree incomplet order creat child node node n processor must rst move current node locat node n processor may assum locat root orparallel tree initi follow denit focu three import oper model comput task creation task switch variabl access denit task site task site incomplet orparallel tree node n least one untri procedur denit rst call ns continu denit task creation n task site processor said creat task node n construct global environ continu child node correspond untri procedur denit n time taken construct global environ child node n call cost task creation remark lowerbound cost task creation cost creat local environ child node n ii certain parallel scheme c87 l84 variabl bind copi child node local environ parent node local environ complet call regard work part task creation next call denit current environ current environ processor locat node n gn denit task switch processor said taskswitch move node n 1 node n 2 orparallel tree time taken processor chang current environ n 2 call cost taskswitch denit access cell everi variabl v access processor p node n memori locat call access cell use look bind v variabl access partial function dene access cell v environ processor p node n function ac satis requir acv p unden ov remark dierenc access cell valu cell former use look bind v variabl access wherea latter use store bind v variabl bind ii valu cell variabl access processor sinc contain bind gener variabl henc valu cell maintain privat processor contrari processor maintain access cell particular bind variabl v henc vc function p ac iii everi v n p valu associ access cell acv p n ident valu cell vcv n thu orparallel model ensur content valu cell ect access cell given environ method ensur valu cell access cell share physic memori locat hc83 b84 method keep physic separ copi bind valu cell access cell variabl bind gener w87 h87 denit variabl access process locat access cell acv p n processor p node n variabl v gn call variabl access time taken processor oper call cost variabl access remark locat nal bind variabl twostep process variabl access applic access cell locat b deref enc content bind cell use obtain nal bind dereferenc may involv indirect thu gener would nonconst time denit variabl access includ dereferenc conclud section restat three criteria ideal orparallel implement light discuss 1 cost task creation constanttim 2 cost variabl access constanttim 3 cost task switch constanttim constanttim mean time taken oper depend either size orparallel tree size continu similarli consid size set nonconst cardin proport depth size orparallel tree size continu size term creat execut exampl size set condit variabl global environ node nonconst sinc cardin proport depth tree 3 main result section prove three criteria simultan satis convent strategi proof would construct constanttim reduct known problem desir properti problem hand known problem solv problem hand solv howev awar problem could serv basi reduct therefor present altern essenti consid possibl way problem could solv show one criteria violat proof divid two main case 1 access cell valu cell ident sinc onetoon correspond valu bind node access valu reduc determin bind node prove corollari 1 method show gener bind node determin without violat one criteria lemma 1 consid case inform need locat bind node kept somewher orparallel tree ie combin owner node bind node access node lemma 2 consid case inform maintain datastructur independ node theorem 1 combin lemma 1 2 togeth 2 access cell valu cell separ method show lemma 3 taskswitch alway nonconst time oper final conclus lemma 1 2 3 theorem 1 use prove theorem 2 main result constanttim argument hing follow basic proposit proof obviou proposit 2 given arbitrari set properti p px true one x 2 determin x satis px done constanttim ie time independ jsj lemma assum variabl treat uniformli environ exampl particular bind variabl particular environ store valu cell alloc bind node bind v environ also store valu cell alloc respect bind node easi extend proof includ nonuniform treatment variabl dierent environ includ sake simplic breviti access cell valu cell ident inform regard bind node bv n variabl v global environ node n associ either owner node bind node access node either bv n determin constanttim processor node n nonconst overhead incur task creation proof consid possibl place inform bv n record orparallel tree sinc three oper perform variablecr bindingunbind access valuew consid rst three case inform maintain exclus either owner creation node bind node access node consid case inform maintain combin three type node associ v n bv n kept bind node sinc one bind node v global environ gn n sinc nonconst number node gn follow proposit 2 determin bv n constanttim oper bind node v gn fact also determin constanttim proposit 2 sinc number node ov n constant gener ii associ v n bv n kept owner node case owner node v maintain set bind node v mg order processor n determin applic bind node bv n n must determin x 2 bv x n sinc bv set nonconst size search x x n nonconst time oper proposit 2 iii associ v n bv n kept access node sinc access node determin advanc associ would maintain everi node ie node k would need store bind pair hw bw ki condit variabl w access sinc number condit variabl access particular k would gener constant creation k would becom nonconst time oper bind pair ks parent would copi k instead copi pair node k share parent node access pair henc access bind node would becom nonconst time oper sinc ks parent might share bind pair parent etc worst case determin bind node variabl ancestor k would also search thu case degener case thu either determin bind node becom nonconst time oper nonconst overhead incur taskcreat iv associ v n bv n store combin bind owner access node let c set condit variabl global environ node n gener c would set nonconst size let c 1 set possibl empti condit variabl case true c 2 set possibl empti condit variabl case ii true c 3 set possibl empti condit variabl case iii true thu assum c nonempti least one c 3 nonempti sinc c nonconst size least one c 1 c 3 nonconst size thu reason case ii iii use prove case end proof lemma 2 let access cell valu cell ident let c set condit variabl global environ node n inform regard bind node bv n variabl v 2 c record datastructur independ orparallel tree either access bind node nonconstanttim oper nonconst time overhead incur taskcreat taskswitch proof suppos processor record datastructur valu bv n variabl v2 c access n make assumpt structur could array hash tabl etc gener case arbitrari number datastructur independ orparallel tree global subset processor two extrem case gener case one singl datastructur common processor one privat datastructur processor show former case either access bind node taskcreat non constanttim oper latter case taskswitch nonconst time oper show gener case combin extrem case singl global datastructur common processor processor creat node n must ensur bv n v 2 record global datastructur two occas done bv n valu record either time n creat ii increment individu bv n valu need one descend node n consid case turn bv n valu variabl gnc access node n record global datastructur creation node n taskcreat nonconst time oper sinc gener nonconst size subset variabl would access n bv n valu record increment need access would nonconst time oper would nd ancestor node n bv n bv entri exist global datastructur done constanttim proposit 2 sinc size gn global datastructur constant ii datastructur privat processor taskswitch nonconst time oper sinc time processor switch task record privat datastructur entri variabl access new node processor path number new node access processor taskswitch well number variabl access newli access node depend depth node correspond new task thu constant henc taskswitch nonconst time oper gener case reduc combin case ii let set processor p divid disjoint subset p datastructur record bv n reason similar case either taskcreat access bind node nonconst time oper similar case ii processor switch anoth branch creat processor q 62 p taskswitch nonconst time oper sinc inform new bind node ps path record datastructur set processor p also possibl split datastructur part global part privat processor sinc c nonconst size either set variabl record global datastructur set variabl record privat datastructur would nonconst size henc case ii one taskcreat bind node access taskswitch nonconst time end proof theorem 1 let access cell valu cell ident let c set condit variabl global environ node n bind node bv n variabl v 2 c determin processor node n constant time without incur nonconst overhead taskcreat taskswitch proof function b describ algorithm sinc would allow us predict bind node given variabl particular environ even variabl get bound mean evalu function bv n associ variabl v bind node environ gn explicitli maintain two way maintain associ either orparallel tree combin owner bind access node independ orparallel tree datastructur independ tree let c set variabl associ inform store orparallel tree let c set variabl associ inform store independ orparallel tree sinc c set nonconst size least one c c also nonconst size c nonconst size lemma 1 either bind node access constant time nonconst overhead incur taskcreat c nonconst size lemma either bind node access constant time nonconst overhead incur taskcreat taskswitch thu either case nonconst overhead incur end proof corollari 1 let access cell valu cell ident let c set condit variabl global environ node n possibl processor access node n access valv n v 2 c vcv n constant time without incur nonconst overhead taskcreat taskswitch proof sinc relat function b val oneon nding valv n constant time without incur nonconst time taskcreat overhead mean bv n also found constant time without incur nonconstanttim taskcreat overheadsi clearli possibl accord theorem 1 end proof lemma 3 access cell distinct valu cell taskswitch nonconst time oper proof let c set condit variabl size therefor constant taskswitch arbitrari processor p bind applic condit variabl c may chang due chang current global environ p henc p ensur access cell correctli establish condit variabl suppos p switch node k 1 node k 2 let k least common ancestor node k 1 let k set node path k 1 k 2 via k kg variabl w aect task switch w 2 c 0 set c partit two subset c 1 c 2 g condit variabl c 1 processor use physic memori locat access cell irrespect environ ie alloc new one ii g new physic memori locat alloc environ k 2 access cell condit variabl set c 2 sinc c nonconst size least one c 1 c 2 also nonconst size case access cell updat condit variabl c 1 least aect condit variabl c 0 c 1 similarli case ii access cell creat updat condit variabl c 2 least aect condit variabl c 0 c 2 c 2 nonconst size gener c 0 would nonconst size taskswitch nonconst time oper end proof theorem 2 implement method bound number processor satis three criteria c nonconst size set condit variabl orparallel tree given moment partit set c two disjoint set c c b c subset c access cell valu cell distinct c b subset c cell ident clearli either c c b must nonconst number variabl lemma 3 c nonconst size taskswitch exampl bind gener record address bind node valu cell access variabl bind valu cell mean automat access correspond bind node extra cost nonconst time oper henc consid case c b nonconst correspond set access cell valu cell ident variabl access variabl amount access valu valuecel corollari 1 c b nonconst size valu variabl c b access constant time without incur nonconst overhead taskcreat end proof 4 orparallel execut logic program appli result previou section orparallel execut logic program note earlier nondetermin logic program aris multipl claus head may unifi procedur call goal sinc unic essenti twoway patternmatch unbound variabl call environ may bound unic aspect unic coupl nondetermin eectiv make possibl multipl bind variabl local environ note lemma 1 2 theorem 1 main task orparallel execut model determin bind node variabl access seen suce restrict attent singleassign languag purpos deriv result imper languageswher variabl bound nondeterminist pathdetermin applic bind node complic sinc sever bind node variabl given global environ given access node variabl applic bind node would one closest path access node root orparallel tree dierent method dier identifi bind node central aim method identifi bind node ecient valu cell access constant time variabl access environmentupd taskswitch exampl method simplifi oper nding bind node variabl alloc valu cell bind node eg bind array method w84 w87a version vector method h87 hash window method b84 scheme assign uniqu id bind node record id bind exampl time stamp method t89 variabl bind organ fashion bind node known correspond bind ecient access method propos literatur orparallel execut logic program either set c c b describ theorem 2 empti set howev proof gener subsum even method may c c b nonempti consid method see satisfi theorem 2 process see illustr proof lemma theorem bind array method bind array method w84 w87 valu cell access cell alloc memori space separ access cell alloc space bind array privat processor valu cell alloc space bind list bind node sinc slot use access cell particular condit variabl xed irrespect global environ content updat taskswitch result taskswitch time becom nonconst accord lemma 3 thu theorem 2 hold bind array method similar reason see version vector h87 method also nonconst taskswitch time thu satis theorem 2 bind array method valu set c c b describ theorem 2 c set condit variabl orparallel tree given time also valu set c 1 describ lemma 3 c 1 note lemma 3 parameter p k 1 thu variat standard bind array method conceiv certain pair node k 1 processor decid updat bind array place c 1 certain pair node k 3 k 4 leav old bind array station k 3 construct new one k 4 correspond case bind array number processor ownership bind array chang time time case order optim taskswitch time processor may build new bind array branch see orparallel tree becom big obvious modi bind array method satis lemma 3 thu theorem 2 note necessari bind array version vector method record valu cell bind node valu cell record use dierent scheme say exampl time stamp method t89 give us variat bind array version vector method variat bind array method manchesterargonn argonnesri model also satisfi theorem 2 given w87b muse kabuwak delphi random parallel backtrack muse system ak90 bind environ processor distinct ie share other processor switch anoth node orparallel tree construct whole stack node root node memori copi stack regard privat datastructur allud lemma 2 access variabl bind result case ii lemma 2 corollari 1 taskswitch becom nonconst time oper taskswitch also nonconst time oper kabuwak method k86 delphi method ca88 random parallel backtrack method ja88 l89 latter two case taskswitch processor construct datastructur mention lemma 2 recomput node root orparallel tree node tasksit locat thu stack reconstruct rather copi although recomput result less interact processor overal strategi incur overhead gener recomput would involv work copi stack avoid repeat recomput delphi method use optim base compar socal oracl oracl essenti node identi indic path taken reach node root sinc oracl size proport depth node orparallel tree compar nonconst time oper henc even optim taskswitch still remain nonconst time oper directori tree method directori tree method hc83 bind environ repres use directori context node directori contain number context one ancestor node context correspond claus space variabl claus node branch creat new directori copi node context children node method valu cell access cell ident alloc space access node node copi context henc lemma 1 corollari 1 task creation nonconst time oper thu theorem 2 hold directori tree method note method valu set c c b describ theorem 2 c similar reason theorem 2 hold environ close method c87 environ represent scheme use ropm rk89 nonconst taskcreat time hash window method hash window method b84 access cell valu cell ident alloc space bind node henc lemma 1 corollari 1 variabl access nonconst time oper insur fast access variabl bind within bind node valu cell alloc cell hash window whose address obtain hash variabl address thu hash window method also satis theorem 2 similar reason theorem 2 hold argonn model dlo87 w87b howev argonn model hash window constant size 32 content hash window node share children result bucket hashwindow larg number variabl map store list thu nonconst cost travers tree upward toward root nding bind node ect cost locat valu cell bucket tree bind node v toward end list bucket would valu cell v theorem 2 also hold variat hash window method adopt repres environ pepsi model wr87 model condit variabl access node bind copi hash window access node futur access variabl descend node travers fewer node thu scheme also satis theorem 2 virtu lemma 1 case iii corollari 1 time stamp method time stamp method t89 record id processor uniqu time stamp variabl bind hpid timestampi pair regard id bind node creat bind id later use access bind valu cell ident access cell method organ datastructur independ orparallel tree thu accord lemma 2 corollari 1 variabl access nonconst time oper actual time stamp method taskswitch nonconst time oper ancestor stack view represent associ variabl bind node construct taskswitch inform record node thu due lemma 2 corollari 1 taskswitch non constant time oper method andor parallel method theorem 2 also hold orparallel compon andor parallel sy tem exampl consid follow three method incorpor independ andparallel orparallel singl framework reduceor parallel model rk87 ii pepsi model wr87 iii author andor parallel model gj89 g91 note environ represent scheme use three method sacric taskcreat variableaccess taskswitch criteria respect 5 classic orparallel model logic program fact three criteria simultan satis partli reason mani method propos literatur orparallel execut logic program base criteria one choos satisfi one dierent execut model orparallel one also use basi classifi variou orparallel execut model sinc three criteria satis principl 2 class method accord classic see figur 1 prove method exist class 1 correspond method provid constanttim three oper ie task creation variabl access task switch class 8 method uninterest sinc three oper nonconst time none method propos literatur fall class 7 correspond nonconst task creation well nonconst taskswitch time although theoret possibl creat orparallel method would fall class unlik practic task creation nonconst time like environ alreadi replic nodecr thu need environ updat taskswitch sinc branch orparallel tree privat environ true fals true fals cva cva cva cva true true class 1 class 2 class 3 class 4 class 5 class 6 class 7 class 8 true true true fals fals fals fals fals method eg directori tree eg bind array eg hash window eg time stamp method eg variabl import constant time task switch constant time variabl access theorem figur 1 classic orparallel method theoret reason method sacric one criterion although method eg variabl import method l84 time stamp method t89 distribut cost multipl environ represent two oper instead one overal perform may eventu remain unchang may even improv exampl time stamp method t89 worst case variabl bind would access global datastructur search entir datastructur howev keep ancestor stack result nonconst time taskswitch fraction global datastructur access thu although two criteria may sacric particular method necessarili mean inferior method sacric one criterion method ctc cva ct version vector h87 bind array w84 w87a p p argonnesri model w87b manchesterargonn timestamp t89 hash window b84 p p naiv model w87b argonn model dlo87 p p directori tree hc83 environ close c87 p p variabl import l84 kabuwak k86 p p bcmachin a88 muse ak90 p p abstract model random method ja88 p p tabl 1 criteria satis variou method tabl 1 give tabl show particular criteria satis dierent method column indic criterion correspond column satis method method fall class directli compar best one among determin make sens compar method within class rather method belong dierent class exampl directori tree method environ close method duplic environ taskcreat howev environ close duplic smaller fraction environ sinc duplic variabl alreadi bound directori tree method thu although two orparallel method might theoret equival practic one may ecient similarli bind array method superior version vector method far execut cost concern reason given w87a sharedmemori multiprocessor method sacric constant time taskswitch tend superior sacric constanttim taskcreat variableaccess number task creation variableaccess oper program depend number taskswitch oper depend schedul polici employ runtim system thu cost taskswitch care control implementor optim granular stanc possibl taskcreat variabl access demonstr aurora muse system lwh90 employ sophist schedul ak90 cs89 s89 b90 minim cost taskswitch distribut memori system method nonconst time task creation like perform better relev part environ need carri parallel execut anoth processor made avail explicit copi task creation processor exampl environ close method c87 directori tree method hc83 access variabl processor use copi avail local howev advent distribut share memori system lh89 wh88 may make method sac rice constanttim taskswitch competit distribut system sacric constanttim taskcreat mention earlier sinc perform method former class less depend behavior logic program might even outperform method latter class distribut memori system 6 conclus present three criteria ideal orparallel system sat isfi constanttim access variabl constanttim task creation constanttim taskswitch signic criteria correspond natur three fundament oper nondeterminist program languag procedur call involv environ creation assign paramet transmiss involv variabl access bind resumpt success failur involv task switch show given nite number processor orparallel execut method base upon orparallel tree method satisfi three criteria simultan believ result also appli orparallel model base upon orparallel tree leav formal proof conjectur open question notwithstand restrict model base upon orparallel tree believ result signic sinc wellknown orparallel implement logic program base upon approach sucient deriv result class nondeterminist singleassign languag sinc easier satisfi three criteria destruct assign present although result rst formul logic program gj90 reformul gener nondeterminist languag hope access research interest parallel applic symbol comput reason exhibit substanti orparallel symbol integr program syn thesi natur languag analysi theoremprov gametre search etc technolog parallel execut logic program advanc point sever practic parallel prolog implement lwh90 ak90 t92 much done organ subject systemat way paper provid framework could serv valuabl refer implementor logic languag compar exist work result provid greater insight natur orparallel execut model facilit meaning comparison acknowledg thank david hd warren felik kluzniak comment suggest earlier version paper thank also due anonmy refere whose comment spur us gener earlier result broaden scope paper work support part nsf grant dcr 8603609 gopal gupta also support uk scienc engin research council grant grf 27420 perform work univers bristol r 2nd intern logic prog conf tr method effici execut horn claus program use multipl processor random parallel backtrack algorithm perform orparallel logic program system find lowest common ancestor simplif parallel orparallel execut model prolog memori coher share virtual memori system aurora orparallel prolog system muse orparallel prolog model perform parallel execut logic program share memori multiprocessor ctr enrico pontelli karen villaverd haifeng guo gopal gupta stack split techniqu effici exploit search parallel sharenoth platform journal parallel distribut comput v66 n10 p12671293 octob 2006 enrico pontelli gopal gupta parallel symbol comput ace annal mathemat artifici intellig v21 n24 p359395 1997 gopal gupta enrico pontelli khayri ali mat carlsson manuel v hermenegildo parallel execut prolog program survey acm transact program languag system topla v23 n4 p472602 juli 2001