loop reorder prefetch runtim order loop iter execut larg impact number cach miss applic take new loop order preserv semant old order better cach data reus improv perform applic sever compil techniqu exist transform loop order iter reduc cach miss paper introduc runtim method determin order base dependencedriven execut dependencedriven execut execut travers iter space follow depend arc iter b introduct despit rapid increas cpu perform primari obstacl achiev higher perform current processor organ remain control data hazard estim 5 show perform singlechip microprocessor improv rate 80 annual dram speed improv rate 510 amount time 5 8 grow inabl memori system keep processor increas import cach data reus reduc traffic main memori prefetch mechan hide memori access latenc technolog trend pose challeng interest scientif engin applic whose data requir much larger processor cach scientif engin applic spend execut time loop effort local optim focus restructur loop chang iter order restructur loop significantli improv perform applic reorder iter loop convent done compil time appli transform loop interchang skew revers unfortun compiletim transform appli certain type loop transform must provabl correct without know valu variabl forc compil make conserv assumpt paper present hybrid compiletimeruntim method reorder loop iter use dependencedriven execut model loos base concept systol array 911 coars grain dataflow 3 dependencedriven execut system enabl block iter depend constraint iter satisfi immedi execut newli enabl iter produc depthfirst travers iter space improv data reus maintain symbol datadepend inform base array subscript express found bodi loop evalu runtim metacomput symbol depend allow us avoid earli commit specif order give system greater flexibl turn increas class loop optim reorder iter furthermor maintain depend inform runtim runtim system prefetch sink depend hide latenc memori access convent wisdom suggest determin iter order dynam would add much comput overhead howev overhead addit comput one overhead caus control data hazard previou gener comput balanc memori system cost may inde unjustifi contemporari processor cpu cycl rel cheap comparison memori cycl two order magnitud expens imbal suggest comput overhead logic avoid cach miss may signific logic reduc traffic memori hide latenc memori oper elsewher 16 discuss parallel scalabl dependencedriven execut multiprocessor paper evalu efficaci runtim loop order improv tempor local contemporari uniprocessor background relat work mani import numer applic scienc engin consist composit function form f function necessarili distinct larg data set much greater processor cach size n denot number time function sequenc appli implement imper languag composit function would appear nest loop f express simpl loop iter data space semant loop languag order iter lexicograph respect induct variabl forc comput travers data space strict functionatatim order execut order lead poor reus cach data fit entir cach cach contain last c byte upon complet function f forc f i1 reload everi byte cach may possibl desir execut iter differ order improv local determin desir legal order specifi express order effici execut much work local optim reli compiletim transform reorder iter loop unfortun transform appli loop perfectli nest loop assign statement occur innermost loop loop transform perfectli nest loop put differ compiletim transform applic case f equat 1 section briefli review compil time loop transform follow section describ loop reorder extend composit function f discuss compil transform use defin notion iter space iter space ndimension space integ model nest loop depth n loop iter point iter space describ vector 1 2 n p index variabl delimit iter rang correspond loop depth p linear loop transform transform origin iter space anoth iter space desir properti better local parallel sequenc loop transform model product nonsingular matric matrix make transform skew loop interchang revers etc thu find possibl desir iter order formul search nonsingular matrix object function satisfi set constraint transform also call unimodular transform preserv volum iter space integ loop transform legal transform preserv depend relat depend two point j iter space differ vector j vector ji call depend distanc vector set distanc vector make data depend determin allow reorder transform base depend optim compil may make follow transform improv local loop interchang loop interchang 191 swap inner loop outer loop optim compil appli transform improv memori local interchang reduc array access stride block tile block 201217 take advantag applic spatial local travers rectangl iter space time memori access applic limit address within rectangl rectangl data fit wholli cach processor access cach line multipl time leav cach skew block may legal iter space distanc vector contain neg distanc case skew 19 appli enabl block transform skew travers iter space diagon wave figur 1 skew tile transform hyperbol 1d pde transform iter space compil gener code form new loop exampl consid hyperbol 1d pde figur 1 show depend iter space prior skew block transform block size two gener code complex origin new code better local parallel survey compil transform high perform comput found 418 dependencedriven execut given transform iter space compil must gener code describ travers entir iter space earli commit specif order limit flexibl specif compil time transform follow limit unimodular transform appli composit function multipl distinct function appli larg class imperfectli nest loop depend loop iter involv unknown user variabl subscript express exampl consid follow loop i0 n1 j1 j n2 j compil appli unimodular transform without know valu k l least know whether valu neg posit compil must give static specif iter order code gener transform iter space becom complex exampl skew block transform figur 1 complex code mani level nest condit caus control hazard reduc instruct level parallel contemporari processor furthermor difficult compil appli optim complex code exampl none compil variou architectur experi abl appli loop unrol code gener figur 1 furthermor compil time linear loop transform give us gener techniqu autom prefetch data hide memori access latenc section describ dude defusedescriptor environ runtim system dude meant use either target optim compil set librari call programm use directli 1 optim code basic model loos base underli concept systol array like systol array comput dude consist larg number process element cell type howev effici comput commerci processor granular comput dude much coarser implement cell actual c object consist oper descriptor describ region data oper appli term object iter array iter make iteratecollect procedur cell systol array may consist sever altern option similarli oper iter iteratecollect may overload like cell systol array iter interconnect link unlik interconnect cell systol array physic hardwir link link dude symbol express indic index space iteratecollect express symbol link call depend rule deriv array access pattern statement origin loop therefor summar depend iter space symbol metacomput depend rule determin path execut iter space also like comput systol array data process transfer one element anoth pipelin sinc one physic process element uniprocessor comput speedup due pipelin howev tempor local model offer expect perform improv even uniprocessor unlik comput systol array comput dude synchron global clock sens model closer wavefront array 10 asynchron comput togeth pipelin function applic allow system appli multipl function block data data block leav processor cach figur 2 dependencedriven execut model describ loop dude goal runtim system abl optim complex loop form shown equat 1 achiev goal taken objectori loop block iter extens first class object put togeth describ complex loop put togeth special object user special system creat softwar systol array applic hand objectori model base awesim 7 chore 6 runtim system follow list object dude data descriptor data descriptor describ subsect data space exampl matrix divid submatric submatrix defin data descriptor method object sx ex sy ey etc retriev corner submatrix iter iter tupl data descriptor oper user special iter overload default oper applic specif oper consist statement found bodi simpl loop system appli virtual oper data describ descriptor iteratecollect iteratecollect name impli array iter iteratecollect repres simpl loop nest loop simpl function composit function perform oper entir data space dimension iteratecollect normal data array oper loop loop templat structur use describ composit function put togeth one iteratecollect user reli follow method provid loop object glue togeth differ iteratecollect begin comput make iteratecollect nth simpl function composit function defin symbol link dep iteratecollect ic1 ic2 symbol link express term depend rule variabl rang index space iteratecollect execut execut entir loop nest describ loop descriptor loop object creat defin runtim give system flexibl describ comput complex loop nest figur 2 show basic model runtim system use initi system push unconstrain iter onto system lifo queue allow schedul pop iter perform oper iter associ complet iter potenti enabl iter base data depend specifi setdepend base iter complet creat cycl shown figur 2 system repeat entir loop nest complet exampl redblack sor describ dependencedriven execut respect exampl redblack sor form red n number time step note sinc loop red blk oper nest within perfectli nest henc unimodular transform appli figur 3 multiloop depend redblack figur 4 redblack sor dude figur 3 show origin code interloop depend red blk oper loop bodi simpli take averag element neighbor point creat depend shown figur figur 4 show applic would appear written dude applic two iter red blk correspond blkmain redmain method overload oper special iter applic iter compos redcol blkcoll collect final collect combin loop descriptor creat composit function iter 10 iter execut function loop figur 4 start system push initi unconstrain iter redcol collect onto system lifo queue dependencedriven execut memori local entir execut nest loop sensit order initi unconstrain iter load applic block memori access pattern one system load iter morton order 15 comput begin initi iter load system schedul pop red iter system lifo queue appli main oper data describ descriptor iter complet system determin list sink depend arc iter base depend rule sink system decrement counter destin iter point execut blk iter count zero iter becom unconstrain enabl depend satisfact engin push enabl iter onto system lifo queue lifo order next time schedul pop iter lifo queue would blk iter continu complet blk iter enabl red iter second time step forth describ depthfirst travers iter space sinc blk oper begin red oper complet note use fifo queue would enforc breadthfirst travers order iter space would order produc origin sourc loop figur 5 iter order hyperbol 1d pde use dude describ runtim system posit compar compiletim transform compiletim optim transform loop structur redblack sor revert back exampl hyperbol 1d pde compar iter order loop nest would run dude compiletim loop reorder figur 5 show snapshot iter order hyperbol 1d pde run dude code shown diagram bodi oper pde iter note code much simpler code requir skewingtil shown figur 1 simpler code less condit run effici contemporari processor deep pipelin also enabl possibl optim shown figur 1 realli two order consid dependencedriven execut intraiter order indic number interiter order enforc arrow interiter order determin depend rule order within iter exactli origin sourc loop note given depend rule caus diagon travers iter much like skew transform support autom prefetch far discuss method reduc number cach miss hide memori access latenc cach miss unavoid section discuss dude insert prefetch instruct mask memori access latenc use comput case cach miss unavoid figur 2 show prefetch logic fit dependencedriven model system execut current readi iter c prefetch logic tri predict next iter n execut would base c depend rule predict simpli simul depend satisfact engin enabl new iter follow except instead push newli gener iter n onto lifo queue prefetch logic invok prefetch command region data iter n associ caus data need n deliv processor cach system execut iter c intent system final execut n data n would avail processor cach experiment result analysi measur perform six applic redblack sor oddeven sort multigrid levialdi compon label algorithm hyperbol 1d pde vector chain addit one would ordinarili run algorithm uniprocessor sinc effici scalar algorithm exist aim ultim run algorithm multiprocessor conduct experi uniprocessor isol benefit increas parallel dependencedriven execut benefit improv tempor local experi conduct singl processor dec 21164 run 290 mhz 16kb first level cach 4 mb second level cach cach penalti two cach 15 cycl 60 cycl respect program compil dec c cxx compil o5 option determin cycl cach miss branch mispredict use comput etc spent use digit continu profil infrastructur dcpi 2 avail alpha platform dcpi run background low overhead slowdown 13 unobtrus gener profil data applic run machin sampl hardwar perform counter avail alpha cycl attribut follow categori comput cycl spent use comput static stall stall due static resourc conflict among instruct depend previou instruct conflict function unit dcach miss stall dynam stall caus dcach miss dynam stall sourc dynam stall miss branch predict icach miss itb dtb miss figur cycl breakdown variou applic figur 6 show breakdown cycl spent six applic method relev certain applic graph compar fewer method other measur averag 15 run neglig standard deviat redblack sor figur 7 analysi sor 2048x2048 run dude applic good spatial local sinc element access neighbor element also potenti tempor local pipelin iter differ time step compar use dependencedriven execut three method unoptim tile row tile block chose matrix size 2048x2048 64bit float insur entir matrix entir fit processor cach method use optim block size method 256x2048 tile row 256x256 block 32x32 dude sinc time step redblack sor normal control loop use follow done i0 i10 figur 6 show redblack sor use unoptim method spend much 76 time dcach stall surpris given expens memori access rel cpu cycl sinc tile row creat iter order unoptim case littl benefit use tile rowdu access pattern access north south west east neighbor tile block littl better spatial local shown figur dude incur greatest overhead term number instruct execut runtim depend satisfact partli respons overhead anoth sourc overhead caus use smaller block size 32x32 increas number loop henc number instruct compar overhead cycl spent dcach stall clear overhead rel insignific neverthless tension overhead caus smaller block size benefit greater tempor local smaller block allow algorithm explor deeper time step improv tempor local also increas total overhead right hand side figur 7 show effect grain size applic analyz cach behavior sor use variou method use atom 14 instrument applic lefthand side figur show total number refer l1 cach miss l2 cach miss deriv instrument execut expect memori refer requir dude also suffer least l2 cach miss work set applic larg dependencedriven execut entir fit l1 caus dude slight increas l1 cach miss tile block method hyperbol 1d pde compar runtim method skew block compil transform also measur breakdown cycl hyperbol 1d pde wavefront comput perfectli nest loop figur 6 show perform three method static runtim reorder optim significantli improv local static skew transform best local introduc overhead dependencedriven execut control hazard introduc compil gener code right side figur 1 increas static stall shown figur analysi skew code use dcpi also reveal method suffer resourc conflict stall due integ arithmet subscript express requir compilertransform code see right side figur 1 compon label levialdi algorithm 13 compon label use imag process detect connect compon pictur involv seri phase phase consist chang 1pixel 0pixel upper left upperleft neighbor 0pixel 0pixel chang 1pixel upper left neighbor 1pixel comparison perform variou method shown figur 6 see higher overhead determin iter order dynam small compar benefit avoid stall oddeven sort overhead dependencedriven execut proport number depend arc eman iter applic two arc per iter dude dramat outperform unoptim method includ perform tile method tile would chang iter order onedimension problem compiletim skew transform appli two function odd even oper multigrid multigrid anoth iter pde solver interest one five distinct oper smooth even element smooth odd element restrict form prolong differ depend relat oper dimens data space also chang depend level multigrid pyramid vector chain addit measur perform dude pure static method determin iter order analyz perform simpli ad 14 vector length 1048576 doubl float unoptim version two vector ad entireti ad next vector tile version vector broken chunk contain element gave best perform element 031 14 vector ad ad element forth final dude use chunk size consist 512 element depend rule set dude incur slightli overhead determin iter order also benefit data prefetch effect prefetch studi well system prefetch data 1 inspect footprint execut 2 compar cycl breakdown applic without enabl prefetch instruct two prefetch instruct alpha fetchm instruct document implement 21164 instuct load ldt ldl zero regist implement document sinc run experi 21164 use load zero regist gener prefetch look footprint execut system prefetch system execut abl verifi system inde prefetch next iter execut current one howev perform result observ show littl benefit prefetch applic look left side 7 give us clue prefetch effect applic figur show hardli l2 miss lot l1 miss impli work set dependencedriven execut larg fit l1 prefetch next iter may help reduc l2 cach miss realli sourc stall help miss l1 conflict work set current iter reduc size work set reduc granular would increas total overhead figur 8 effect prefetch oddeven sort vector chain addit applic small work set abl get 7 perform improv prefetch shown figur 8 work set oddeven sort consist left right neighbor onedimension array work set vector chain addit consist vector contain total sum current vector ad expect efficaci prefetch would greater l1 suffici big enough fit work set prefetch granular dependencedriven execut suit distribut share memori system larger cach larger latenc nevertheless preliminari experi indic prefetch autom dependencedriven execut conclus compiletim optim advantag compil appli optim littl overhead case total execut time runtim optim advantag inform avail assum inform compiletim kept runtim inform includ state comput valu variabl depend satisfi depend yet satisfi inform runtim flexibl flexibl come cost instruct execut cpu cycl howev modern commerci machin processor cycl cheap addit cycl use use memori system effect reduc overal execut time applic describ runtim system use symbol depend inform determin loopord runtim also shown comput driven depend significantli reduc number cach miss stall ad rel insignific overhead furthermor cach miss avoid shown system also use prefetch data avoid memori access latenc memori access cost becom expens cpu speed continu get faster size cach continu get larger mechan prefetch becom better support overhead dependencedriven execut becom justifi r automat loop interchang continu profil cycl gone parallel process largegrain data flow techniqu compil transform highperform comput keynot address enhanc runtim support share memori parallel comput user guid awesim object orient parallel program simul system comput architectur quantit approach systol array vlsi wavefront array processor vlsi array processor cach perform optim block algorithm shrink binari pictur pattern design analysi spatial data structur improv local parallel nest loop high perform compil parallel comput optim supercompil supercomput iter space tile tr vlsi array processor iter space tile comput architectur quantit approach design analysi spatial data structur cach perform optim block algorithm chore enhanc runtim support sharedmemori parallel comput linktim optim address calcul 64bit architectur continu profil shrink binari pictur pattern automat loop interchang compil transform highperform comput optim supercompil supercomput ctr suva vajracharya dirk grunwald depend driven execut multiprogram multiprocessor proceed 12th intern confer supercomput p329336 juli 1998 melbourn australia suva vajracharya steve karmesin peter beckman jame croting allen maloni sameer shend rod oldehoeft stephen smith smart exploit tempor local parallel vertic execut proceed 13th intern confer supercomput p302310 june 2025 1999 rhode greec