effici increment algorithm dynam detect like invari dynam detect like invari program analysi gener observ valu hypothes program properti report program properti set like invari program also known oper abstract oper abstract use test verif bug detect refactor compar behavior mani task previou techniqu dynam invari detect scale poorli report properti increment algorithm attract process observ valu thu scale well data size previou increment algorithm check report small number properti paper take step toward correct problem paper present two new increment algorithm invari detect compar analyt experiment two exist algorithm furthermor paper present four optim show implement context increment algorithm result scalabl invari detect sacrific function b introduct paper present evalu algorithm optim obtain oper abstract formal descript properti held seri program run expect hold futur run task gener oper abstract also known dynam detect like invari dynam invari detect dynam invari detect import practic prob lem oper abstract use verifi safeti properti 35 30 31 autom theoremprov 27 28 identifi refactor opportun 19 predic abstract 8 9 gener test case 38 39 13 14 select priorit test case 16 explain test failur 12 predict incompat permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee sigsoft04fse12 oct 31nov 6 2004 newport beach ca usa compon upgrad 24 25 error detect 34 15 33 23 4 error isol 37 21 choos modal 22 among task dynam invari detect independ implement sever research group relat tool also produc formal descript runtim behavior seen wide use see section 10 dynam invari detect valuabl implement effici challeng naiv implement straightforward fail scale problem substanti size key paramet control runtim runtim subject program longerrun program produc data analyz number variabl field examin size variabl ar ray expens test integ boolean number program point invari detect perform stanc everi instruct versu entri exit point one compon grammar invari check check ing invari relat three variabl expens consid relat two variabl size program relev except insofar might affect measur previou invari detect algorithm control runtim space limit one factor see section 10 result result limit ex pressiv applic fewer program would desir goal remov limit enabl invari detect appli program produc detail result address goal provid two new algorithm invari detect topdown increment algorithm bottomup increment algorithm analyt experiment compar algorithm one anoth two previous known algorithm simpl increment algorithm multipass batch algorithm describ three optim equiva lenc set constant suppress previous implement multipass batch algorithm show extend increment algorithm present new optim hierarchi optim take advantag fact certain properti hold properti guarante hold need check experiment evalu four optim discuss complic aris integr optim algorithm paper organ follow section 2 provid background dynam invari detect explain factor affect runtim section 3 give simpl increment algorithm invari detect section 4 note four type redund output follow section give algorithm exploit redund differ way multipass algorithm section 5 bottomup increment algorithm section 6 topdown increment algorithm section 7 along optim increment algorithm section 8 section 9 give result experi variou algorithm optim section 10 discuss relat work section 11 conclud 2 background dynam invari detect dynam detect like invari 10 discov like invari program execut instrument target program sourc binari form trace variabl interest run instrument program set test case postul check invari valu program comput essenti idea use generateandcheck algorithm test set possibl invari observ valu instrument variabl set observ valu program point call sampl invari detector report properti test suffici degre without falsif output includ properti entri procedur foo mylist sort exit procedur bar return myvar return stand return valu link object dynam approach profil accuraci result depend part qualiti complet test case even modest test suit produc good result practic 31 30 techniqu exist creat good test suit invari detect 16 14 39 remaind paper breviti use invari mean like invari unless otherwis note invari report depend properti check specif grammar properti express invari detector variabl properti check program point properti check discuss factor section 10 discuss choic variou implement make fac tor report properti also depend filter perform check statist test reduc fals posit 10 elimin redund properti 11 program point invari check arbitrari locat program two exampl procedur entri exit result invari correspond precondit post condit use comput invari procedur exit ie return statement also comput aggreg exit point view client gener individu exit point object class invari also comput aggreg program point object point gener object observ entri exit public method class pass return method class store object field grammar properti invari detector may check type properti equal inequ among variabl may check larger varieti let xyz variabl let abc constant properti might check includ constant rang x b linear relationship function librari ness x sort mani other invari detector may permit user add domainspecif properti check invari detector may also report condit properti implic left null left valu thisvalu check larger number properti make like output contain fact need human tool howev also increas runtim invari detector likelihood fals posit grammar variabl properti invari detector express must instanti particular variabl valu exampl x instanti two variabl second must collect addit proce dure paramet return valu use detect invari addit variabl instanc global variabl prestat valu also valu call deriv variabl manifest program exampl array integ lasti scope properti alasti may terest even though variabl may even appear program procedur exit includ origin valu variabl permit report side effect inputoutput relat ship given object field af field afg provid use addit inform result call sideeffectfre method also use deriv variabl examin structur element result miss variabl valu exampl variabl null af nonsens subtler exampl result field dereferenc depth say 1 class contain field x type integ field type b contain field z type integ use b type b b typic repres address hash code field bz avail howev use type field ax ay avail field ayz beyond field derefer depth avail even ay non null requir special care report correct result one variabl invari may miss invari falsifi reli certain situat experiment evalu paper experiment evalu use daikon implement publicli avail httppagcsailmitedudaikon daikon implement featur list section includ ternari deriv variabl invari field dereferenc userspecifi depth userspecifi invari condit invari statist test full list 31 deriv variabl 12 enabl de fault 161 invari 152 enabl appear daikon user manual avail websit daikon oper c java perl code variou data format 3 simpl increment algorithm section give increment singlepass invari detect algorithm discard sampl process storag space requir grow number sampl increment algorithm also run onlin simultan target program elimin need store trace file disk algorithm follow 1 initi assum properti grammar true instanti candid invari properti combin variabl exampl grammar properti odd variabl x z instanti oddx oddi oddz 2 sampl check candid invari associ program point sampl discard contradict sampl exampl sampl 3 4 3 elimin invari oddi list 3 report invari remain process sam vp number variablesvalu scope program point vd v number deriv variabl obtain v origin variabl total variabl program point execut length number sampl program point number possibl invari program point ri number report invari program point number program point gv grammar number invari templat given v variabl figur 1 variabl use run time space analys ple appli postprocess filter program point process independ algorithm use space store candid invari initi maximum space usag figur 1 definit variabl suppos 12 type deriv variabl involv 3 variabl exampl subarray aij 152 type invari involv 3 variabl exampl ax 100 program point instrument 300 reachabl variabl field scope program point p 29 prohibit static analysi determin variabl sensibl compar other 32 11 number invari still highord polynomi number variabl ov 9 hand grammar invari small simpl increment algorithm space usag reason worstcas runtim requir check invari sampl practic invari fals fals invari falsifi quickli o1 sampl commoncas runtim first summand falsifi properti second summand neverfalsifi invari check sampl simpl increment algorithm implement number research group everi invari detector awar except daikon base 4 optim opportun redund properti simpl increment algorithm section 3 check report invari necessari section give four exampl redund output optim base three equal variabl constant suppress yield signific perform enhanc multipass batch algorithm 11 41 equal variabl two variabl alway equal invari true one variabl true variabl exampl invari f fx impli fy context condit requir whenev one variabl miss exampl x miss fx necessarili impli fy sinc valu x miss may invalid invari 42 dynam constant variabl dynam constant variabl one valu observ sampl invari x constant make invari x redund exampl impli oddx x 5 likewis combin variabl miss valu affect conclud group constant must exist least one sampl constant group miss 43 variabl hierarchi variabl valu contribut invari multipl program point exampl valu observ public method exit affect method postcondit also object invari two program point b sampl b also appear invari true necessarili true b redund b formal relationship partial order lesser element receiv subset sampl receiv higher element higher element contain subset invari true lower element 29 26 differ variabl appear differ program point partial order better understood variabl organ program point rather program point figur 2 illustr variabl hierarchi two simpl java class three way partial order relat variabl enter exit exit point use notat x final valu variabl x origx initi valu x entri procedur variabl procedur entri point correspond origin variabl procedur exit point object method variabl object point correspond variabl method entri exit point object client variabl object point correspond variabl client class relat automat determin program sourc 44 suppress weaker invari invari suppress logic impli set invari previou three exampl redund special case one give rise specif optim opportun exampl x impli x 0 x equal variabl dynam constant miss valu affect suppress second exampl must least one sampl x z present order x div z true 5 multipass batch algorithm opportun identifi section 4 give power way identifi logic redund properti whenev certain anteced properti hold properti redund need creat check report howev simpl increment algorithm take advantag redund anteced properti reli upon invari detect complet properti may falsifi time multipass algorithm 11 address issu perform invari detect multipl pass earli pass check simpl invari later pass check complex invari creat deriv variabl necessari implement use 5 pass number repres compromis expos optim opportun reduc number pass 1 unari constant pass determin whether variabl constant whether miss subsequ pass ignor constant variabl arg thisbx thisbx thisb aobject thisx thisx bobject public class public void putb arg public class b public int x public int get object method object client enter exit type variabl relat bgetent thisb arg thisbx argx aputent return thisx figur 2 variabl hierarchi two simpl java class shade area name program point unshad box repres variabl program point line show partial order describ section 43 lesser element appear lower figur instanc lower left corner note variabl connect variabl objectcli relat variabl arg paramet method put null never null 2 binari equal pass check equal pair nonconst variabl set equal variabl leader variabl arbitrarili chosen repres set subsequ pass process leader 3 unari 4 binari 5 ternari suppress weaker invari optim built pass creat invari invariantspecif code check whether invari impli exist invari one exampl pass 4 discov pass 5 need check ternari invari note per pass 1 invari check constant variabl power optim undesir side effect interest invari may omit result previou experi demonstr necessari achiev accept perform 10 version constant variabl optim increment algorithm section 82 flaw implement multipass algorithm current implement hierarchybas optim po sibl would make algorithm complic would requir either postprocess increas number pass least addit factor depth hierarchi section 6 7 describ hierarchi optim increment algorithm multipass algorithm process program point one one perform 5 pass trace data program point program point process sampl associ program point discard optim multipass algorithm worstcas space cost first argument store trace repres total space usag start algorithm second store invari repres space usag end algorithm practic first argument domin intern trace data reduc storag cost worstcas runtim mani invari quickli falsifi even never even check lead commoncas runtim downsid multipass approach need store trace data process multipl time even modest trace occupi gigabyt disk space memori limit abil algorithm work nontrivi program make inappropri onlin use read file multipl time anoth possibl howev file io substanti cost impl mentat store trace memori perform runlength encod intern ident sampl save space altern store trace data one could run target program multipl time pass multipass algorithm accept prohibit difficult program perform side effect depend aspect environ may chang includ random number gener memori address hash code thread schedul use expens resourc includ human attent mani program oper system web server never termin user may also wish switch gather invari check invari fli 15 6 bottomup increment algorithm increment algorithm handl arbitrarili long execut target program process sampl exactli discard howev optim becom complic costli invari detector must undo optim anteced depend ever falsifi section present new bottomup increment algorithm section 7 propos topdown increment algorithm two algorithm differ primarili address variabl hierarchi optim optim similar two increment algorithm given section 8 invari true higher level variabl hierarchi also true lower level instanc everi object invari precondit postcondit everi public method key idea hierarchi optim particular properti true multipl program point invari check one level hierarchi bottomup impl mentat invari check lowest possibl level topdown implement check highest possibl level bottomup algorithm process sampl leav variabl hierarchi aggreg program point handl postpass sampl process invari nonleaf built merg invari children invari creat parent iff invari type variabl exist child invari exist child must falsifi child thu falsifi parent invari merg routin oper manner similar runtim process straightforward stateless sampleindepend invari express one fact variabl whose intern state chang result process sampl exampl greaterthan product stateless invari sampledepend invari whose equat includ constant x 42 1 reason instanti check everi possibl x c variant instead one object stand invari given variabl constant comput fit observ sam ple run time process sampl may chang mean invari instanc ad linearli independ point permit constant comput weaken variant chang x 42 x 10 sampl valu 10 observ merg sampledepend invari requir invariantspecif process exampl one child contain invari x 15 child contain invari x 22 merg invari parent x 22 one complic popul parent program point need properli relat variabl multipl program point illustr figur 2 variabl name need cor respond correspond cross class boundari optim section 8 complic correspond merg parent set equival set variabl section 81 intersect set equival set child two variabl equal parent iff equal child invari merg must also merg inform use statist test mention section 2 statist comput parent program point process sampl bottom approach sampl process exactli leaf nonleaf program point consid process complet process time parent depend small number invari found children larg number sampl 7 topdown increment algorithm bottomup algorithm instanti given invari say x everi leaf program point contain x contrast topdown algorithm aim save space cost addit runtim instanti invari highest point hierarchi true invari initi creat top partial order sampl read trace process everi program point top partial order leaf program point sampl belong invari falsifi program point invari immedi remov program point ad children sampl process child 1 result invari appear path start top hierarchi set invari program point consist invari appear implement account fact partial order form dag tree invari a1 hold program point falsifi sampl c1 falsifi sampl c2 figur 3 exampl topdown hierarchi optim left diagram show invari point mark gray back ground top hierarchi hold everi program point center diagram show hierarchi falsifi sampl receiv point c process order b c right diagram show hierarchi falsifi sampl receiv point c2 higher program point exampl see figur 3 order appli multipl program point sampl must transform includ correct valu correct order requir differ variabl appear differ program point nonleaf program point may see sampl origin multipl leav bottomup algorithm transform postprocess also transform invari sampl topdown algorithm also make increment optim section complex invari hold program point physic locat program point higher locat partial order order search invari optim travers hierarchi copi invari possibl differ program point place copi target program point appear anywher higher target unfortun sampledepend invari tend numer practic must exempt topdown hierarchi optim instanti everywher partial order process sampledepend invari must observ everi sampl program point without omit exampl suppos figur 3 invari x equal constant c order sampl prog point valu first sampl would set equat 5 third sampl would falsifi invari follow algorithm outlin would copi children shown center diagram figur 3 howev would incorrect sinc program point b2 b3 receiv sampl instead indic c yet bound problem achiev correct led us modifi implement topdown algorithm rather instanti invari highest point hierarchi instanti level tree lower tree suppress see section 83 higher tree gain time advantag made possibl util variabl hierarchi invari check one level hierarchi space advantag invari duplic word although topdown algorithm intuit appeal promis space save instanti invari fewer locat hierarchi achiev goal gv v gv v figur 4 copi invari due split equal set equal set invari shown process sampl z 8 optim increment algorithm multipass algorithm later pass reli properti known true across sampl contrast properti enabl optim increment algorithm alway subject chang algorithm must abl undo optim may requir creat previous suppress invari put state would process sampl seen far 81 equal variabl increment algorithm use equival set variabl batch algorithm must dynam updat equival set initi variabl place singl equival set modulo compar note section 3 invari instanti leader set process element equival set differ valu whether miss equival set broken multipl part invari origin leader copi new leader copi proce follow invari mention leader old equival set duplic invari mani time new equival set dupli cate replac first instanc old leader differ one new leader origin invari mention old leader duplic still mention old leader least must recurs process origin invari mention old leader n time turn newset n duplic exampl see figur 4 algorithm extend straightforward manner multipl equival set break simultan reflex invari use singl variabl x x uninterest never report howev equal variabl optim requir exist process equal variabl optim invari leader variabl stand multipl invari member equival set left side figur 4 fv stand fv fw gv x stand six invari reflex invari requir equival set might later break exampl gx x stand gx gx z 7 invari without gx x invari gx z gz x right side figur would creat duplic step optim reflex invari need creat fewer member equal set variabl invari thu exampl necessari creat gz z 82 constant variabl increment algorithm dynam maintain set constant variabl necessari instanti invari variabl constant howev invari variabl nonconst member constant set invari instanti sampl process new valu constant variabl examin new valu differ miss variabl remov constant set invari relat valu remain constant creat variabl ever miss consid constant variabl sometim miss known combin variabl variabl ever exist increment algorithm instanti invari constant nonconst two reason first interest right second necessari constant later becom nonconst last variabl set becom non constant late creat invari set previou valu variabl lost instanti check invari everi set variabl contain least one nonconst solv problem 83 suppress weaker invari type invari specifi set possibl suppress suppress set anteced invari togeth impli invari exampl xy z1 xz y1 possibl set suppress product invari invari suppress anteced suppress hold discuss two implement suppress mechan first one instanti everi invari usual check invari might suppress whether anteced exist suppress data structur record fact suppresse invari need check sampl anteced falsifi suppresse becom unsuppress unless suppress hold elimin check sampl save runtim data structur track suppress increas memori usag second implement avoid instanti suppress variant maintain state whatsoev indic whether nonexist invari remov falsifi never instanti suppress save space cost complic process rather link instanti invari act anteced inform indic instanti invari help suppress invari type list suppress type may anteced whenev invari might anteced falsifi everi noninstanti invari might suppress check suppress invari hold falsif anteced suppress hold falsif anteced invari must instanti word invari unsuppress instanti soon last suppress longer hold exampl potenti anteced falsifi product invari must consid everi set 3 variabl includ w everi suppress invari must check expens achiev goal requir storag suppress invari implement topdown algorithm use solut instanti suppress invari bottomup algorithm use solut complex expens search anteced topdown section 7 combin expens extra search requir non instanti solut prohibit invari count sampl count candid invari count sampl process without optim optim figur 5 number candid invari sampl pro cess without optim bottomup algorithm data singl program point flex lexic analyz 84 discuss optim increment algorithm effect process initi sampl trace initi invari true redund variabl equal set inmemori represent rel small sampl process anteced properti falsifi equal set break number instanti invari grow contrast without optim simpl increment algorithm initi creat invari number decreas thereaft figur 5 show number invari grow without optim figur also highlight effect optim maximum number invari optim 100 time less minimum number invari without optim 9 experi order evalu algorithm optim describ paper ran experi measur term time space effect algorithm optim program size trace size paper present experi two rather differ target program flex lexic analyz c program part standard linux distribut util librari daikon written java flex contain 391 program point averag 275 variabl trace use 92 gigabyt 232000 sampl trace creat run flex number sampl scan ner daikon util contain 1593 program point averag variabl maximum 3672 variabl trace file 115 gigabyt 26 million sampl trace file creat run daikon small exampl program simpl increment algorithm creat 750 million candid invari flex 460 million daikon ignor program point 1500 variabl could even instanti 14 gigabyt memori ran two set experi first evalu differ algorithm one anoth optim enabl second evalu optim compar effect optim isol run invari detec tor measur run time wall clock time maximum memori size use five ident 22 ghz pentium 4 pc 1 gbyte memori limit maximum java heap 750 mbyte elimin thrash result shown size graph experi ran memori complet set experi simul program variou size consid fewer program point file io oper read entir file invari detector process sampl ignor program point use part singl program rather mani distinct program differ size avoid conflat program size number type variabl pattern data factor permit direct comparison result also indic perform user instrument part larg program realist scenario simul shorter run target program read fraction trace file process program point invari creat algorithm without optim ident except rel minor differ note discuss implement compar output increas confid implement 91 algorithm comparison figur 6 show time space usag multipass bottom topdown algorithm graph target program run time trace size figur 7 graph time space target program size number program point simpl increment algorithm complet even minimum program size minimum data trace file size topdown algorithm run memori process full flex trace topdown algorithm requir memori bottomup one two reason first correct must instanti invari everi level variabl hierarchi second data structur significantli larger need relat variabl hierarchi process sampl bottom algorithm use hierarchi merg invari daikon util memori usag similar bottom algorithm run twice fast larg program size trace size due greater overhead requir topdown process memori usag bottomup independ trace size linearli relat program size sinc program point process independ multipass algorithm similar speed bottomup algorithm multipass process full trace flex daikon util maximum memori use multipass grew less quickli expect probabl effect intern optim fact java memori system work harder save memori instanc garbagecollect frequent limit approach explain memori graph measur maximum memori usag flat near memori limit 92 optim comparison compar optim use bottomup algo rithm domin other abl process full trace wish use singl good baselin optim integr part multipass approach difficult turn result shown figur 8 equal optim far power crucial mani variabl equal one anoth ex ampl sideeffectfre procedur poststat valu paramet global variabl equal prestat valu elimin one optim caus daikon run memori flex exampl none extran optim benefit daikon util librari less flex util far fewer variabl per program point librari littl state heavili exercis librari procedur simpl assert repres almost 20 call librari thu much process time util expend optim afford littl benefit memori mbyte flex multipass bottomup topdown 010000200000k 50k 100k 150k 200k 250k time second flex multipass bottomup topdown2006001000 memori mbyte number sampl process util multipass bottomup topdown50001500025000 time number sampl process util multipass bottomup topdown figur comparison algorithm flex daikon util respect trace length multipass topdown algorithm run memori process full flex trace multipass also run memori process full daikon util trace simpl increment algorithm never complet even minimum trace length 20000 samples2006001000 memori mbyte flex multipass bottomup topdown 01000020000 time second flex multipass bottomup topdown2006001000 memori mbyte number program point util multipass bottomup topdown5000150000 200 400 600 800 1000 1200 1400 1600 time number program point execut time versu program size util multipass bottomup topdown figur 7 comparison algorithm flex daikon util respect program size multipass topdown algorithm run memori process program point flex multipass also run memori process program point daikon util simpl increment algorithm complet even one program point 10 relat work numer research adopt adapt idea dynam detect like invari section 2 discuss relev featur daikon implement describ implement base publish inform implement daikon publicli avail implement use simpl increment algorithm run faster daikon primarili daikon check mani invari million time flex exampl howev increment algorithm optim applic implement diduc tool 15 check one unari invari java pro gram program point field array refer procedur call invari check three valu variabl current previou valu differ invari indic previous seen valu everi bit valu invari weaken new valu observ given bit messag print user look weaken print program hierarchi equal constant suppress time flex 248 179 160 111 space flex 186 670 181 168 time util 120 172 116 100 space util 116 156 126 100 figur 8 comparison optim averag varieti differ program size trace length report number result without one optim divid result optim enabl exampl process flex 179 time slower use 67 time memori without equal optim figur time space spent read trace file common approach includ erron run error occur find rare corner case tool use help explain sever known error reveal two new error carrot tool 33 check 2 unari 4 binari invari reus daikon instrument handl languag daikon derefer field experi compar faulti nonfaulti program run result indic problem contrast work similar aim 15 12 remot program sampl 21 lightweight mechan evalu two properti one unari one binari instanti linear rather quadrat number variabl pair assign c program plu predic branch count number time properti satisfi properti check probabilist execut program point properti check skip implement could extend sacrif sound test suit gain perform result process statist indic properti best correl fault thu like indic fault diduc rel dens instrument mean earli warn one rel simpl properti indic bug experi tool rediscov 7 known error found one new one arnout tool extract implicit contract 2 aim add precondit analysi determin condit give rise except thrown add negat condit precondit henkel diwan 17 18 built tool discov algebra specif relat mean sequenc code oper poppushxstackstack tool gener mani term test case signatur java class propos equat base result test tool also propos test gener spin model checker extend check whether two variabl relat 35 output graph variabl node edg label comparison relat program demonstr induct logic program aim gener program sequenc exampl data 3 7 20 output similar obtain dynam invari detect aim complet rather partial must target smaller domain sever research infer program system trace finit state automata repres permit transit 6 5 1 36 specif written form automata complementari formulabas program properti gener dynam invari detector 11 conclus present two new increment invari detect algorithm compar two exist algorithm one increment one batch shown perform three previous describ optim one new one challeng increment context requir undo optim anteced depend becom invalid aspect work view specialpurpos automat theorem prover optim effici retract axiom implement algorithm optim singl framework permit direct experiment comparison conclud discuss merit variou al gorithm simpl increment algorithm easi understand implement least 6 implement invari detector base algorithm number invari check small exampl implement consid small number variabl invari type clearli best algorithm howev scale multipass algorithm offer conveni framework op timiz work ever need undon greatli reduc comput complex storag requir optim storag save offset need store trace data reprocess rerun target program often impract one optim elimin desir invari output multipass algorithm reason moderates dataset larg number invari beyond scope simpl increment algorithm howev longer run requir increment algorithm bottomup increment algorithm best perform experi algorithm abl fulli process dataset optim control space usag ensur modest number invari exist one time even near begin run substanti accomplish competit perform multipass algorithm tune year use increment natur algorithm make runtim proport space usag independ dataset size permit onlin invari detect concurr target program without store trace data much complex algorithm incur final postprocess step topdown increment algorithm share mani characterist bottomup algorithm howev topdown algorithm ineffect sampledepend invari complic process sampl requir difficult search determin whether invari true algorithm implement experi suggest invari detect simultan scale nontrivi number invari program nontrivi size increment algorithm optim implement version 3 daikon invari detector avail http pagcsailmitedudaikon acknowledg jeremi nimmer toh ne win wrote preliminari implement topdown increment algorithm discuss help develop mani idea comment anonym refere help us improv present paper research fund nsf grant ccr0133580 ccr0234651 oxygen project deshpand center technolog innov gift ntt toshiba 12 r mine specif extract implicit contract induct learn appli program construct verif find latent code error via machin learn program execut discov model softwar process eventbas data watch program demonstr select predic implic program analysi dynam discov like program invari support program evolut quickli detect relev program invari went wrong explain counterexampl gener test data dynam discov like program invari new structur coverag criterion dynam detect program invari track softwar bug use automat anomali detect improv test suit via oper abstract discov algebra specif java class tool write debug algebra specif autom support program refactor use invari learn program trace use version space algebra bug isol via remot program sampl improv adapt via program steer techniqu verifi componentbas softwar predict problem caus compon upgrad earli identif incompat multicompon upgrad verifi distribut algorithm via dynam analysi theorem prove automat gener check program specif automat gener program specif invari infer static check empir evalu program understand tool base type infer autom fault local use potenti invari anomali detect onlin data sourc automat detect invari spin automat extract objectori compon interfac check insid black box regress fault exposur local base valu spectra differ exploit synergi test infer partial specif tr watch discov model softwar process eventbas data eventbas detect concurr quickli detect relev program invari dynam discov like program invari support program evolut mine specif automat extract objectori compon interfac automat gener program specif track softwar bug use automat anomali detect anomali detect onlin data sourc invari infer static check induct learn appli program construct verif improv test suit via oper abstract bug isol via remot program sampl autom support program refactor use invari predict problem caus compon upgrad learn program trace use version space algebra tool write debug algebra specif find latent code error via machin learn program execut improv adapt multimod system via program steer use simul execut verifi distribut algorithm ctr nadya kuzmina ruben gamboa dynam constraint detect polymorph behavior companion 21st acm sigplan confer objectori program system languag applic octob 2226 2006 portland oregon usa christoph csallner yanni smaragdaki dynam discov like interfac invari proceed 28th intern confer softwar engin may 2028 2006 shanghai china nadya kuzmina ruben gamboa extend dynam constraint detect polymorph analysi proceed 5th intern workshop dynam analysi p1 may 2026 2007 marat boshernitsan roongko doong alberto savoia daikon agit lesson challeng build commerci tool develop test proceed 2006 intern symposium softwar test analysi juli 1720 2006 portland main usa sofien khemakhem khalil drira moham jmaiel sec search engin compon base softwar develop proceed 2006 acm symposium appli comput april 2327 2006 dijon franc zhenmin li yuanyuan zhou prminer automat extract implicit program rule detect violat larg softwar code acm sigsoft softwar engin note v30 n5 septemb 2005 philip j guo jeff h perkin stephen mccamant michael ernst dynam infer abstract type proceed 2006 intern symposium softwar test analysi juli 1720 2006 portland main usa