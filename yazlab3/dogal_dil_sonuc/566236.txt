determinist parallel backtrack search backtrack search problem involv visit node arbitrari binari tree given pointer root subject constraint children node reveal parent visit present fast determinist backtrack search algorithm pprocessor common crcwpram visit nnode tree height h time onphlogloglogp22 upper bound compar favour natur ohgrnph lower bound problem approach embodi novel effici techniqu dynam assign treenod processor ensur work share equit among b introduct sever algorithm techniqu employ solv mani optim problem base systemat explor tree whose intern node correspond partial solut grow progress rene increas depth whose leav correspond feasibl solut paper concern implement tree explor research support part ec esprit iii basic research project 9072geppcom cnr itali grant cnr9602538ct07 murst itali project mosaico result paper appear preliminari form proceed 23rd intern colloquium automata languag program paderborn germani juli 1996 preprint submit elsevi preprint januari 2001 sharedmemori parallel machin specic consid backtrack search problem involv visit node tree subject constraint 1 initi root known processor 2 children node made known node visit moreov structur size n height h unknown processor assum node visit children reveal constant time sinc n work need visit n node sinc tree height h contain path h node whose visit time must form strictli increas sequenc follow algorithm backtrack search problem requir time pprocessor machin number work parallel backtrack search appear litera ture random algorithm develop completelyconnect network processor kz93lab93 butter network ran94 run optim onph step high probabl note howev butter algorithm focus number nodevisit step fulli account overhead due manipul local data structur determinist algorithm given kp94 run ph time p p op clear whether latter algorithm extend work larger tree size relationship comput commun explor tree aris irregular divideandconqu comput studi wk91 number relat problem also address liter atur branchandbound ran90kz93lab93kp94hpp99ahpp99b dynam tree embed al91bgll91lnrs92 paper present determinist pram algorithm backtrack search whose run time within triplylogarithm factor natur lower bound discuss main result summar follow theorem theorem 1 determinist algorithm run pprocessor common crcwpram perform backtrack search nnode boundeddegre tree height h np hlog log log p 2 time worst case rst ecient determinist pram algorithm place restrict structur size height boundeddegre tree appli whose run time faith account cost algorithm perform optim number onp step olog log log p 2 multipl factor run time captur averag overhead per step requir ensur workload equit distribut among processor consequ algorithm would becom optim cost node visit e like case typic applic backtrack search everi node repres complex subproblem solv rest paper organ follow section 2 provid number basic denit discuss simpl direct approach backtrack search algorithm use combin sophist strategi attain ecienc highlevel structur algorithm describ section 3 section 4 provid detail descript key routin perform node visit load balanc section 5 argu gener approach discuss adapt schedul straightlin comput repres boundeddegre dag section 6 close paper nal remark preliminari algorithm design common crcw pram model com putat consist p processor share memori unbound size singl step processor either perform constant amount local comput access arbitrari cell share memori common crcw variant pram concurr read permit concurr write provid compet processor write valu jaj92 let tree visit simplic assum tree binari although result immedi extend gener class boundeddegre tree concret suppos node repres memori mean descriptor initi descriptor root avail share memori pram design locat descriptor node gener access descriptor node father visit node involv access descriptor gener store descriptor children mention node visit assum take constant time straightforward strategi solv backtrack search problem visit tree breadthrst levelbylevel fashion algorithm base strategi would proceed phase phase visit node certain level evenli redistribut children among processor guarante overal number parallel visit step nph term parallel visit step refer ktupl k p simultan visit distinct tree node perform distinct pram processor perfectli balanc redistribut tree node among processor success parallel visit step accomplish determinist use simpl parallel prex sum jaj92 yield onph log p overal run time backtrack search note strategi also work weaker erew pram variant concurr readwrit access allow fact asymptot optim number np visit step still achiev without perfect balanc requir node level tree approxim redistribut among processor node processor given must constant factor would receiv perfect balanc approxim redistribut attain use follow result goldberg zwick fact 2 gz95 arbitrari sequenc p integ valu 0 approxim prex sum b determin olog log p worstcas time pprocessor common crcwpram employ approxim prex sum implement node redistribut visit level tree get determinist onph log log p time algorithm backtrack search problem pprocessor common crcwpram valu n h p next section devis sophist strategi outperform simpl one tree log log plog log log p 2 asymptot improv result near optim perform care loadbalanc techniqu without excess global commun 3 highlevel view algorithm algorithm proce quasibreadthrst fashion let tree node partit h level node one level distanc root explor process split stage visit stratum tree consist consecut level begin stage node top level stratum approxim distribut among processor note previous mention straightforward strategi base approxim prex sum visit stratum size therefor focu techniqu cope ecient smaller strata consid stage visit stratum node conveni number level stratum 0 1 top bottom stage explor node level point explor set node whose descriptor gener yet visit call frontier initi frontier contain node top level stratum let f j denot frontier node level j denot entir frontier order evalu progress algorithm make dene weight function frontier f follow ie node level j weight 3 j note contribut frontier node wf exponenti decreas level within stratum also visit frontier node level j involv replac node frontier children whose combin weight 2 3 constant factor less parent henc node visit decreas frontier weight visit node lower number level rather node stratum result substanti decreas weight function order avoid frequent expens balanc step explor strategi necessarili proceed regular breadthrst man ner nonetheless make use certain cheaper weightdriven loadbalanc techniqu ensur frontier weight decreas predict rate pictori represent explor process shown fig 1 stage consist two part rst part sequenc parallel visit step perform explor node stratum frontier weight less equal p order detect end rst part visit stratum h fig 1 weightdriven explor process tree height h portion within thin solid line enclos visit node belong previou strata thick solid line enclos visitedgener node within current stratum level frontier node lie along thick spline dash line enclos node still gener b frontier weight reduct induc visit node level j stratum 0 j step execut batch weight estim comput execut batch use approxim prex sum algorithm whose olog log p complex domin visit step second part stage complet explor stratum follow first everi 0 j cluster 2 j distinct processor assign node f j mean approxim prex sum olog log p time sinc assign feasibl next descend node f visit correspond cluster processor time specic consid frontier node x level j let fp cluster processor assign explor proce 1 j round round k 0 k 1 j descend x distanc k visit round zero p 0 visit x give children p 0 p 1 thereaft round p take node given previou round visit give children processor p 2i p 2i1 end stage children node last level stratum make initi frontier next stage evenli distribut among processor employ approxim prex sum algorithm highlevel procedur descript new strategi visit small strata op 2 node given fig 2 summari stratum visit stage procedur stage visit rst altern parallel visit step procedur visit step approxim count frontier weight procedur approxim count latter goe p visit stratum complet rst alloc processor cluster residu unexplor node procedur alloc cluster visit subtre within stratum use simpl techniqu illustr procedur complet visit nalli redistribut initi frontier next stage p processor procedur redistribut node note three proce procedur stage visit wf p repeat time repeat fig 2 overal structur algorithm visit small strata dure node implement mean simpl variat approxim prex sum algorithm gz95 order determin total run time stage need give bound number visit step perform let f frontier begin tth visit step step call full visit p node f call reduc visit least half node rang 0 section 4 show perform visit step time olog log log p 2 ensur alway either full reduc see theorem 10 clearli stratum node omp full visit step stage wherea number reduc step bound follow lemma lemma reduc visit step sucient reduc frontier weight p proof proof base follow properti claim let x two sequenc nonneg integ proof claim proof induct n case suppos properti hold n 1 consid sequenc assum x n n sinc otherwis induct step immedi easi see note therefor appli induct hypothesi combin previou inequ prove claim consid reduc visit step let f frontier prior execut step let n j number node f j visit step visit step reduc 0 claim show jf jj thu visit node account least half total frontier weight sinc combin weight children node two third weight parent follow weight reduct must least one third total weight visit node ie least one sixth frontier weight wf prior execut visit step thu new frontier weight follow complet step 56wf sinc frontier begin stage contain op 2 node level 0 initi frontier weight op 2 3 impli frontier weight less equal p reduc step prove lemma discuss conclud new strategi employ visit stratum size visit step strata size visit omp time use straightforward breadthrst strategi outlin section 2 suitabl interleav two strategi obtain algorithm visit stratum time omp valu immedi yield backtrack search algorithm run time stipul theorem 1 note number visit step requir onp h 4 implement visit step section describ implement visit step enforc properti step alway either full reduc key idea heaplik data structur hold frontier node node extract prior begin visit step children insert end step conceptu compos p array tree ring also regard p pram processor conceptu arrang row begin visit step tree ring ith row contain current frontier node level 0 tree ring structur forest complet binari tree dierent size 1 leaf vertic tree ring node tree visit intern vertex contain pointer children root tree tree ring organ doublylink list order tree size data structur broadli similar one use cv88 previou section assum stratum visit size op 2 use k denot upper bound size ie number node descriptor store tree ring execut stage later show henc height tree tree ring alway olog note tree ring notion associ particular processor sinc store share pram memori access visit step consist two substep visit balanc describ follow paragraph visit substep execut parallel column processor let total number node held tree ring column let c 1 constant speci later processor column select minf 4cg topmost node union tree ring distribut node evenli among processor visit node receiv final children justvisit node insert appropri tree ring within column balanc substep execut parallel row processor aim partial balanc node store tree ring row dene degre processor number tree node contain tree ring let f sum degre processor row ie number frontier node level stratum balanc redistribut node among tree ring way upon complet minff processor degre larger cdf qe row 0 moreov balanc never increas maximum processor degre row actual implement balanc substep rather involv discuss separ subsect 41 avoid confus discuss element tree visit tree employ tree ring use term node exclus connect former reserv term vertex latter lemma 4 visit step alway either full reduc proof let f frontier begin visit step minfjf jj qg2k processor row j degre larger cdjf jjqe j 0 j ensur either balanc substep execut end preced visit step visit step consider rst stage approxim even distribut frontier node guarante start stage call tree node maintain overload processor bad node other good node sinc k upper bound degre processor total number bad node rst level frontier minfjf jj qg 0 thu bad node level lower account half total number frontier node level suppos jf j 3p let r q number column hold fewer node sinc column hold node number good node bound follow follow tediou simpl arithmet manipul impli r q1 18c sinc c constant greater one conclud column hold least node thu visit step visit node henc step full consid case jf j 3p sinc number good node column cjf jq 4c follow total number node visit step least equal total number good node observ made know visit good node 0 would visit least half frontier node level lower henc step would reduc sinc column select topmost node avail good node visit least number node higher level visit place maintain reduc properti order implement visit step describ need ecient primit oper tree ring consid stage visit stratum note begin stage degre processor 2 visit substep degre increas addit term node visit processor column gener two children singl visit step sinc balanc substep increas maximum degre processor omp visit step execut overal conclud maximum processor degre alway 3 consequ throughout stage tree ring contain olog tree 3 size olog height shown cv88 given k node evenli distribut among k processor tree ring whose tree contain node leav construct processor olog 2 two tree ring size ok merg one tree ring olog time singl processor 3 number k leav extract ok processor tree ring time proport maximum height tree tree ring extract tree ring structur restor within time bound easili argu visit substep implement straightforward fashion within column use standard techniqu prex aforement primit manipul tree ring discuss conclud lemma 5 strata size op 2 visit execut olog olog log log p time 41 implement balanc mention use denot upper bound degre processor stratum size op 2 explor exact valu k deriv analysi assum k known processor prior begin entir algorithm sinc balanc execut parallel independ row concentr oper perform arbitrari row say row k let f k denot total number tree node maintain processor row begin balanc substep purpos substep redistribut node among processor way redistribut number processor degre greater cdf k qe minff k qg2k note valu f k known processor substep also ensur maximum processor degre increas crucial featur implement balanc node physic exchang processor would costli purpos instead move manipul correspond tree ring cost logarithm number node move balanc base balanc strategi introduc broder et al bfsu92 make use special kind expand dene denit 6 bfsu92 undirect graph e b extrovert graph b 0 b 1 set v jsj ajv j least bjsj vertic strictli neighbour v exist regular extrovert graph constant degre prove probabilist method bfsu92 row identifi q processor vertic regular b extrovert graph e odd degre b constant let consist phase number 0 1 phase tree node maintain row processor mark dormant particip subsequ phase remain node said activ begin phase 0 frontier node activ 0 phase perform follow action 1 processor k activ node tree ring declar congest built direct version subgraph g construct proce perform step follow type bfsu92 initi empti step everi congest processor yet check whether least neighbour either noncongest alreadi enter acquir edg 12 neighbour also enter comment construct fact odd guarante dag congest processor outdegre greater indegre non congest processor dag outdegre 0 moreov depth 3 subdag 0 identi compris congest processor k activ node descend congest processor k activ node mark k activ node dormant 2 j k note k j processor 0 extract direct successor 0 tree contain 2 j distinct activ node tree ring send pointer tree successor question processor merg tree receiv tree ring pictori represent construct dag 0 perform phase balanc given fig 3 r r c r r b fig 3 dag construct process perform balanc extrovert graph g connect processor row white node repres uncongest processor black shade node repres respect heavili congest processor k activ node lightli congest processor k 2 k activ node bc twostep construct dag nal subdag 0 contain heavili congest node descend follow show end phase number processor degre cdf k qe minff k qg2k maximum processor degre increas lemma 7 0 begin phase processor hold k activ node k1 node moreov phase increas maximum processor degre proof proceed induct case suppos properti hold index induct processor start phase k activ node k node overal congest processor make dag involv movement node phase processor begin k node k activ k1 dormant end phase k node remain activ rest becom remain dormant moreov processor degre chang subdag 0 empti congest processor k activ node k k node sinc case exchang pointer take place properti index instead 0 empti least one congest processor k activ node note case maximum processor degre greater k congest processor 0 transmit activ node successor sinc outdegre congest processor 0 greater indegre repres net loss least node therefor processor number activ node end phase overal degre decreas moreov number dormant node processor stay unchang name k1 final noncongest processor begin phase k activ node receiv d2 j dk new activ node add less maximum processor degre previou case number dormant node processor stay unchang less k1 refer processor maintain dormant node rogu let rj denot set rogu begin phase j cj set processor declar congest phase dene r c log 1 ka lemma 8 proof proceed induct j case clearli true sinc suppos properti hold index j 1 consid index j note rogu begin phase j given set plu set c 0 cj 1 contain congest processor make dag phase j 1 let us give upper bound j note c j 1 minff k qg aq sinc otherwis congest processor would account activ node imposs extrovert graph g rst step dag construct number congest processor c j 1 impli jc 0 j c j 1 1 b henc number rogu begin phase j lemma 9 end balanc procedur number processor degre cdf k qe minff k qg2k suitabl choic constant c moreov procedur execut time olog log log p 2 common crcwpram proof let us rst consid case 0 begin phase 0 processor maintain k activ node lemma 7 number rogu 1 lemma 8 choic moreov lemma 7 show maximum degre processor rogu end phase 0 increas cdf k qe threshold subsequ 0 1 phase consid case 0 case c 2d moreov sinc r j increas j total number rogu indic equat 1 evalu run time consid phase balanc step 1 clearli take o1 time everi dag construct step accomplish constant time henc construct step 2 take time sinc depth easi see step 3 accomplish time well cost remain step domin cost extract merg oper perform tree ring take olog note number phase conclud overal run time log follow theorem combin contribut section establish result announc section 3 upon analysi backtrack strategi base theorem visit step within stratum size op 2 implement olog log log p 2 time pprocessor common crcwpram ensur step either full reduc 5 evalu boundeddegre dag section show idea involv backtrack search algorithm may use solv dag evalu problem comput dag node zero indegre regard input node repres oper whose operand valu comput predecessor ie node adjac respect incom edg node zero outdegre regard output node evalu operand evalu dag evalu problem consist evalu output node dene layer dag obviou way input layer zero layer everi node one plu maximum layer among predecessor parallel set assum dag constant degre store share memori pprocessor commoncrcw pram dag node repres descriptor contain follow inform eld speci type oper associ node eld store valu two eld operand ie incom edg processor write valu operand timestamp record time pointer node successor initi pointer descriptor dag input known evenli distribut among processor notic similar dag evalu backtrack search problem comput dag necessarili tree nevertheless still visit ie evalu proceed quasi breadthrst stratumbystratum fashion backtrack search algorithm precis recal backtrack search problem node reveal processor visit uniqu parent dag evalu prob lem visit node entail comput node valu write valu node descriptor togeth timestamp appropri eld successor descriptor node reveal henc readi evaluatedvisit last predecessor evalu node regard child predecessor tie broken arbitrarili fashion span forest dag implicitli identi dag evalu regard visit forest note backtrack search algorithm employ visit forest boundeddegre tree onp total number node h maximum treeheight forest conclud dag evalu problem solv within time bound 6 conclus work devis ecient determinist strategi perform parallel backtrack search share memori machin specic strategi attain run time tripli logarithm factor away natur lower bound problem previou studi investig mainli focus run time hand overal space requir algorithm grow larg tree size n wherea space requir random scheme propos kz93lab93ran94 bound minfn phg latter quantiti howev close n larg valu p andor highli unbalanc tree remain challeng open problem devis fast space ecient backtrack search algorithm gener studi timespac tradeo parallel backtrack search r code theori tight bound onlin tree embed approxim parallel schedul optim determinist approxim parallel pre fast determinist parallel branch bound determinist branch bound distributedmemori machin parallel algorithm backtrack search branch bound comput atom model messagepass dynam tree embed butter i hypercub simpler analysi karpzhang parallel branchand bound method optim speedup backtrack search butter network commun complex parallel divid andconqu tr approxim parallel schedul part basic techniqu applic optim parallel list rank logarithm time code theori hypercub embed fault toler commun complex parallel divideandconqu tight bound onlin tree embed introduct parallel algorithm dynam tree embed butterfli hypercub atom model messagepass random parallel algorithm backtrack search branchandbound comput branchandbound backtrack search meshconnect array processor optim speedup backtrack search butterfli network nearperfect token distribut optim determinist approxim parallel prefix sum applic simpler analysi karpzhang parallel branchandbound method