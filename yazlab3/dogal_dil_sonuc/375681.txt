mainmemori index structur fixeds partial key perform mainmemori index structur increasingli determin number cpu cach miss incur travers index key store indirectli standard mainmemori databas cost key retriev term cach miss domin cost index travers yet ineffici time space store even moder size key directli index node paper investig perform tree structur suitabl oltp workload face expens cach miss nontrivi key size propos two index structur pkttree pkbtree significantli reduc cach miss store partialkey inform index show small fix amount key inform allow cach miss avoid allow simpl node structur effici implement final studi perform cach behavior partialkey tree compar mainmemori tree structur wide varieti key size key valu distribut b introduct follow recent dramat reduct random access memori ram competit price disk storag year ago multigigabyt main memori easili afford expand 64bit architectur applic much 1 2 gb data main memori built rel inexpens system moder growth space requir need concern reason spur stringent perform demand advanc busi network internet applic number mainmemori databas mainmemori databas cach product appear market 2 22 29 product essenti fulfil expect research mainmemori databas last fifteen year see permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee acm sigmod 2001 may 2124 santa barbara california usa exampl 9 12 15 16 provid approxim orderof magnitud perform improv simpl databas applica tion compar disk databas data fulli resid main memori 2 29 adapt mainmemori databas algorithm becom cach consciou perform well multilevel mainmemori storag hierarchi recent receiv attent databas literatur 5 24 25 mention paper relat work see exampl 6 commonli use processor execut dozen instruct time taken read main memori cach miss instanc memori access time 450 mhz sun ultra 60 50 time slower time access data resid onchip cach fur ther dispar processor speed memori latenc expect grow sinc cpu speed increas much faster rate 60 per year memori speed 10 per consequ mainmemori index structur design minim cach miss index travers keep cpu cost space overhead low intuit cachemiss cost minim small node size high branch fac tor exampl 6 found optim node size btree implement slightli larger 1 cach block averag number key present node would fill cach block low cpu cost index travers import sinc cach miss cost fewdozen instruct set key comparison cost import compon cpu cost especi multipart variablelength key addit alli space overhead import sinc cost ram approxim 1mb 50 time expens disk storag result amount main memori avail index may limit cost factor lead constraint index size space usag depend space use repres key index node space use pointer averag occup node tree mainmemori oltp environ includ mix read updat oper ttree 1 b tree two index structur studi previous literatur 17 24 mainmemori databas product awar 2 29 implement ttree index structur propos lehman carey 17 howev 24 author found due higher cost cach miss modern hardwar tree perform better experi conduct integ key assumpt integ key may valid olap environ assum suitabl preprocess gener purpos databas must handl complex key multipl part null valu 1 ttree similar binari tree multipl key instead one store node variablelength field countryspecif sort valu etc key size key storag strategi directli affect branch factor tree sinc branch factor small alreadi node size base cach block height tree vari substanti key size chang thu initi motiv research examin ttree btree perform mainmemori oltp environ order consid varieti key storag scheme key size 9 17 author suggest avoid key size problem replac key valu index pointer data reconstruct key need index travers indirect keystorag approach advantag optim storag elimin duplic key valu index improv branch factor node simplifi search avoid complex store long variablelength key index node howev approach must reexamin due addit cach miss caus retriev indirect key second approach deal larg complex key use key compress allow key fit cach block keycompress approach benefit entir key valu construct without access data record dereferenc pointer howev typic compress scheme employ prefix btree 4 disadvantag compress key variables lead undesir space manag overhead small mainmemori index node depend distribut key valu prefixcompress key may still fairli long result low branch factor deeper tree paper propos partialkey approach use fixeds part key inform key differ minim number cach miss cost perform compar tree travers keep simpl node structur incur minim space overhead key repres partialkey tree pointer data record contain key valu key partial key given key index refer index key purpos discuss partial key consist 1 offset first bit index key differ base key 2 l bit index key valu follow offset l input paramet intuit base key given index key recent key encount search prior compar index key partialkey approach reli abl resolv comparison search key index key use partialkey inform index key comparison resolv pointer data record dereferenc obtain full index key valu use idea partial key develop pkttree pkbtree variant ttree btree respect describ search algorithm partialkey tree well strategi maintain partialkey inform presenc updat final conduct extens perform studi pkttree pkbtree structur compar standard tree btree direct indirect key storag scheme experi consid wide rang paramet set key size key valu distribut entropi also studi sensit partialkey algorithm l number key valu bit store partial key perform result given detail section 53 indic ffl index scheme studi partialkey tree minim cach miss key size ffl due lower cpu cost btree direct key storag faster partialkey tree small key size slower larger key size ffl partialkey scheme good space util slightli wors ttree indirect key storag much better direct key storag scheme ffl small fix valu l amount partial key informa avoid indirect key access wide varieti length entropi summari partialkey tree incur cach miss impos minim space overhead reduc cost key comparison without introduc variablelength structur node thu enabl larger key handl much effici smaller key expect rel perform partialkey tree improv time increas cost cach miss remaind paper organ follow section 2 discuss relat work section 3 4 introduc partial comparison appli search pkt pkbtree section 5 present result perform studi fi nalli section 6 present conclus issu address futur work 2 relat work earli studi index structur mainmemori databas undertaken 17 author propos ttree index order optim storag space advoc store pointer data record instead key valu index howev design choic result larg number cach miss sinc pointer derefer access key valu key comparison could potenti lead cach miss sinc time earli work mainmemori databas littl differ cost cachehit cachemiss much attent paid minim cach block miss work cacheconsci data structur outsid databas commun focus optim scientif workload cacheconsci behavior studi 6 pointerbas structur includ search tree howev work focus action taken without programm cooper rather explicitli design data structur recent rao ross propos two new mainmemori index techniqu cachesensit search tree csstree 24 cachesensit b tree 25 design readintens olap environ csstree essenti compact spaceeffici tree csstree node fulli pack key laid contigu level level main memori thu children node easili locat perform simpl arith metic explicit pointer child node longer need absenc updat key valu map integ map preserv order key valu thu key valu csstree compact int ger store node elimin pointer deref erenc summari csstree incur littl storag space overhead exhibit extrem good cach behavior csb tree adapt idea index structur support effici updat csstree author recommend rebuild scratch batch updat structur store group sibl node adjac memori reduc number pointer store parent node without incur addit cach miss howev work continu assum integ key ex tent perform improv csb tree csstree partialkey tree like orthogon sinc former focus reduc pointer overhead improv space util latter focus reduc keysiz comparison cost partialkey techniqu borrow earlier work key compress 4 11 howev differ discuss partialkey tree similar bit tree introduc 11 bit tree extend tree store partial key instead full key valu key contain leaf node partial key bit tree consist offset differ bit rel previou key node author describ sever properti search use offset differ bit particular show somewhat surpris result precis posit search key leaf node determin perform exactli one pointer derefer retriev indirect key focu mainmemori rather disk partialkey tree differ bit tree follow respect 1 partial key store intern node leaf node 2 partial key contain l bit key valu follow differ bit addit differ bit offset 3 search key node partialkey tree requir one pointer dereferenc frequent requir pointer derefer due l bit addit inform novel search algorithm tree propos 4 employ key compress improv storag space characterist branch factor tree suppos p common prefix key subtre root node n node n common prefix p comput tree travers suffix key valu store n key move leaf node due split separ shortest portion key need distinguish valu split node move partialkey tree differ prefix b tree follow respect 1 prefix tree factor portion common key node partialkey tree factor inform common pair adjac key within node typic longer prefix common whole node 2 prefix tree entir suffix separ store partialkey tree first l bit suffix store thu partialkey tree may lose key valu inform prefix 3 prefix b need contrast partialkey tree pointer derefer must perform comparison resolv use partialkey inform 4 partial key store prefix tree variabl size complic implement case separ may even fit 64byte cach line caus index node span multipl cach block reduc branch factor thu partial key tree trade guarante indirect key refer partialkey tree low probabl indirect key derefer exchang simpl node structur strongli bound tree height reason sinc cost cachemiss order magnitud lower cost random disk access ronstrom thesi 28 describ httptree variat prefix tree compress perform within node store key rel previou key factor common suffix etc node also cluster page facilit distribut howev search full key reconstruct order perform comparison compress key size variabl lossless compress scheme primarili numer attribut recent propos databas literatur 13 23 goldstein ramakrishnan shaft 13 propos page level algorithm compress tabl numer attribut minimum valu occur tupl page store separ entir page instead store origin valu attribut tupl differ origin valu minimum store tuple00101111101010 rec 2 1 data record partial l bit figur 1 partial key thu sinc store differ consum fewer bit storag space overhead tabl reduc tupl differenti code tdc 23 compress method also achiev space save store differ instead actual valu attribut howev attribut valu tupl store differ rel attribut valu preced tupl 3 partial key search section describ partial key approach algorithm perform compar search presenc partial key assum key repres fixedlength bit string though requir gener bit number order decreas signific begin bit 0 signific bit 31 partial key overview consid order index key visit compar search key travers ttree btree index observ structur key visit far closest valu search key either recent key compar less search key recent key compar greater easi see recent key compar less search key share initi bit compar less search key search similarli recent key compar greater thu observ follow fact initi bit may share recent search key exampl key either side larg power two event rare follow discuss refer current key visit index key oppos search key previou visit base key partialkey scheme key repres index three item 1 pointer record contain key 2 offset first bit index key differ base key 3 first l bit index key follow offset illustr construct partial key figur 1 figur other index key search key gener refer k k j base key one approach use partial key inform would mirror use prefix prefix btree approach search code would maintain known prefix index key travers tree concaten appropri portion partial key encount known portion suffici resolv comparison search key cach miss avoid howev turn construct prefix necessari fact comparison often resolv note offset search key differ base key compar offset store partial key index key observ ensur comparison perform small fixedlength portion key precis comparison perform topic next section 32 partialkey comparison section discuss properti differ bit formal present theorem bear directli comparison partialkey tree offset signific thu lowest bit differ key k k j also let ck result lt gt eq comparison key k depend whether k k j partialkey approach base observ index key k j base key k b note partial key key k j frequent allow full comparison k j search key k avoid index retriev particular two k j compar way lt exampl base key known possibl determin k compar k j well addit refer key unless theorem 31 given k ae proof assum without loss gener k suppos dk first bit differ must 0 k b bit must 1 follow dk bit k agre bit k b bit includ dk correspond bit k also 1 thu hand suppos dk thu sinc k bit posit dk must 0 k 1 k b sinc dk must k j k b 1 bit sequenc preced bit k k j must ident thu follow k case follow symmetri key idea theorem 31 illustr figur 2a less base key k b dk 9 greater dk 5 thu shown figur first 5 bit k k j k b match 6 th bit k k b 1 k j 0 theorem 31 use comput case result comparison search key k index key k j partial key index key k j store differ bit offset respect base key k b encount previous search sinc attempt made search algorithm compar k k j must case ck avail due previou comparison search key base key thu case dk theorem 31 use infer dk turn propag next index key comparison k j base key case handl theorem 31 occur dk case infer one make ident first dk one determin key k k j compar exampl illustr figur 2b case shown figur k one k differ bit equal l bit key valu store index key compar correspond bit search key bit equal retriev indirectli store key requir note shown figur 1 differ bit includ l bit store partial key sinc k k j differ k b valu bit correspond bit k k j must ident procedur comparepartkeysearchkey indkey comp offset begin 1 indkeypkoffset offset 2 3 comp gt 4 els 5 comp lt 6 offset indkeypkoffset 7 els indkeypkoffset offset 8 9 partkey searchkey0indkeypkoffset1 10 els 11 partkey searchkey0indkeypkoffset1 12 comp offset comparesearchkey 13 14 offset indkeypkoffset 15 comp eq 16 return comp offset figur 3 comparepartkey comparison use partial key procedur comparepartkey figur 3 util theorem 31 comput result comparison search key index key contain partialkey inform partialkey inform consist three field pkoffset pklength partkey describ tabl 1 input paramet comp offset comparepartkey result comparison differ bit locat search key respect base key step 16 procedur straightforward applic theorem 31 case differ bit locat search key index key equal key must ident differ bit differ bit key must either 0 1 depend whether key less greater base key step 12 function compar invok comput comparison l bit follow differ bit key function comparek1 k2 return pair valu comp offset follow semant valu comp one eq lt gt depend whether bit sequenc k1 equal less greater bit sequenc k2 two sequenc compar bit bit return valu offset locat signific bit two key differ thu step 1314 sinc partkey may repres entir index key bit partkey agre correspond bit searchkey comparison search key index key resolv procedur return eq case semant return offset simpli two key agre first offsetgamma1 bit note step 12 function compar need consid bit start bit offset indkeyoffset two key sinc correspond bit preced point ident 2 therefor b figur 2 exampl comparison key k k j resolv tabl 1 partialkey notat symbol descript l maximum number bit key valu store partial key offset differ bit key k base key bit follow locat k pkoffset key k pklength number partialkey bit store key k sequenc consist bit offset l key k k1 delta k2 concaten bit sequenc k1 k2 n numkey number key node n th key node n th pointer node n key case procedur comparepartkey perform one integ comparison involv differ bit offset howev addit expens may incur sinc bit offset must comput anticip next comparison greater cost simpl integ compar compar well comparison larger key shown section 5 partialkey scheme adapt multiseg key even segment arbitrari length idea treat pkoffset two digit number first digit indic key segment second indic offset within seg ment partkey field may limit bit singl seg ment cost complex span segment 33 partialkey node comparepartkey procedur describ previou section basic build block perform retriev pkt tree pkbtree present complet algorithm search tree present linear encod scheme comput partial key array key index node n also present linear search algorithm find search key node present pair adjac key node search key lie linear encod partial key base key key n simpli key immedi preced n first key nkey0 base key key ancestor n tree compar search key tree travers node n visit thu base key first key depend tree structur differ pkttree pkbtree discuss follow section simpl linear search algorithm search key index node n visit search key compar base key nkey0 let comp offset denot result comparison offset differ bit search key base key order locat posit search key n procedur comparepartkey see figur use comput comparison differ bit offset search key nkey0 case comparison resolv use partialkey inform nkey0 comparepartkey return eq nkey0 dereferenc search key compar full key correspond nkey0 result comparison differ bit offset use compar search key nkey1 step compar search repeat success key n comparison differ bit offset previou key key greater equal search key found howev naiv linear search strategi may perform unnecessari derefer follow exampl illustr 32 consid node n figur 4 differ bit key respect previou key mark arrow bit follow differ bit store partial key key let base key first key n search key figur 4 linear search key node 00101 let search key 10111 search key compar base key comparison differ bit offset gt 0 respect invok comparepartkey search key nkey0 gt return eq 2 sinc nkey0pkoffset 0 search match nkey0 first two bit thu nkey0 would dereferenc comp pkoffset comparison nkey0 gt 2 respect next search key compar nkey1 invok comparepartkey sinc greater 2 differ bit offset search key nkey0 comparepartkey return gt 2 nkey1 dereferenc next invoc comparepartkey nkey2 return gt 3 sinc bit sequenc 1010 construct nkey2 smaller 1011 correspond bit search key return gt 3 nkey3 parepartkey move key 4 return lt 1 nkey4 sinc find nkey4pkoffset 1 less 3 offset return nkey3 thu simpl linear search algorithm stop nkey4 posit search key n determin use one key derefer nkey0 howev posit search key also determin without dereferenc key includ nkey0 reason comparepartkey return eq 2 invok nkey0 thu point know first two bit nkey0 10 sinc first two bit nkey0 agre search key sinc nkey1pkoffset 3 also conclud first two bit nkey1 agre nkey0 thu 10 sinc must case third bit nkey2 1 third bit nkey1 must 0 fourth bit nkey2 obtain partial key thu conclud first four bit nkey2 1010 sinc search key 10111 comparison search key nkey2 resolv gt 3 subsequ comparison carri describ earlier conclud search key lie nkey3 nkey4 thu posit search key determin without dereferenc singl key linear search algorithm requir one key deref erenc procedur findnod shown figur 5 avoid unnecessari derefer made simpl linear search algorithm compar search key index key node n case procedur comparepartkey return eq comparison search key index key resolv findnod immedi derefer index key stead exploit semant eq offset return com procedur findnoden searchkey offset begin 1 high n numkey 2 low 1 3 cur offset 4 cur cmp gt 5 cur low 1 6 cur highf 7 cur cmp cur 8 comparepartkeysearchkey n keycur cur cmp cur 9 cur 10 high cur 11 break 12 els cur 13 low cur 14 offset cur 15 cur 17 high low 1 18 low high offset findbittreen searchkey low high 19 cach miss 20 return low high offset figur 5 findnod linear search key node use partial key parepartkey search key index key agre first offset1 bit tri resolv comparison subsequ key illustr earlier exampl 32 eq 2 result comparison nkey0 use resolv comparison oper key nkey2 fact procedur comparepartkey alreadi state correctli handl valu eq input paramet call findnod inform proof fact found appendix procedur findnod accept input paramet node n perform linear search differ bit offset search key base key nkey0 assum search key nkey0 greater base key respect nkey0 partial key comput similar simpl linear search algorithm describ earlier compar search key success index key node index key larger search key found procedur comparepartkey use perform everi comparison result previou comparison store variabl cur cmp cur pass input paramet unlik simpl linear search scheme index key immedi dereferenc precis result comparison key search key comput instead variabl low high use keep track posit index key n search key definit known greater less respect end sweep key node n high low greater 1 impli precis posit search key n ambigu case procedur findbittre use locat exact posit search key low high return consecut key search key lie differ bit offset search key respect lower key procedur findbittre employ search algorithm bit tree describ 11 requir exactli one key dereferenc nutshel algorithm perform sequenti scan key n offset low high maintain variabl po initi set low key examin differ bit offset partial key bit valu search key 1 variabl po set posit key n hand bit valu search key 0 key differ bit offset greater current skip next key examin key whose differ bit offset less current key examin nkeypo dereferenc compar search key comp offset pair return comparesearchkey nkeypo findbittre take one follow action 1 2 suppos high posit first key rightleft po differ bit offset less nkeypo return high1 high offset correct findbittre case 2 due follow properti po po key whose differ bit offset equal po key whose differ bit offset less poss refer reader 11 detail variabl offset return findnod differ bit offset search key n keylow 1 case low 1 search key less nkey0 offset differ bit offset search key base key nkey0 final search key contain n procedur return posit index key equal search key revisit exampl 32 findnod determin posit search key node n without requir key deref erenc success invoc procedur comparepartkey sequenc key n return eq 2 eq 2 gt 3 gt 3 lt 1 maintain partialkey inform presenc date linear encod strategi maintain partial key inform quit straightforward insert new key node requir partial key insert key key follow recomput delet requir partial key key follow delet key recomput 4 partialkey tree build partialkey comparison singlenod partial search algorithm present previou section discuss partial key improv perform mainmemori index structur reduc l2 cach miss rate particular present partialkey variant ttree 17 btree 3 index structur suitabl use mainmemori pktttree pkbtree refer extend mainmemori counterpart repres key partialkey inform describ section 3 linear encod scheme describ previou section use comput partial key index key node linear encod node level thu need specifi base key respect first key node encod sinc base key everi key node simpli key preced 41 pkttree ttree balanc binari tree multipl key store node leftmost rightmost key valu node defin rang key valu contain node balanc handl avl tree 1 refer reader 17 26 addit inform ttree includ detail updat strategi concurr control pkttree similar ttree except addit pointer data record contain full key valu index key entri also contain partialkey format follow nptr0 nptr1 denot pointer left right children node n store partialkey inform first key node n base key respect partial key comput first key parent node describ leftmost key parent node key search key compar node n visit figur 6a depict exampl pkttree figur solid arrow denot base index key dash arrow repres pointer child node procedur findttreesearchkey begin 1 n root tree 2 lan nil 3 offset 0 4 comp gt 5 n nil f 6 comp offset comparepartkeysearchkey 7 8 derefer nkey0 cach miss 9 comp offset comparesearchkeynkey0 10 11 return n 0 0 offset 12 els 13 n nptr0 14 els 15 lan n 16 lanoffset offset 17 n n ptr1 19 return lan findnodelan lan0 searchkey lanoffset figur 7 findttre search key ttree use partial key search key search key valu pkttree rel straightforward perform describ procedur findttre see figur 7 procedur findttre includ optim 17 requir node search key compar leftmost key valu node step 6 variabl comp offset keep track result recent comparison search key leftmost key parent node pass paramet com parepartkey case comparepartkey resolv comparison leftmost key current node dereferenc step 8 search key found less key search proce left subtre found greater search proce right subtre current node note variabl lan step 15 signific lan search reach bottom tree search key present tree node store lan greater lan0 procedur findnod thu employ order determin posit search key node lan sinc find node requir leftmost key greater base key lan0 delet lan pass input paramet findnod maintain partialkey inform presenc date insert delet key pkttree caus ro tation movement key node insertionsdelet pkttree b pkbtree pointer pointer figur pkttree pkbtree key node partialkey inform case updat follow ffl case rotat parent node involv rotat may chang thu partialkey inform leftmost key node recomput respect new parent ffl leftmost key node chang partialkey inform recomput leftmost key node two children ffl case key left key node chang due key insert delet partialkey inform key recomput rel new preced key 42 pkbtree pkbtree ident btree except structur index key index key consist pointer data record key partialkey inform leaf node contain index intern node also contain nnumkey1 pointer index node subtre point nptri contain key store partialkey inform base key leftmost key n largest key contain ancestor n less leftmost key thu n 0 node n 0 ptri point n one parent n 00 path n 0 n n 00 ptr0 point n one parent base key rel nkey0 encod n illustr figur 6b solid arrow denot base key index key pkbtree dash arrow repres pointer child node search key procedur findbtre figur 8 contain code search key pkbtree begin root node node procedur findnod invok determin child node visit next search variabl offset store offset differ bit search key base key nkey0 largest key ancestor n also less nkey0 findnod simpli return offset input search key less nkey0 maintain partialkey inform presenc date insert oper caus key insert leaf node pkbtree key insert leftmost posit leaf partial key need comput rel largest key less ancestor hand key left node partial key procedur findbtreesearchkey begin 1 n root tree 2 pn nil 3 offset 0 4 n nil f 5 pn n 6 low high offset findnoden searchkey offset 7 low high 8 return n low high 9 n nptrhigh 11 return pn low high figur 8 findbtre search key btree use partial key comput easili rel preced key partial key next key comput respect case node n split split key n insert parent split thu handl simpli updat partialkey inform parent similar key insert case key delet pkbtree somewhat complic case leftmost key leaf delet partialkey inform need recomput base key ancestor delet nonleftmost key leaf simpli requir partial key key follow recomput final delet key nkeyi intern node n pkbtree caus replac smallest key subtre point node contain key everi node n 00 n n 00 n 00 0s partial key recomput smallest key replac delet key nkeyi base key 5 perform goal perform studi compar lookup perform ttree btree pkttree pkbtree mainmemori set particular goal follow 1 studi perform wide rang key size key valu distri bution 2 evalu impact chang amount partial inform use pkt pkbtree 3 evalu space usag spacetim tradeoff subsequ section describ hardwar platform design experi present select result 51 memori hierarchi latenc observ memori refer depend primarili whether data present cach whether vir system cpu l1 data l2 data dram cycl time size block latenc size block latenc l2 miss latenc sun ultra 37n 16k 64 6n 2m 64 33n 266n sun ultra 22n 16k 64 4n 4m 64 22n 208n pentium iii 17n 16k 5n 512k 40n 142n pentium iiie 14n 16k 4n 256k 10n 113n tabl 2 latenc cach vs memori tual address translat lookasid buffer tlb 2 modern mainmemori architectur typic includ two level cach small fast oncpu l1 cach larger offcpu 3 therefor slower l2 cach typic paramet cach memori speed shown tabl 2 see 19 20 7 latenc inform gener version 19 lmbench 18 local avail processor intend give reader feel current cach paramet comparison system anoth compon memori hierarchi tlb cach translat virtual physic address shown 5 signific effect perfor manc focu tlb issu paper one justif approach fact almost modern tlb capabl use superpag 14 essenti allow singl tlb entri point much larger region pose difficulti oper system implementor 27 facil may effect remov tlb miss issu mainmemori databas allow entir databas effect share one two tlb entri focu tlb effect appar experiment form better perform index node span multipl cach line result shown due limit space determin effect superpag tlb cost mainmemori data structur remain futur work 52 experiment design implement ttree btree direct indirect storag key also implement pkttree pkbtree vari size partial key store node ttree algorithm essenti lehman carey optim perform singl keycomparison given level direct key partialkey variant store en tireparti key valu leftmost key node use initi travers ttree code adapt system addit support concurr control 26 next lock 21 iteratorbas scan featur exercis test partialkey tree implement two scheme store offset bitwis bytewis bitwis scheme use descript section 3 sinc scheme concept clearli articul howev may conveni implement store differ inform larger granular particular consid byte granular clearli result section 3 4 hold byte offset differ sinc bit offset also differ manner ever byte offset equal may still case bit offset would differ case one simpli store bit differ could occur word entir byte thu offset compar equal key disambigu 2 physic characterist memori modul especi repeat access page may also factor consid paper 3 pentium iiie l2 cach though rel small onchip first byte store offset larger granular trade distinguish power code simplic bit offset one alway store precis l bit capabl distinguish otherwis bit store key model key uniqu fixedlength sequenc unsign byte key comparison perform bytewis context separ function call indirect key store separ l2 cach line sinc typic retriev data record intuit partial key would sensit distribut key particular entropi key sinc test gener byte key independ entropi byte depend number symbol byte select specif byte select uniformli alphabet n symbol byte contain lg n bit shannon entropi 8 intuit key higher entropi distinguish earlier compar lead lower comparison cost term partial key lower entropi lead larger common prefix lower chanc two key differ within l byte common prefix mention section 3 partialkey tree may use multipart variablelength key implement option test note degre implement wider varieti key thu expens key com parison work partialkey scheme sinc scheme reduc impact key comparison cost case partial key suffici howev bytewis comparison may somewhat less effici exampl singleinstruct integ comparison select bytewis comparison reason model key comparison expens attempt vari cost addit paramet current studi perform metric evalu variou indic base follow three perform metric walltim number l2 cach miss storag space requir number l2 measur use special regist avail ultrasparc via perfmon softwar 10 paramet set unless otherwis state index node span three l2cach block total 192 byte index store 1m key key chosen uniformli random reject uniqu three cach block chosen size could handl larger innod key size experi shown perform compar better smaller larger node size studi algorithm 1m record repres largest size machin could easili hold memori rel larg number record requir see effect l2 cach miss time number test present result two choic byte entropi gener key 36 bit 78 bit correspond alphabet size 12 220 respect though actual experi consid wide varieti entropi inbetween experi key size independ paramet fix time per lookup usec l2 miss per lookup time vs cach miss pkbtree pkttree time per lookup usec l2 miss per lookup time vs cach miss pkbtree pkttree b figur 9 time l2 cach perform variou key strategi high low entropi size l partial key store 2 byte store offset byte granular sinc found partialkey tree perform optim nearoptim choic hardwar environ experi conduct sun ultra workstat 296mhz ultrasparc ii processor 256 megabyt ram shown tabl 2 machin 16k l1 data cach size 2m l2 directmap cach 64 byte block size latenc shown lmbench 18 6n 2 cycl l1 cach 33n 11 cycl l2 266 ns 88 cycl main memori implement index structur use sun c compil version 42 optim level o3 experi ensur virtual memori access run resid ram experiment run case run consist 100000 lookup pregener list randomli select key tree search success run repeat 10 time averag ensur overal standard deviat time low less 1 figur shown document tree 15 million element maximum fit main memori platform 53 select result index perform mainmemori environ domin cpu cost perform key comparison cach miss cost thu reason btree direct key storag perform better partialkey tree small key sinc space usag compar space requir partial key partialkey comparison code somewhat expens simpl bytewis key compar howev key becom longer btree perform expect becom wors partial tree due lower branch factor higher key comparison cost low byteentropi case expect indirect index perform poorli comparison direct index data structur indirect index requir extra cach miss perform comparison expect confirm experi figur 9 summar experiment result index scheme data set 15 million element yaxi show number l2 cach miss xaxi show averag time lookup microsecond plot parametr key size key size 8 12 20 28 36 byte high entropi case addit point size 4 figur 9a show behavior low entropi entropi per byte 36 figur 9b show experi run entropi 78 given key size entropi left defin improv perform perform thu partial order one algorithm outperform anoth valu key size entropi valu algorithm faster fewer cach miss use metric cach miss lookup time make follow observ ffl pkbtree consist outperform algorithm l2 cach miss ffl direct btree outperform algorithm time small key size would hold integ key ffl direct ttree outperform algorithm time larg key size slightli outperform pkbtree ffl direct ttree indirect btree essenti cach perform occur ttree suffer due tree level btree suffer due key dereferenc ffl indirect ttree perform poorli compar strate gie primarili due cach miss tree level dereferenc ffl key size cachemiss behavior partialkey tree good correspond tree structur direct storag 4 byte key one reason superior cachemiss characterist partialkey tree alway translat better time number especi smaller key size factor like cpu cost perform key comparison etc signific compon overal perform howev base cachemiss statist expect perform partialkey tree improv rel tree direct key storag long processor speed improv quickli mainmemori latenc choic l larger valu l necessari entropi low suffici entropi must present partial key high probabl differ correspond byte search key gener random key length l 2 lg 2 nh ensur two key collid key disambigu length lg 2 nh 8 one see key wise differ inform adapt low entropi key key time per lookup usec partial key length byte pkb bit pkb byte pkt bit pkt byte time per lookup usec overhead per key byte pkbtree pkttree b figur 10 vari partialkey size timespac tradeoff low entropi adjac key like larger common prefix increas l advers affect branch factor node thu tradeoff reduc cach miss avoid refer indirect key reduc cach miss bushier thu shallow tree investig issu run experi wide varieti key entropi valu l experi key rel low entropi 36 bit per byte result similar wide rang entropi valu expect partial key perform well wide varieti key distribut fact perform almost alway optim small valu l 2 4 byte due efficaci store differ offset store zero byte key inform special case reduc algorithm similar bit tree 11 gener handl intern level tree incur fewer cach miss option perform well l 0 experi confirm follow intuit store differ bit level import order increas distinguish power space usag space overhead critic attribut mainmemori index figur 10b show spacetim tradeoff differ algorithm varieti key size graph xaxi space axi lookup time lower lefthand corner optim key size paramet vari 0 8 byte space number obtain tree built random insert 1m key see graph indirect storag poor time perform excel space ever scheme direct key storag trade space time storag overhead increas significantli key size pkt pkbtree provid nice tradeoff take approxim twice space indirect storag key size less space directstorag btree key size greater 4 6 conclus futur work paper introduc two new index structur pkt pkbtree design optim space time cachemiss perform indic mainmemori oltp databas index structur base partial key small fixeds represent key allow index node retain simpl struc ture improv branch factor speed key comparison yet resolv key comparison without refer indirectli store key perform studi found partialkey tree perform better btree key store directli node key larger 1220 byte depend key distribut partialkey tree incur fewer cach miss btree smallest key size lead expect perform pkbtree rel btree improv time gap processor main memori speed widen caus penalti cach miss sever fi nalli pkbtree take much less space standard btree smallest tree pkttree direct ttree perform well pkbtree perform better slightli larger howev expect time ttree replac variat btree mainmemori databas dramat better l2 cach coher optim perform key size perform result lead one consid hybrid approach direct storag use small fixedlength key partialkey represent use larger variablelength key futur work intend explor way architectur trend affect performancecrit mainmemori dbm code one trend increas avail instructionlevel parallel relat trend increas cost branch mispredict pipelin bubbl second trend avail superpag tlb may significantli reduc tlb cost inmemori algorithm 7 r design analysi comput algorithm storag manag main memori databas perform critic applic organ mainten larg order index prefix btree databas architectur optim new bottleneck memori access imporv pointerbas code cacheconsci data placement pentium iii processor sc242 450 mhz 800 mhz datasheet element inform theori implement techniqu main memori databas system perfmon user guid main memori databas system overview compress relat index virtual memori contemporari microprocessor dali high perform mainmemori storag manag evalu starburst memori resid storag compon studi index structur main memori databas manag system portabl tool perform analysi ultra ultra workstat datasheet arieskvl keyvalu lock method concurr control multiact transact oper btree index microsoft com cach consciou index decisionsupport main memori make b logic physic version mainmemori databas reduc tlb memori overhead use onlin superpag promot design model parallel data server telecom applic timesten team tr element inform theori bittre data structur fast file process reduc tlb memori overhead use onlin superpag promot storag manag inmemori data manag consum transact timesten approach prefix italicbitalictre make b tree cach consciou main memori design analysi comput algorithm implement techniqu main memori databas system virtual memori contemporari microprocessor main memori databas system evalu starburst memori resid storag compon blockori compress techniqu larg statist databas compress relat index logic physic version main memori databas studi index structur main memori databas manag system cach consciou index decisionsupport main memori databas architectur optim new bottleneck ctr peter bumbuli ivan bowman compact btree proceed 2002 acm sigmod intern confer manag data june 0306 2002 madison wisconsin bin cui beng chin ooi jianwen su kianle tan contort high dimension data effici main memori knn process proceed acm sigmod intern confer manag data june 0912 2003 san diego california phil garcia multithread architectur sort benchmark proceed 1st intern workshop data manag new hardwar june 1212 2005 baltimor maryland b barla cambazoglu cevdet aykanat perform queri process implement rankingbas text retriev system use invert indic inform process manag intern journal v42 n4 p875898 juli 2006 inga sitzmann peter j stuckey compact discrimin inform spatial tree australian comput scienc commun v24 n2 p167176 januaryfebruari 2002 main memori index case bdtree ieee transact knowledg data engin v16 n7 p870874 juli 2004 jingren zhou john cieslewicz kenneth ross mihir shah improv databas perform simultan multithread processor proceed 31st intern confer larg data base august 30septemb 02 2005 trondheim norway ke wang yabo xu jeffrey xu yu scalabl sequenti pattern mine biolog sequenc proceed thirteenth acm intern confer inform knowledg manag novemb 0813 2004 washington dc usa bin cui beng chin ooi jianwen su kianle tan index highdimension data effici inmemori similar search ieee transact knowledg data engin v17 n3 p339353 march 2005 shimin chen phillip b gibbon todd c mowri gari valentin fractal prefetch btree optim cach disk perform proceed 2002 acm sigmod intern confer manag data june 0306 2002 madison wisconsin richard hankin jignesh patel effect node size perform cacheconsci btree acm sigmetr perform evalu review v31 n1 june shimin chen phillip b gibbon todd c mowri improv index perform prefetch acm sigmod record v30 n2 p235246 june 2001 bingsheng qiong luo cacheoblivi nestedloop join proceed 15th acm intern confer inform knowledg manag novemb 0611 2006 arlington virginia usa jeong min shim seok il song jae soo yoo young soo min effici cach consciou multidimension index structur inform process letter v92 n3 p133142 15 novemb 2004