simpl fast parallel hash oblivi execut hash tabl represent set linear size data structur support constanttim membership queri show construct hash tabl given set n key olg lg n parallel time high probabl use n processor weak version concurrentread concurrentwrit parallel random access machin crcw pram algorithm use novel approach hash oblivi execut base probabilist analysi algorithm simpl follow structur partit input set bucket random polynomi constant degre 1 olg lg n alloc mt memori block size kt let bucket select block random tri inject map key block use random linear function bucket fail carri next iter crux algorithm care priori select paramet mt kt algorithm use olg lg n random word implement workeffici manner b introduct let set n key drawn finit univers u hash problem construct follow attribut inject two key map h valu space effici space requir repres h time effici everi x 2 u hx evalu o1 time singl processor function induc linear space data structur perfect hash tabl repres data structur support membership queri o1 time paper present simpl fast effici parallel algorithm hash problem use n processor run time algorithm olg lg n overwhelm probabl superior previous known algorithm sever respect comput model model comput use concurrentread concurr parallel random access machin crcw pram famili see eg 35 member famili differ outcom event one processor attempt write simultan share memori locat main submodel crcw pram descend order power prioriti 29 lowestnumb processor succe arbitrari 42 one processor succe known advanc one collis 9 differ valu attempt written special collis symbol written cell collis 15 special collis symbol written cell toler 32 content cell chang final less standard robust 7 34 two processor attempt write cell given step attempt cell obtain valu 11 previou work hash tabl fundament data structur numer applic comput scienc extens studi literatur see eg 37 40 survey 41 recent one particular interest perfect hash tabl everi membership queri guarante complet constant time worst case perfect hash tabl perhap even signific parallel context sinc time execut batch queri parallel determin slowest queri fredman komlo szemeredi 16 first solv hash problem expect linear time univers size input set scheme build 2level hash function level1 function split subset bucket whose size distribut favor manner inject level2 hash function built subset alloc privat memori block appropri size 2level scheme form basi algorithm dynam version hash problem also call dictionari problem insert delet may chang dynam algorithm given dietzfelbing karlin mehlhorn meyer auf der heid rohnert tarjan 12 dietzfelbing meyer auf der heid 14 dietzfelbing gil matia pippeng 11 parallel set dietzfelbing meyer auf der heid 13 present algorithm dictionari problem fix ffl 0 n arbitrari dictionari instruct insert delet lookup execut ffl expect time n 1gammaffl processor prioriti crcw matia vishkin 39 present algorithm hash problem run olg n expect time use lg n processor arbitrari crcw fastest parallel hash algorithm previou work base 2level scheme make extens use count sort procedur known lower bound parallel hash given gil meyer auf der heid wigderson 27 rather gener model comput requir number parallel step omegagamma1 n also show restrict model one processor may simultan work key parallel hash time isomegagamma3 lg n also gave algorithm yield match upper bound function applic charg oper eg count sort free algorithm fall within realm mention restrict model match omegagamma lg n lower bound charg oper concret pram model 12 result main result linear static hash tabl construct olg lg n time high probabl space use n processor crcw pram algorithm follow properti time optim best possibl result use processor realloc shown 27 optim speedup achiev small penalti execut time signific improv olg n time algorithm 39 reliabl time bound olg lg n obey high probabl contrast time bound algorithm 39 guarante constant probabl simplic arguabl simpler hash algorithm previous publish never theless analysi quit involv due tight tradeoff probabl conflict event reduc random adapt consum olg lg n random word compar omegagamma n random word previous use work optim work optim implement present timeprocessor product run time increas factor olg n also requir olg lg n random word comput model allow lookup time olg lg n well algorithm implement robust crcw model result summar follow theorem theorem 1 given set n key drawn univers u hash problem solv use space olg lg n time high probabl use n processor ii olg lg n lg n time oper high probabl algorithm run crcw pram realloc processor key employ use olg lg bit previou algorithm implement 2level scheme either sequenti parallel base group key accord bucket belong requir learn size bucket bucket alloc privat memori block whose size depend bucket size approach reli techniqu relat sort count requir omegagammaeq n lg lg n time solv polynomi number processor impli lower bound beam hastad 4 lower bound hold even random algorithm recent result found involv way circumv barrier cf 38 3 26 30 circumv obstacl learn bucket size purpos appropri memori alloc techniqu oblivi execut sketch figur 1 1 partit input set bucket random polynomi constant degre 2 1 olg lg n alloc memori block size k b let bucket select block random tri inject map block use random linear function block select anoth bucket inject map found bucket carri next iter figur 1 templat hash algorithm crux algorithm care priori select paramet k iter k depend expect number activ bucket expect distribut bucket size iter way make desir progress possibl rather like execut oblivi follow sens bucket treat equal regardless size algorithm make explicit attempt estim size individu bucket alloc memori bucket base size case previou implement 2level scheme attempt estim number activ bucket distribut size select paramet k iter made accord priori estim random variabl estim base properti level1 hash function well induct assumpt behavior previou iter remark hash result demonstr power random parallel comput crcw machin memori restrict linear size boppana 6 consid problem element distinct given n integ decid whether distinct show solv element distinct nprocessor prioriti machin bound memori requir omegagammaeq n lg lg n time bound memori mean memori size arbitrari function n rang input valu easi see memori size bound omegagamma element distinct solv o1 expect time use hash function fact 22 howev hold linear size memori parallel hash algorithm impli incorpor random element distinct solv expect olg lg n time use n processor collis weaker prioriti model linear memori size 13 applic perfect hash tabl data structur use tool parallel algorithm matia vishkin 39 propos use parallel hash scheme space reduct algorithm larg amount space requir commun processor algorithm becom space effici preserv number oper penalti introduc random increas time use hash scheme time increas may substanti smaller algorithm use scheme 39 result time increas olg n use new scheme time increas lg lg n lg n case construct suffix tree string 2 17 name assign procedur substr larg alphabet 17 algorithm time increas 39 olg lg n lg lg n 2 algorithm leav expect time unchang case integ sort polynomi rang 33 superpolynomi rang 5 39 applic discuss conclus section 14 outlin rest paper organ follow preliminari technic use algorithm analysi given section 2 algorithm templat present greater detail section 3 two differ implement base differ select k given subsequ section section 4 present implement fulli satisfi statement theorem 1 rel simpl analysi improv implement main algorithm involv analysi present section 5 section 6 show reduc number random bit section 7 explain algorithm implement optim number oper model comput discuss section 8 also give modifi algorithm weaker model section 9 briefli discuss extens hash problem input may consist multiset final conclus given section 10 preliminari follow inequ standard see eg 1 markov inequ let random variabl assum nonneg valu chebyshev inequ let random variabl 0 chernoff inequ let binomi variabl 0 terminolog probabl say event occur ndomin probabl occur probabl gammaomegagamma21 usag notat essenti follow polylogarithm number event one occur ndomin probabl conjunct occur ndomin probabl well therefor usual satisfi demonstr algorithm step succe ndomin probabl fact 21 let independ binari random variabl let 2 domin probabl 3 proof recal well known fact 1in pairwis independ 1 inequ 2 2 2 e 2 inequ 2 inequ 1 3 follow immedi hash function remaind section let u fix split set bucket bucket subset fx size collid bucket singleton function inject perfect element collid let 0im r function inject number collis pair key gener b r number rtupl key collid h polynomi hash function let prime class degre polynomi hash function 1 map u 0 mod c rest section consid probabl space h select uniformli random h follow fact corollari shown fredman komlo szemeredi 16 carter wegman 8 origin proof case howev gener 1 straightforward fact 22 e corollari 23 hash function h inject probabl least 1 proof function h inject fact 22 markov inequ probabl h inject prob b follow shown 11 fact 24 3 r 0 let r rth moment distribut 0im r easi see shown complet random function r linear n high probabl fix r 2 polynomi hash function dietzfelbing et al 12 prove follow fact fact 25 let r 0 n r exist constant oe r 0 depend r tighter estim distribut r given 11 complet proof attach appendix b fact 26 let r 2 r 1jr r phi r psi stirl number second kind 1 fact 27 let ffl 0 constant probabl stirl number second kind number way partit set k distinct element j nonempti subset eg 31 chapter 6 3 framework hash oblivi execut 31 algorithm templat input algorithm set n key given array hash algorithm work two stage correspond two level hash scheme fredman komlo szemeredi 16 first stage level1 hash function f chosen function select random class h suffici larg constant select analysi hash function f partit input set bucket bucket first stage easili implement constant time main effort implement second stage describ next second level hash tabl built second stage algorithm bucket privat memori region call block assign address memori block alloc bucket record cell design array ptr size also bucket level2 function construct function inject map bucket block descript level2 function written ptr let us call bucket activ appropri level2 function yet found inact otherwis begin stage bucket activ algorithm termin bucket becom inact second stage consist olg lg n iter execut constant time iter process rapidli reduc number activ bucket number activ key iter new memori segment use segment partit block size k k set analysi bucket key associ one processor oper activ bucket iter given figur 2 alloc bucket select random one memori block block select anoth bucket bucket remain activ particip next step hash bucket select random two function h 1 tri hash block separ function either one function inject descript memori address block written appropri cell array ptr bucket becom inact otherwis bucket remain activ carri next iter figur 2 two step iter base oblivi execut last iter may becom necessari iter repeat bodi constant number time precis condit number repetit given section 5 hash tabl construct algorithm support lookup queri constant time given key x search begin read cell ptrfx content cell defin level2 function use x well address memori block x store actual offset block x store given inject level2 hash function found hash step 32 implement algorithm templat describ constitut framework build parallel hash algorithm execut algorithm oblivi sens iter process find level2 hash function requir inform number size activ bucket success termin perform depend priori set paramet k effect alloc step reli suffici mani memori block effect hash step reli suffici larg memori block requir keep total memori linear impos tradeoff two paramet challeng find balanc k achiev desir rate decay number activ bucket number activ key deduc number activ bucket base characterist level1 hash function determin show two differ implement algorithm templat lead analysi differ natur first implement given section 4 paramet select way iter number activ bucket expect decreas constant factor although iter may fail constant probabl geometr decreas seri bound number activ bucket iter olg lg n iter expect number activ key activ bucket becom nlg n omegagamma1 remain key hash addit constant time use differ approach employ olg lg n time procedur technic point view analysi implement impos rel modest requir level1 hash function sinc use firstmoment analysi ie markov inequ moreov requir simpler version hash step one hash function h 1 use expect run time olg lg n run time guarante arbitrari small constant probabl second implement given section 5 implement character doublyexponenti rate decreas 2 number activ bucket key olg lg n sequenc v0 decreas exponenti rate v v01 sequenc decreas doublyexponenti rate v v02 1ffl ffl 0 iter key hash without process implement superior sever respect time perform high probabl key handl origin processor form basi improv reduc number random bit technic point view analysi implement subtl impos demand requir level1 hash function sinc use secondmo analysi ie chebyshev inequ achiev doublyexponenti rate decreas requir care select paramet done use symbol spreadsheet approach togeth implement demonstr two differ paradigm fast parallel random algorithm involv differ flavor analysi one requir exponenti rate decreas problem size reli realloc processor item subsequ work use paradigm extens mention section 10 paradigm rel easi understand difficult analyz use framework probabilist induct analysi expect analysi show iter succe constant probabl impli overal constant success probabl contrast second implement show iter succe ndomin probabl impli overal ndomin success probabl analysi significantli subtl reli power techniqu second moment analysi second paradigm consist doublyexponenti rate decreas problem size henc requir wrapup step 4 obtain exponenti decreas section present first implement algorithm templat use rather elementari analysi expect show iter problem size decreas constant factor constant probabl gener framework describ section 41 show impli problem size decreas overal exponenti rate olg lg n iter number key reduc nlg nomegagamma1 simpl load balanc algorithm alloc lg nomegagamma21 processor remain key use excess number processor key final hash constant time 41 design expect consid iter random algorithm iter measur problem decreas random amount companion paper 22 show iter one actual assum previou iter algorithm far expect behavior paradigm suggest design iter success constant probabl assumpt least constant fraction previou iter success justifi follow lemma lemma 41 probabilist induct 22 consid iter random process 0 follow hold iter probabl least 12 provid among first iter least t4 success probabilityomegagammail everi 0 number success iter among first iter least t4 42 paramet set analysi let level1 function taken h 10 set let fact 25 simplifi analysi allow paramet k assum nonintegr valu actual implement must round nearest integ increas memori requir constant factor perform measur improv memori usag memori space use lemma 42 let v number activ bucket begin iter proof assum level1 function f satisfi fact 25 11 hold probabl least 12 proof continu use lemma 41 iter success v t1 v 2 thu number activ bucket j success iter m2 gammaj probabilist induct hypothesi among first iter least t4 success probabilist induct step show iter paramet k chosen achiev constant deactiv probabl bucket size distinguish follow three type event failur may caus bucket remain activ end iter alloc failur bucket may select memori block also select bucket probabl fix bucket success reserv block alloc step sinc v bucket select random one memori block ae 1 v 12 10 ii size failur bucket may larg current memori block size result probabl find level2 hash function high enough number bucket begin iter larger fi 11 therefor 13 without loss gener assum v t1 v 2 v bucket need becom inact still consid activ thu purpos analysi iii hash failur bucket may fail find inject level2 hash function even though suffici small uniqu select block let ae 3 probabl bucket size fi success map block size k hash step corollari 23 13 bucket size fi success reserv block size k success map becom inact expect number activ bucket begin iter therefor bound markov inequ prove induct step lemma follow lemma 43 let n number activ key begin iter constant c ff 0 proof follow 11 use simpl convex argument n maxim activ bucket begin iter size q case 11 therefor lemma 42 lemma follow lemma 43 lemma 42 exponenti decreas number activ key number activ bucket probabilityomegagamma329 number activ key becom nlg n c constant c 0 olg lg n iter 43 final stage execut second stage paramet set describ number avail resourc memori cell processor factor lg nomegagamma1 larger number activ key resourc redund make possibl hash remain activ key constant time describ remaind section key hash iter process hash auxiliari hash tabl size consequ implement lookup queri consist search key hash tabl auxiliari hash tabl built use 2level hash scheme level1 function map set activ key array size n function select random class hash function present dietzfelbing meyer auf der heid 14 definit 41 properti ndomin probabl bucket size smaller lg n 14 theorem 46b remaind section assum event inde occur altern use n ffl univers class hash function present siegel 43 activ key alloc 2 lg n processor activ bucket alloc 4lg n 3 mem ori alloc done map activ key inject array size lg n map indic bucket inject array size onlg n 3 map done olg lg n time ndomin probabl use simpl renam algorithm 20 remain step take constant time independ select 2 lg n linear hash function store design array hash function use bucket memori alloc bucket partit 2 lg n memori block size 2 lg 2 n bucket map parallel 2 lg n block 2 lg n select linear hash function map test inject carri 2 lg n processor alloc key bucket one inject map select level2 function select made use simpl leftmost 1 algorithm 15 bucket map inject construct auxiliari hash tabl fail lemma 44 assum number key remain activ iter process nlg n 3 construct auxiliari hash tabl succe ndomin probabl proof recal bucket size lg n map bucket memori block size 2lg n 2 inject probabl least 12 corollari 23 probabl bucket inject map therefor 1n 2 probabl least 1 gamma 1n everi bucket least one inject map easi identifi failur algorithm fail termin within design time restart hash tabl therefor alway construct sinc overal failur probabl constant expect run time olg lg n 5 obtain doublyexponenti decreas implement algorithm templat present previou section maintain exponenti decreas number activ bucket throughout iter section present implement number activ bucket decreas doubli exponenti rate intuit stochast process behind algorithm templat potenti achiev doublyexponenti rate memori block suffici larg comparison bucket size probabl bucket remain activ invers proport size memori block corollari 23 consid ideal situat case iter activ bucket alloc memori block size k iter k activ bucket could alloc memori block size k 2 iter k 3 activ bucket alloc memori block size k 4 less ideal set bucket deactiv larg current valu k number bucket bound use properti level1 hash function must guarante fraction larg bucket also decreas doublyexponenti rate illustr crude calcul given assum memori evenli distribut activ bucket make doublyexponenti rate possibl failur probabl alloc step henc ratio must also decreas doublyexponenti rate establish bound number larg block show larg fraction bucket alloc memori block also concern previou section howev enough show constant bound probabl alloc failur size failur hash failur paramet set establish balanc requir doublyexponenti rate present follow analysi algorithm perform section conclud descript paramet select 51 paramet set let level1 function taken h set let 52 memori usag proposit 51 total memori use algorithm proof 17 memori use first stage memori use iter second stage total memori use second stage therefor mostx 53 framework time perform analysi defin runtim analysi second stage carri show lemma 52 ndomin probabl number activ bucket begin iter lemma prove induct lg lg n lg induct base follow fact n activ bucket subsequ subsect prove induct step deriv estim number fail bucket iter assumpt begin iter activ bucket specif show induct ndomin probabl number activ bucket end iter bucket may fail find inject level2 hash function estim number bucket fail find inject level2 function iter assum bucket uniqu select memori block bucket size larg rel current block size accordingli section 42 distinguish follow three type event failur may caus bucket remain activ end iter alloc failur bucket may select memori block also select bucket ii size failur bucket may larg current memori block size result probabl find level2 hash function high enough iii hash failur bucket may fail find level2 hash function even though suffici small uniqu select block provid estim number bucket remain activ due either reason lemma 55 case lemma 56 case ii lemma 57 lemma 58 case iii estim shown hold ndomin probabl induct step follow ad estim wrap let therefor infer proposit 53 ndomin probabl number iter requir deactiv bucket lg lg n lg 54 failur uniqu select block lemma 54 let ffl fix suppos either 12ffl let random variabl repres number bucket fail uniqu select block proof bucket probabl bucket select memori block select therefor stochast smaller binomi distribut random variabl obtain perform independ trial probabl success say 3 gammaomegagamma26 otherwis situat e 1 sinc integ valu 2m 2 1 25 set cover lemma 12gammaffl occur constant number iter throughout algorithm requir follow special treatment bodi iter repeat thu provid second alloc attempt bucket fail uniqu select memori block first trial random variabl repres number bucket fail uniqu select block first second attempt respect j 1 25 gammaomegagamma27 therefor domin probabl second attempt fall within condit equat lemma 55 let lg lg n lg number bucket fail uniqu select block ndomin probabl t1 4 proof lemma 54 number bucket fail uniqu select memori block domin probabl 1923 20 20 24 hold also ndomin probabl sinc 19 20 55 failur hash consid bucket uniqu select block fail find inject level2 function draw special attent bucket size lemma 56 number bucket larger fi ndomin probabl t1 4 proof let incorpor appropri valu stirl number second kind fact 26 get 17 therefor fact 27 ndomin probabl 6 follow number bucket bigger fi ndomin probabl 3116 18 20 20 20 24 analysi hash failur bucket small enough split two case lemma 57 suppos 2k n number bucket size fi fail hash step iter ndomin probabl t1 4 proof without loss gener may assum exactli activ bucket size fi particip step 2 bucket map memori block size k probabl map noninject corollari 23 fi 2 probabl bucket fail hash attempt therefor 12k let total number fail bucket fact 21 1823 20 20 2024 note sinc 2k n hold ndomin probabl done lemma 58 suppos n repeat hash step iter constant number time get proof thu therefor 18 36 constant ffi 0 recal proof lemma 57 bucket fail hash step probabl 12k 37 iter bodi repeat d2ffie failur probabl bucket becom 2k lemma follow markov inequ 6 reduc number random bit section show reduc number random bit use hash algorithm algorithm describ previou section consum thetan lg u random bit first iter alreadi use thetan lg u random bit subsequ iter number random word u use constant factor larger memori use iter result total thetan lg u random bit sequenti hash algorithm fredman komlo szemeredi 16 implement olg lg u bit 11 show parallel hash algorithm implement olg lg u bit first show algorithm modifi reduc number random bit olg u lg lg n first stage requir o1 random element u construct level1 function remain unchang iter second stage requir om random element u modifi follow alloc step bucket independ select random memori block om lg random bit consum reduc olg make use polynomi hash function lemma 61 use 6 lg random bit set r map constant time array size 3m number collid element 2m 2 proof let select random imag bucket defin algorithm h 1 first appli element h 2 appli element collid h 1 collid element g collid h 1 h 2 r 0 set element collid h 1 clearli jr 16 consid follow three case corollari 23 prob r 0 6 2 follow fact 24 probabl 2 jr 3 12gammaffl fact 22 2 markov inequ therefor domin probabl jr case corollari 23 inject r 0 invok procedur block alloc increas total memori consumpt algorithm constant factor hash step implement hash part iter bodi use independ hash function activ bucket consum om lg u random bit reduc olg u use hash function pairwis independ techniqu applic context hash function essenti due 10 11 modif step follow hash attempt execut step four global paramet select random algorithm hash function attempt bucket hash attempt bucket fulli independ thu proof lemma 58 unaffect modif recal fact 21 assum pairwis independ sinc pairwis independ proof lemma 57 remain valid well lead reduct number random bit use algorithm olg u lg lg n number random bit reduc follow employ preprocess hash step input set inject map rang 0 done appli hash function select appropri class map univers u rang algorithm describ use build hash tabl set lookup key x done search x hash tabl simpl class hash function h 3 appropri univers reduct applic shown 11 class h 3 follow properti 1 select random function class requir olg lg u bit 2 select made constant time singl processor 3 function inject ndomin probabl 4 comput x x 2 u done constant time preprocess tantamount reduct size univers applic algorithm requir olg n lg lg n bit total number random bit use therefor olg lg u 7 obtain optim speedup descript algorithm section 3 assum number processor n thu timeprocessor product lg lg n object section workoptim implement product p number processor maxim array bucket array divid p sector one per processor parallel step algorithm execut processor travers sector execut task includ key activ bucket activ let n number activ key begin iter assum implement algorithm reach point assum activ element gather array size lg lg n appli nonoptim algorithm section 3 p n lg lg n processor respons np lg lg n problem instanc give run time lg lg n np workoptim first show problem size reduc suffici applic nonoptim algorithm olg lg lg lg n iter lemma 71 exist n n n ndomin probabl proof number activ bucket decreas doublyexponenti rate seen lemma 52 see number key decreas doublyexponenti rate well show ndomin probabl inequ 32 r 6n clearli hold summat activ bucket convex argument total number key activ bucket maxim activ bucket equal size number activ bucket bound therefor inequ 40 obtain 41 replac definit 23 substitut numer valu paramet use 16 20 lemma follow choos appropri valu 0 respect 23 40 remain exhibit workeffici implement first 0 step algorithm implement output activ element gather array size lg lg n rest section dedic descript implement algorithm progress number activ key number activ bucket de creas howev decreas number activ element differ sector necessarili ident time implement one parallel step proport number activ element largest sector therefor crucial occasion balanc number activ element among differ sector order obtain work effici let load sector number activ element task load balanc algorithm take input set task arbitrarili distribut among p sector use p processor redistribut set load sector greater averag load constant factor suppos load balanc algorithm whose run time use p processor lb p ndomin probabl load balanc appli step size sector p describ simpl workoptim implement load balanc appli first 0 parallel step parallel step execut time order total time implement order decreas least exponenti rate total time order onp use load balanc algorithm 20 run lb time conclud ndomin probabl run time pprocessor machin load balanc algorithm appli consum op lg lg p random bit bit use random map step similar alloc step hash algorithm thu similar approach map procedur lemma 61 may establish number random bit load balanc algorithm reduc olg p lg lg p final remark use load balanc effici yet simpl way describ 23 yield faster workeffici implement techniqu base care choos appropri time invok load balanc procedur appli algorithm problem size exponenti rate decreas henc appli implement section 4 well implement load balanc algorithm use olg n time result parallel hash algorithm take onplg lg n lg n time ndomin probabl 8 model comput section give closer attent detail implement pram studi type concurr memori access requir algorithm first present implement collis extens weaker toler model proceed present implement even weaker robust model hashtabl construct implement support search olg lg n time final examin concurr read capabl need implement 81 implement collis toler describ implement collis implement also valid toler sinc step collis simul constant time toler provid case linear memori use 32 initi select level1 hash function done singl processor sinc level1 function polynomi constant degre select done singl processor read processor constant time use sing memori cell dmax flg lg u lg nge bit concurrentwrit oper requir implement stage bucket repres algorithm templat assum bucket act singl entiti oper eg select random block select random hash function sinc usual sever key belong bucket necessari coordin action processor alloc key simpl way base fact linearli mani bucket bucket uniqu index valu f level1 hash function member processor whose index determin bucket index act bucket repres perform action prescrib algorithm bucket alloc hash step processor repres activ bucket select memori block level2 hash function record select design cell processor key bucket read cell use select block hash step particip processor whose key belong activ bucket write key cell determin level examin cell content see write oper success processor write fail attempt write key posit array ptr number bucket processor belong processor belong bucket learn level2 function select bucket inject read content ptri chang valu collis symbol indic noninject complet process array ptr restor next hash attempt restor done constant time sinc array linear size summari proposit 81 algorithm theorem 1 implement toler 82 implement robust describ implement expens slow lookup oper make assumpt result concurrentwrit cell specif present implement robust model lookup queri may take olg lg n time worst case o1 expect time key tabl difficulti robust model let processor bucket know whether level2 hash function bucket inject main idea modifi implement allow iter proceed without determin whether level2 hash function inject whenev key written memori cell hash step deactiv bucket size decreas modifi algorithm perform least well implement bucket deactiv key map inject total memori use modifi algorithm size represent hash tabl chang alloc step first note algorithm carri without use bucket repres alloc memori block done use hash function lemma 61 processor individu comput index memori block evalu function g function select design processor represent 6 lg bit read constant time processor modifi algorithm hash step carri activ bucket even bucket collid alloc step particip hash step modif serv improv perform algorithm sinc even share block anoth bucket probabl bucket find inject function block zero modif elimin concurr memori access need detect failur alloc step hash step select level2 hash function done hash step describ section 6 seen 39 four global paramet select made avail processor done constant time remain elimin concurr memori access requir determin level2 function singl bucket inject whenev key success hash function deactiv even key bucket success hash thu key bucket may store hash tabl use differ level2 hash function two step iter hash algorithm summar figur 3 let x activ key bucket fx processor assign x execut follow step alloc comput index memori block select bucket x g defin 38 hash determin h level2 hash function select bucket x h defin 39 write x cell h x memori block g read content cell x written key x becom inact figur 3 implement iter hash algorithm robust lookup algorithm search key x done follow let read posit h x memori block g appropri array random bit use hash tabl construct algorithm assum record avail search termin either x found els exce number iter construct algorithm lookup algorithm requir olg lg n iter worst case howev key x 2 expect lookup time random select made hash algorithm o1 altern simplifi implement curious sequenc modif algorithm describ section lead 1level hash scheme ie elimin indirect address see observ iter activ key x written memori cell g x function g x depend n random select made algorithm input even simpler implement 1level hash algorithm delin next iter new array size 3m use defin 19 addit function g defin 38 select random processor repres activ key x iter tri write x g x read cell x success written g x x deactiv otherwis x remain activ processor repres carri next iter see algorithm termin olg lg n iter observ oper key iter oper bucket alloc step section 6 therefor analysi section 6 reus substitut key bucket ignor failur hash step 2level algorithm hash tabl consist collect array easili verifi linear size lookup queri given key x execut olg lg n time read g x 83 minim concurr read requir algorithm construct hash tabl toler robust modifi use concurrentread singl cell allow preprocess stage olg n time concurr read elimin impli ercw model suffici modif parallel lookup still requir concurr read execut time increas olg lg n worst case nevertheless expect time lookup singl key x 2 o1 detail describ next 831 concurr read toler implement two type concurr read oper requir modifi algorithm first sequenc olg lg n function g altern g simplifi implement must agre upon processor sinc function repres olg u bit select broadcast begin iter concurrentread cell singl cell concurr read requir broadcast elimin ad olg ntime preprocess step broadcast special case simul crcw pram erew pram kind concurrentread oper occur processor read memori cell verifi hash cell succeed oper replac follow procedur memori cell processor stand whenev pair hx ji written cell processor assign cell send acknowledg processor j write memori cell j design array lookup algorithm requir concurrentread capabl sens lookup oper demand construct hash tabl similar phenomenon observ karp lubi meyer auf der heid 36 context simul random access machin distribut memori machin main challeng design parallelhash base simul algorithm execut read step congest execut write step resolv attempt write sever locat use first write succeed difficult resolv read congest sinc cell valu store alreadi determin inde read oper constitut main runtim bottleneck algorithm 832 concurr read robust implement simplifi 1level hash algorithm construct hash tabl robust modifi follow elimin step processor key x read content cell tri write cell instead use acknowledg techniqu describ processor j handl activ key x write hx ji cell g x processor stand cell g x hx ji written send acknowledg processor j note implement introduc new type failur due unpredict concurr write oper robust acknowledg success hash may receiv consid exampl follow situat let j processor whose key x collid let 0 two processor collid key 0 ie g two processor concurr write pair hy ii hy cell g result concurr write arbitrari particular pair hx 0 ji would caus processor stand cell g garbl acknowledg sent processor j recal acknowledg processor j implement write memori locat associ j number new failur describ half number collid key easi verifi analysi remain valid sinc number new failur number hash failur account section 55 occur implement 9 hash multiset conclud technic discuss briefli consid variat hash problem input multiset rather set first note analys exponenti doublyexponenti rate decreas problem size affect possibl multipl occurr key result reli estim number activ bucket rather number activ key number distinct keysnot number keysdetermin probabl bucket find inject function predict decreas number activ key essenti obtain optim speedup algorithm unfortun analysi section 7 regard implement section 5 hold understand difficulti consid case substanti fraction input consist copi key nonneglig probabl key may belong larg bucket probabl bucket deactiv first iter memori block suffici larg small allow global decreas number key high probabl consequ rapid decreas number bucket may accompani similar decreas number key contrast natur analysi section 4 make suscept easi extens multipl key lead optim speedup algorithm albeit expect perform use probabilist induct lemma requir show copi activ key stand constant posit probabl deactiv iter sinc analysi base expect concern regard correl copi key depend differ iter detail left reader also note model comput requir multiset collis sinc must possibl distinguish case multipl copi key written memori cell case distinct key written also extens hash algorithm requir concurr read singl memori cell use hash multiset input collis model oppos robust must assum final observ hash problem multiset input reduc ordinari hash problem input consist set procedur known leader elect procedur select singl repres among processor share valu use olg lg ntime linearwork leader elect algorithm run toler 24 theorem 2 given multiset n key drawn univers u hash problem solv use space olg lg n time high probabl use n processor ii olg lg n lg n time oper high probabl algorithm run toler convers note hash algorithm run arbitrari solv leader elect problem particular simpl 1level hash algorithm robust implement arbitrari multiset input give simpl leader elect algorithm consid anoth variant multiset hash problem data record associ key natur semant problem multipl copi key insert hash tabl data record ident processor repres copi key conflict data record termin comput error code collis model make easi enough extend implement discuss accommod variant sophist semant data record consolid requir differ treatment eg appli integ sort algorithm hash key see 39 conclus present novel techniqu hash oblivi execut use techniqu algorithm construct perfect hash tabl fast simpl effici made possibl run time obtain best possibl model key handl origin processor number random bit consum algorithm thetalg lg u n open question close gap number thetalg lg u bit consum sequenti hash algorithm 11 program execut processor extrem simpl inde coordin processor comput function test inject implement robust model even coordin elimin larg constant hidden oh notat analysi may render describ implement still far practic believ constant substanti improv without compromis simplic algorithm care tune paramet tighten analysi may interest subject separ research use oblivi execut approach present paper limit hash problem alon adopt 24 simul among submodel crcw pram hash algorithm key partit subset howev partit arbitrari given input subset maximum key must comput subsequ work oblivi execut techniqu hash section 3 implement section 4 present preliminari form 21 subsequ oblivi execut techniqu use sever time obtain improv run time parallel hash algorithm matia vishkin 38 gave olg n lg lg n expect time algorithm gil matia vishkin 26 gave tighter failur probabl analysi algorithm 38 yield olg n time high similar improv olg n lg lg n expect time olg n time high probabl describ independ bast hagerup 3 olg n time hash algorithm use build block parallel dictionari algorithm present 26 parallel dictionari algorithm support parallel batch oper insert delet lookup oblivi execut techniqu import role implement insert dictionari dictionari algorithm run olg n time high probabl improv ffl dictionari algorithm dietzfelbing meyer auf der heid 13 dictionari algorithm use obtain space effici implement parallel algorithm cost slowdown olg n time high probabl hash algorithm use logstar paradigm 38 reli extens processor realloc simpl algorithm present paper moreov requir substanti larger number random bit karp lubi meyer auf der heid 36 present effici simul pram distribut memori machin doublylogarithm time level improv previou simul logarithm time level use fast parallel hash algorithm essenti result algorithm present suffici obtain goldberg jerrum leighton rao 28 use techniqu paper obtain oh lg lg n random algorithm hrelat problem optic commun parallel comput model gibbon matia ramachandran 18 adapt algorithm present obtain lowcontent parallel hash algorithm qrqw pram model 19 impli effici hash algorithm valiant bsp model henc hypercubetyp noncombin network 44 acknowledg thank martin dietzfelbing faith e fich provid help comment also wish thank uzi vishkin avi wigderson earli discuss part research done visit first author att bell laboratori second author univers british columbia would like thank institut support visit mani valuabl comment made two anonym refere grate acknowledg r probabilist method parallel construct suffix tree fast reliabl parallel hash optim bound decis problem crcw pram improv determinist parallel integ sort optim separ concurrentwrit parallel machin observ concern synchron parallel model comput univers class hash function new simul crcw pram power twopoint base sampl polynomi hash function reliabl relat concurrentwrit model parallel comput store spars tabl o1 worst case access time data structur algorithm approxim string match effici lowcontent parallel algo rithm qrqw pram account content parallel algorithm fast load balanc pram fast hash pramdesign expect design algorithm expect effect load balanc polici geometr decay algorithm fast effici simul among crcw pram simpl fast parallel hash toward theori nearli constant time parallel algorithm doubli logarithm commun algorithm optic commun parallel comput univers interconnect pattern parallel comput optim parallel approxim algorithm prefix sum integ sort concret mathemat incompar parallel comput toward optim parallel bucket sort everi robust crcw pram effici simul prioriti pram introduct parallel algorithm sort search convert high probabl nearlyconst timewith applic parallel hash parallel hash integ sort data structur algorithm sort search data structur olg n parallel connect algorithm univers class fast high perform hash function gener purpos parallel architectur tr