obtain knuth morri pratt string matcher partial evalu present first formal proof partial evalu quadrat string matcher yield precis behaviour knuth morri pratt linear string matcherobtain kmplike string matcher canon exampl partial evalu start naiv quadrat program check whether pattern occur text one ensur backtrack perform partialevalu time bindingtim shift yield stage string matcher special result stage program yield residu program back text la kmp awar howev formal proof partial evalu stage string matcher precis yield kmp string matcher fact specif string matcherin articl present stage string matcher formal prove perform sequenc comparison pattern text kmp string matcher end oper specifi program languag matcher written formal sequenc comparison trace semant also state mild condit special stage string matcher respect pattern string provabl yield special string matcher whose size proport length pattern string whose time complex proport length text string final show tabul one function stage string matcher give rise next tabl origin kmp algorithmth method scale obtain linear string matcher known new b introduct obtain knuth morri pratt linear string matcher naiv quadrat string matcher tradit exercis partial evalu run match pat re run pe match pat run match pat re given static pattern partial evalu perform backtrack static produc special matcher travers text linear time initi exercis propos futamura illustr gener partial comput form partial evalu memoiz result dynam test process condit branch 10 1 subsequ consel danvi point bindingtim improv ie stage quadrat string matcher could also special linear string matcher use standard mixstyl partial evalu 7 number public follow show either rang bindingtim improv string matcher present rang partial evalu integr bindingtim improv 1 9 11 12 15 23 24 25 15 year howev observ 1 kmp test call appear littl impact develop algorithm outsid field partial evalu 2 except grobauer lawal recent work 13 issu precis character time space special string matcher address goal work address second item hope contribut remedi first one long run 11 work relat origin kmp algorithm 18 stage quadrat string matcher keep one charact neg inform essenti consel danvi origin solut 7 mani way stage string matcher 1 13 show one appendix approach semant rather algorithm intuit 1 exampl dynam test comparison static ie known charact pattern dynam ie unknown charact text one condit branch charact match static know dynam charact branch charact mismatch static know dynam charact former piec posit inform latter piec neg inform formal imper languag similar one kmp algorithm tradit specifi formal subset scheme stage matcher specifi present two trace semant account sequenc indic correspond success comparison charact pattern text show kmp algorithm stage matcher share trace analyz bind time stage matcher use otheshelf bindingtim analysi similix 3 4 observ dynam comparison one static pattern dynam text therefor special stage string matcher preserv trace given oin program special similix 1 comput static oper special time 2 gener residu program dynam oper disappear duplic execut order sourc program also assess size residu program proport size correspond static pattern 2 correspond preserv trace show stage matcher keep one charact neg inform correspond special second half kmp algorithm precis also two corollari 1 stage matcher keep track neg inform srensen gluck joness work posit supercompil 25 give rise kmp algorithm instead observ stage matcher give rise morri pratt algorithm 5 chapter 6 also linear slightli less ecient 2 stage string matcher keep track charact neg inform accumul consecut charact mismatch futamura gener partial comput 9 11 gluck klimov supercompil 12 jone gomard sestoft textbook 15 figur 123 give rise kmp algorithm either correspond residu program slightli ecient kmp algorithm size linearli proport length pattern inde grobauer lawal shown size residu program bound pat pat denot pattern denot alphabet 13 said linear string match kmp exampl handbook exact string match 5 charra lecroq list dierent algorithm follow tradit count size integ unit exampl tabl integ size log n integ lie interv 0 n 1 consid size b mani naiv string matcher exist stage yield varieti linear string matcher eg boyer moor 1 observ half algorithm list charra lecroq obtain special version stage string matcher prove observ done manner present articl kmp furthermor obtain new linear string matcher explor varieti stage string matcher 12 overview rest articl organ follow section 2 specifi oper semant imper languag use knuth morri pratt section 3 specifi oper semant subset scheme 16 section specifi 1 abstract syntax languag 2 express valu 3 evalu rule 4 string matcher 5 semant string matcher 6 abstract semant string matcher point abstract semant account sequenc comparison pattern text knuth morri pratt algorithm imper matcher stage string matcher function matcher lemma 1 2 show abstract semant faith account comparison pattern text string matcher theorem 1 establish correspond abstract imper matcher section 26 theorem 1 section abstract function matcher section 36 concret imper matcher section 25 section 26 concret function matcher section 35 section 36 section 4 show imper matcher function matcher give rise sequenc comparison section 5 investig result special function matcher respect pattern string use program special use simpl form data special section 6 conclud 2 kmp imper section describ imper languag imper string matcher specifi languag canon constant mutabl identifi immut array present imper string matcher mean final specifi trace semant imper matcher 21 abstract syntax program consist statement stm express e exp numer mutabl identifi x mid array identifi aid oper opr opr xe ss e els fi e od return e e num x c ae e opr e e e 22 express valu valu integ boolean charact alphabet 23 rule follow rule e exp v 231 auxiliari construct languag includ numer oper comparison oper charact 232 store store total function 233 constant constant defin total function 234 array array defin partial function n denot set natur number includ zero index array start zero index bound undefin 235 relat bigstep evalu relat express read smallstep evalu relat statement read r stm comput progress r unit comput complet normal r z comput abort return choos bigstep evalu relat express interest intermedi evalu step choos smallstep evalu relat statement want monitor progress imper comput 236 express var array 237 statement assign e od unit e od swhile e od c return e n 24 string matcher kmp algorithm consist two part initi next tabl actual string match 18 241 initi next tabl first part build next tabl pattern satisfi follow definit tabl next tabl array indic length pattern next j largest less j pat j exist next j 1 initi next tabl describ pseudocod figur assum pat txt lpat ltxt given initi store pat denot pattern lpat length txt denot text ltxt length j lpat 1 0 patj patt nextj nextt els nextj od figur 1 initi next tabl 242 string match second part travers text use next tabl describ program figur 2 written imper languag specifi section 21 22 23 second part lpat ltxt constant identifi j k mutabl identifi pat txt next array identifi pat denot pattern lpat length txt denot text ltxt length 3 write pseudocod instead code languag section 21 22 23 array immut could easili extend languag support mutabl array would clutter rest develop side condit express next tabl updat second part kmp algorithm therefor chosen simplifi languag jlpat kltxt j 0 patj txtk figur 2 imper string matcher rest articl consid second part kmp algorithm refer imper matcher 25 semant imper matcher consid mean imper matcher state without proof imper matcher termin access pattern text next tabl within bound sequenc indic correspond success comparison charact pattern text imper languag determinist kmp algorithm correct string matcher sequenc exist uniqu imper comparison string matcher section 24 deriv tree form deriv tree definit 3 index follow function map imper comparison correspond pair indic pattern text index definit 4 comput imper comput deriv imper matcher premis 0 1 sn1 deriv tree contain pattern text next tabl c contain length pattern text 0 imper matcher 0 initi state map identifi zero comput said complet r 1 n imper comput premis might contain imper com parison want build sequenc indic correspond success comparison charact pattern text appli index function imper comparison premis give indic collect sequenc nonempti set pair indic follow premis imper comput let c set imper comparison n imper trace sequenc neutral element concaten section 26 lemma 1 show premis definit 5 contain one imper comparison therefor p either empti singleton set imper trace thu sequenc singleton set correspond success comparison charact pat txt choos three program point one check whether end pattern end text one compar charact pattern charact text one reiniti index pattern ie shift pattern 18 page 324 base next tabl definit 6 program point imper program point match compar shift defin follow set configur match compar shift jlpat kltxt j 0 patj txtk set imper program point defin sum compar 26 abstract semant definit 7 abstract state set abstract imper state sum set abstract imper final state set abstract imper intermedi state state state int state fin state int match compar shift inject tag definit 8 program point abstract state defin correspond abstract imper state union imper program point final result follow relat state int pp match j match compar j compar shift j definit 9 abstract matcher let pat txt let next next tabl pat abstract imper matcher follow total function state int state match j compar j compar j shift j compar nextj match function last yield last element nonempti sequenc abstract state last state last definit 11 abstract comput let pat txt let correspond abstract imper matcher set abstract imper comput abscomp state least set close 1 match 0 last p p abscomp said complet last state fin comput faith abstract imper comput repres imper comput faith word 1 imper comput start initi deriv either contain program point 1 contain program point apart final configur 2 contain comparison 3 final configur program point p match match 0 p 2 whenev last configur imper comput imper program point p relat abstract state exist imper program point final result p abstract state follow hold 1 deriv p p contain program point 2 3 p 4 deriv contain comparison c index proof part 1 straightforward verifi part 2 must divid case dictat abstract matcher show singl case p match k case similar deriv jlpat kltxt od unit jlpat kltxt od els return j lpat return kj els return c j lpat return kj els return return kj var sinc match j kj also kj n furthermor observ deriv contain program point comparison sinc one comparison exist step deriv imper trace definit 5 sequenc singleton set moreov sinc imper matcher termin abstract matcher well definit 12 abstract trace abstract imper trace map sequenc abstract state anoth sequenc abstract state trace state trace follow corollari lemma 1 show abstract imper trace repres imper trace corollari 1 imper trace faith let pat txt given imper trace complet imper comput let compar j abstract imper trace correspond complet abstract imper comput word abstract trace faith repres imper trace 27 summari formal specifi imper string matcher implement kmp algorithm given trace semant account indic success compar charact pattern text next section turn function string matcher treat similarli 3 kmp function section describ function languag function string matcher specifi languag firstord subset scheme tail recurs equat present function string matcher mean final specifi trace semant function matcher 31 abstract syntax program consist seriou express e exp trivial express triv oper opr opr numer num num valu identifi x vid function identifi f fid sequenc valu identifi x vid 32 express valu valu integ boolean charact string 33 rule 331 auxiliari construct languag includ numer oper comparison oper charact stringindex oper c ith charact index string start zero index bound undefin 332 environ express evalu valu environ venv function environ 333 relat bigstep evalu relat trivial express read smallstep evalu relat seriou express read e f r choos bigstep evalu relat trivial express interest intermedi evalu step choos smallstep evalu relat seriou express want monitor progress comput 334 program top level program evalu initi function environ 0 hold predefin function initi valu environ 0 hold predefin valu initi configur program thu e 0 0 function environ 335 trivial express var 336 seriou express 34 string matcher consid string matcher figur 3 motiv appendix written subset scheme specifi section 31 32 33 initi environ 0 bind pat lpat pattern length txt ltxt text length none pat txt lpat ltxt bound program therefor denot initi valu throughout rest articl refer string matcher function matcher 35 semant function matcher consid mean function matcher sequenc indic correspond success comparison charact pattern text function comparison string matcher section 34 deriv tree form denot anoth deriv tree letrec match lambda j k ltxt compar j k compar lambda j eq stringref pat match 0 match rematch rematch lambda j k jp kp kp eq stringref pat jp jp match rematch compar jp k eq stringref pat jp rematch rematch match figur 3 function matcher definit 14 index follow function map function comparison correspond pair indic pattern text index f definit 15 comput function comput deriv function matcher premis deriv tree initi function environ e 0 function matcher 0 valu environ map pat txt lpat ltxt pattern text length respect valu identifi zero comput said complet r 1 n function comput premis might contain function compar ison want build sequenc indic correspond success comparison charact pattern text appli index function function comparison premis give indic collect sequenc nonempti set pair indic follow definit premis function comput let c set function comparison e n function trace sequenc otherwis section 36 lemma 2 show premis definit 16 contain one function comparison therefor p either empti singleton set function trace thu sequenc singleton set correspond success comparison charact pat txt choos three program point one check whether end pattern end text one compar charact pattern charact text one match pattern prefix sux pattern program point correspond bodi match compar rematch function definit 17 program point function program point match f compar f rematch f defin follow set configur match compar f rematch bodi match function c bodi compar function r bodi rematch function set function program point defin sum compar f rematch f 36 abstract semant definit abstract state set abstract function state sum set abstract function final state set abstract function intermedi state f state int f state fin f state int f rematch n n n n match compar rematch inject tag definit 19 program point abstract state defin correspond abstract function state union function program point final result follow relat f state int match j compar j rematch j k jp kp f e rematch f definit 20 abstract matcher let pat txt abstract function matcher follow total function f state int match j compar j compar j match rematch j k 0 1 otherwis rematch j k jp kp f match compar jp rematch j k jp definit 21 last function last f yield last element nonempti sequenc abstract state last last definit 22 abstract comput let pat txt let f correspond abstract function matcher set abstract function comput abscomp f state f least set close 1 match 0 last f f p p abscomp f said complet last f state fin f comput faith abstract function comput repres function comput faith word 1 function comput start initi deriv either contain program point 1 contain program point apart final configur 2 contain comparison 3 final configur program point p match f match 0 2 whenev last configur function comput function program point p relat abstract state f exist function program point final result p abstract state follow hold 1 deriv p p contain program point 2 f 3 f p 4 deriv contain comparison c indexf proof part 1 straightforward verifi part 2 must divid case dictat abstract matcher show singl case p match f txt case similar deriv var var compar app c denot bodi compar function definit 17 sinc match j k also compar j k correspond final configur deriv furthermor observ deriv contain program point comparison sinc one comparison exist step deriv function trace definit 16 sequenc singleton set moreov one matcher termin well definit 23 abstract trace abstract function trace map sequenc abstract state anoth sequenc abstract state trace trace follow corollari lemma 2 show abstract function trace trace corollari 2 function trace faith let pat txt given function trace complet function comput let compar j abstract trace correspond complet abstract function compu tation word abstract trace faith repres function trace lemma 3 invari let pat txt abscomp f correspond set abstract function comput 1 follow condit whose conclus call invari satisfi proof let pat txt given let abscomp f proof structur induct base case show invari hold initi induct case show invari preserv match compar rematch initi definit abscomp f initi abstract function state comput match 0 0 length string pat txt nonneg insert obtain 0 m2 thu hold trivial initi abstract function state preserv match let us assum invari m1 m2 hold abstract function state match j k consid three possibl case j next abstract state abstract function comput therefor kj invari preserv 1 next abstract state therefor 1 invari preserv next abstract state therefor compar k case assumpt invari c1 c2 invari thu preserv match preserv compar let us assum invari c1 c2 hold abstract function state compar j k consid three possibl case 1 next abstract state abstract function comput match 1 sinc j k pat txt integ j pat hold sinc premis true invari c1 c2 invari m1 m2 hold txtk patj 0 definit compar j 1 next abstract state match 1 argument ident obtain invari m2 insert valu invari m1 done init case also obtain invari m1 txtk patjj 0 definit compar j next abstract state rematch due c1 j 0 r1 hold c2 ident r2 thu r3 hold convent denot empti string similarli patkp jp denot empti string invari r4 hold final r5 hold trivial interv 1 kp jp 1 0 denot empti set convent invari thu preserv compar preserv rematch let us assum invari r1 r2 r3 r4 r5 hold abstract function state rematch j k jp kp consid five possibl case 0 definit rematch j k jp kp f match 1 next abstract state abstract function comput match 1 invari r2 obtain shown 0 definit rematch j k jp kp f 1 next abstract state rematch invari r1 r2 hold j k trivial updat immedi give invari r1 r2 kp sinc j invari r3 satisfi first look pat0 patjp 1 empti string sinc 1 empti string therefor invari r4 hold invari know bodi r5 hold everi k interv 1 kp jp 2 sinc j need show pat0 patj k specif 1 easili seen sinc case assumpt give patj invari r5 hold k next abstract state therefor compar r1 r3 case assumpt hold sinc k kp 1 next abstract state therefor rematch give us r3 pat0 patjp need show patjp true case assumpt thu r4 hold sinc interv k unchang hold assumpt kp j patjp patkp definit rematch j k jp kp f rematch j k 0 kp jp 1 next abstract state therefor rematch trivial updat j k r1 r2 shown still hold clearli jp 0 assumpt kp jp give us kp final sinc kp j kp1 j kp thu invari r3 hold shown second case string empti condit thu invari r4 hold similarli second case need show pat0 patj specif hold consid jpth k jpth entri charact patjp patkp respect sinc k kp case assumpt entri distinct conclud show first string contain jpth entri case assumpt us 0 jp thu invari r5 hold key connect abstract function matcher abstract imper matcher state follow remark remark show interpret invari r5 term next tabl remark 1 notic j 0 b k bpat0 patj definit 1 next j occur interv j b j inde k j pat0 patj k patj k patj j k candid nextj therefor negat condit give us j k candid nextj 37 summari formal specifi function string matcher given trace semant account indic success compar charact pattern text next section show given pattern text trace imper matcher function matcher coincid extension correspond imper function matcher definit 24 correspond defin correspond imper function state relat state state f match j compar j shift j defin state state f sequenc f hold empti sequenc synchron relat sync state state f defin trace trace f last last f theorem 1 abstract equival given pattern text uniqu complet abstract imper comput uniqu complet abstract function comput two abstract comput synchron ie sync hold proof let pat txt given let abscomp proof structur induct abstract comput base case prove abstract comput start abstract state therefor initi synchron induct case prove synchron alway preserv initi definit abscomp abscomp f abstract comput start abstract state match 0 0 sinc syncmatch 0 0 match 0 0 hold abstract comput initi synchron preserv match assumpt initi subsequ synchron ie synci hold last last f match j k three case occur exhaust invari lemma 3 j similarli definit match j j assumpt synci hold therefor thu complet abstract comput synchron similarli definit match j 1 synchron preserv sinc comput end integ j pat k txt definit match j larli definit match j assumpt synci compar j k compar j k also hold synchron thu preserv case preserv compar assumpt initi subsequ synchron ie synci hold last last f compar j k three case occur exhaust invari lemma 3 txtk patj 0 definit compar j 1 similarli definit compar j sinc definit sinc synci assumpt shift state includ abstract trace synci shift j match txtk patjj 0 definit compar j similarli definit compar j hold assumpt shift j 1 similarli definit compar j synci hold assumpt synci match j 1 k1 match synchron preserv case preserv rematch shift assumpt initi subsequ synchron ie synci hold last last f rematch j k jp kp sinc definit 24 shift j jp kp consid case abstract function comput goe abstract state form dierent rematch j k jp kp sound recurs call rematch function never diverg lexicograph order kp jp jp termin relat rematch call match compar two case occur 0 definit rematch j k jp kp f match 1 know invari r5 hold k interv remark 1 impli next j case assumpt know next j 1 j 1 next therefor definit abstract imper matcher shift j synci hold assumpt synci match 0 k1 match 0 k1 also hold due invari r1 r3 jp pat definit rematch j k jp kp f compar jp k know bodi invari r5 hold k interv 1 jjp1 remark 1 give us next j jp1 j1 r4 know case assumpt patjp patj therefor jp candid next j sinc next j sinc next j largest valu less j satisfi requir next invari r3 know jp 0 definit abstract imper matcher shift j compar jp k sinc synci hold assumpt synci compar jp k compar jp k also hold sinc kmp algorithm termin sinc abstract matcher total function complet abstract comput exist uniqu posit state main result captur diagram section 12 abstract imper matcher section 26 theorem 1 section abstract function matcher section 36 concret imper matcher section 25 section 26 concret function matcher section 35 section 36 corollari 3 equival let pat txt given 1 correspond complet imper comput c final configur n number n 2 correspond complet function computa tion c final configur n number n 3 4 trace c c equal proof theorem 1 abstract function matcher termin corollari 2 function matcher complet function comput therefor exist lemma 1 lemma 2 corollari abstract comput repres comput trace result repres faith final theorem 1 abstract comput synchron mean abstract trace result equal summar shown given pattern text trace imper matcher function matcher coincid sens two matcher albeit dierent time complex next section show elimin extra complex function matcher use partial evalu 5 intension correspond imper function matcher turn special function string matcher respect given pattern first use partial evalu ie program special next consid simpl form data special first show size special program linear size pattern special program run time linear size text next show special data coincid next tabl kmp section inform make somewhat liber use partial evalu terminolog 21 defin main pat txt let lpat stringlength pat ltxt stringlength txt letrec match lambda j k compar j k compar lambda j k match 0 match rematch rematch lambda j k jp kp kp eq stringref pat jp jp match rematch compar jp k eq stringref pat jp rematch rematch match figur 4 bindingtim annot function matcher 51 program special figur 4 display bindingtim annot version complet function matcher deriv appendix formal paramet tag static dynam depend whether denot valu depend data avail partialevalu time whether denot valu may depend data avail run time addit dynam condit express dynam test dynam addit subtract box part sourc program static evalu partialevalu time dynam part reconstruct give rise residu program partial evalu similix 3 4 design preserv dynam comput order present case dynam test among dynam comput guarante occur special program order sourc program therefor construct similix gener program travers text order function matcher thu kmp algorithm exampl special function matcher respect pattern abac without postunfold result residu program display figur 5 lambdadrop 8 renam charact follow subscript next charact pattern match textan intuit notat suggest grobauer lawal 13 special string matcher travers text linearli compar charact text liter charact pattern articl 18 page 330 knuth morri pratt display similar program next tabl compil control flow come back point end section 52 revisit partial evalu pattern match string 13 grobauer lawal analyz size complex residu code produc similix measur term number residu test show size residu program linear length pattern time complex linear length text manner show similix yield residu program linear length pattern whose time complex linear length text similix polyvari programpoint special build mutual recurs special version sourc program point default condit express dynam test sourc program point special respect set static valu correspond residu program point index set sourc program point met set static valu residu call correspond residu program point gener proposit 1 special function matcher figur 4 respect pattern yield residu program whose size linear length pattern proof inform function residu code gener main match compar first one main goal function contain memoiz point one residu main function gener exactli one memoiz pointa dynam condit express function match compar static data avail two memoiz point bound j pat lpat piec static data vari valu j ie j sinc 0 j pat memoiz point invari lemma 3 section 4 fact memoiz point match reach j pat pat variant two memoiz point gener number defin mainabac txt let ltxt stringlength txt defin match abac defin compar abac eq stringref txt k match abac k 1 match abac k 1 defin match abac defin compar abac eq b stringref txt k match abac k 1 compar abac k defin match abac defin compar abac eq stringref txt k match abac k 1 match abac k 1 defin match abac defin compar abac eq c stringref txt k compar abac k match abac 0 txt evalu mainabac txt yield result evalu main abac txt k evalu match abac k scope ltxt yield result evalu match 0 k scope lpat ltxt lpat denot length pat ltxt denot length txt k evalu match abac k scope ltxt yield result evalu match 1 scope lpat ltxt k evalu match abac k scope ltxt yield result evalu match 2 k scope lpat ltxt k evalu match abac k scope ltxt yield result evalu match 3 k scope lpat ltxt figur 5 result special function matcher wrt abac residu function therefor linear size pattern addit size function bound small constant seen one write bnf residu program 20 proposit 2 special function matcher figur 4 respect pattern yield residu program whose time complex linear length text proof inform proven knuth morri pratt kmp algorithm perform number comparison charact pattern text linear length text 18 corollari 3 show function matcher perform exact sequenc comparison charact pattern text kmp algorithm comparison perform compar function exactli one comparison perform call compar number call compar therefor linear length text sinc match function either termin call compar number call match bound number call compar proposit 1 residu code gener function main compar match time complex function main compar match easili seen bound small constant sinc main call number call compar match linear length text time complex residu program linear length text 52 data special section 36 remark 1 connect rematch function function matcher next tabl kmp algorithm section revisit connect show actual deriv kmp algorithm next tabl function matcher use simpl form data special 2 6 17 19 end first restat function matcher function matcher function tail recurs ie iter call particular rematch complet either call match call compar two actual paramet match 0 liter increment k avail scope match two actual paramet compar jp comput cours rematch k avail scope compar make possibl tabul rematch function modifi function matcher longer tail recurs instead rematch call match compar tail recurs make return valu call match compar set valu jp natur number 1 correspondingli instead compar call rematch tail recurs make dispatch result rematch call match compar tail recurs result display figur 6 proof theorem 1 show rematch termin call compar jp equal next j kmp algorithm also show defin main pat txt let lpat stringlength pat ltxt stringlength txt letrec match lambda j k ltxt compar j k compar lambda j eq stringref pat match 0 match let next rematch j 0 1 next 1 match compar next k rematch lambda j jp kp kp eq stringref pat jp jp rematch eq stringref pat jp rematch rematch match figur variat function matcher match call rematch valu next j kmp algorithm 1 call rematch compar therefor call new rematch function equival lookup next tabl kmp algorithm particular tabul pat input valu rematch correspond j 0 pat 1 yield next tabl use kmp algorithm simpl data special yield string matcher travers text linearli match pattern look next index pattern next tabl case mismatch word data special function matcher yield kmp algorithm particular special string matcher figur 6 tabul version respect pattern would compil correspond next tabl control flow residu program result would coincid compil code knuth morri pratt articl 18 page 330 6 conclus issu present first formal proof partial evalu precis yield kmp extension trace semant synchron intension size special program relat next tabl actual deriv kmp algorithm shown key obtain kmp naiv quadrat string matcher keep backtrack static control also maintain exactli one charact neg format consel danvi origin solut togeth grobauer lawal complex proof size time complex residu program buildup corollari 3 pave way relat eect stage string matcher independ known string matcher eg boyer moor 1 work led us consid famili kmp algorithm relat follow famili stage string matcher stage string matcher keep track neg inform give rise knuth morri pratt next tabl f function 18 page 327 ie morri pratt algorithm 5 chapter 6 tabul function yield array size pattern stage string matcher keep track one charact neg inform correspond knuth morri pratt algorithm next tabl stage string matcher keep track limit number charact neg inform give rise kmplike algorithm correspond residu program ecient also bigger stage string matcher keep track charact neg inform also give rise kmplike algorithm correspond residu program even ecient also even bigger grobauer lawal shown size residu program bound pat size alphabet 13 howev conjectur string matcher keep track two charact neg inform tighter upper bound size twice length pattern ie 2pat conjectur hold short pattern let us conclud two point obtain ecient string matcher partial evalu naiv string matcher obtain ecient essenc obtain ecient string matcher partial evalu naiv string matcher ensur backtrack naiv matcher static one either stage naiv matcher use simpl partial evalu keep naiv matcher unstag use sophist partial evalu matter backtrack carri special time dynam comput preserv special program size residu program provid lower bound time complex special exampl look kmp size residu program proport size pattern posit inform kept best generalpurpos partial evalu could thu proceed time linear pat ie opat first pass kmp algorithm ever evalu static part sourc program special time driven static control flow sourc program seem like optim strategi even discount complex bindingtim analysi exampl data special section 52 work time quadrat pat ie opat 2 construct next tabl hand ecient treatment could one bullet partial evalu gun 22 section 11 ie treatment gener applic dramat eect occasion exampl prove conjectur could lead bullet acknowledg grate torben amtoft julia lawal karolin malmkjr jan midtgaard mikkel nygaard anonym review varieti comment special thank andrzej filinski comment led us reshap articl work support esprit work group appsem http wwwmdchalmerssecsresearchsemanticsappsem stage quadrat string matcher figur 7 display naiv quadrat string matcher success check whether pattern pat prefix one success sux text txt main function initi indic j k access pat txt match function check whether match finish either success failur whether one comparison need compar function carri comparison either continu match rest pat rest current sux txt start match pat next sux txt figur 8 display stage version quadrat string matcher instead match pat next sux txt version use rematch function recompar function first match pat prefix sux pat know equal correspond segment txt eventu rematch function resum match rest pattern rest txt result stage string matcher backtrack txt partialevalu jargon string matcher figur 8 use posit inform text see footnot 1 page 4 piec neg inform also avail name latest charact provok mismatch figur 9 display stage version quadrat string matcher exploit neg inform rather blindli resum compar function rematch function first check whether charact caus latest mismatch could caus new mismatch therebi avoid one access text simplifi formal develop inlin recompar rematch lambdalift rematch lexic level match compar 8 14 result string matcher display figur 10 section 34 cours mani way stage string matcher one chosen easi deriv easi reason r abstract instanti stringmatch program mix comput translat linearis decomposit compil similix 51 manual automat autoproject recurs equat global variabl abstract data type exact string match algorithm sandrin chiroko partial evalu pattern match string transform recurs equat program block structur program transform system base gener partial comput gener partial comput essenc gener partial comput occam razor metacomput notion perfect process tree partial evalu pattern match string lambda lift transform program recurs equat partial evalu automat program gener revis 5 report algorithm languag scheme data special fast pattern match string program data special principl abstract interpret partialevalu algo rithm transformationbas optimis haskel christian queinnec jeanmari geroy partial evalu pattern match constraint logic program languag posit su percompil tr lambda lift transform program recurs equat partial evalu pattern match string partial evalu pattern match constraint logic program languag automat autoproject recurs equat global variabl abstract data type essenc gener partial comput partial evalu automat program gener abstract interpret partial evalu algorithm data special transformationbas optimis haskel lambdadrop glossari partial evalu relat topic program transform system base gener partial comput revis report algorithm languag scheme combin program data special occam razor metacompu partial evalu pattern match string revisit ctr mad sig ager olivi danvi hen korsholm rohd fast partial evalu pattern match string acm sigplan notic v38 n10 p39 octob yoshihiko futamura zenjiro konishi robert glck automat gener effici string match algorithm gener partial comput proceed asian symposium partial evalu semanticsbas program manipul p18 septemb 1214 2002 aizu japan olivi danvi hen korsholm rohd obtain boyermoor stringmatch algorithm partial evalu inform process letter v99 n4 p158162 31 august 2006 mad sig ager olivi danvi hen korsholm rohd fast partial evalu pattern match string acm transact program languag system topla v28 n4 p696714 juli 2006 germn vidal costaug partial evalu function logic program higherord symbol comput v17 n12 p746 marchjun 2004