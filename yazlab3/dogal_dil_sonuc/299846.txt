synthes effici outofcor program block recurs algorithm use blockcycl data distribut abstractin paper present framework synthes io effici outofcor program block recurs algorithm fast fourier transform fft block matrix transposit algorithm framework use algebra represent base tensor product matrix oper program optim stripe vitter shriver twolevel memori model data distribut use variou cyclicb distribut contrast normal use physic track distribut cyclicbd bd physic disk block size first introduc tensor base captur semant blockcycl data distribut outofcor data also data access pattern outofcor data present program gener techniqu tensor product matrix transposit accur repres number parallel io oper requir synthes program tensor product matrix transposit function tensor base data distribut introduc algorithm determin data distribut optim perform synthes program formal procedur synthes effici outofcor program tensor product formula variou blockcycl distribut dynam program problem demonstr effect approach sever exampl show choic appropri data distribut reduc number pass access outofcor data larg eight time tensor product dynam program approach larg reduc number pass access outofcor data overal tensor product formula b introduct due rapid increas perform processor commun network last two decad cost memori access becom main bottleneck achiev highperform mani applic modern comput includ parallel comput use sophist memori hierarchi consist exampl cach main memori disk array narrow gap processor memori system perform howev effici use deep memori hierarchi becom challeng outofcor applic comput fluid dynam seismic data process involv larg volum data task effici use io subsystem becom support nsf grant nsfiri9100681 rome lab contract f3060294c0037 arpasisto contract n00014 91j1985 n0001492c0182 subcontract ki92010182 z surfac mail depart comput scienc duke univers box 90129 durham nc 277080129 extrem import spur larg interest variou aspect outofcor applic includ languag support outofcor compil parallel file system outofcor algorithm outofcor program synthesi 2 18 7 4 program synthesi automat program gener long histori comput scienc 16 recent past tensor kroneck product algebra success use synthes program class block recurs algorithm variou architectur vector share memori distribut memori machin 11 9 5 memori hierarchi cach singl disk system 14 13 recent enhanc program synthesi framework multipl disk system fix physic track data distribut 10 captur twolevel disk model propos vitter shriver 19 paper present framework use tensor product synthes program block recurs algorithm stripe vitter shriver twolevel memori model permit variou blockcycl distribut outofcor data disk array framework present paper gener framework present 10 use algebra properti tensor product captur semant blockcycl data distribut cyclicb b logic block size disk array investig implic variou blockcycl distribut cyclicb perform outof core block recurs algorithm fast fourier transform fft block matrix transposit algorithm tensor product represent block recurs algorithm may involv stride permut sinc stride permut interpret matrix transposit synthes effici outofcor program stride permut import 17 6 12 present procedur synthes effici outofcor program stride permut use cyclicb distribut data algorithm determin block size b optim perform synthes program also present discuss program gener techniqu tensor product variou blockcycl data di tribut discuss sever strategi factor group data rearrang improv perform tensor product formula formal procedur synthes effici outof core program tensor product formula variou data distribut dynam program problem howev sinc data rearrang expens target model discuss section 7 incorpor dynam program approach sens stride permut mainli understood method program synthesi matrix transposit tensor product formula illustr effect dynam program approach exampl outofcor fft program examin perform issu synthes program show 1 choic data distribut larg influenc perform synthes program 2 simpl algorithm select appropri data distribut size effect 3 dynam program approach alway reduc number pass access outofcor data paper organ follow section 2 discuss formul block recurs algorithm use tensor product matrix oper section 3 introduc twolevel comput model present semant data distribut data access pattern also argu advantag use variou blockcycl distribut section 4 present overview approach outofcor program synthesi gener program synthes outofcor program tensor product given tensor base also discuss section 5 present framework synthes program variou blockcycl data distribut stride permut section 6 present approach synthes outof core program tensor product section 7 present multistep dynam program algorithm synthes program tensor product formula section 8 summar perform result show effect use variou blockcycl data distribut section 9 discuss relat research conclus provid section 10 appendix list select set symbol use paper appendix b appendix c present addit detail prove properti discuss section 4 section 5 respect product algebra tensor kroneck product 8 theta n matrix mn p theta q matrix b pq block matrix obtain replac element ij mn matrix ij b pq tensor product involv ident matrix implement parallel oper ident matrix order n denot n consid applic vector n interpret n copi b pq act parallel disjoint segment x nq howev interpret applic mnomega p np parallel oper need understand stride permut stride permut l mn n mn theta mn permut matrix applic l mn n x mn result vector mn vector consist element set fx ij lambdan 1g one import properti stride permut l mp pqomega mn l nq q use stride permut applic mnomega p vector np also interpret p parallel applic mn disjoint segment np use ident l mp pomega mn l np case howev input applic mn access stride p output also store stride p gener momega npomega q interpret mq parallel applic np properti tensor product use transform tensor product represent algorithm anoth equival form take advantag parallel oper discuss exampl use follow tensor product factor mnomega p mnomega q 4 aomega b implement first appli q parallel applic parallel applic properti tensor product list 11 1 aomega bomega aomega bomega c 2 aomega bcomega acomega bd assum ordinari multipl ac bd defin 3 4 contrast tensor product use describ variou comput tensor product vector base call tensor basi use describ data access storag pattern multidimension array vector basi e column vector length one posit zero elsewher use e denot ith index onedimension array size sinc inj use e repres index j twodimension array assum rowmajor storag order multidimension array memori gener tensor basi e deltaomega e m1 correspond index array index function need access element multidimension array obtain linear tensor basi exampl linear tensor basi e deltaomega e m1 result vector basi e deltadeltadeltam 1 index linear tensor basi exactli index function need access tdimension array rowmajor order equival vector basi e factor tensor product vector base deltaomega e m1 3 factor vector basi correspond view onedimension array multidimension array use tensor base semant stride permut l mn n formal express l mn correspond matrix transposit theta n array store rowmajor order appropri factor vector basi input vector use result tensor basi describ data access pattern tensor product exampl tensor product momega pnomega q input vector basi e mnq factor obtain input tensor basi e j known oper basi output vector basi e mnq factor obtain output tensor basi e also determin follow ident momega pnomega q e iomega pn e n jomega q e q iomega pn e n replac pn e n j e p use input output base determin input output data element applic pn deriv program twodimension iter space ignor dimens matric whenev clear context code kth applic pn indic input data element kth applic obtain linear input tensor basi e mnq inqqjk finq ng similarli output indic determin linear output tensor basi fipq pg note loop correspond indic j j 0 program 21 tensor product formul block recurs algorithm tensor product formul block recurs algorithm follow gener form jomega v jomega c j v j v j theta v j linear transform 6 definit stride permut understood special case 1 theta 1 matric v j permut matrix correspond stride permut ident term r j allow decomposit comput set smaller size comput may comput main memori similarli ident term c j allow decomposit comput set subcomput subcomput access data storag stride fashion although parallel stride comput structur help decompos comput smaller incor comput task combin decomposit goal minim io entir comput challeng problem next present exampl illustr use tensor product formula repres cooleytukey fft algorithm fast fourier transform fourier transform denot follow matrix vector multipl fn n theta n discret fourier matrix fn n nth primit root uniti rs discret fourier matrix fn factor follow 11 15 romega rs rs call twiddl factor defin rs use factor recurs obtain follow tensor product represent cooleytukey fft algorithm figur 1 data organ 4 column disk box physic block row consist physic track number box denot record indic 2 igamma1 diagon matrix constant r 2 n permut input sequenc bitrevers order ignor initi bitrevers oper r 2 n notic 2 2 igamma1 diagon matrix see comput structur f 2 n captur first factor 2 2omega 2 igamma1 easili verifi major comput portion exampl formula 6 3 parallel io model blockcycl data distribut use twolevel model similar vitter shriver twolevel memori model 19 howev model data disk call outofcor data distribut differ logic block size model consist processor intern random access memori set disk storag capac disk assum infinit disk data organ physic block fix size four paramet n size input size intern memori b size physic block number disk use model assum n bd model disk io occur physic track defin size b physic block rel posit disk constitut physic track physic track number contigu outermost track lowest address innermost track highest address ith physic track denot fig 1 show exampl data layout b parallel io oper simultan access physic block one block disk therefor parallel data access two level element one physic block transfer concurr physic block transfer one io oper paper use stripe disk access model physic block one io oper come track oppos independ io model block come differ track use parallel primit parallel readi parallel writei denot read write physic track respect defin measur io perform number parallel io requir 31 blockcycl data distribut blockcycl distribut use distribut array among processor multiprocessor sy tem blockcycl distribut partit array equal size block consecut element map onto processor cyclic manner regard disk model processor 43 44 48 figur 2 data organ 8 column disk first left shadow box denot exampl logic block two logic track lt 0 lt 1 consist two physic track data organ describ eg fig 1 exactli blockcycl distribut denot block size b moreov assum data distribut arbitrari block size 2 fig 2 show data organ paramet fig 1 cyclic8 distribut notic size physic track size physic block chang howev contain differ record call b record block form cyclicb distribut logic block similarli logic block rel posit disk consist logic track ith logic track denot lt note parallel io oper still access physic track logic track henc sever parallel io oper need access logic track exampl load logic track lt 1 fig 2 two parallel read oper parallel read2 parallel read3 respect load physic track 2 3 need next use simpl exampl show advantag use logic distribut develop ioeffici program block recurs algorithm logic data distribut assum want implement f 8 target model paramet given fig 1 assum size main memori half size input mainli interest data access pattern ignor real comput conduct f 8 thing need rememb f 8 need eight element stride eight exist ident matrix 8 first consid implement f 8 physic block distribut discuss know first f 8 need appli eight element 0 8 16 24 28 32 40 48 56 fig 1 see element requir f 8 comput store four physic track howev main memori hold two physic track simpli load four physic track main memori accomplish comput one pass io get around memori limit use two differ approach first load first physic track keep first half record physic block load physic track throw half record everi physic track comput half record main memori finish comput half record write result repeat procedur howev keep half 2 cormen call data organ disk band data layout 3 studi perform class permut sever basic primit nesl language1 record main memori load track comput way obvious need two pass load outofcor data anoth method use logic block distribut suppos size logic block eight shown fig 2 eight record requir one f 8 store two physic track physic track one three physic track two four therefor load physic track one three first comput load physic track two four comput finish comput one pass exampl clearli show advantag use logic distribut compar use physic track distribut howev sever problem address determin block size logic distribut determin data access pattern discuss issu rest paper note stripe io model data distribut cyclicb transform model 1 howev transform may true arbitrari cyclicb distribut therefor normal reduc problem simpler case 1 simplic make follow assumpt input output data store separ set disk paramet power two 3 block size b distribut multipl b 32 semant data distribut access pattern discuss 9 blockcycl distribut algebra repres tensor basi approach adopt disk model substitut disk processor howev exist physic block physic track tensor basi use defin blockcycl distribut multiprocessor need factor call factor tensor basi outofcor data distribut basi defin follow definit 31 vector n distribut accord cyclicb distribut disk data distribut basi defin gomega e bomega e bd b use ds refer sth factor left eg exampl data distribut basi figur 2 e 2 b data distribut basi figur 1 written e 4 b select portion distribut basi formula 10 use obtain index function need denot particular data unit logic track physic track let 3 result easili gener paramet power integ figur 3 exampl data organ access pattern logic track consist two physic track physic block decompos two subblock shadow subblock togeth use form data access pattern one exampl access shadow subblock rowmajor order index function access physic track obtain linear tensor basi obtain physicaltrackbasisd take differ 4 data distribut basi tensor base denot record insid logic track physic track respect tensor base call logic trackel basi e bomega e bd b physic trackel basi e domega e bd b respect concept extend denot subset data discuss later hand differ order instanti indic data distribut basi defin formula 10 result differ access pattern outofcor data exampl instanti indic formula order left right ie g slowest b fastest chang index actual access data first first logic block first disk access first logic block second disk finish access first logic track sequenti second logic track access obviou order indic data distribut basi instanti differ outofcor data access differ pattern exampl instanti index b b e b b index e formula 10 result access pattern first data along physic track access success physic track access chang instanti order indic regard permut 5 data distribut basi call permut data distribut basi loop basi synthes program everi index loop basi may use gener loop nest order loop nest determin order vector base loop basi gener outofcor data view organ multidimension structur exampl data layout fig 2 view threedimension array logic block view b b theta b matrix convert b twodimension structur combin record disk togeth submatrix view denot factor regroup data distribut base use form differ data access pattern fig 3 show exampl data organ access pattern assum logic 4 let g two tensor base differ denot sg tensor basi construct delet vector base g 5 let tensor basi omega q let ff permut permut tensor basi defin follow ff omega q track consist two physic track decompos physic block b two subblock size b d1 order reflect data organ factor data distribut basi follow gomega e b permut factor data distribut basi loop basi access subset data differ pattern assum want access data fig 3 follow order first access darker shadow subblock rowmajor order access lighter shadow subblock rowmajor order move d3 d4 d2 d1 respect result follow loop basi b bomega e verifi correct loop basi follow 1 index b d2 choos shadow subblock 2 index g choos logic track 3 index b b choos logic block 4 index choos disk 5 index b d1 choos record insid subblock sinc increas indic revers order five step first access record insid first darker shadow subblock first disk access record shadow subblock second disk access record darker shadow subblock rowmajor order repeat procedur lighter shadow subblock 4 overview program synthesi effici implement block recurs algorithm obtain use properti tensor product transform tensor product represent block recurs algorithm transform use result perform individu tensor product perform tensor product obtain use method present section 6 fig 4 show procedur synthes effici outofcor program block recurs algorithm figur augment tensor basi contain follow inform data distribut base loop base subcomput memoryload necessari code gener explain section input tensor product formula consist stride permut quickli pass program transform step use algorithm present section 4 gener augment tensor basi tensor product formula success step appli tensor product transform tensor product formula obtain augment tensor basi tensor product use method present section 6 code gener step tensor product stride permut use procedur present section present deriv effici implement block recurs algorithm revers order fig 4 first present procedur code gener use inform contain target machin model tensor product formula tensor product formula data distribut augment tensor basi code gener parallel io program program transform comput partit access pattern analysi figur 4 procedur synthes effici outofcor program block recurs algorithm augment tensor basi determin effici implement stride permut simpl tensor product given data distribut given model determin correspond augment tensor base develop algorithm determin data distribut result effici implement simpl tensor product use inform obtain far use dynam multistep dynam program algorithm determin effici implement block recurs algorithm rest section summar synthes effici program simpl tensor product stride permut target machin model detail perform synthes program discuss next two section minim number io oper synthes program need exploit local reus load data requir decompos comput reorgan data data access pattern maxim data reus synthes program subcomput perform sever time differ data set henc loop structur synthes program construct follow outer loop nest enclos three inner loop nest read loop nest read data comput loop nest perform subcomput load data write loop nest write output data back disk inner read loop nest load outofcor data without overflow main memori refer data set memoryload inner comput loop nest perform subcomput memoryload data set access use parallel primit parallel read parallel write load store physic track time one main result paper effici tensor product decomposit comput gener loop indic n gener loop indic parallel read use input distribut basi construct memoryload end loop correspond perform oper memoryload gener loop indic parallel write use output distribut basi end loop correspond end loop correspond n figur 5 procedur code gener tensor product effici data access pattern obtain use algebra properti data distribut base loop base word determin data distribut base loop base determin memoryload subcomput oper memoryload tensor product comput input output data may organ access differ therefor use input data distribut basi fi output data distribut basi ffi input loop basi output loop basi denot respect data distribut base obtain input output base rewrit form formula 10 howev nontrivi task determin loop base goal minim number io oper next present gener synthes program summar gener idea determin loop base discuss detail determin loop base therefor memoryload oper memoryload next two section consid task gener target code assum data distribut base loop base memoryload oper memoryload alreadi determin discuss previou section stripe io model io oper read store record physic track time henc part loop basi explicitli appear synthes program moreov input output loop basi separ two part first part specifi memoryload second part specifi record insid memoryload second part separ two part one part denot use construct memoryload anoth part denot gener loop nest synthes program word write input output base follow call n n memori basi sinc instanti indic n correspond memoryload use loop base gener program obtain describ fig 5 notic parallel read track track number obtain index function physicaltrackbasisfi part input data distribut basi defin formula 12 parallel write fig 6 show exampl synthes program 4 assum f 2 2 theta 2 matrix data distribut cyclic2 manner use e 8 b input output distribut base input output loop base also e 2 b g1 factor e 8 let us examin formula 15 16 obvious consist physic track element base input output data respect outofcor data need access term memoryload memoryload follow properti input memori load occupi locat set physic track specifi input data distribut basi comput record main memori organ occupi locat set physic track specifi output data distribut basi call type memoryload perfect memoryload construct memoryload manner synthes program access outofcor data call onepass program howev may possibl construct perfect memoryload comput case may need keep part record load physic track main memori discard record therefor multipass program need synthes physic track load sever time term tensor base correspond move vector base physic track basi memori basi consid exampl present section 32 move fi4 first factor sinc unit data access still physic track move correspond load track bd time howev load track half record kept main memori assum size main memori half input size record kept load track determin vector base move memoryload basi case e instanti index b d2 determin subblock physic track kept current memoryload detail program load outofcor data construct memoryload shown enddo enddo enddo enddo enddo temporari array hold physic track x hold memoryload summari order determin effici loop base construct initi loop base consist physic trackel base input output data distribut base respect determin vector base need move n move vector base use determin portion physic block kept current memoryload size move vector base equal number time physic track load may need determin order rest vector base gamma reflect order access physic track parallel read track enddo perform oper memori load write result back parallel write track parallel enddo enddo figur code tensor product 2omega 4 x array size 4 synthes program stride permut section present framework synthes effici outofcor program stride permut use cyclicb distribut perform synthes program repres function size subtensor basi whose valu obtain distribut size given also present algorithm determin distribut optim perform 51 stride permut cyclicb distribut mention goal decompos comput sequenc subcomput oper perfect memoryload howev may alway possibl limit memori size case minim number time data load memoryload well ensur physic track output written parallel develop approach determin input output loop base given distribut cyclicb base loop base data distribut base determin memoryload oper memoryload follow program synthes use procedur present section 4 cost program also determin loop base summar result follow theorem present construct proof theorem 51 let input output vector length n respect let x distribut accord cyclicb data distribut base denot fi ffi respect denot fi2omega fi4 ffi2omega ffi4 program synthes n oper stride permut proof present algorithm shown fig 7 determin input output loop base algorithm explain step 1 shown step 2 step 3 show construct 6 notat j j denot size tensor basi equal multipl dimens vector basi initi fi1omega fi3omega fi2omega fi4 onepass multipass implement j els consist last factor factor tensor basi bdd final input output loop base figur 7 algorithm determin input output loop base memoryload oper memoryload step 4 show io cost obtain inform 1 determin input output loop base begin follow construct input output loop base use convent appear right hand side refer origin represent equal fi1omega fi3omega fi2omega fi4 appear left hand side refer updat assum ffi2omega ffi4 easi verifi gamma permut therefor denot record thu number record denot j size main memori simpli take howev number record denot j may exceed size main memori case want construct memoryload obtain read input data sever time howev write output data term tensor base discuss section 4 reload achiev loop part indic word need factor 2 1 2 denot subblock kept load physic track 1 denot record insid subblock j 2 j equal number time reload physic track reload achiev take move 2 summari input output loop base formula 17 18 modifi follow consist last factor factor tensor basi size equal bdd ffl input loop basi let 2 therefor input output loop base written verifi follow fact first contain vector base howev differ order proof present appendix b therefor denot record howev differ order second previou result j therefor record denot fit memoryload third j dbd mean load record fit main memori need discard record detail determin record discard discuss next step 4 n contain vector base therefor set mn chang order write result onto physic track 2 determin memoryload j therefor record denot use form perfect memoryload howev condit satisfi need use formula 19 20 input output loop base respect j size memoryload set equal size main memori howev mention need discard record load track form memoryload done linear 2 instanti 2 give set subblock physic track kept 3 determin oper memoryload mention memori load tensor vector input output loop base denot record insid memoryload differ order word one permut anoth input output loop base permut input output data distribut base actual permut memoryload data time therefor inmemori oper noth permut subset data distribut base denot momega 4 io cost synthes program readili see j program synthes ie number parallel io 2n bdd condit hold keep j record load physic track load physic track j 2 j time moreov sinc dbd easili determin j 2 write record number parallel io oper 1 bdd combin two case togeth yield perform result present theorem program perform synthes use procedur list fig 5 52 determin effici data distribut previou subsect present approach synthes effici io program given data distribut present algorithm determin data distribut optim perform synthes program idea algorithm follow begin physic track distribut cyclicb ie initi onepass algorithm distribut b desir block size data distribut otherwis doubl valu b perform synthes program distribut increas continu procedur otherwis algorithm stop current block size desir size data distribut formal idea fig 8 number io use cyclicb cost 6 2n dbd b n number io use cyclicb c new cost cost c new els break output distribut size b2 number figur 8 algorithm comput desir size data distribut 6 synthes program tensor product tensor product romega vomega c main comput matrix v need v record stride c call v record desir record first present possibl gener form input output loop base given distribut cyclicb paramet form determin analyz rel valu paramet base loop base also data distribut base determin memoryload oper memoryload therefor program gener use procedur discuss section 4 cost program also determin loop base sinc tensor product romega vomega c chang order input comput inplac use input output data distribut base input output data also input output loop base program synthes section therefor consid input input distribut input loop base assum output base input base respect summar result theorem present construct proof theorem 62 let input data distribut accord cyclicb input data distribut basi denot let fi2omega fi4 assum 1 denot subset move memori basi tensor product romega vomega c rv program synthes 2n bdd parallel io oper otherwis program synthes j 2 j 3n bdd parallel io oper proof 1 determin input loop basi desir record v comput store physic track bdd simpli load track parallel therefor onepass program gener howev bdd keep record track main memori take simpl approach keep mani possibl record follow desir record track main memori reload track finish comput record term tensor basi need noth factor permut input data distribut basi reflect data access pattern specif begin 2omega 4 defin initi valu defin section 5 onepass program factor permut nomega chang order access physic track howev multipass program need factor permut sinc need keep part record load main memori discard record part record kept discard denot subset vector base physic track basi one exampl factor permut semant discuss chapter 4 howev gener order factor permut tensor basi desir form need examin rel valu paramet target io model tensor product size b data distribut space limit present major idea analysi appendix c follow analysi enough say found subset denot 1 2 2 move memori basi gener loop nest data access 2 determin memoryload onepass program simpli factor nomega bdd multipass program nomega j vector base 2 appear n moreov multipass program discuss section 5 use 2 determin record kept current memoryload 3 determin oper memoryload origin tensor product regard r parallel applic v input stride c data distribut among disk load unit physic track net effect possibl reduc stride v access main memori oper memoryload gener form zomega vomega z howev valu z depend rel valu paramet appendix c present major idea determin valu z 4 io cost synthes program onepass program move vector base number parallel io simpli equal 2n bdd word synthes program optim term number io multipass program need read input j 2 j time therefor number parallel io oper j 2 j 3n bdd constant 3 explain follow store physic track need read physic track main memori sinc part record physic track discard reload physic track reassembl physic track part updat record write parallel otherwis part record written physic track may correct reassembl physic track need use tensor basi 2 notic 2 equal 2 put updat record correct locat physic track similar use 2 take subblock load physic track current memoryload program perform discuss synthes use procedur list fig 5 howev accur synthes multipass program need incorpor idea reassembl physic track writeout part procedur list fig 5 discuss noth use linear 2 put subblock current memoryload correct locat reload physic track7 synthes program tensor product formula section discuss techniqu program synthesi tensor product formula sever strategi develop diskeffici program exploit local exploit parallel access data similar idea discuss 13 use factor group exploit local data rearrang reduc cost io oper also present greedi method use factor group improv perform stripe vitter shriver twolevel memori model fix block size data distribut 10 factor group combin contigu tensor product tensor product formula togeth therefor reduc number pass access secondari storag consid core cooleytukey fft comput comput repres formula 9 ignor initi bitrevers twiddl factor oper i2 3 follow tensor product 2 2omega 2 2 respect assum tensor product implement optim number parallel io oper requir implement two step individu 4n db howev success tensor product formula 6 henc use properti tensor product combin one tensor product 2 2omega 2 may also implement optim use 2n dbd parallel io oper data rearrang use properti tensor product chang data access pattern exampl tensor product romega c transform equival form c best case number parallel io requir 6n dbd use transform sinc least three pass need transform form extra pass introduc transform profit use target machin model first last term transform formula may implement optim therefor incorpor transform current optim procedur minim io cost use dynam program sinc factor group shown size data distribut shown next section larg influenc perform synthes program take follow approach determin optim manner tensor product formula implement use algorithm determin optim data distribut present fig 8 main routin howev cyclicb data distribut use dynam program algorithm determin optim factor group henc also call method multistep dynam program method let ci j optim cost minimum number io pass requir access outofcor data comput j gamma tensor factor ith factor jth factor tensor product formula ci j comput follow ae formula c 0 denot cost comput tensor product method determin cost tensor product discuss section 6 valu c 0 differ case found tabl 3 tabl 4 present section 82 special case need explain assum cj use ci k repres cost group tensor product factor j togeth group tensor product simpl tensor product valu ci k case also determin use tabl 3 tabl 4 present section 82 howev case size group oper larger size main memori dont want group k gamma factor togeth assign larg valu 1 ck j avoid select perform result 81 perform synthes program matrix transposit given flexibl choos differ data distribut synthes program better perform obtain use fix size data distribut stride permut present set experiment result number io oper requir cyclicb distribut distribut size b distribut vari result summar tabl 1 tabl 2 tabl see number pass monoton increas decreas function howev normal decreas increas b increas therefor algorithm fig 8 good chanc find effici size data distribut also notic stride permut alway find distribut implement comput onepass tabl 1 number io pass requir perform stride permut l pq use variou cyclicb distribut tabl 2 number io pass requir perform stride permut l pq use variou cyclicb distribut 82 perform synthes program tensor product number io pass requir synthes program tensor product summar tabl 3 tabl 4 go variou case use approach present appendix c verifi result present comprehens result present 10 case use approach present section 51 actual synthes program better perform exampl 10 program v bdd pass synthes howev condit c b v c assum result tabl 3 synthes program v c pass less v bdd tabl 3 number io pass requir tensor product romega vomega c use cyclicb distribut bdd maximum number physic track memoryload tabl 4 number io pass requir tensor product romega vomega c given size b data distribut n bdd maximum number physic track memoryload show use appropri cyclicb data distribut better perform program synthes case sever typic exampl shown tabl 5 notic increas b reduc number pass data access case decreas number pass larg eight time valu tabl also suggest use algorithm present fig 8 find effici size data distribut given tensor product also notic case c b improv perform reason stride requir v less physic block size reduc redistribut tabl 5 number io pass requir variou size data distribut tensor product romega vomega c let let size n rv c input vector larg 83 perform synthes program tensor product formula show effect multistep dynam program method compar program synthes program synthes greedi method dynam program method appli data distribut fix size respect exampl use core cooleytukey fft comput result sever typic size input shown tabl 6 find use dynam program fix size cyclicb distribut normal improv perform greedi method howev use multistep dynam program reduc number pass synthes program least 1 n significantli larg input size larg perform gain reduc even one pass access outofcor data signific greedi dp mdp 4 tabl number io pass synthes program use greedi dynam program dp multistep dynam programmingmdp method 9 relat research tensor product algebra success use synthes program block recurs algorithm variou architectur vector share memori distribut memori machin 11 9 5 recent tensor product framework use synthes program memori hierarchi exampl method program synthesi singl disk system discuss 13 howev address issu data distribut multipl disk system 14 kumar huang sadayappan johnson discuss method program synthesi cach memori address issu data layout setassoci cach 10 present framework use tensor product synthes effici program deeper level memori hierarchi model vitter shriver twolevel memori model howev consid data distribut fix physic track distribut program synthes also effici program synthes approach present paper also mani recent research effort area io intens applic includ outofcor algorithm languag compil parallel file system perform model 2 exampl vitter shriver prove lower upper bound matrix transposit fft graph comput twolevel memori model 19 cormen present algorithm bmmc permut 3 includ stride permut subclass twolevel memori model conclus present novel framework synthes outofcor program block recurs algorithm use algebra properti tensor product use stripe vitter shriver two level memori model target machin model howev instead use simpler physic track distribut normal use model use variou blockcycl distribut support high perform fortran organ data disk moreov use tensor base tool captur semant data distribut data access pattern show use algebra properti tensor product decompos comput arrang data access pattern gener outofcor program automat demonstr import choos appropri data distribut effici outofcor implement set experi experiment result also show simpl algorithm choos effici data distribut effect observ import data distribut factor group tensor product propos dynam program approach determin effici data distribut factor group exampl fft comput dynam program approach reduc number io pass least one compar use simpler greedi algorithm acknowledg thank peter mill comment paper r vector model dataparallel comput virtual memori dataparallel comput integr theori practic parallel file system extent portabl program environ design implement high perform block recurs algorithm fast comput method matrix transpos parallel io system interfac parallel comput kroneck product matrix calculu applic synthes communicationeffici distributedmemori parallel program block recurs algorithm gener effici program twolevel memori tensor product methodolog design effici transposit algorithm larg matric methodolog gener effici diskbas algorithm tensor product formula algebra approach cach memori character block recurs algorithm comput framework fast fourier transform parallel algorithm deriv program transform parallel process perfect shuffl compil outofcor data parallel program distribut memori machin algorithm parallel memori twolevel memori tr