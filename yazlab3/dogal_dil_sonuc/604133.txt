select memoiz present framework appli memoiz select framework provid programm control equal space usag identif precis depend memoiz appli accord need applic two key properti framework effici yield program whose perform analyz use standard techniquesw describ framework context function languag implement sml librari languag base modal type system allow programm express program reveal true data depend execut sml implement support modal type system static instead employ runtim check ensur correct usag primit b describ framework context function languag implement sml librari languag base modal type system allow programm express program reveal true data depend execut sml implement support modal type system stati calli instead employ runtim check ensur correct usag primit categori subject descriptor program languag gener f20 analysi algorithm problem complex gener d31 program languag formal denit theori d33 program languag languag construct fea turescontrol structur gener term languag perform algorithm keyword memoiz select programm control perform research support part nsf grant ccr9706572 ccr0085982 ccr0122581 permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut prot commerci advantag copi bear notic full citat rst page copi otherwis republish post server redistribut list requir prior specic permiss andor fee popl03 januari 1517 2003 new orlean louisiana usa acm 1581136285030001 500 memoiz fundament power techniqu result reus date back half centuri 7 21 22 use extens mani area dynam program 4 9 10 19 increment comput 11 34 12 36 16 1 37 20 14 2 mani other 8 23 17 25 26 20 fact lazi evalu provid limit form memoiz 18 although memoiz dramat improv perform requir small chang code languag librari support memoiz gain broad accept instead mani success use memoiz reli applicationspec support code underli reason one control sinc memoiz perform user must abl control perform memoiz mani subtleti memoiza tion includ cost equal check cach replac polici memo tabl make differ exponenti linear run time gener wide applic memoiz framework must provid control three area 1 kind cost equal test 2 ident precis depend input output memoiz code 3 space manag control equal test critic reusabl result identi control ident precis depend import maxim result reus abl control memo tabl individu entri purg critic otherwis user know whether result reus paper propos framework memoiz provid control equal ident depend control space manag studi framework context small languag call mfl provid implement standard ml languag also prove type safeti correct mflie semant preserv respect nonmemo version exampl show analyz perform memoiz version quicksort within framework next section describ background relat work section 3 introduc framework via exampl section 4 formal mfl languag discuss safeti cor rect perform properti section 5 present simpl implement framework standard ml librari section 6 discuss framework might extend allow better control space usag discuss relationship work previou work adapt comput 2 background relat work typic memoiz scheme maintain memo tabl map argument valu previous comput result tabl consult function call determin particular argument tabl call skip result return otherwis call perform result ad tabl semant implement memo lookup critic perform review key issu implement memoiz efcient equal memoiz scheme need search memo tabl match current argument search minimum requir test equal typic also requir form hash standard languag implement test equal structur exampl requir travers whole structur cost equal test negat advantag memoiz may even chang asymptot behavior function approach propos allevi problem rst base fact memoiz equal need exactit return unequ two argument actual equal implement could therefor decid skip test equal expens could use conserv equal test locat equal problem approach whether match found could depend particular implement sure evid programm anoth approach reduc cost equal test ensur one copi everi valu via techniqu known hash cons 13 5 35 one copi equal implement compar locat fact locat also use key hash tabl theori overhead hashcons constant expect case expecta tion intern random hash function realiti howev rather differ larg memori demand hashcons interact garbag collect fact sever research argu hashcons expens practic purpos 32 33 6 24 altern hash con sing pugh propos lazi structur share 32 lazi structur share whenev two equal valu compar made point copi speed subsequ comparison pugh point disadvantag approach perform depend order comparison thu difcult analyz note even hashcons method remain critic dene equal type includ real function claim function never equival exam ple satisfactori result call involv function paramet never reus depend maxim result reus result function call must store respect true depend issu aris function examin part approxim paramet enabl partial equal check unexamin part paramet disregard increas likelihood result reus one abl match approxim rather paramet exam ple consid code result f depend either xy xz also depend approxim xwhether positiverath exact valu thu memo entri 71120 match 41150 sinc x posit result depend sever research remark partial match import applic 28 27 1 14 abadi lampson levi 1 heydon levin yu 14 suggest program analysi method track depend purpos although techniqu like effect catch potenti match provid programm control mechan specifi depend track also program analysi techniqu chang asymptot perform pro gram make difcult ass effect memoiz space manag anoth problem memoiz space requir program execut memo tabl becom larg limit util memoiz allevi problem memo tabl individu entri dispos programm control applic dynam program result reus occur among recurs call function thu memo tabl function dispos whenev ter minat applic result reus less structur individu memo tabl entri purg accord replac polici 15 33 problem determin exact replac polici use analyz perform effect chosen polici one wide use approach replac least recent use entri sophist polici also suggest 33 gener replac polici must applicationspec xed polici program whose perform made wors choic 33 3 framework select memoiz present overview framework via exampl framework extend pure function languag sever construct support select memoiz section use extens mllike languag discuss formal core languag studi safeti sound perform properti section 4 framework enabl programm determin precis depend input result function main idea deem paramet function resourc provid primit explor increment valu includ underli valu resourc increment explor process reveal depend paramet function result increment explor process guid type valu modal type underli valu type bound ordinari unrestrict variabl let construct creat depend underli valu result valu product type two part bound two resourc use let construct creat depend valu sum type case analyz use mcase construct branch accord outermost form valu assign inner valu resourc mcase creat depend outer form valu resourc key aspect let mcase bind resourc rather ordinari variabl nonmemo memoiz fun fib nint mfun mfib nint n 2 n n 2 n els yint yint fy return fy els els fz z return fz z figur 1 fibonacci express partial depend explor input function via let mcase let build branch record depend input result function let add branch full valu mcase add kind sum let add noth con sequent branch contain data depend let control depend mcase return en counter branch record reveal depend use key memo tabl result found memo tabl store valu return otherwis bodi return evalu memo tabl updat map branch result type system ensur depend made explicit preclud use resourc within return bodi exampl consid fibonacci function fib memoiz counterpart mfib shown figur 1 memoiz version mfib expos underli valu paramet resourc perform two recurs call usual sinc result depend full valu paramet bang type memoiz fibonacci function run linear time oppos exponenti time memoiz partial depend input result function captur use increment explor techniqu exampl consid function f shown figur 1 function check whether x posit return fyy fzz thu result function depend approxim x sign either z memoiz version mf captur rst check x posit expos underli valu z accordingli consequ result depend sign x either z thu mf call paramet 157 rst 253 result found memo second time x posit result depend note mif construct use exampl special case gener mcase construct critic issu efcient memoiz implement memo tabl along lookup updat oper framework support expect constant time memo tabl lookup updat oper repres memo tabl use hash requir underli type modal type index type index type associ inject function call index function map valu type uniqu integ integ call index valu uniqu properti indic given type ensur two valu equal indic equal framework equal dene nonmemo type irlintr list ks case l c w ks ct els let v1v2 v1 els v2 figur 2 memo tabl card complet memoiz type irlintr blist mfun mk cintlirl case unbox l conswvt c w els let v1v2 v1 els v2 end memoiz knapsack di index type enabl us implement memo tabl hash tabl key branch consist indic assum primit type come index function exampl integ ident function chosen index function composit type list function must box obtain index type box valu type type tbox box creat assign uniqu locat tag locat use uniqu index box valu exampl dene box list follow datatyp con blist box type blist blist box base box implement hashcons form memoiza tion exampl hashcons box list implement follow mfun hcon ha ta return box consht function take item box list return box list form cons sinc function memoiz ever call two valu alreadi hashcons result return advantag abl de ne hashcons memoiz function appli select control space usag memo tabl framework give programm way dispos memo tabl convent scop ing framework memoiz function alloc memo tabl thu function goe scope memo tabl garbag collect exampl mani dynamicprogram algorithm result reus occur recurs call function case programm scope memoiz function insid auxiliari function memo tabl discard soon auxiliari function return exampl consid standard algorithm knapsack problem ks memoiz version mk figur 2 sinc result share mostli occur among recurs call mk scope function call mk mk return memo tabl go scope discard note techniqu give partial control space usag particular give control individu nonmemo memoiz 15 20 fun fil gintbool fun mfil gintbool lint case l case unbox l nil nil nil empti ht consht let let case g h case g h true htt true hconshtt fals tt fals tt let return case l case unbox l nil nil nil nil consht consht let let qs shq g mq shmq g figur 3 quicksort algorithm memo tabl entri purg section 6 discuss framework might extend memo tabl manag accord programm speci cach scheme basic idea requir programm suppli cach scheme paramet mfun maintain memo tabl accord chosen cach scheme memoiz quicksort sophist exampl consid quicksort figur 3 show implement quicksort algorithm memoiz counterpart algorithm rst divid input two list contain key less pivot greater pivot use lter function fil sort two sublist return concaten result memoiz lter function mfil use hashcons ensur one copi result list memoiz quicksort algorithm mq expos underli valu paramet otherwis similar qs note mq build result via hashconsingit output two copi result sinc exampl output mq consum func tion need even result consum function one choos use hashcons oper insert delet input list sure chang result quicksort memoiz quicksort algorithm call similar put one would expect result would reus inde show memoiz quicksort algorithm comput result expect linear time input obtain previou input insert new key begin expect permut input list also intern random hash function use implement memo tabl analysi assum without loss gener iti key list uniqu theorem 1 let l list let run memoiz quicksort l l0 run time quicksort modi list l0 expect n length l0 3 26 9 figur 4 recurs tree quicksort input proof consid recurs tree quicksort input l denot ql label node pivot correspond recurs call see figur 4 exampl consid pivot key p l let lp denot key preced p l easi see key k subtre root p follow two properti satis key k0 2 lp 1 k0 p k k0 2 k0 p k k0 key subtre p less p left subtre greater p right subtre consid recurs tree ql0 pivot ql0 suppos p let k key left subtre p ql sinc k p two properti k left subtre p ql0 similarli p k right subtre p ql also right subtre p ql0 sinc ltere preserv respect order key input list p p input recurs call correspond left child similarli p input recurs call correspond right child thu sort l0 recurs call nd result memo therefor recurs call correspond root children node rightmost spine left subtre root children node leftmost spine right subtre root may execut two spine shown thick line figur 4 furthermor result call adjac spine found memo consid call whose result found memo worst case call along two spine consid size input node spine dene random variabl x1 xk xi least number recurs call node perform input size becom n less after3 i1 rst becom 4 n less sinc k dlog43 ne total expect number oper along spine dlog43 ne 3i1 dlog43 ne 3i1 sinc probabl pivot lie middl half list 12 exi 2 1 dlog43 ne i1ecn 2 ni1 thu bound hold spine therefor number oper due call whose result found memo sinc oper includ hashcons take expect constant time total time call whose result memo consid call whose result found memo call spine adjac thu expect ologn call sinc memo tabl lookup overhead expect constant time total cost ologn conclud quicksort take expect time sort modi list l0 easi extend theorem show bound hold insert anywher list although bound better complet rerun would take onlogn would like achiev ologn section 6 discuss combin memoiz adapt 2 may use reduc expect cost random insert ologn section studi small function languag call mfl support select memoiz mfl distinguish memoiz nonmemo code equip modal track depend data structur within memoiz code modal central approach select memoiz focu attent main result sound theorem state memoiz affect outcom comput compar standard nonmemo semant also show memoiz mechan mfl caus constant factor slowdown compar standard nonmemo semant 41 abstract abstract syntax mfl given figur 5 metavari x rang countabl set variabl metavari b rang overf countabl set resourc distinct made clear metavari l rang countabl set locat assum variabl resourc locat mutual disjoint bind scope convent variabl resourc would expect syntact form usual identifi piec syntax differ choic bound variabl resourc name term express resourcefre contain free resourc variablefre contain free variabl close term express resourcefre variablefre otherwis open type mfl includ 1 unit int product sum recurs data type ut memoiz function type bang type h mfl distinguish index type denot h accept inject function call index function whose codomain integ underli type bang type h restrict index type int type ident serv index constant function chosen index function nonprimit type index suppli box valu type box valu would alloc ix type type mcase mfun f at1t2 iseend j figur 5 abstract syntax mfl store uniqu locat box would serv index underli valu extens index type would dene although support box type critic practic purpos formal focu main idea syntax structur term express terminolog pfen davi 30 roughli speak term evalu independ context ordinari function program ming wherea express evalu rel memo tabl thu bodi memoiz function express wherea function term note howev applic function term express correspond encapsul memoiz function updat memo tabl benign complet languag would includ case analysi project form among term sake simplic includ express would also includ plain function bodi term note everi term trivial express return express inclus 42 static semant type structur mfl extend framework pfen davi 30 necessit modal h use track data depend select memoiz modal correspond monad interpret memoiz effect notat pfen davi though one could imagin ad modal languag introductori eliminatori form necess standard name introduct letxhbet ineend elimin modal demand distinguish variabl sourc variabl mfl correspond valid unr strict context modal logic wherea resourc mfl correspond truth restrict context analog may also made judgment present linear logic 29 31 variabl correspond intuitionist context resourc linear context1 1note howev impos linear constraint type system re pair g fun g funval appli bang inl inr unrol figur 6 type judgment term inclus returnt term express analogu pure modal logic specic interpret memoiz comput effect type rule returnt requir resourcefre ensur depend argument memoiz function made explicit code comput return valu function rst instanc resourc aris paramet memoiz function resourc introduc increment decomposit use let mcase addit resourc track usag asyetunexplor part data structur ultim complet valu resourc may access use let construct bind valu variabl may use without restrict practic mean part argument memoiz function whose valu function depend given modal type howev essenti resourc modal type comput depend upon everi resourc modal type static semant mfl consist set rule deriv type judgment form gd express judgment g variabl type assign nite function assign type variabl resourc type assign nite function assign type resourc rule deriv judgment given figur 6 7 return let case figur 7 type judgment express 43 dynam semant dynam semant mfl formal select memoiz evalu parameter store contain memo tabl track behavior function program evalu function express caus empti memo tabl alloc associ function applic memoiz function affect may affect associ memo tabl function valu becom inaccess also associ memo tabl henc storag requir reclaim unlik convent memoiz howev memo tabl key control ow inform rather valu argument memoiz function key support select memoiz express evalu essenti explor avail resourc culmin resourcefre term determin valu sinc explor datasensit certain aspect resourc may relev particular outcom exampl memoiz function may take pair integ argument outcom determin independ second compon case rst posit record controlow inform evalu may use provid select memoiz exampl situat describ pair form map result valu irrespect valu v convent memoiz memo tabl would key pair result redund comput perform case function previous call v even though valu v irrelev result framework instead key memo tabl branch record sufcient control ow inform captur gener case whenev encount return statement queri memo tabl current branch determin whether result comput return store valu evalu return statement associ valu branch memo tabl futur use crucial return term contain resourc assur valu chang across call function dynam semant mfl given set rule deriv judgment form st vs0 term slbe e vs0 express rule deriv judgment given figur 8 9 rule make use branch memo tabl store whose precis denit follow simpl branch list simpl event correspond choic point evalu express simpl event simpl branch eb write bbe stand extens b event e end memo tabl q nite function map simpl branch valu write qb v b 2 domq stand 7 extens q given bind b write qb mean b 2 domq store nite function map locat l memo tabl write sl q l 2 dom stand extens 7 given bind l l 2 dom write sl q store map l q l sl0term evalu larg standard except evalu memoiz function applic argument evalu memoiz function term alloc fresh memo ta ble associ function valu express evalu initi applic memoiz function argument function valu determin memo tabl use call evalu bodi perform rel tabl initi null branch express evalu perform rel current memo tabl branch return statement encount current memo tabl consult determin whether branch previous taken store valu turn otherwis argument term evalu store current memo tabl branch valu return let mcase express extend current branch reect control ow sinc let signal depend complet valu valu ad branch case analysi howev mere extend branch indic case taken let construct extend branch addit inform glean split pair 44 sound mfl prove sound mfl rel nonmemo semant languag straightforward give pure function semant pure fragment mfl induct denit relat v e e v e v pure sens may involv subscript function valu underli term mfl term obtain eras locat subscript function valu occur within sound mfl consist show evalu memoiz yield outcom evalu without memoiz theorem 2 sound 0t vs 00 full proof given 3 statement theorem must strengthen consider account term expr sion take account nonempti memoiz context proof proce induct evalu easi show nonmemo semant mfl type safe use complet convent techniqu follow unit number sn ns sn1tn vnsn pair l 2 dom se vs0 funval appli bang st vs0 inject sinlt1t2t inlt1t2 vs0 sinrt1t2t inrt1t2 vs0 unrol figur 8 evalu term memoiz semant also typesaf would close valu type canon type ever erasur preserv reect canon form henc sound theorem mfl must also type safe 45 perform show memoiz slow mfl program constant factor expect respect standard nonmemo semant even result reus result reli repres branch sequenc integ use sequenc key memo tabl implement hash tabl repres branch integ sequenc use properti mfl underli type h bang type h index ret found s0lbv1a1v2a2 e vs00 let slbleta1a2 bet ineend vs00 case figur 9 evalu express type sinc valu index type integ index repres branch depend sequenc integ correspond indic lete valu zero one inl inr consid nonmemo semant return rule alway evalu bodi neither look updat memo tabl store consid mfl program let denot time take number evalu step evalu program respect nonmemo semant let t0 denot time take evalu program respect mem oiz semant worst case result reus thu differ t0 due memot lookup updat done memoiz semant bound time consid memo tabl lookup updat branch b let jbj length branch sinc branch sequenc integ lookup updat perform expect ojbj time use nest hash tabl repres memo tabl note nonmemo semant take jbj time build branch thu cost lookup updat charg evalu build branch b ie evalu let mcase furthermor evalu let mcase charg exactli one return thu conclud expect case 5 implement describ implement framework standard ml librari aspect mfl languag reli syntact distinct resourc variabl enforc static standard ml therefor use separ type resourc employ runtim check detect violat correct usag signatur sig express type expr val return unit expr resourc type re val expos re bang type bang val bang int bang val letbang bang b expr b expr product type ab prod val pair b ab prod val letx ab prod re b re c expr c expr val split ab prod b c c sum type ab sum val inl ab sum val inr b ab sum val mcase ab sum re c expr b re c expr c expr val choos ab sum c b c c memoiz arrow type ab marrow val mfun re b expr ab marrow val mfun rec b marrow re b expr ab marrow val mappli ab marrow b signatur type box val init unitunit val box aa box val unbox boxa val getkey boxint figur 10 signatur memo librari box interfac librari shown figur 10 provid type express resourc bang product sum memoiz function along introduct elimin form express type expr monad return inclus variou form bind induc elimin form letbang letx mcase resourc type re expos elimin form resourc creat librari thu introduct form resourc avail user introduct elimin form bang type bang letbang introduct elimin form product type pair letx split respect letx form bind monad expr split elimin form term context treatment sum similar product type introduct form inl inr elimin form mcase choos mcase form bind expr monad choos elimin term context memoiz function introduc mfun mfun rec mfun take function type re b expr return memoiz function type ab marrow mfun rec similar mfun also take paramet memoiz version note result type contain effect exprw encapsul memoiz effect benign within function elimin form marrow memoiz appli function mappli functor buildmemo structur box box structur struct type list unit type re re expos val val h vbranch susp type val f re x1 re x2 datatyp ab sum inl inr b mcase f val case inr v 1g re v lrbranchsusp choos f case inl v f v inr v g v type fun mfun rec val val val case memopadextend mpad branch val vnone v found result similar mfun rec mappli f figur 11 implement memoiz librari figur 11 show implement librari without runtim check correct usag incorpor runtim check one need sophist denit resourc order detect resourc expos context ie function instanc addit interfac must updat rst paramet letbang letx mcase occur suspend form allow us updat state consist certain ag forc term structur struct type util fun ibang fibonacci letbang expos n fn n return fn els mappli f ibangn1 mappli f ibangn2 mappli mfun rec mfib n box list datatyp con blist box type blist blist box hash con letx expos x fn ht letbang expos h fn h letbang expos fn return fn box consht val hcon mfun hcon knapsack letx expos arg fn cl letbang expos c fn c letbang expos l fn l return fn case unbox l conswvt c w mappli mk pair ibang c bbang els let val ibang c bbang val mappli mk arg1 val ibang cw bbang val mappli mk arg2 v1 v2 v1 els v2 fun mk mappli mfun rec mk x quicksort val val hcon mfun hcon case unbox l consht f h mappli hcon pair ibang h bbang fil f els letbang expos l fn l return fn case unbox l consht let val val val mappli qs bbang val mappli qs bbang gg mfun rec qs figur 12 exampl section 3 sml librari implement extend oper semant mfl languag section 43 box bang primit take valu inject function call index function map valu integ call index index valu use key memo tabl restrict indic uniqu enabl us implement memo tabl nest hash tabl support updat lookup oper expect constant time primit letbang take valu b bang type bodi appli bodi underli valu b extend branch index b function letx take pair p bodi bind part pair two resourc appli bodi resourc oper semant letx extend branch function mcase take valu sum type bodi branch outer form bind inner valu resourc appli bodi resourc extend branch 0 1 depend outer form elimin form sum product term context split choos standard return primit naliz branch return bodi suspens branch use mfun rec mfun key memo tabl result found memo tabl suspens disregard result reus otherwis suspens forc result store memo tabl key branch mfun rec primit take recurs function f paramet memoiz f associ memo pad subtl issu f must call memoiz version recurs therefor f must take memoiz version paramet note also memoiz function intern convert paramet resourc appli f interfac librari provid introduct form sourc inde resourc creat librari insid letx mcase mfun rec mfun function expos elimin form resourc exampl one would like appli letbang resourc must rst expos sourc expos underli valu figur 12 show exampl section 3 written sml librari note memoiz fibonacci function mfib creat memo tabl everi time call mfib nish tabl garbag collect appli mk quicksort provid function mq return instanc memoiz quicksort appli instanc memo tabl note also mq creat local instanc hashcon function instanc memoiz quicksort memo tabl hashcons exampl use sum type provid librari repres box list need gener one use provid sum type instead ml counterpart exampl mcase need exampl figur 12 implement use follow denit box list datatyp roll unit boxlist box prod sum type boxlist boxlist box chang code figur 12 work denit box list requir sever straightforward modic 6 discuss space cach manag framework associ separ memo tabl memoiz function allow programm control lifespan memo tabl convent scope somewhat coars degre control sufcient certain applic dynam program ner level control may desir applic result reus less regular applic benet specifi cach scheme individu memo tabl determin size memo tabl replac polici discuss framework extend associ cach scheme memo tabl maintain memo tabl accordingli cach scheme speci form paramet mfun construct evalu construct bind cach scheme memo tabl memo tabl maintain accordingli chang oper semant accommod extens small store map label pair consist memo tabl cach scheme handl return chang store mere expand updat accord cach scheme ad new entri follow show updat return rule denot cach scheme q denot memo tabl updat function denot function updat memo tabl accommod new entri possibl purg exist entri programm must ensur cach scheme violat integr memo tabl tamper store valu found exampl specifi memo tabl fibonacci function shown figur 1 contain two entri manag use leastrecentlyus replac polici sufcient ensur memoiz fibonacci run linear time extens also incorpor type system describ section 4 would requir associ type memo store also requir develop type system safe updat function enforc cach scheme safe local vs nonloc depend depend track mechan captur local depend input result function local depend function f one creat insid static scope f nonloc depend f creat f pass input function g examin fs input indirectli previou work abadi et al 1 heydon et al 14 show program analysi techniqu track nonloc depend propag depend function caller howev make clear perform implic techniqu framework extend track nonloc depend introduc applic form memoiz function express context extens would exampl allow depend nonconst length chose support nonloc depend clear util exce perform effect memoiz adapt work present paper motiv previou work adapt comput 2 briey discuss relationship memoiz adapt combin obtain efcient dynam increment algorithm 5 6 adapt comput maintain dynam depend graph repres data control depend input modi chang propag algorithm updat output depend graph adapt mechan handl deep 7 chang efcient say chang deep affect call occur leav call tree comput contrast 8 chang shallow affect call occur root call tree exampl consid quicksort algorithm pick rst key input pivot insert new key end input list deep chang chang affect last 10 recurs call lter function becom pivot end sequenc recurs call quicksort contrast insert new key begin list shallow chang quicksort new key select pivot immedi rst call quicksort adapt mechan base dynam depend graph handl insert end input deep chang expect ologn 12 time 2 wherea insert begin list shallow chang caus complet rerun take onlogn time use memoiz howev insert begin list handl time show section 3 13 chang thought combin shallow deep chang sinc memoiz adapt complement handl deep shallow chang would expect combin two techniqu would handl gener 14 chang efcient exampl quicksort expect insert random posit list would handl expect time combin two techniqu 15 7 conclus 16 present framework select memoiz programm control framework make explicit perform effect memoiz yield program whose run time analyz use standard techniqu key aspect 17 framework captur control data depend input result memoiz function main contribut paper particular set primit 18 suggest semant along proof sound gave simpl implement framework standard 19 ml languag expect framework implement purelyfunct languag r analysi cach depend adapt function program select memo 23 izat design analysi comput algorithm anatomi lisp dynam program tabul techniqu recurs program acm comput survey elimin redund recurs call acm transact program languag system algorithm increment evalu attribut grammar applic syntax direct confer record 8th annual acm symposium page 105 increment reduct page 307 hash lemma time complex applic formula manipul cach function call use acm sigplan notic elimin recurs call use small tabl randomli select function valu alphons increment comput program lazi memofunct confer implement dynam program via static static cach increment comput languag system formal system memo function machin learn autom program speedup decid cach wizard tilt ef cient techniqu automat memoiz applic contextfre pars gener increment attribut evalu use cach function constructor increment attribut evalua tion structur cut elimin judgment reconstruct modal logic natur deduct intuitionist noncommut linear logic increment comput via function cach improv replac strategi function cach increment comput via function cach exampl hierarch design proof increment compil via partial evalu autom deriv increment program tr elimin redund recurs call lazi memofunct improv replac strategi function cach increment comput via function cach specif transform program formal approach softwar develop introduct algorithm increment reduct lambda calculu alphons analysi cach depend autom deriv increment program static cach increment comput cach function call use precis depend tabul techniqu recurs program exampl hierarch design proof adapt function program anatomi lisp increment evalu attribut grammar applic syntaxdirect editor design analysi comput algorithm dynam program via static increment natur deduct intuitionist noncommun linear logic use cach function constructor increment attribut evalu structur cut elimin hash lemma time complex applic formula manipul dynam program ctr kedar swadi walid taha oleg kiselyov emir pasal monad approach avoid code duplic stage memoiz function proceed 2006 acm sigplan symposium partial evalu semanticsbas program manipul januari 0910 2006 charleston south carolina haiy xu christoph j f pickett clark verbrugg dynam puriti analysi java program proceed 7th acm sigplansigsoft workshop program analysi softwar tool engin p7582 june 1314 2007 san diego california usa kevin walsh emin gn sirer stage simul gener techniqu improv simul scale perform acm transact model comput simul tomac v14 n2 p170195 april 2004 geoffrey washburn stephani weirich box go banana encod higherord abstract syntax parametr polymorph acm sigplan notic v38 n9 p249262 septemb darko marinov robert ocallahan object equal profil acm sigplan notic v38 n11 novemb neil jone transform interpret specialis scienc comput program v52 n13 p307339 august 2004 weingan chin siaucheng khoo neil jone redund call elimin via tupl fundamenta informatica v69 n12 p137 januari 2006 umut acar guy e blelloch robert harper adapt function program acm transact program languag system topla v28 n6 p9901034 novemb 2006 umut acar guy e blelloch matthia blume kanat tangwongsan experiment analysi selfadjust comput acm sigplan notic v41 n6 june 2006 k v seshu kumar valu reus optim reus evalu math librari function call compil gener cach acm sigplan notic v38 n8 august