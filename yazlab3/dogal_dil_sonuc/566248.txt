decis tree approxim boolean function decis tree popular represent boolean function show given altern represent boolean function f say readonc branch program one find decis tree approxim f desir amount accuraci moreov size decis tree smallest decis tree repres f construct obtain quasipolynomi time also extend result case one access sourc random evalu boolean function f instead complet represent case show similar approxim obtain specifi amount confid oppos absolut certainti former case latter result impli proper paclearn decis tree uniform distribut without use membership queri b introduct decis tree popular represent boolean func tion form basic infer engin wellknown machin learn program c45 q86 q96 boolean decis tree also use problem perform reliabl comput presenc faulti compon kk94 medic diagnosi popular decis tree repres boolean function may attribut follow reason univers decis tree repres boolean function amen manipul mani use oper boolean function perform effici time polynomi size decis tree rep resent contrast oper intract popular represent tabl 1 give comparison decis tree dnf formula readonc branch program support nsf grant 9820840 advantag decis tree represent motiv follow problem given arbitrari represent boolean function f find equival represent f decis tree small size immedi evid problem bound hard state polynomi time solvabl problem would impli satisfi cnf formula decid polynomi time imposs unless pnp therefor consid slightli differ problem let us say g approxim f fraction assign g f differ evalu given arbitrari represent boolean function f find approxim f decis tree small size order fall trap interest solv problem effici reali tical may use time polynomi follow paramet 1 size given represent f 2 size smallest decis tree represent f given 3 invers desir error toler ie 1 approxim would use applic small amount error toler return gain would accru decis tree rep resent inde case applic machin learn data mine exampl one could postprocess hypothesi output learn program convert decis tree ensur much error introduc choos suitabl small note one may use knowledg special properti represent scheme hypothesi construct decis tree approxim note one may even construct decis tree approxim decis tree hypothesi would use conjunct program like c45 output decis tree make special effort ensur output tree provabl smallest desir error toler expens sacrif littl error one could achiev desir minim case tabl 1 complex oper differ represent scheme readonc branch decis tree program univers 2 represent polynomi time polynomi time polynomi time 2 represent polynomi time polynomi time polynomi time complement represent exponenti time polynomi time polynomi time decid satisfi polynomi time polynomi time polynomi time decid unsatisfi np complet b polynomi time polynomi time decid monoton conp complet b open polynomi time c decid equival conp complet b corp polynomi time e decid symmetri conp complet b polynomi time c polynomi time c decid relev conp complet b open polynomi time e variabl count number pcomplet f polynomi time c polynomi time c satisfi assign make represent np hard b corp polynomi time e irredund make represent np hard b open nphard g minimum truthtabl np hard h open polynomi time minim straightforward definit represent scheme easi reduct cnfsatisfi c prove paper result follow one bcw80 e folk theorem prove decis tree testabl equival polynomi time result follow f prove s75 prove zb98 h result masek cite garey johnson book gj79 prove glr99 first show case wellknown represent scheme small approxim decis tree obtain quasipolynomi time polynomi factor first paramet list multipli factor involv expon logarithm second third paramet scheme 1 decis tree 2 order binari decis diagram 3 readonc branch program 4 olog nheight branch program 5 satj dnf formula constant j 6 boolean formula third item gener first two result first two follow third quasipolynomi time algorithm actual hold gener class roughli speak represent scheme number satisfi assign input function small project comput efficientlya properti call satcount paperwould come techniqu employ inde present algorithm gener way argu requir properti hold scheme worth emphas although time taken algorithm quasipolynomi size decis tree approxim fact output decis tree smallest size decis tree height level approxim sens optim certainli size larger smallest decis tree repres boolean function approxim also consid situat evalu boolean function f avail given sampl evalu show previou algorithm modifi slightli give quasipolynomi time algorithm produc small approxim decis tree sampl decis tree may disagre f evalu jsj assign given argu latter result impli proper quasipolynomi time paclearn decis tree uniform distribut inform learn result may interpret 8a follow compar absolut certainti approxim first result learn result say given access sourc random evalu f instead complet represent f output algorithm approxim decis tree much confid desir absolut certainti may way obtain decis tree approxim represent scheme like dnf formula count number satisfi assign pcomplet gj79 novel featur learn algorithm occam algorithm behw87 unlik one known learn theori algorithm may actual make error even train sampl use consequ analysi sampl complex gener one normal use may independ interest learn result compar similar one learn theori bshouti monoton theori base algorithm b95 deploy learn decis tree arbitrari fix distribut polynomi time follow drawback comparison algo rithm algorithm use membership queri output decis tree depth3 formula similarli bshouti mansour algorithm bm95 output decis tree ehrenfeucht haussler eh89 show decis tree rank r learnabl time n distribu tion rank decis tree height largest complet binari tree embed sinc decis tree node rank log first glanc result would seem improv learn result paper sinc one could learn node decis tree quasipolynomi time distribut differ learn node decis tree n variabl algorithm would alway produc decis tree size larger use sampl size polynomi invers error confid paramet contrast algorithm ehrenfeucht haussler may output tree size n olog use sampl size quasipolynomi n polynomi invers error confid paramet rest paper organ follow section 2 contain definit lemma use remain sec tion section 3 algorithm find approx imat decis tree given satcount represent section 4 contain result approxim decis tree given sourc random evalu boolean function conclud open problem section 5 preliminari let f boolean function set n variabl total assign obtain set n variabl either 0 1 assign may repres nbit vector f0 1g n natur way satisfi assign f one 1 number satisfi assign f denot f partial assign obtain subset variabl v assign valu partial assign may repres vector length n whose element either 0 1 vector element correspond variabl assign valu thu total number partial assign 3 n number partial assign k variabl assign valu n size partial vector denot jj number element assign 0 1 empti partial vector denot one variabl assign project f partial assign denot f function obtain hardwir valu variabl includ precis given total assign partial assign let denot total assign obtain set variabl whose valu valu variabl whose valu valu f defin interest projectionclos represent class boolean function ie one given represent boolean function f partial vector boolean function f also repres class moreov represent comput polynomi time say projectionclos represent class polynomialtim satcount given represent f valu f comput time polynomi size represent n total number variabl represent function f use jdj denot size context assur ambigu treat represent synonym boolean function repres error errf f 0 f respect anoth boolean function f 0 defin set n variabl total number assign f 6 f 0 moreov f approxim f 0 consid follow projectionclos represent class boolean function paper 1 decis tree decis tree binari tree leav label either 0 1 intern node label variabl given assign evalu start root iter appli follow rule leaf reach let variabl current node x valu posit 1 branch right otherwis branch left leaf reach label 0 resp 1 1 size decis tree number node 2 branch program bp branch program direct acycl graph uniqu node indegre call root two node outdegre 0 call leav one label 0 label 1 nonleaf node graph contain variabl outdegre exactli two everi variabl appear rootleaf path branch program call readonc robp note decis tree effect consid robp assig evalu follow rule decis tree height bp length longest path root leaf node order binari decis diagram obdd robp addit properti variabl appear order path root leaf 3 satj dnf formula dnf formula everi assign satisfi j term formula 4 formula boolean formula everi variabl occur proposit 1 decis tree obdd robp bp sat j dnf formula formula projectionclos proof bp project partial vector comput follow redirect incom edg vertex label variabl assign valu left respect right child vertex variabl assign valu 0 respect 1 recurs delet vertic incom edg use depthfirst search step achiev linear time note bp decis tree obdd robp h height bp project also belong class sat jdnf formula project obtain substitut valu assign variabl 0 dnf term result delet term wherea 1 result delet variabl term formula appropri boolean algebra rule appli elimin 1s 0s obtain accomplish linear time case proposit 2 robp olog nheight bp satcount abl proof number satisfi assign robp f comput follow travers node f revers topolog order let fx denot subrobp root node x consist vertic reach x edg join node x visit fraction x 0 x 1 assign fx satisfi assign comput follow x leaf x 0 1 valu leaf node otherwis x intern node x yz z left right children x simpl induct argument show complet r r root robp fraction satisfi assign f consequ n number variabl f next let b olog n height bp repres boolean function f first construct decis tree equival f spread b creat separ copi node whenev need rather share subfunct branch program decis tree may immedi satisfi readonc properti easili convert one elimin subtre duplic variabl along path total number node result decis tree 2 olog final comput number satisfi assign decis tree describ robp next two proposit use paper prove simpli order complet tabl 1 proposit 3 decis tree test monoton polynomi time proof let given decis tree n variabl conveni extend partial order defin boolean lattic set partial vector impli 6 0 partial vector say everi total vector leaf node x determin partial vector px base assign variabl path root leaf node let us say x counterexampl monoton partial vector px x valu 1 essenti observ monoton leaf counterexampl monoton easi test monoton use observ leaf node x assign valu 1 let partial vector obtain set 1 variabl px assign 1 leav remain variabl project p 0 x ident 1 x counterexampl monoton demonstr path 0 project boolean function fv permut v 0 proposit 4 robp test symmetri polynomi time proof proof inspir central idea bcw80 let f boolean function set variabl denot set assign f evalu 1 first gener f realvalu function treat v set real variabl precis redefin f variabl v assum valu 0 1 valu redefinit coincid valu boolean true gener shown bcw80 given robp represent boolean function f valu real function real vector v comput linear time visit robp topolog order next let tabl 2 system linear equat calcul jr k jb set assign f precis k one x comput valu g0 mention use robp represent f treat jr k j variabl lead system linear equat tabl 2 easili shown rank coeffici matrix therefor system admit uniqu solut final observ boolean function f symmetr jr k j either 0 n valu k 0 k n proof follow decid symmetri obdd decis tree also polynomi time proposit 5 sat jdnf formula satcount proof let us say two term 0 conflict contain liter l 0 contain liter l consensu two nonconflict term 0 denot tt 0 term obtain union liter 0 conflict consensu 0 definit satj dnf formula f impli everi set term formula must least two conflict term therefor use principl inclus exclus term k liter simpli 2 n k comment sum need consid consensu j term f constant j total time comput polynomi proposit 6 formula satcount proof let f formula set n variabl f constant 1 f constant 0 term contain singl liter written either f 1 f 2 formula disjoint set n 1 n 2 variabl respect easi argu recurs applic rule ensur f comput 3 find decis tree approxim main result section algorithm construct decis tree approxim boolean function f repres projectionclos satcount class heart algorithm procedur find gener dynam program method use glr99 truthtabl minim decis tree find work follow given f boolean function n variabl height paramet h size paramet build precis one tree set k partial vector size h eac h k 0 k k set decis tree represent function f size k height h jj minimum error respect f among tree minimum size desir approxim therefor tree construct set w 1g algorithm employ twodimension array p k hold tree k tree p array repres tripl form root left subtre right sub tree unless contain singl leaf node case repres leaf valu partial vector notat v 1 v 0 respect denot partial vector obtain extend set variabl v 1 0 respect lemma 7 algorithm find correct ie given satcount abl represent boolean function f height paramet h size paramet find output decis tree 0 height h size among decis tree errt 0 f minimum one decis tree minimum error minimum size among tree proof show induct l p k tree k 0 jj h 01 foreach jj h 02 f 03 els p 0 0 04 05 0 06 foreach 07 foreach 08 p 09 foreach variabl v use k 11 errp k f errv 12 13 els errp k f 14 jp v 0 k 15 figur 1 algorithm find mg tree must leaf valu 0 1 depend valu yield minimum error rel f line 2 3 algorithm find examin hypercub correspond f determin whether major assign 0 1 also true l l assum p k 0 correctli comput l l k 0 0 minf2 hjj also assum p k 0 correctli comput k 0 0 k 1 show find caus tree k place p k size tree k less k induct hypoth si p k initi tree k line 8 line 915 modifi p k algorithm cor rect therefor let size tree k exactli k let opt tree k let v root v must variabl assign valu let size opt left right subtre k 0 respect observ k 0 k 1 one examin line 9 let let 1 induct hypoth errright subtre opt f1 sinc error tree sum error two subtre algorithm find tree p k error opt size opt lemma follow lemma 8 let pjf j n denot time complex comput number satisfi assign arbitrari project given satcount function f time complex find oh proof sinc f satcount represent time requir line 2 opjf j nn number partial vector examin line 1 h line 14 take opjf j nn oh time line 5 6 caus oh partial vector examin variabl line 7 take valu n possibl v possibl combin k 0 k 00 line 9 complex line 1015 domin o1 error comput decis tree p satcount function f error comput implement follow leaf node x partial vector correspond evalu path lead x contribut total error partial vector either f leaf x valu 0 2 njjjj f valu 1 total error errt obtain sum error comput fashion leaf complex comput bound opjf j nm line 515 henc algorithm find bound oh 3 pjf j n common dynam program algorithm memoiz help reduc overal complex observ complex error comput reduc maintain second twodimension array e whose element contain error correspond element array p first e 0 comput opjf j n time line 2 3 remain e ks comput everi time p k updat o1 time simpli sum error left right subtre p k timesav modif time complex becom opjf lemma 9 let mnode decis tree exist decis tree height node approxim proof restrict height h convert node x level h either 0 1 depend whether 0s 1s respect hypercub defin path lead x call tree clearli node error confin hypercub convert node x level h origin tree sinc dm2e node error node 2 n h 1 follow approxim substitut 4 yield desir result theorem 10 given satcount boolean function represent f whose smallest decis tree represent node error paramet find decis tree 0 node approxim f time polynomi jf j n log proof given f use standard doubl trick determin olog iter algorithm least valu findf logm return decis tree approxim f lemma 9 size smallest decis tree repres f correct time complex follow lemma 7 8 respect 4 learn decis tree uniform distribut show algorithm previou section extend learn decis tree uniform distribut remark introduct mean given access uniformli distribut sampl evalu boolean function f error paramet confid paramet algorithm output decis tree node least number node need repres f decis tree approxim f confid least 1 algorithm take time polynomi n logm log1 ie quasipolynomi time algorithm howev sampl complex algorithm modest polynomi paramet log n log1 log1 use follow addit terminolog prove result section let mhn denot class decis tree n variabl height h size decis tree let h tree height h obtain convert nonleaf node depth h leaf node classif 0 1 depend whether major assign correspond hypercub f classifi 0 1 respect recal two boolean function f 1 f 2 n denot number assign f 1 6 f 2 extens sampl classifi exampl form h bi assign number exampl form h bi f 6 b need follow wellknown inequ proposit 11 chernoff bound let outcom r ident independ bernoulli trial prob x pr 0 probr p given sampl classifi exampl boolean function form h bi assign b 2 f0 1g height paramet h size paramet decis tree height h size comput among decis tree errd minimum among minimum error tree minimum size comput requir oh proof let denot assign extend partial assign given comput ojsjn time modifi condit line 2 algorithm find number assign whose valu 1 0 compar modifi line 2 take ojsjn time refer f line 10 11 13 replac error comput carri describ proof lemma 8 error comput take ojsjm time sinc rest algorithm unchang complex obtain replac pjf j n jsj note also true modifi algorithm propos proof lemma 8 correct follow lemma 7 theorem 13 given uniformli distribut sampl size exampl mnode decis tree n variabl error paramet 0 1 confid paramet 0 1 find decis tree mhn time orm 2 n oh confid least 1 error approxim ie proof execut algorithm find modifi deal sampl describ lemma 12 paramet h let call decis tree 0 mhn bad errt fix bad decis tree 0 output mhn least error sampl 2here last inequ follow chernoff bound appli number error tree 0 probabl p find output bad tree 0 mhn certainli jt mhn j 2e r 2 8 number binari tree node 2 4 number decis tree node also upper bound mhn con sequent choic r proposit littl bit arithmet probabl p turn conclus given satcount represent boolean function uniformli distribut sampl evalu boolean function paper present quasipolynomi algorithm comput decis tree smallest size approxim function possibl achiev polynomi time fail possibl obtain decis tree whose size within polynomi factor smallest approxim decis tree polynomi time find decis tree smallest size equival given one nphard zb98 open question whether least polynomi approxim smallest equival decis tree possibl polynomi time idea paper seem enough answer que tion hope combin idea result ehrenfeucht haussler eh89 work matter fact result alreadi use give quasipolynomi approxim smallest decis tree equival projectionclos represent allow test tautolog satisfi polynomi time quasipolynomi time done follow way consid sampl ehrenfeucht haussler algorithm 2 n assign howev avoid use time polynomi sampl size note oper sampl algorithm consist 1 check assign evalu either 0 1 2 comput new sampl 0 obtain project given variabl 0 1 oper time polynomi given represent convert algorithm one whose complex ad factor form r smallest rank equival decis tree sinc r exceed olog size smallest equival decis tree get desir quasipolynomi approxim final idea paper combin ehrenfeucht haussler properli learn decis tree arbitrari distribut without membership queri 6 acknowledg thank anonym refere suggest sharper bound mhn led improv sampl complex theorem 13 r occam razor equival free boolean graph decid probabilist polynomi time exact learn boolean function via monoton theori simpl learn algorithm decis tree multivari polynomi learn decis tree random exampl comput intract exact learn irrelev variabl abound construct optim binari decis tree npcomplet boolean decis tree faulti node induct decis tree learn decis tree classi fier central problem comput complex find small equival decis tree hard tr occam razor learn decis tree random exampl need learn exact learn boolean function via monoton theori learn decis tree classifi partial occam razor applic exact learn irrelev variabl abound comput intract induct decis tree simpl learn algorithm decis tree multivari polynomi central problem comput complex