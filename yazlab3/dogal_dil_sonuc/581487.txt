demanddriven adapt type analysi compil dynam static type languag ensur safe execut verifi oper perform appropri valu oper simpl car scheme hd sml includ run time check unless compil prove argument alway nonempti list use type analysi present demanddriven type analysi adapt precis analysi variou part program compil approach advantag analysi effort spent justifi possibl remov run time check ad precis need accur analyz complex part program like kcfa approach base abstract interpret analyz import program accur kcfa valu k built prototyp type analysi test variou program higher order function remov run time type check nontrivi program use map combin b introduct optim compil typic consist two compon program analyz program transform goal ana permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee icfp02 octob 46 2002 pittsburgh pennsylvania usa let f lambda b con 1 car 2 b lambda c c let j lambda 3 car 4 f f con 5 5 con 6 6 figur 1 scheme program analysi lyzer determin variou attribut program transform decid optim possibl worth avoid miss optim opportun analyz typic comput larg set attribut predetermin level detail wast time transform use small subset attribut attribut detail requir moreov transform may requir level detail attribut higher determin analyz consid compil scheme optim call car remov run time type check argument known pair compil could use 0cfa analysi 8 9 comput everi variabl program conserv set alloc point program creat valu pair function number etc bound instanc variabl program fragment shown figur 1 0cfa analysi comput pair creat con 1 con 5 bound instanc variabl consequ transform safe remov run time type check call car 2 note 0cfa analysi wast time comput properti variabl b need transform call car b fs bodi would take complex 1 cfa analysi discov pair creat con 6 con 8 bound instanc variabl b 0cfa exclud empti list bound b empti list bound c return function 1cfa analysi achiev higher precis use abstract execut model partit instanc particular variabl basi call site creat instanc consequ distinguish instanc variabl c creat call 7 con creat call 9 allow narrow type return 7 con pair two call replac call j 2cfa analysi would need fulli remov type check call car use abstract execut model keep track call chain length 2 2cfa analysi distinguish instanc variabl c creat call chain 7 j con call chain 9 j 3 compil implement user face difficult task find program x l x var l lab l l x e 1 l e con l e 1 car l e 1 cdr l e 1 pair l e 1 figur 2 syntax sourc languag accept tradeoff extent optim valu k compil time analysi approach present paper demanddriven type analysi adapt analysi sourc program work perform analyz driven need determin run time type check safe remov demanddriven analyz avoid perform useless analysi work perform deeper analysi specif part program may result remov run time type check achiev chang abstract execut model dynam increas precis appear benefici like kcfa analysi base abstract interpret explain section 4 model use lexic contour instead call chain import program analyz approach accur analyz kcfa valu k see section 6 particular program higher order function includ use map combin analyz precis demanddriven analysi place priori limit precis analysi advantag analysi effort vari accord complex sourc program differ part program hand analysi may termin program difficult imposs prove particular type check remov take pragmat point view user decid maxim optim effort limit time resourc compil expend type check could remov within time simpli kept gener code think better give user choic optim level k use kcfa direct link compil time although motiv effici compil scheme analysi also applic languag sml haskel remov run time patternmatch check inde previou exampl translat directli static type languag run time type check call hd brief descript sourc languag explain ana lyzer abstract execut model process demand experiment result obtain prototyp analyz present sourc languag analysi pure function languag similar scheme three data type fals valu pair one argument function express uniqu label allow easi identif sourc program syntax given figur 2 boolean pair env var val evalu function lv lv lv lv appli function figur 3 semant sourc languag builtin letrec special form combin must written explicitli defin recurs function note also con car cdr pair treat special form semant languag given figur 3 notabl departur scheme semant pair return argument pair oper may requir run time type check car cdr argument must pair function call function posit must function 3 analysi framework abl modifi abstract evalu model analysi program use analysi framework framework parameter analysi gener enough use type anal ysi well varieti program analys specif abstract evalu model fed framework analysi instanc obtain use analyz program analysi instanc compos set evalu constraint produc framework paramet program constraint repres abstract interpret pro gram analysi program amount solv set constraint solut analysi result program framework paramet also produc safeti constraint indic program point run time type check may need confront analysi result safeti constraint redund type check identifi safeti constraint satisfi type check remov optim detail descript analysi 1 oper disjoint union ie set combin must disjoint abstract boolean al c abstract closur al p abstract pair cont contour al c abstract closur creation abstract pair creation al c v al cont cont contour select subject v al c ont figur 4 instanti paramet analysi framework valu e l k lk v al l lab k cont content x k return valu c bodi k flag indic evalu e l k creation circumst c creation circumst p circumst lead k figur 5 matric contain result analysi framework implement given 4 give overview framework 31 framework paramet figur 4 present framework paramet specifi abstract evalu model interfac simpl flexibl four abstract domain main contour three abstract evalu function provid framework al p abstract domain boolean closur pair must nonempti mutual disjoint al union three domain cont abstract domain contour contour abstract version evalu context express program get concret evalu ate part evalu context abstractli model contour may lexic environ continu combin main contour k 0 indic abstract contour main express program evalu abstract evalu function cc pc call specifi closur creation pair creation contour select function call occur cclk return abstract closur creat lexpress e l evalu contour k pclv 1 v 2 return abstract pair creat consexpress label l evalu contour k argument v 1 v 2 final calll cvk indic contour bodi closur c evalu c call callexpress e l contour k argument v group model paramet satisfi constraint given figur 4 valid abstract evalu model framework mpatf l l l k p l lab k mkpat pp mpat spat l l l k p l lab k skpat skpat figur 6 syntax pattern 32 analysi result analysi result return seven abstract matric shown figur 5 matric b g indic respect valu express valu variabl return valu closur valu b xk defin follow assum closur c creat lexpress l l x e l c call call function prescrib contour k evalu cs bodi paramet x bound abstract valu b xk lk indic whether express e l evalu contour k e l evalu contour k lk 0 appar lk defin boolean instead set howev use set make implement analysi framework simpler see 4 matric c p k log keep circumst prevail differ closur pair contour respect creat exampl abstract interpret program pair p creat express e l valu v 1 v 2 contour k creation p log p p time circumst log log variabl much fewer theoret word p p usual contain fewer valu pc similarli closur creat evalu e l k l insert c c contour select contour bodi f evalu f get invok v e l k l f v insert k k patternbas model demanddriven type analysi use pattern pattern matcher implement abstract evalu model pattern constitut abstract valu v al abstract contour cont abstract valu shallow version concret valu abstract contour shallow version lexic environ lexic contour one featur distinguish analysi type controlflow analys typic use call chain call chain string label k nearest enclos dynam call although use call chain guarante polynomialtim analys also fool easili believ lexic contour provid much robust way abstract concret evalu context figur 6 give syntax pattern two kind pat tern model pattern mpat mkpat split pattern spat skpat model pattern split pattern valu variant mpat spat contour variant mkpat skpat split pattern contain singl split point design use demand drive analysi split demand precis model pattern contain split point form represent abstract valu contour f f r l r valid label l 2 r valid label l x innermost variabl domr figur 7 formal definit relat abstract 41 mean pattern model pattern repres abstract valu turn seen set concret valu pattern abstract valu pattern f abstract boolean valu f pattern l abstract clo sure pattern l l k abstract closur come lexpress label l definit environ abstract k mkpat pattern p 1 abstract pair whose compon abstract p 1 p 2 respect differ abstract valu concret valu abstract valu made imprecis part cut use l model contour pattern appear model pattern clo sure simplifi use term contour mean model contour pattern contour abstract lexic environ contour list abstract valu variabl visibl certain label innermost variabl outermost exampl contour l indic innermost variabl say closur say x pair could abstract follow concret environ 5 formal definit concret valu abstract abstract valu given figur 7 relat val mpat relat concret abstract valu v p mean v abstract p mention without proof concret valu obtain execut program abstract model pattern perfectli accur latter abstract one concret valu former split pattern split contour pattern use express split demand increas precis abstract evalu model structur similar model pattern includ one one split point indic exactli abstract valu improv precis model request util made clearer section 5 oper split pattern explain next 2 r valid label l domain exactli set variabl visibl e l denot domain function f 4 denot undefin valu consequ r x environ r without bind x 5 empti concret environ contain bind l l l l p 1 p n l l p l l p figur 8 algorithm comput intersect two pattern 42 pattern intersect although relat provid formal definit concret valu abstract abstract valu extens abstract valu abstract anoth necessarili express algorithm moreov demanddriven analysi manipul concret valu pattern kind present method test whether abstract valu abstract anoth gener want abl test whether model split pattern intersect anoth similarli kind contour pattern intersect pattern defin figur 8 partial defin two pattern may incompat sens intersect empti intersect repres use pattern intersect two split pattern may creat someth two split point equat figur seen case tri order first last possibl case appli pattern p intersect anoth pattern p intersect function defin appli p p moreov p intersect p result intersect character 6 43 spread split pattern anoth relat need perform demanddriven analysi spread test use determin given split pattern increas precis model use split demand spread occur set abstract valu model pattern split pattern split pattern thought denot subdivis set abstract concret valu partit number set correspond differ possibl seen split point set call bucket exampl pattern abstract valu val subdivid val three bucket valb valc valp spread occur set abstract valu v split 6 provid consid l abstract concret valu concret closur respect f sf 0 l l 1 p 2 p figur 9 algorithm relat spread pattern p two valu refin valu v abstract p fall differ bucket say v spread split pattern p denot v p figur 9 give formal definit oper case tri order mathemat relat follow mean set abstract valu spread split pattern p denot p model pattern obtain replac p f l respect 44 model implement abstract valu view concret valu gone project similarli contour view lexic environ gone project one arrang imag project finit one obtain desir abstract domain al p cont project use relat much help sinc gener concret valu v may one abstract valu v v v project base would illdefin project use base exhaust nonredund patternmatch patternmatch implement project valu finit set model pattern concret valu v exist one one model pattern v set v v patternmatch describ finit partit val exampl simplest project valu 7 f l finit exhaust nonredund 7 exactli true simplest patternmatch would trivial one would implement legal model framework sinc abstract model must least distinguish boolean closur pair project contour use one patternmatch per l express given lexpress e l lexic environ bodi evalu project patternmatch l empti lexic environ alway project onto list length 0 empti list contour abstract empti environ simplest contour patternmatch l express l l x e l singl list mani entri visibl variabl environ e l evalu patternmatch v project valu famili patternmatch project lexic environ assum v project closur come differ l express differ abstract closur easi creat abstract model ie defin paramet analysi framework follow al b f al c l l k v al p v 1 cont k 0 cclk project l l k v project v 1 calll l l w 1 w n v project v w 1 w n l 45 maintain model consist one remain problem requir special attent consi tenci demanddriven analysi patternmatch use project concret valu abstract valu one abstract valu precis enough project oper may becom illdefin gener abstract valu abstract set concret valu suppos 1 imprecis abstract valu 2 model pattern contain 1 subpattern want project order obtain result abstract valu sensibl definit project consist choos model pattern w patternmatch concret valu abstract abstract w unfortun w may exist may take union mani model pattern properli abstract concret valu abstract exampl help clarifi notion follow patternmatch intend project valu inconsist f f f l l l note patternmatch finit exhaust nonredund nevertheless inconsist explain let us see model valu first distinguish valu toplevel type second distinguish pair type valu cdrfield final pair contain sub pair cdrfield distinguish type valu carfield subpair note carfield sub pair precis describ carfield pair inconsist problem occur tri make pair anoth pair cdrfield let us tri make pm pm pm c pm l pm onod v al onod l 1 l n l lexpr pm l leaf mpat leaf mkpat figur 10 implement patternmatch project p mpat pm project p 1 p n mkpat pm queue mpatmpatmkpat pmonod v al 1 pq pmonod pmonod v al c 2 pq pmonod pmcnode lab 1 pq pmcnode l l l figur 11 patternmatch algorithm pair valu f f obtain model pattern project use clear nonambigu choos one model pattern abstract valu abstract v order avoid inconsist time entiti refin one patternmatch must ensur abstract valu contour refin entiti depend suffici precis cascad refin propag depend entiti cascad termin sinc propag depth extra detail requir decreas 46 patternmatch implement implement patternmatch quit simpl patternmatch basic decis tree breadthfirst inspect model pattern model contour pattern project intern node decis tree either onod object cnode closur leaf contain abstract valu contour result project onod either threeway switch depend type object inspect oneway catchal ignor object continu singl child cnode either multiway switch depend label closur inspect oneway catchal ignor closur continu singl child figur present data structur use implement patternmatch demand show b avarb bound split p splitteep spat show badcal l avarb bvarc gvar avar lk l labk mkpat gvar g ck c mpatk mkpat dvar lk l labk mkpat figur 12 syntax demand patternmatch algorithm present figur 11 breadthfirst travers done use queue content queue alway remain synchron posit decis tree cnode reach closur next queue leaf reach queue empti initi queue abstract valu project contain abstract valu initi queue contour project contain abstract valu contain contour first abstract valu contour first extract queue keep notat ters use view oper enqueu dequeu valu enqueu queue left dequeu queue right empti queue denot patternmatch use initi abstract model fol low note describ term set theori term actual data structur valu patternmatch contain one abstract boolean one abstract pair one abstract closur lexpress lexpress correspond contour patternmatch trivial one note consist patternmatch almost blind de tail inspect perform switch label project closur howev project closur alway involv closur explicit label sinc occur use abstract model function cc give detail descript process refin patternmatch would lengthi conceptu difficult 5 demand process figur 12 present syntax demand syntax demand build syntax pattern show de mand split demand bad call demand 51 mean demand show demand ask demonstr certain properti exampl might ask demonstr particular abstract variabl must contain pair mean certain ex pression certain evalu context must evalu pair might ask demonstr particular abstract variabl must empti mean certain express certain evalu context must get evalu note bound al rue repres valu act true condit al p bad call demand ask demonstr particular function call happen specifi contour bad call current happen function call valu pass argument cours except label paramet demand abstract split demand ask proper modif done model way splitte longer spread pattern take demand exampl split lk ask abstract valu contain lk distinguish type pattern variabl lk current contain abstract valu differ type valu said spread pattern model ought modifi way contour k subdivid number subcontour lk contain abstract valu singl case success one might observ lk 1 contain pair lk 2 closur lk 3 noth lk 4 f etc valu express e l contour k would split accord type split demand splitte aspect abstract model v al c v al p abstract variabl one b g matric splitte bvar denot ordinari entri b matrix indic name sourc variabl also give label contour variabl referenc bound valu intersect pattern concern split exampl demand split lk ff ff l thing matter two abstract pair must separ happen boolean import intersect pattern normal show demand emit analysi determin specifi properti fals type error plausibl happen real program similarli bad call demand unfortun split demand natur interpret pure artifici creation necessari demanddriven analysi perform task moreov concret evalu program express particular evalu context evalu exactli one valu split concret evalu meaningless 52 demanddriven analysi algorithm main algorithm demanddriven analysi rel sim ple sketch figur 13 basic analysismodel updat cycl analysi phase analys program use framework parameter current abstract model modelupd phase comput possibl modelupd demand base current analysi result appli model note success updat abstract model make increasingli refin analysi result help produc improv monoton consequ run time type check prove redund point remain rest cycl step perform modelupd phase initi demand gather demand process demand modifi model call monitor occur new demand gener modelupd demand best one select appli model model modifi demand split demand splitte al c v al p member bvar creat initi model analyz program model time left set demand pool initi demand make set modifi demand empti repeat monitor call site l k mark time left new demand pool pick new demand pool modifi demand insert modifi demand set els process add return demand pool time left call site monitor modifi demand set empti exit els pick best modifi demand modifi model reanalyz program new model figur 13 main demanddriven analysi algorithm initi demand obtain respond need optim demand process nonclosur may call nonpair may go strictli pairwis oper bound demand ask demonstr violat realli occur gener precis call l e e l k cont l k v al c initi demand show l k v al c gener pairaccess express car l e l cdr l e l k cont l k al p initi demand show l k v al p gener criterion use select good modelupd demand implement describ section 6 analysismodelupd cycl continu time left model updat propos model updat phase inde user compil includ demanddriven analysi determin bound comput effort invest analysi program time necessarili wall clock time may measur implement unit time allow algorithm process demand two reason may caus algorithm stop lack modelupd demand one initi de mand mean run time type check program shown redund remain initi demand current analysi result mix way demand process lead gener modelupd demand 53 demand process 531 show demand us present process demand begin process show avarbound demand let us consid demand show lk b 3 case first case valu lk lie insid bound b demand trivial success noth done order obtain desir demonstr lk b second case valu lk lie outsid bound b must shown express e l get evalu abstract contour k suffici necessari condit e l evalu contour k valu return outsid bound caus origin demand fail e l get evalu contour k conclud valu lk lie insid bound lk 0 show last case valu lk lie insid b sensibl thing first split contour k subcontour way becom clear whether valu lie insid b lie outsid b sinc bound simpl split type object suffici would better say split demand success origin demand process otherwis split lk 532 show empti demand continu process show demand let us consid demand show mani case process first variabl lk alreadi empti demand trivial success 0 otherwis fact e l get evalu contour k depend lot parent express one parent express mean e l main express program consequ possibl prove e l get evalu contour k 8 e l main express case e l parent express let e l express let us consid case e l lexpress impli e l bodi e note evalu e l contour k direct connect evalu e l contour k fact e l get evalu contour k closur c result evalu e l contour get call somewher express e l contour k certain argument v way result contour calll cvk bodi c must evalu k process demand consist emit bad call demand abstract call note log matric k c use recov circumst contour closur creat 8 fact littl complic suppos abstract variabl contain minim solut evalu constraint gener analysi framework condit l label program main expr sion lk nonempti k main abstract contour contour k lk e l let us consid case e l condit condit three subexpress first consid case e l thenbranch e l clearli suffici show e l evalu contour k howev requir abus suffici necessari condit thenbranch evalu evalu test return return resp true valu e l show l k case e l elsebranch condit analog elsebranch get evalu test alway return true valu e l show l k v al rue case e l test condit treat default case default case concern situat explicitli treat default case prove e l get evalu contour k requir demonstr e l get evalu contour k either obviou sinc evalu call con car cdr pair express necessarili involv evalu subexpress similarli test subexpress condit otherwis show l next describ bad call demand process let us consid demand badcal l f v k express e l necessarili call let e two case either specifi call occur call occur demand trivial success 9 case specifi call note bad call log anoth note kept order later take care bad call e l contour k call oper monitor e contour k one bad call may concern express contour monitor crucial oper access bad call inform accur possibl prefer postpon monitor much possibl otherwis bad call log flag l k candid monitor 9 actual current implement case occur demand gener precis specifi call found k matrix howev previou implement differ way demand gener bad call demand could emit later prove trivial success 534 split demand direct model split let us present process split demand process differ consider depend splitte start describ process follow demand split v al c p split v al p p easi process explicitli prescrib modif abstract model modif alway accomplish success updat v p avari involv part demand process process split avarspat demand demand ask split valu express certain contour spread valu specifi pattern let us consid demand split lk p first possibl actual spread demand trivial success howev spread express e spect natur comput differ express vari greatli let us examin kind express one one first consid fals constant note express evalu f valu spread p matter split pattern p complet mention process demand nevertheless second e l may variabl refer process demand straightforward translat split demand onto bvar third e l may call clearli case difficult deal way call express abstractli evalu potenti mani closur present caller posit mani valu present argument posit follow cartesian product possibl invoc must done turn invoc produc set potenti contain mani return valu order succeed split set return valu spread pattern must split subexpress call must split way invoc produc nonspread return valu occur contour anoth invoc produc incompat non spread return valu second task done help function sc split coupl prescrib split pattern separ incompat coupl exampl follow formal descript process split demand call split g ck p c l k v al c split l k split l k follow exampl illustr process demand suppos want process demand split lk two closur may result evalu e l say l two valu may pass argument say l g c 2 k 22 v al p closur c 1 call v 2 closur c 2 call v 1 return valu spread follow return valu circumst must split g c 1 k 12 g c 2 k 21 must split pattern necessari two split succeed order make origin demand succeed suffici howev allow c 1 call v 1 c 2 call v 2 contour k union return valu spread incompat sc function come play use return either l 0 either case split accord prescrib pattern success would make two incompat call occur differ contour suppos first case happen result process origin demand split split l k l fourth e may lexpress process demand simpl reduc split abstract model closur fifth let us consid case e l condit two case possibl first case least one branch spread pattern second branch caus spread pattern incompat test subexpress evalu true fals valu first case conserv approach consist split branch caus spread split l n k p l n second case suffici split type test subexpress determin type test subexpress allow one determin two branch taken consequ know valu condit equal one two branch split l k sixth express e l may pair construct fact valu e l spread pattern impli first pattern form p second valu one two subexpress e l spread correspond subpattern p p either case demand process split appropri subexpress appropri subpattern con l e l e l split l k p con l e l e l split l k p seventh e l may carexpress order split valu e l p subexpress split p howev possibl abstract model pair precis enough abstract pair level detail requir p model pair split first split subexpress proceed plan al p precis enough p split l k p al p p eighth e l cdrexpress process similar carexpress al p precis enough p split l k p ninth e l must pairexpress process demand simpli consist split subexpress see import recal case current consid lk p type subexpress must found order find type ex pression split requir subexpress sinc pair pairexpress come subexpress p l l l k l lab k mkpat e l evalu boolean pair split l k p bvariabl next kind split demand bvar splitte recal bvar indic name program variabl label contour refer variabl occur let us consid particular demand split b xkl p recal also contour k model contour pattern consist list model pattern one per variabl lexic environ visibl express e l model pattern repres kind bound valu correspond guarante lie first model pattern correspond innermost variabl last correspond outermost note analysi framework comput valu variabl refer use bound far framework concern whole contour name particular evalu context framework refer variabl x comput either inspect abstract variabl b xk x innermost variabl translat refer x label l lexpress immedi surround e l contour lexpress e l got evalu creat closur later got invok lead evalu bodi contour k detail variabl refer analysi framework see 4 nonetheless way implement abstract model refer variabl x label l contour k alway produc valu lie insid bound correspond x k consequ split program variabl involv certain number split abstract model call cc moreov consist abstract valu also prescrib multipl split abstract model exampl contour k result call closur l l k valu v label l contour k precis program variabl bound share contour k turn closur l l k result evalu e l contour k l l k precis k program variabl bound share contour follow split program variabl seen refin bound local contour requir refin chain contour closur environ point reach contour refin share variabl closur lead creation come back process split b xkl p first thing must verifi whether refer x e l contour k produc valu spread pattern p denot variabl refer refxk l spread occur 10 demand trivial success otherwis modif model must done otherwis updat v l l m1 updat l m1 p m1 p updat v l l n updat l n p n p m1 p l l x l l m1 m1 l l n n x l lexpress bind x gvariabl last kind demand split demand gvar splitte process demand straightforward sinc case occur current implement return valu closur result evalu bodi let us consid particular demand split g ck p case return valu spread pattern demand trivial success otherwis split l k p 535 call site monitor process rule given demand howev add descript monitor call site monitor call site pretti similar process demand split lk p e l call differ come fact monitor effort made order prove bad call occur let us consid monitor call express l e l e l contour k let l bc denot bad call log potenti mani closur may result evalu e l potenti mani valu may result evalu e l among possibl closureargu pair certain number may mark bad bad call log other pair mark bad monitor e l k trivial success l k v al ca l k l bc l 0 contrari pair mark bad call demand emit ask show call get evalu show gener case mark pair nonmark pair occur call site tempt emit demand ask proof call get evalu would simpl would good idea nonmark pair may abstract actual comput concret evalu program consequ would hope ever make success 11 done separ use split pair mark pair overload sc function use otherwis split l k 536 split coupl function conclud section short descript sc function sc use two differ task split closureargu pair 11 analysi done use framework conserv see 4 comput made abstract interpret abstract least comput made concret interpret imposs prove abstract invoc occur concret counterpart occur concret interpret accord bucket return valu fall rel split pattern split closureargu pair depend criterion consid bad call fact two task similar case set pair partit equival class given either split pattern bucket bad call order separ two pair belong differ class suffici provid split separ v 1 w 1 split separ v 2 w 2 sc prescrib set split perform first compon pair anoth set split perform second compon two pair differ class would separ clearli possibl sinc prescrib split intend separ first compon simpl task similarli second compon way pair would separ other would overli aggress howev usual much smaller set split suffici separ pair implement sc proce way first comput equival class next pair convert genuin abstract pair model pattern breadthfirst travers pair simultan split strategi elabor compar end strategi requir smallest number split obtain littl aggress possibl import propos split appli one two subexpress call express subexpress may express hard split call 6 experiment result 61 current implement current implement demanddriven analysi mere prototyp written scheme experi analysi approach effort put make fast space effici instanc abstract valu implement list symbol close resembl syntax gave model pattern reanalysi phase use data without convert number bitvector project use patternmatch done use cc pc call function asid way demand process mani variant main algorithm tri variant present section 5 first method provid interest result previou variant tri clever model chang concurr demand process lead mani compli cation demand could contain valu contour express term older model reanalysi period done necessarili follow model updat caus demand see benefit split model done complex system success failur propaga tion sequenc process period process resum necessari etc strength current variant model updat reanalysi done whole demand propag restart scratch greatli benefit new analysi result current variant tri differ approach way best modelupd demand select appli model first appli modelupd demand propos demand process phase lead exagger l 2 op l 3 l 4 l 5 con 6 7 cdr 15 l l 17 let let 22 24 25 f 26 letrec l 28 data let data let 36 data 42 43 loop 44 con 45 con 46 con car 50 data 51 con 52 l 53 w f 54 cdr data 56 con 59 f figur 14 sourc maphard benchmark refin model lead massiv space use decid make select one demand accord certain criterion first criterion measur much abstract model increas size particular demand select help control increas size model choos wise obtain inform analysi result new result express finer valu knowledg program data flow alway creas moreov necessarili help control increas size analysi result second criterion use measur much abstract model plu analysi result increas size criterion realli make differ although demand select step involv reanalyz program candid demand 62 benchmark experi small benchmark program benchmark involv numer comput use natur two import remark must made first minilanguag includ letrecexpress mean recurs function must creat use combin note wrote benchmark extend languag let letrec express use translat reduc base lan guag includ two kind letrec translat one defin global recurs function creat use one privat combin gener letrecexpress first kind translat realli make program intric recurs function closur creat second kind translat loos correspond make analysi abl handl letrecexpress special form made test use translat mode second remark concern number minilanguag includ int ger anoth translat step replac integ simpl numer oper list boolean function respect thu integ repres unari peano number oper number proceed accordingli add anoth level difficulti top letrecexpress translat exampl translat see appendix benchmark follow cdrsafe contain definit function check argument verifi pair access analyz perfectli well 1cfa 0cfa loop infinit loop 21 comput valu 2 1 mapeasi use map function short list pair use two differ oper maphard repetit use map function two differ list use two differ oper list pass grow longer longer use map mention 7 imposs analyz perfectli well kcfa sourc code benchmark shown figur 14 fib gcd tak ack classic numer computa tion nqueen count number solut 4 queen ski interpret express written well known k combin interpret run ski program infinit loop combin call encod use pair boolean 63 result figur 15 present result run analysi bench mark benchmark analyz reduc translat method global privat time limit 10000 work unit allow analysi bench mark machin run benchmark pc 12 ghz athlon cpu 1 gbyte ram run rh linux kernel 242 gambitc 40 use compil demanddriven analysi column label indic whether combin global privat next column indic size translat benchmark term number basic express column label total pre post indic number run time type check still requir program moment respect analysi done analysi initi model done demanddriven analysi final comput effort invest analysi measur term work unit cpu time measur column total pure syntact one basic count number call car cdrexpress program measur pre use comparison 0cfa analysi inde initi abstract model use approach quit similar implicitli use 0cfa entri like 223 column indic 2 run time type check still requir invest 23 work unit demanddriven analysi give idea converg rate analysi look figur 15 aspect result strike small improv full demanddriven analysi obtain result obtain 0cfa two reason explain fact first mani run time type check complet trivial remov instanc everi letexpress tran late introduc express form lx turn translat letrecexpress introduc 2 3 let express depend translat method easi optim express even pure syntact detect would suffic second type check equal difficult remov check remov 0cfa remov easi addit check remov demanddriven phase difficult one fact difficulti type check seem grow rapidli come close 100 mark statement support number present 2 lineartim analysi sub0cfa obtain analysi result almost use optim 0cfa despit patent neglig manipul abstract valu note translat privat per letrec help 0cfa demanddriven analysi fact except nqueen benchmark demanddriven analysi abl remov type check privat combin use success analysi vari consider benchmark size total pre post unit time loop g mapeasi g maphard g 96 33 9 638 5254 3305 1520 0 1399 7626 nqueen g 372 121 51 51 10000 1589939 ack g 162 7473 6543 51474 43584 figur 15 experiment result unrol unit 176 280 532 1276 3724 figur 16 effect size program analysi work moreov close relat size program influenc style code order evalu perform analysi similar program conduct experi famili program modifi ack benchmark unrol recurs certain number time translat privat use figur 16 show result rang unrol level unrol level total number type check result program 43 optim done 3 check still requir program analyz initi model check elimin demanddriven analysi finish observ somewhat quadrat increas analysi time certainli better exponenti behavior expect type analysi use lexic environ contour conclus type analysi present paper produc high qualiti result use adapt abstract model analysi abstract model updat respons specif program consid need opti mizer adapt obtain process demand express directli indirectli need optim model updat demanddriven optim process rule demand make approach robust differ code style approach includ flexibl analysi framework gener analys provid model paramet propos model data base pattern describ method automat comput use modif abstract model gave set demand process rule comput use model updat final demonstr power approach experi show analyz precis rel short time program known imposs analyz kcfa complet present contribut found 3 indepth present concept algorithm along proof behind import theoret result also found except idea abstract interpret flexibl analys remaind present work best knowl edg origin abstract interpret frequent use field static analysi see 2 7 8 9 kcfa famili analys see 8 9 extent consid flexibl configur analysi present 2 ashley dybvig produc extend famili analys compil implement time analysi framework see 4 allow subtleti modifi analysi think mani way continu research subject extend experi approach comparison mani analys speed memori consumpt analysi increment reanalysi analysi result r 1 obtain use model 1 model 2 refin model 1 comput new result r 2 effici better select modelupd demand moreov languag extens consid handl larger part scheme extend demanddriven approach analys also theoret question know analyz analysi framework adequ model paramet alway least power kcfa mani analys howev requir paramet given oracl know whether current demanddriven approach alway least power kcfa famili think yet proof l 2 l 3 n 4 figur 17 ack benchmark expans p ackp con 22 f 23 con 24 f 25 con 26 f 27 con 28 f 29 f l 35 ackf l 36 l 37 n 38 con 67 f 68 f 69 l 94 f l 95 x l 96 97 x 109 110 f 111 con 112 f 113 f 114 l 118 f l 119 x2 l 120 y2 121 y2 122 123 124 f 125 cdr 126 x2 127 l 134 f l 135 x3 l 136 y3 137 x3 138 con 139 f 140 141 142 f 143 cdr 144 x3 145 l 148 f 149 l 150 g 151 g 152 g 153 figur 18 ack benchmark expans research work demanddriven analysi substanti differ way see work duesterwald et al 5 agraw 1 heintz tardieu 6 approach abstract execut model chang suit pro gram goal adapt wellknown analysi algorithm variant one perform amount lazi evalu analysi result acknowledg author thank anonym refere care review numer construct comment work support part grant natur scienc engin research council canada 9 r simultan demanddriven dataflow call graph analysi practic flexibl flow analysi higherord languag unifi treatment flow analysi higherord languag control flow analysi scheme semant scheme controlflow analysi tr control flow analysi scheme semant scheme controlflow analysi demanddriven comput interprocedur data flow unifi treatment flow analysi higherord languag practic flexibl flow analysi higherord languag demanddriven pointer analysi simultan demanddriven dataflow call graph analysi