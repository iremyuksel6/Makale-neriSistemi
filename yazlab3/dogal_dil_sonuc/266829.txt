procedur placement use tempor order inform instruct cach perform import instruct fetch effici overal processor perform layout execut substanti effect cach miss rate execut mean perform execut improv significantli appli codeplac algorithm minim instruct cach conflict describ algorithm procedur placement one type codeplac algorithm significantli differ previou approach type inform use drive placement algorithm particular gather tempor order inform summar interleav procedur program trace algorithm use inform along cach configur procedur size inform better estim conflict cost potenti procedur order compar perform algorithm previous publish procedureplac algorithm show notic improv instruct cach behavior b introduct linear order procedur program text segment fix address procedur turn determin cach line procedur occupi instruct cach case directmap cach conflict miss result execut program altern two procedur whose address map overlap set cach line sever compiletim codeplac techniqu develop use heurist profil inform reduc number conflict miss instruct cach reorder program code block 567811 though techniqu success remov sizeabl number conflict miss compar default code layout produc typic compil process possibl even better gather improv profil inform consid specif hardwar configur end propos method summar import tempor order inform relat code placement show use inform machinespecif manner often reduc number instruct cach conflict miss particular appli new techniqu problem procedur placement directmap cach compil 2achiev optim cach line address procedur specifi order procedur gap procedur execut codeplac techniqu may reorgan applic one level granular typic techniqu focus placement whole procedur individu basic block use term code block refer unit granular codeplac techniqu appli though focu placement variables code block defin procedur boundari techniqu captur tempor inform use inform placement appli code block granular default code layout produc compil place procedur execut order list sourc file preserv order object file linker command line therefor left chanc code block conflict cach whenev code block often execut togeth happen overlap cach caus signific number conflict miss instruct cach sever studi shown compiletim optim chang rel placement code block caus larg chang instruct cach miss rate 34 chang rel placement code block occur perform program affect intend effect optim also result chang instruct cach miss make difficult predict total effect optim chang code size use chang run time optim execut judg effect optim summari codeplac techniqu import improv perform instruct fetcher enabl effect use compiletim optim reduc instruct cach miss rate applic code placement algorithm requir two capabl must abl assign code block cach line must inform rel import avoid overlap differ set code block way compil set address code block compil manipul order procedur appear execut leav gap two adjac procedur forc align next procedur specif cach line interest problem determin procedur overlap hardwar instruct cach previou work procedur placement almost exclus base summari profil statist simpli indic often code block execut often inform organ weight procedur call graph wcg record number call occur pair procedur profil run program figur 1 contain exampl wcg summari inform use estim penalti result placement procedur pair cach locat aim exist algorithm place procedur pair high call count conflict cach count number call procedur summar inform wcg provid way recogn procedur tempor relat execut program howev wcg give us tempor inform would like particular absenc edg two procedur necessarili mean penalti overlap procedur exampl wcg figur 1 produc condit cond altern true fals trace 1 figur 1 proc loop 20time loop 4time cond call els call endl call z endl figur 1 exampl simpl program call three leaf procedur weight procedur call graph obtain condit cond true 50 time notic wcg obtain call trace given right figur exampl program b weight procedur call graph c possibl trace correspond wcg trace 1 trace 2 condit cond true 40 time fals 40 time trace 2 assum purpos exampl procedur figur 1 requir singl cach line three locat directmap instruct cach one cach locat reserv procedur clearli want code layout last two cach locat execut trace trace 1 experi fewer cach conflict miss procedur given distinct cach line z share cach line trace 2 experi fewer cach conflict miss procedur share cach line z given cach line wcg figur 1 captur tempor order inform need determin layout best wcg summar direct call inform precis inform provid import conflict sibl illustr figur 1 distant tempor relationship enabl better code layout want measur much execut program altern pair procedur pair connect edg wcg refer measur tempor order inform inform concern procedur size target cach configur make better estim number conflict miss experienc specif layout begin section 2 brief descript wellknown procedureplac algorithm set framework understand new algorithm present detail algorithm section 3 4 section 3 describ method extract summar tempor order inform program trace section 4 present procedureplac ment algorithm use inform produc method section 5 explain experiment methodolog present empir result demonstr benefit algorithm previou algorithm directmap cach section 6 describ modifi algorithm setassoci cach final section 7 review relat work code layout section 8 conclud procedur placement petti hansen current approach procedur placement reli greedi algorithm summar differ algorithm describ select order procedur consid placement determin place procedur rel alreadyplac procedur begin descript wellknown procedureplac algorithm petti hansen 8 explain new algorithm retain much structur mani import heurist found petti hansen approach addit procedur placement petti hansen also address issu basicblock placement branch align purpos paper use acronym ph refer implement procedur placement portion algorithm petti hansen reduc instructioncach conflict procedur place frequent callercalle procedur pair adjac address approach base wcg summari profil inform use summari inform select next procedur place determin place procedur relationship alreadi place procedur implement ph produc undirect graph weight edg contain essenti inform wcg one node graph procedur program edg e pq connect two node p q p call q q call p weight pq given e pq equal 2 call pq call qp call pq total number call made procedur p procedur q collect inform scan instruc tionaddress trace program note transit procedur count call return therefor get edg weight twice number call extra factor two chang procedur placement produc ph graph use select next procedur place determin rel placement procedur ph begin make copi initi graph refer copi work graph ph search work graph edg largest weight call edg e uv edg found algorithm merg two node u v singl node u work graph detail moment remain edg origin node u v node becom edg new node u maintain invari singl edg pair node ph combin pair edg e ur e vr singl edg e ur weight ur algorithm repeat process search edg largest weight work graph graph reduc singl node ph way reduc chanc conflict miss procedur proxim address space closer place two procedur address space less like conflict procedur within node organ linear list call chain 8 ph merg two node chain combin singl chain four way let b repres chain b revers chain four possibl ab ab ab ab choos best one ph queri origin graph determin edg e largest weight procedur p first chain procedur q second chain implement ph choos merg chain minim distanc byte p q 3 summar tempor order inform algorithm aim optim arrang code block need conflict metric quantifi import avoid conflict set code block ideal metric would report number cach conflict miss caus map set code block overlap cach line expect find metric give exact number result cach conflict miss need one simpli need metric linear function number conflict miss 1 section 53 show metric use algorithm exhibit strong correl instruct cach miss rate 1 clearli differ train test data set also affect metric abil predict cach conflict miss test run discuss previou section ph use callgraph edg weight wpq two procedur q conflict metric simpl metric drive merg node unfortu nate metric sever drawback illustr section 1 understand build better conflict metric help review action cach process instruct stream assum moment track code block size equal size cach line directmap cach code block b map cach line l addrb div lines mod cachelin code block remain cach anoth code block map cach line term code layout import therefor note code block referenc tempor nearbi refer b ideal none block referenc consecut refer b map cach line b way get reus initi fetch block b experi conflict miss second refer b sinc reus code block prevent singl code block directmap cach construct data structur summar frequenc altern two code block conveni build data structur weight graph node repres individu code block refer graph tempor relationship graph trg ph conflict metric simpli edg weight e pq two node p q trg gener call graph contain edg connect pair code block interleav program execut rest section describ process build trg next section explain use result trg place procedur construct summari tempor local code block trace analyz set recentlyreferenc code block transit code block implement order set q codeblock identifi eg procedur name order appear trace alway access histori recentlyreferenc code block bound maximum size q entri eventu becom irrelev remov two way code block identifi p becom irrelev first need latest occurr p q code block execut recent occurr p effect occurr earlier occurr p second p becom irrelev suffici larg amount uniqu code execut sinc ps last occurr evict p cach let set code block identifi reach sinc last refer p let st sum size code block referenc exactli big st need grow p becom irrelev depend cach map code assum code layout maxim reus member map nonoverlap address cach footprint equal st therefor p becom irrelev st greater cach size summari perform follow step insert new element p order set q first place p recent end q previou occurr p q remov remov oldest member q remov next leastrecentlyus identifi would caus total size byte remain code block q less cach size build trg process trace one code block identifi time process step contain set code block tempor local often set code block appear q import occupi cach locat code block identifi p remov trace updat trg follow everi code block q q start mostrec end q increment weight edg e pq node p exist creat edg e pq exist creat weight 1 continu q reach previou occurr p end q stop encount previou occurr p indic reus code block temporarili referenc previou occurr p q could displac p instruct cach collect relationship data p insert p q describ process repeat process entir trace process ing left trg whose edg weight pq record number time p q occur within suffici small tempor distanc present q time independ p q relat program call graph 4 placement algorithm given discuss section 2 3 clear could use trg construct section 3 within procedureplac algorithm describ petti hansen 8 found howev extra tempor order inform alon suffici guarante lower instruct cach miss rate get consist improv also make two key chang way determin place procedur rel alreadyplac procedur first involv use procedur size cach configur inform allow us make inform procedureplac decis second involv gather tempor order inform granular finer procedur unit use detail inform overcom problem creat procedur larger cach size effici reason also consid popular ie frequent execut procedur build relationship graph propos hashemi et al 5 rest section outlin procedureplac algorithm section 41 begin descript trg requir algorithm iter procedur list select order procedur process main outer loop section 42 focus portion algorithm main loop place procedur rel procedur alreadi process use cach configur procedur size inform placement decis simpli specifi cacherel align among set procedur determin procedur start address ie placement linear address space occur popular procedur process section 43 present detail process 41 trg main outer loop algorithm use two relat trg one select next procedur place trg select aid determin place select procedur trg place ph two graph initi algorithm graph differ granular code block process trg build code block trg select correspond whole procedur code block trg place correspond chunk procedur benchmark found chunk procedur 256byte piec work well trg place therefor contain node procedur p program straightforward modifi algorithm previou section gener trg simultan though record tempor inform concern part procedur procedureplac ment algorithm place whole procedur use finergrain inform find best rel align whole procedur explain though trg select contain edg per node relationship graph built ph due addit tempor order inform process trg select exactli greedi merg manner relationship graph discuss section 2 though tri sever method creat order select procedur placement could find robust heurist one simpl eleg differ work relationship graph trg select contain popular procedur section 43 discuss place remain unpopular procedur 42 determin cacherel align ph data structur node work graph linear list chain pro cedur build chain restrict term select start address place procedur need howev constraint need maintain place procedur map address result cach layout small conflict cost explain exactli calcul cost placement moment instead chain use data structur node trg select compris set tupl tupl consist procedur identifi offset cach line begin procedur begin cach node contain singl procedur offset zero two node contain singl procedur merg togeth algorithm modifi offset second procedur ensur cost metric placement two procedur cach minim algorithm figur 2 present pseudocod merg two node contain number alreadyplac procedur three item noteworthi concern mergenod routin figur 2 first merg two node leav rel align procedur within node figur 2 pseudocod merg two node tempor relationship graph rg select procedur chunk within node identifi uniqu id offset chunk id record cachelin index correspond begin chunk offset alway unit cach line array cachelin id mergenod node n1 node n2 initi cach array c1 mark line procedurechunk id node n1 occupi line foreach id offset pair p n1 int foreach idoffset pair p poffset bestoffset return n1 unchang backtrack undo previou decis though abil rearrang entir set procedur two node merg might lead better layout flexibl would notic increas comput complex algorithm assum select order procedur placement guarante alreadi avoid expens potenti cach conflict experiment result show greedi heurist work quit well practic open research question limit amount backtrack could improv upon layout found current approach second mergenod calcul cost metric potenti align layout first node respect layout second node fix layout first node begin cach line 0 offset start second node layout number 0 number line cach evalu rel offset use finegrain tempor inform trg place given offset comput procedur piec first node procedur piec second node overlap cach pair overlap procedur piec comput estim number cach conflict correspond overlap access weight edg two procedur piec trg place sum estim obtain total estim potenti placement calcul estim procedurepiec conflict node intranod conflict procedur piec want increment cost placement cost intranod overlap fix chang ultim find calcul extra cost would increas work done algorithm third costmetr calcul produc sever rel offset cost algorithm select first offset simplest case merg two node contain singl procedur call p q total size two procedur less cach size merg node result node equival chain creat ph word mergenod select first empti cach line procedur p begin procedur q sinc first zerocost locat q 43 produc final linear list merg phase algorithm end edg left trg select 2 final step algorithm produc linear arrang program procedur given rel align decis contain remain trg select node begin select procedur p cachelin offset 0 3 first procedur linear layout find next procedur linear layout search node procedur q whose cacherela tive offset result smallest posit gap cach line end p start q understand gener case assum procedur p last procedur linear layout p end cacherel offset pendlin choos procedur q start cacherel ativ offset qstartlin next procedur linear layout q produc smallest posit valu gap among unconsid popular procedur final whenev produc gap two popular procedur search unpopular procedur one fit gap determin address popular procedur linear address space simpli append remain unplac unpopular procedur end linear list 5 experiment evalu section compar three differ procedureplac algorithm addit ph algorithm gbsc present result recent publish procedureplac algo rithm algorithm hashemi kaeli calder 5 refer hkc like algo rithm hkc also extend ph use knowledg procedur size cach size cach organ hkc use weight call graph addit tempor inform key advantag hkc ph hkc record set cach line occupi 2 unlik ph work graph trg select necessarili reduc singl node trg select contain popular procedur possibl connect two popular procedur unpopular procedur 3 assum start text segment map cachelin 0 easi adjust algorithm gap qstartlin pendlin qstartlin numcachelin pendlin procedur placement tri prevent overlap procedur immedi neighbor call graph begin section 51 aspect behavior code placement techniqu need address order make meaning comparison differ algorithm particular introduc experiment methodolog base random techniqu section 52 outlin experiment methodolog section 53 present result 51 evalu perform code placement algorithm normal expect code optim behav similar continu function small chang behavior optim caus small chang perform result exe cutabl code placement optim often case small chang layout program caus dramat chang cach miss rate exampl simul instruct cach behavior specint95 perl program two slightli differ layout first layout output code layout algorithm second layout ident first except procedur pad addit byte one cach line empti space end instruct cach miss rate chang 38 first layout 54 second layout remark chang trivial differ layout fact possibl introduc larg number miss move one code block singl cach line greedi codelayout algorithm addit problem differ layout fact substanti differ layout often result small chang input profil data step ph hkc gbsc greedili choos highestweight edg work graph two edg say weight 1000000 1000001 bare larger edg alway chosen first even though small differ unlik repres statist signific basi prefer one edg wors tie result ident edg weight decid arbitrarili decis two equal good altern must necessarili made one way affect current step algorithm futur step result find difficult draw conclus rel perform differ code layout algorithm small number program trace ideal would like larg enough set differ input benchmark get accur impress distribut result unfortun hard practic sinc common benchmark suit distribut hand input set benchmark applic simul effect mani slightli differ applic input set first run applic singl input appli random perturb result profil data algorithm comparison perturb weight graph multipli edg weight valu close one specif initi weight w replac perturb weight accord equat x random variabl normal distribut mean 0 varianc 1 scale factor determin magnitud random perturb use multipl rather addit nois attract two reason first addit nois caus weight becom neg obviou interpret second method inher selfscal sens reason valu independ initi edg weight larg enough valu caus layout effect random perturb graph bear littl relationship profil data low valu caus statist insignific differ edg weight observ rang result produc small chang use experi blackwel 2 show sever code placement algorithm valu low 001 elicit rang perform variat system valu high 20 degrad averag perform much exp 52 methodolog implement ph hkc gbsc procedureplac algorithm integr one two differ environ simul environ base atom 10 compil environ base suif 9 result section 53 base atom environ use suif environ verifi algorithm produc runnabl correct code tabl 1 list benchmark use studi except ghostscript specint95 benchmark suit use five eight specint95 benchmark three compress ijpeg xlisp uninterest small instruct work set equal well reason procedureplac algorithm compil go perl use suif compil version 112 benchmark compil use gcc 272 o2 optim flag chose input data set keep trace manag size report miss rate next section base simul 8 kilobyt directmap cach line size 32 byte use train input drive procedureplac algorithm simul instructioncach perform result optim execut use test input 53 result graph figur 3 show experiment result ph hkc gbsc graph show result singl benchmark three algorithm curv show cumul distribut result set 20 experi base train test trace describ section 51 use random obtain twenti slightli differ wcg trg result slightli differ placement point along curv xcoordin cach miss rate one placement ycoordin give percentag placement equal better miss rate consequ curv one algorithm left curv anoth algorithm first algorithm give better result notic algorithm give clearli better result two benchmark 7except m88ksim perl two benchmark rang result overlap though gbsc yield lowest averag miss rate placement summari result demonstr benefit use tempor order inform well algorithm consid cacherel align place code section 3 said use conflict metric strongli correl number cach miss figur 4 examin issu show relationship conflictmetr valu cach miss rate plot figur 4 contain 80 point point correspond differ placement go benchmark placement base gbsc algorithm howev vari output algorithm produc placement rang differ miss rate accomplish randomli select 050 procedur gbsc placement randomli chang cacherel offset metric valu plot correspond result placement figur 4a show conflict metric base finegrain inform trg place show linear relationship actual number cach miss point graph close diagon hand figur 4b show metric base wcg alway good predictor cach miss program name procedur popular procedur train trace test trace miss rate default layout avg size procedur histori size count size count input descript length input descript length go 590 k 3221 134 k 112 11x11 board level 4 stone level 6 4 stone ghostscript 1817 k 372 104 k 216 14page pre sentat 37 3page paper 38 263 89 limit 50m bb limit 50m bb 50 292 143 perl 664 k 271 reduc dic tionari reduc input file vortex 1073 k 923 117 k 156 persons250 reduc iter reduc iter tabl 1 detail benchmark applic report size byte trace length basic block benchmark averag size procedur histori report averag number procedur present order set q build trg figur 3 instruct cach miss rate benchmark graph show distribut miss rate correspond layout produc ph hkc new procedureplac algorithm gbsc data point graph repres result singl placement cach miss rate vari along xaxi yaxi show cumul distribut miss rates02061 gcph gchkc gcgbsc gcc02061 gsph gshkc gsgbsc b ghostscript02061 goph gohkc gogbsc c go m88ksim02061 m8ph m8hkc m8gbsc plph plhkc plgbsc02061 voph vohkc vogbsc f vortex 6 extens setassoci cach point describ techniqu collect use tempor inform specif directmap cach implement word assum singl occurr procedur q two occurr procedur p suffici displac p assumpt necessarili true setassoci cach especi implement lru polici use approach setassoci cach construct slightli differ data structur replac trg place slightli modifi costmetr calcul mergenod section focus 2way setassoci cach implement chang associ follow directli explan instead graph represent trg place conveni think tempor relationship structur databas record number time codeblock pair rs appear consecut occurr anoth code block p program trace still use order set approach build databas howev process tempor associ relat next code block p trace associ p possibl select two identifi identifi current q previou occurr p before4812 figur 4 correl conflict metric cach miss data point 80 random layout go benchmark xcoordin point cach miss rate layout ycoordin sum conflict metric indic method entir placement cach miss rate conflict estim million conflict metric base finegrain trg b conflict metric base wcg4812 cach miss rate conflict estim million two uniqu refer requir guarante reus thu databas simpli record frequenc associ p pair rs access dpr r p occupi set twoway setassoci cach estim dpr program refer p result cach conflict due displac p interven refer r access inform instead trg place edg weight conflictmetr calcul mergenod clearli innerloop calcul must also chang slightli check cost associ code block node n1 pair code block n2 viceversa though chang trg place chang trg select trg select heurist select order code block place obvious affect cach associ mention earlier heurist approach may work better found one 7 discuss relat work much prior work area compiletim code placement relat earli work reduc frequenc page fault virtual memori system recent work reduc cost pipelin penalti associ control transfer instruct howev limit discuss studi directli address issu code placement aim reduc instruct cach conflict miss earliest work area done hwu chang 6 mcfarl 7 petti hansen 8 hwu chang use wcg proxim heurist address problem basicblock placement approach uniqu also perform function inlin expans code placement overcom artifici barrier impos procedur call boundari mcfarl 7 use interest program represent dag procedur loop condi tional drive codeplac algorithm profil inform still summar way tempor interleav block trace lost fact paper explicitli state unabl collect tempor interleav inform algorithm assum optim worstcas interleav block like algorithm mcfarl 1doe consid cach size modulo properti evalu potenti layout cost calcul obvious differ final algorithm uniqu abil determin portion text segment exclud instruct cach torella xia daigl 11 propos codeplac techniqu kernelintens applica tion algorithm consid cach address map perform code placement defin array logic cach equal size address align hardwar cach code place within singl logic cach guarante never conflict code logic cach though subarea logic cach reserv frequentlyexecut basic block gener mechan calcul placement cost across differ logic cach code placement guid execut count edg basic block therefor captur tempor order inform histori mechan use analyz tempor behavior trace similar problem profil path procedur call graph ammon et al 1 describ way implement effici path profil howev data structur gener techniqu use place trg captur suffici tempor order inform 8 conclus present method extract tempor order inform trace describ procedureplac algorithm use inform along knowledg cach line procedur occupi predict accur placement result least number conflict miss result show two factor combin allow us obtain better instruct cach miss rate previou procedureplac techniqu codeplac techniqu fluff remov 8 branch align 12 orthogon problem place whole procedur therefor combin techniqu achiev improv success experi indic worthwhil continu research tempor behavior applic particular plan develop similar techniqu optim behavior applic layer memori hierarchi 9 r exploit hardwar perform counter flow context sensit profil applic random system perform measur effect code expand optim instruct cach design perform issu correl branch predict scheme effici procedur map use cach line color achiev high instruct cach perform optim compil program optim instruct cach profil guid code posit extend suif machinedepend optim atom system build custom program analysi tool optim instruct cach perform oper system intens workload nearoptim intraprocedur branch align tr program optim instruct cach achiev high instruct cach perform optim compil profil guid code posit atom perform issu correl branch predict scheme exploit hardwar perform counter flow context sensit profil effici procedur map use cach line color nearoptim intraprocedur branch align optim instruct cach perform oper system intens workload applic random system perform measur ctr christoph guillon fabric rastello thierri bidault florent bouchez procedur placement use temporalord inform deal code size expans journal embed comput v1 n4 p437459 decemb 2005 keoncheol shin jungeun kim seonggun kim hwansoo han restructur field layout embed memori system proceed confer design autom test europ proceed march 0610 2006 munich germani alex ramrez josepl larribapey carlo navarro josep torrella mateo valero softwar trace cach proceed 13th intern confer supercomput p119126 june 2025 1999 rhode greec alex ramirez josep larribapey carlo navarro mateo valero josep torrella softwar trace cach commerci applic intern journal parallel program v30 n5 p373395 octob 2002 john kalamatiano alireza khalafi david r kaeli wale melei analysi temporalbas program behavior improv instruct cach perform ieee transact comput v48 n2 p168175 februari 1999 young michael smith better global schedul use path profil proceed 31st annual acmiee intern symposium microarchitectur p115123 novemb 1998 dalla texa unit state rakesh kumar dean tullsen compil instruct cach perform multithread architectur proceed 35th annual acmiee intern symposium microarchitectur novemb 1822 2002 istanbul turkey bartolini c prete optim instruct cach perform embed system acm transact embed comput system tec v4 n4 p934965 novemb 2005 architectur compil support effect instruct prefetch cooper approach acm transact comput system toc v19 n1 p71109 feb 2001 trishul chilimbi ran shaham cacheconsci coalloc hot data stream acm sigplan notic v41 n6 june 2006 alex ramirez luiz andr barroso kourosh gharachorloo robert cohn josep larribapey p geoffrey lowney mateo valero code layout optim transact process workload acm sigarch comput architectur news v29 n2 p155164 may 2001 chandra krintz brad calder han bok lee benjamin g zorn overlap execut transfer use nonstrict execut mobil program acm sigop oper system review v32 n5 p159169 dec 1998 stephen brown jeet asher william h mangionesmith offlin program remap improv branch predict effici embed system proceed 2000 confer asia south pacif design autom p111116 januari 2000 yokohama japan alex ramirez josep l larribapey mateo valero softwar trace cach ieee transact comput v54 n1 p2235 januari 2005 trishul chilimbi effici represent abstract quantifi exploit data refer local acm sigplan notic v36 n5 p191202 may 2001 alex ramirez oliverio j santana josep l larribapey mateo valero fetch instruct stream proceed 35th annual acmiee intern symposium microarchitectur novemb 1822 2002 istanbul turkey young michael smith static correl branch predict acm transact program languag system topla v21 n5 p10281075 sept 1999 ann gordonross frank vahid nikil dutt first look interplay code reorder configur cach proceed 15th acm great lake symposium vlsi april 1719 2005 chicago illinoi usa brad calder chandra krintz simmi john todd austin cacheconsci data placement acm sigplan notic v33 n11 p139149 nov 1998 timothi sherwood brad calder joel emer reduc cach miss use hardwar softwar page placement proceed 13th intern confer supercomput p155164 june 2025 1999 rhode greec thoma kistler michael franz autom datamemb layout heap object improv memoryhierarchi perform acm transact program languag system topla v22 n3 p490505 may 2000 murali annavaram jignesh patel edward davidson call graph prefetch databas applic acm transact comput system toc v21 n4 p412444 novemb rajiv ravindran pracheeti nagarkar ganesh dasika eric marsman robert senger scott mahlk richard b brown compil manag dynam instruct placement lowpow code cach proceed intern symposium code gener optim p179190 march 2023 2005 nikola gloy michael smith procedur placement use temporalord inform acm transact program languag system topla v21 n5 p9771027 sept 1999 martha mercaldi steven swanson andrew petersen andrew putnam andrew schwerin mark oskin susan j egger model instruct placement spatial architectur proceed eighteenth annual acm symposium parallel algorithm architectur juli 30august 02 2006 cambridg massachusett usa bartolini c prete propos inputsensit analysi profiledriven optim embed applic acm sigarch comput architectur news v32 n3 p7077 june 2004 trishul chilimbi mark hill jame r laru cacheconsci structur layout acm sigplan notic v34 n5 p112 may 1999 sangwook p kim gari tyson analyz work set characterist branch execut proceed 31st annual acmiee intern symposium microarchitectur p4958 novemb 1998 dalla texa unit state mahmut kandemir compilerdirect collectiveio ieee transact parallel distribut system v12 n12 p13181331 decemb 2001 thoma kistler michael franz continu program optim case studi acm transact program languag system topla v25 n4 p500548 juli