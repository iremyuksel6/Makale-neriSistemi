regular languag testabl constant number queri continu studi combinatori properti test initi goldreich goldwass ron j acm 45 1998 pp 653750 subject paper test regular languag main result follow regular languag lin 01 integ n exist random algorithm alway accept word w length n win l reject high probabl w modifi least epsilon n posit creat word l algorithm queri tildeo1epsilon bit w queri complex shown optim factor polylogarithm 1epsilon also discuss testabl complex languag show particular queri complex requir test contextfre languag bound function epsilon problem test regular languag view part gener approach seek probe testabl properti defin logic mean b introduct properti test deal question decid whether given input x satis prescrib properti p far input satisfi let p properti ie nonempti famili binari word word w length n call far satisfi p word w 0 length dier w n place satis p test p random algorithm given quantiti n abil make queri valu desir bit input word w length n distinguish probabl least 23 case w 2 p preliminari version paper appear proceed 40 th symposium foundat comput scienc depart mathemat raymond beverli sackler faculti exact scienc tel aviv univers tel aviv 69978 israel att labsresearch florham park nj 07932 usa email nogamathtauacil research support usa isra bsf grant grant israel scienc foundat hermann minkowski minerva center geometri tel aviv univers z depart mathemat raymond beverli sackler faculti exact scienc tel aviv univers tel aviv 69978 israel email krivelevmathtauacil part research perform author dimac center rutger univers piscataway nj 08854 usa att labsresearch florham park nj 07932 usa research support part dimac postdoctor fellowship x depart comput scienc univers haifa haifa israel email ilancshaifaacil part research perform author visit lab research florham park nj 07932 usa school mathemat institut advanc studi olden lane princeton nj 08540 usa email szegedymathiasedu part research perform author att labsresearch florham park nj 07932 usa case w far satisfi p final say properti p c testabl everi 0 exist test p whose total number queri bound c properti test dene goldreich et al 7 inspir 13 emerg natur context pac learn program check 6 3 10 13 probabilist checkabl proof 2 approxim algorithm 7 7 author mainli consid graph properti bipartit show among thing quit surpris fact test bipartit done randomli test polynomi 1 number edg graph answer question constant probabl failur also rais question obtain gener result everi 0 test properti use queri ie c function independ n constant probabl failur call properti type testabl far answer quit spars interest exampl given 7 sever addit one obtain appli regular lemma show subsequ paper 1 paper address testabl formal languag see 8 gener refer languag properti usual view sequenc boolean function f main result state regular languag testabl queri complex o1 also show complex optim factor polylogarithm 1 posit result extend contextfre languag exampl simpl contextfre languag testabl sinc regular languag character use second order monad logic thu obtain larg set logic dene object testabl 1 provid testabl graph properti describ logic mean well result indic strong interrel testabl logic although result regular languag view separ result logic bear opinion logic provid right context testabl problem may lead discoveri class testabl properti rest paper organ follow section 2 present proof main result show everi regular languag testabl section 3 show upper bound o1 queri complex test regular languag obtain theorem 1 tight polylogarithm factor section 4 devot discuss testabl contextfre languag show particular exist nontest contextfre languag also discuss testabl dyck languag nal section 5 contain conclud remark outlin new research direct test regular languag section prove main result paper name regular languag 1 testabl result asymptot assum n big enough respect 1 respect constant depend xed languag work logarithm binari unless state explicitli otherwis start recal standard denit regular languag base nite automata denit conveni algorithm purpos denit 21 determinist nite automaton dfa f0 1g state given function set f q one state q 1 call initi state state belong set f call accept state call transit function extend transit function f0 1g recurs follow let denot empti word thu start state q process string u end state q u say accept word u q reject u mean q 1 final languag accept denot lm set u 2 f0 1g accept use follow denit regular languag denit 22 languag regular exist nite automaton accept therefor assum section regular languag l given automaton word w length n dene sequenc state q follow natur way q 1 j n sequenc describ automaton move read w later paper occasion refer sequenc travers path w nite automaton dene direct graph gm v g period gg direct graph g greatest common divisor cycl length g g acycl set use follow lemma direct graph lemma 23 let e nonempti strongli connect direct graph nite period gg exist partit v exceed 3jv j 2 1 everi 0 1 everi length everi direct path u v g j mod 2 everi 0 1 everi everi integ r mod g exist direct path u v g length r proof prove part 1 x arbitrari vertex z 2 v 0 g 1 let v set vertic reachabl v direct necessarili simpl path length g note sinc close direct walk g disjoint union cycl length walk divis g impli set v pairwis disjoint inde assum fals suppos w lie v v j 6 j g strongli connect path p 1 w z denit path p 2 length mod g z w well path p 3 length mod g z w number edg either 3 divis g imposs therefor set v form inde partit v union direct path z u direct path u v form path z v path must length j mod g assert part 1 follow next prove part 2 consid set posit integ fa g whose greatest common divisor g well known smallest number everi integ divis g linear combin nonneg integ coecient number moreov known see 9 5 smaller squar maxim number fix close direct walk g visit vertic whose length jv j 2 easili obtain number vertic g arbitrarili concaten direct path v v i1 0 k 1 indic taken modulo k associ set cycl length walk set posit integ fa g follow close walk travers direct cycl mani time desir conclud everi integ divis g exce 2jv j 2 length close walk pass vertic graph given vertex integ r 3jv j mod g x shortest path p u v note length l satis l j mod g l jv j jv j 2 ad p close walk length r l v obtain requir path complet proof 2 call constant lemma reachabl constant g denot mg sequel assum divis g lm f0 1g test algorithm reject input without read therefor assum nontrivi case lm f0 1g n 6 introduc key denit sequel denit 24 given word w 2 f0 1g n subword run w 0 w start posit call feasibl languag lm exist state q 2 q q reachabl q 1 g exactli step path length n jw g state q w 0 least one accept state otherwis w 0 call cours nding infeas run w prove w 62 l aim show given word w length n far word length n l mani short run w infeas thu choic small number random run w almost sure contain infeas run first treat follow basic case denit 25 call automaton essenti strongli connect 1 uniqu accept state q acc 2 set state automaton q partit two part c subgraph gm induc c strongli connect edg gm go c edg go c note may empti lemma 26 assum languag contain word length n essenti strongli connect c partit state denit 25 let reachabl constant gc assum also n 64m log4m word w length exist integ 1 log4m number infeas run w length 2 i1 least 2 4 n proof intent construct sequenc r j j1 disjoint infeas run minim sens prex feasibl subword given word w show concaten subword form word languag far w far essenti depend number run construct turn show distw l n lower bound number infeas run reason becom obviou later also want run interv natur way construct sequenc repeat follow procedur start 1 shortest infeas run start wm 1 end run stop assum construct end wc j 1 next construct r j take minim infeas run start wc end wn 1 run stop assum construct way run r 1 r h note run subword w run pairwis disjoint concaten order form continu subword w also note denit run r j minim infeas prex r obtain discard last bit r j feasibl turn impli r 0 j obtain r j ip last bit feasibl addit denit 24 mean r 0 state q j reachabl q 1 c next induct construct word w 2 l distw w hm 2m 2 assum distw l n impli lower bound h gener idea glue togeth r 0 h feasibl yet close subword w except last bit concern glue piec togeth whole word feasibl requir extra chang bit per run plu addit 2m bit end word maintain induct construct feasibl start posit 1 end posit c j base case let c word length feasibl start posit 1 assum alreadi dene word w posit 1 end posit c j 1 let q p j q j reachabl q 1 path length c j 1 accord lemma 23 chang last bit w j 1 get word u j q 1 dene w j concaten u j r 0 let w h nal word dene way end place c h reason stop r h either infeas run start c h 1 case chang last bit w h concaten remain sux w start posit c h exactli case ad r 0 yield requir w possibl reason stop grow r h minim infeas run start c h end posit n 1 let r run let r 0 run obtain ip last bit r case r 0 feasibl posit c h 1 henc feasibl word u r 0 prex u length q h construct w w h u exactli construct w form w h sux w previou case denit w w 2 l follow induct construct w follow 1 get w h w concaten r 0 either subword w rst case previous discuss subword w one bit chang second case follow chang bit end w h possibl addit bit end u therefor distw w hm 2 claim recal distw l n conclud h n 2 last inequ assumpt n 64m log4m alreadi show distw l n n mani disjoint infeas run w howev need stronger depend state lemma achiev follow way let log4m 1 denot number run fr j g h whose length fall interv 2 p h n4m n4m therefor exist index n4am consid infeas run r j jr run contain infeas subrun infeas infeas run length 2 contain least run length 2 i1 except mayb rst two last two run two smallest js two largest js r j disjoint infeas run length contain three r j length least 2 1 thu get total least run length 2 i1 assumpt paramet number log4m claim 2 aim reduc gener case describ case given dfa graph cg graph compon g whose vertic correspond maximalbi inclus strongli connect compon g whose direct edg connect compon g connect edg g note vertic cg may repres singl vertic g self loop belong strongli connect subgraph g least two vertic compon non empti path insid call truli connect reserv k number vertic cg set may assum vertic g reachabl initi state q 1 cg acycl graph exist direct path compon c 1 contain q 1 everi compon run truli connect compon g correspond vertic cg assum sequel follow relat satis paramet condit 2k 64m log 8mk log1 1 clearli xed k l small enough n larg enough condit hold next step describ word w 2 lm length n move along automaton word w belong l travers g start q 1 end one accept state accordingli w travers cg start c 1 end compon contain accept state reason call path cg admiss start c 1 end compon accept state given admiss path cg sequenc pair vertic g state call admiss sequenc portal satis follow restrict 1 everi 1 j 2 3 accept state 4 everi 2 j one p 2 idea behind denit admiss portal simpl given admiss path admiss sequenc p portal dene word w 2 l move one strongli connect compon next one start initi state q 1 end accept state rst last state travers c j given admiss path correspond admiss sequenc p portal say increas sequenc integ form admiss partit respect p follow hold 1 2 everi 1 j exist path p 1 j p 2 length n j1 3 mean partit j1 follow w 2 l w travers accord valu n j indic w arriv compon c rst time n j bit conveni also set n 1 thu 1 j word w stay c j interv n possibl principl given admiss path correspond admiss sequenc portal p correspond admiss partit could happen path set portal p correspond word length n triplet admiss path p correspond admiss sequenc portal correspond admiss partit call admiss triplet clear denit admiss triplet word w 2 l travers g accord scenario suggest one admiss triplet therefor order get convinc w 62 l enough check w admiss triplet fix admiss triplet dene languag l j contain word travers p 1 j p 2 done formal dene automaton j follow set state j obtain ad new state f j initi state j uniqu accept state p 1 respect 2 f0 1g q set j name j transit within c remain transit go compon go f j loop thu j essenti strongli connect denit 25 g l j languag accept j given xed admiss triplet word w length subword set note jw name w path accord partit substr w j correspond portion travers path w lie within compon c lemma 27 let admiss triplet let w word length n satisfi distw l n dene languag l word w describ exist index j 1 j distw k proof assum case let j1 partit recal k everi word length n j1 n j 1 empti word also 1 j 1 choos j 2 f0 1g p 2 j1 construct word w belong l distw w contradictionnow present key idea proof ideal would like test whether input word w length n ts admiss triplet posit case ie w 2 lm travers path w dene natur admiss triplet w obvious neg case ie distw l n lemma 27 impli everi admiss triplet p least one subword w j far correspond languag l j lemma 26 w j contain mani short infeas run thu sampl small number random run catch one high probabl howev problem total number admiss triplet clearli depend n make task appli directli union bound probabl catch infeas run imposs circumv diculti follow way place evenli bound number depend paramet transit interv bound length postul transit compon cg happen insid transit interv show w 2 l modi slightli meet restrict wherea distw l n choic admiss triplet w far tting number admiss triplet consider bound function appli union bound estim probabl failur recal run truli connect compon g correspond vertic cg let log1 place transit interv s1 evenli n length transit interv jt algorithm input word w length 1 1 log8km choos r random run w length 2 i1 2 admiss triplet j1 2 j one follow form automata j 1 j describ discard chosen run end begin place p jp n j j n128km log1 name run one end closer n128km log1 remain run r r fall n j n j1 check whether feasibl automaton j start b n rst coordin r w name place r start rel n j place w enter j 3 admiss triplet check run turn feasibl output ye otherwis ie case admiss triplet least one infeas run found output lemma 28 distw l n algorithm output probabl least 34 w 2 l algorithm alway output ye proof proof contain two independ part rst consid case input w distw l n algorithm answer high probabl part treat case w 2 l algorithm answer ye let us rst assum distw l n number admiss triplet partit point fall union transit interv estim rst choos admiss path cg number admiss path 2 k subset vertic cg dene one path span choos portal total number chosen portal 2k therefor jv j 2k possibl choic portal xed sjt j choic n j 2 j k satisfi condit express 1 2k thu need check 1 2k admiss triplet let admiss triplet satisfi restrict formul step 2 algorithm write triplet dene automata languag l describ lemma 27 1 j one n2k lemma 26 exist 1 log8km contain least 2 4 n2km log8km run length 2 i1 may touch last bit interv n 1 may touch rst bit interv henc least 2 6 nkm log1 2 touch neither rst last n128km log1 bit interv obvious random sampl contain one infeas run provid certic fact w admiss triplet random sampl r run length 2 i1 miss infeas run probabl 2k thu union bound conclud case random sampl contain wit feasibl triplet probabl 14 complet proof case distw l n address case w 2 l need show case algorithm answer ye enough show w 2 l exist admiss triplet pass success test algorithm travers w natur dene triplet follow compon cg order accord order travers w rst resp last state c visit w set rst time w enter travers howev partit necessarili meet requir state step 2 algorithm true travers w transit c j c j1 might occur outsid transit interv show desir triplet obtain actual triplet modifi third compon modi triplet would correspond dierent word w quit close w make transit insid postul transit interv addit take care queri made bit w 0 dier w henc algorithm actual consist fact reason discard run close n j step 2 algorithm intuit done follow assum n j transit interv either make travers longer end p 2 transit interv shorten travers c enter transit interv depend closest transit interv formal done follow dene new partit choos transit interv closest n j c truli connect compon choos n 0 j leftmost coordin satisfi follow restrict n 0 singleton without loop set n 0 n 0 exist final set note obtain triplet truli connect exist path p 1 j p 2 length n j1 n j 1 also exist path length n 0 j 1 impli admiss 0 henc admiss let r run w insid n 0 j1 n128km log1 let b rst coordin sinc place transit interv ft g evenli n jn 0 therefor r fall also complet insid n remark point purpos discard margin run step 2 algorithm achiev one remain run fall complet within n 0 j1 also within see immedi guarante r feasibl correspond automaton j without delet posit probabl one sampl run r may start place w c end place w c j thu make imposs attribut r one particular automaton j therefor posit probabl algorithm would fail posit case discard margin run allow us get onesid error algorithm w 2 l exist state q 2 c q r 2 c also q reachabl p 1 initi state c step b rst coordin r accord choic n 0 j period c lemma 23 q reachabl p 1 step show r feasibl j start b n 0 1 thu w 2 l algorithm alway output ye 2 final number bit w queri algorithm log8km x log8km x thu proven follow theorem theorem 1 everi regular languag l everi integ n everi small enough 0 exist onesid error test algorithm l f0 1g n whose queri complex c log 3 1 constant c 0 depend l nal note depend complex paramet place proof consid xed algorithm tailor xed given languag howev calcul kept depend queri complex paramet explicit one take mind though estim hold condit hold particular requir third item 1 anoth note run time algorithm rather queri complex domin term step 1 rst two subset step 2 algorithm queri complex last substep run check j check involv check whether word u word v suitabl length urv 2 l check whether u v done directli lemma 23 case length u v longer check word one shorter 3 lower bound regular languag mani testabl question quit natur expect lower bound order 1 queri complex test usual proven take posit exampl size n perturb randomli chosen n place creat neg instanc hard distinguish posit one regular languag except respect shown next proposit fairli simpl proof proposit 1 let l regular languag alphabet f0 1g dene 1g n test l f0 1g n queri complex least 1 3 proof proof base follow reformul renown principl yao 14 say exist probabl distribut union posit neg exampl determinist test algorithm queri complex correct probabl less 23 input randomli chosen accord distribut lower bound queri complex random test algorithm dene distribut set posit neg instanc length n follow word get probabl 12 next partit index set 1 n size n 1 give probabl 12t vector creat 1 n ip bit 1 0 note disti neg instanc appli mention principl yao let determinist test algorithm queri complex incorrect word 1 n alreadi incorrect probabl least 12 otherwis accept input test bit equal 1 therefor accept well least input show give incorrect answer probabl least d2t 13 impli t3 2 main idea proof proposit use get lower bound queri complex test nontrivi regular languag natur denit nontrivi proven next proposit somewhat paradox featur proof main posit result theorem 1 proof use get neg result languag l let l denit 31 languag l nontrivi exist constant 0 0 1 innit mani valu n set l n nonempti exist word w 2 f0 1g n distw l n 0 n proposit 2 let l nontrivi regular languag sucient small 0 test algorithm l requir queri proof proof essenti gener proof proposit 1 thu present somewhat abridg form let n larg enough assum l n 6 w 2 f0 1g n distw l n 0 n may clearli assum constant 0 small need purpos main result theorem 1 proof impli probabl least 23 random choic set run built describ step 1 test algorithm theorem 1 total length algorithm reject w notic test algorithm one side error ie alway accept word l thu choos random set run caus reject w probabl 23 coincid word u 2 l n otherwis would reject u random set run random set interv ng length dene step 1 test algorithm total length bound two random set intersect probabl n therefor choos n subset random expect 2 n pair intersect 23 member reject w impli exist famili disjoint set run member word l n coincid w set fix 0 let 0 small enough compar 0 partit famili cardin n constant c depend 0 thu independ let u word l n 1 word w obtain u chang bit u correspond w follow inde transform w word l n least one bit chang everi member proof proposit 1 dene probabl distribut union posit neg exampl word u get probabl 12 one word w probabl 12t simpl argument essenti ident proof proposit 1 show determinist algorithm need queri least 3 bit input word success probabl least 23 dene probabl distribut appli yao principl get desir result 2 4 testabl contextfre languag essenti complet analysi testabl regular languag quit natur tri make one step address testabl much complex class contextfre languag see eg 8 background inform turn gener situat chang drastic compar case regular languag show exist quit simpl contextfre languag testabl turn attent one particular famili contextfre languag socal dyck languag prove rst languag famili testabl time polynomi 1 languag famili alreadi nontest relev denit proof follow 41 contextfre languag nontest alreadi mention contextfre languag testabl proven follow proposit theorem 2 test algorithm contextfre languag revers word w requir n queri order error 13 proof let n divis 6 dene distribut union posit neg input follow way neg instanc chosen uniformli random among neg instanc ie word w 2 f0 1g n distanc least n l refer distribut n posit instanc gener accord distribut p dene follow pick uniformli random integ k interv n6 select posit exampl uniformli among word vv r uu r k final distribut input dene follow probabl 12 choos posit input accord p probabl 12 choos neg input accord n note posit instanc actual pair k w word w may gener use dierent ks use mention yao principl let determinist test algorithm l show maximum number queri n expect error respect least 1 algorithm view binari decis tree node repres queri certain place two outgo edg label 0 1 repres possibl answer leaf repres end possibl comput label posit neg accord decis algorithm trace path root node associ node pair q ng set queri input word f vector answer receiv algorithm may obvious assum full binari tree height thu 2 leav jq leaf use follow notat subset q ng function f f qg f qg set neg resp posit instanc length n consist pair q f also probabl distribut set binari string length n subset dene pr w2e pr w set leav label posit let 0 set leav label neg total error algorithm distribut pr theorem follow follow two claim 41 everi subset q ng cardin pr e q f 42 everi subset q ng cardin n everi function f pr base claim 41 42 estim error algorithm pr theorem follow 2 present proof claim 41 42 proof claim 41 notic rst l 2 n2 n2 word length n rst choos word length n2 cut two part v u thu get word number word length n distanc less n l jl f0 1g n j log1n get follow denit pr e q f proof claim 42 follow denit distribut word w 2 lf0 1g n pr recal f set word l consist f set queri q henc pr observ pair place q two choic k pair symmetr respect k n2 k impli n6 2 choic k set q contain pair symmetr respect k n2k k therefor pr conclud remark subsect would like note next subsect theorem give anoth proof fact contextfre languag testabl show nontest dyck languag 2 howev prefer give theorem 2 well due follow reason first languag discuss theorem 2 simpler natur dyck languag 2 secondli lower bound theorem 2 better theorem 4 proof two theorem mani common point reader may view theorem 2 warmup theorem 4 42 testabl dyck languag would extrem nice determin exactli contextfre languag testabl present seem far fulll task howev abl solv question complet one famili contextfre languag call dyck languag integ n 1 dyck languag order n denot n languag alphabet 2n symbol group n order pair languag n dene follow product 2 3 denot empti word though word n binari accord denit easili encod grammar describ use 0s 1s thu may still assum framework languag binari alphabet interpret n languag n distinct pair bracket word w belong n form balanc bracket express basic well known languag famili 1 one pair bracket dyck languag play import role theori contextfre languag see eg 4 relev discuss therefor task explor testabl interest rst goal subsect show languag 1 testabl let us introduc suitabl notat first sake simplic denot bracket assum n larg enough even number obvious odd n 1 f0 1g noth test case let w binari word length n 1 n denot xw number 0s rst posit w also yw stand number 1 0 rst posit w follow claim 43 word w belong 1 follow two condit hold xw proof follow easili denit 1 exampl induct length w omit detail proof 2 proof observ rst claim 43 word w 1 partit letter pairwis disjoint pair left letter pair zero right letter one consid bipartit graph whose two class vertic set indic set indic respect connect assumpt defect form hall theorem graph contain match size least yw n 1 assumpt b yw n n2 2 2 therefor least n2 2 2 1 disjoint pair letter w pair zero left one right let us pair remain element w arbitrarili pair one consist either two 0s two 1s chang need left entri pair 0 right entri 1 obtain word 1 total number chang perform 2 complet proof 2 1 n one yw xw distw 1 s2 b proof follow immedi claim 43 2 conclud three claim word w far 1 coordin deviat signicantli necessari sucient condit provid claim 44 observ use analysi algorithm test 1 propos c 0 sucient larg constant whose valu chosen later assum even integ follow omit oor ceil sign simplifi present algorithm input word w length 1 choos sampl bit follow way bit w independ probabl choos contain ye without queri bit els 2 dist 1 f0 1g 0 lemma 46 algorithm output correct answer probabl least 23 proof alreadi mention set proof contain two independ part rst prove algorithm correct probabl second part prove algorithm bound error word w distw 1 n consid rst posit case w 2 1 set assum simplic well nt integ 1 j let x j number 0s sampl interv 1 njt let also j denot number 1s sampl interv x j j binomi random variabl paramet xw njt p yw njt p respect w 2 1 get claim 43 xw njt yw njt impli ex j ey j appli standard bound tail binomi distribut obtain note ez j npt use similar argument get w 2 1 claim 43 xw henc final follow estim distribut sampl size jsj choos c larg enough recal denit deriv 14 probabl least 23 follow event hold simultan 1 2 3 x np 4 jsj np assum four condit satis claim dist 1 inde rst two condit guarante 1 jsj ys xs 22npt 23 last two condit provid xs jsj ys therefor claim 44 algorithm accept w probabl least 23 requir end rst part proof let us consid neg case assum distw 1 f0 1g n n claim 44 least one follow two condit hold exist index 1 n yw xw n2 b xw n yw n n2 former case let x number 0s 1s respect sampl interv 1 let also k number element 1 chosen binomi distribut paramet xw p yw p respect follow denit ey ex np2 choos constant c sucient larg recal denit p see probabl 16 ys follow claim 45 xw n yw n n2 obtain use similar argument probabl made 16 choic c xs jsj ys jsj 2 follow claim 45 dist 1 thu case obtain algorithm accept w probabl 16 addit algorithm may accept w case rst item algorithm howev equat 4 may bound 16 choos c rst part henc algorithm reject w probabl least 23 complet proof lemma 46 2 lemma 46 follow result testabl dyck languag 1 theorem 3 everi integ n everi small enough 0 exist test algorithm queri complex c log1 2 absolut constant c 0 reader possibl notic one signic dierenc algorithm section 2 test regular languag algorithm test 1 algorithm test regular languag onesid error algorithm section twosid error coincid show onesid error algorithm test membership 1 whose number queri bound function inde assum onesid error algorithm test 1 consid execut input word easi see distu 1 n therefor must reject u probabl least 23 fix sequenc coin toss make reject u denot q correspond set queri bit u claim jq1 n2nj n2 n exist word w length n 1 2 q prove claim may clearli assum jq 1 n2 follow take rst n indic 1 n2 set last n indic 1 n2 sucient condit membership 1 given claim 43 inde point j 1 n2 n number 0s rst j bit w least larg number 1s also j n2 therefor w 2 1 assum onesid error algorithm alway accept everi must jq 1 n2 queri linear n number bit proven follow statement proposit 3 onesid error test membership 1 queri n bit word length n next goal prove dyck languag name k k 2 nontest present detail proof statement 2 clearli impli result k 3 sake clariti exposit replac symbol denit 2 respect 2 dene follow contextfre empti word mind mention bracket interpret dyck languag sometim refer 0 2 left bracket 1 3 right bracket note use encod 2 languag f0 1g rather alphabet size 4 clearli nontest 2 dene impli nontest binari encod 2 obtain xed binari encod f0 1 2 3g theorem 4 languag 2 testabl proof let n larg enough integ divis 8 denot l use yao principl assign probabl distribut input length n show determinist algorithm probe bit output incorrect answer probabl 05 o1 posit neg word compos three part rst sequenc match 01 bracket rst kind follow sequenc 02 left bracket sequenc 13 right bracket posit instanc gener accord distribut p follow choos k uniformli random rang given k word length n length n 2k gener choos vi random 0 2 set vn 2k1 neg instanc chosen follow process similar posit case except restrict vn 2k 1 name choos k random rang given k word length n length n 2k gener choos vi random 0 2 choos vn 2k 1 random 1 3 let us denot n distribut stage note word gener may distanc less n l n fact word l n gener henc condit n event word distanc least n l n probabl distribut input length n dene choos probabl 12 posit instanc gener probabl 12 neg instanc chosen accord describ process 47 probabl instanc gener accord n nclose word l n exponenti small n proof fix k let word length n gener n xed k three part w rst part match 01 length 2k second part random sequenc 02 length n 2kand third part random sequenc 13 length n 2k let us denot three disjoint set indic w bound number word w length n form 2kwhich distanc n l n first choos valu w n 2 give 2 n 2kpossibl choos n bit w chang get word l n n choic set bit 4 n possibl point part w still set valu n 3 allow use right bracket 1 3 word obtain belong l n easi see one way complet current word word l n use right bracket henc number word altogeth 2 n 2k total number word w form 0 word get probabl distribut n therefor probabl word chosen accord n nclose l n estim n4 n2n n small enough 0 promis 2 xed set place let k chosen uniformli random rang n8 n4 contain pair j symmetr respect n 2k2 probabl 8 n proof distinct pair uniqu k symmetr respect point henc probabl bound 8 return proof theorem 4 let algorithm test l n queri queri may assum nonadapt name queri xed set place size everi adapt made non adapt queri ahead 2 possibl queri dene two possibl branch adapt queri look queri possibl set answer f input event w consist f let nosym event contain symmetr pair respect n 2k2 also let f 0 denot f algorithm answer let f 1 f answer ye final denot w posit w neg event random w posit instanc neg instanc respect total error algorithm howev given contain symmetr pair xed f probf w w neg essenti equal probf w w posit probabl would exactli equal neg w would gener accord n claim 47 assert n exponenti close real distribut neg instanc henc probabl 05probf w jnosym o1 plug sum use claim 48 get error probabl bound probnosym f 05 o1probf w jnosym 1 8 conclud remark main technic achiev paper proof testabl regular languag possibl continu research describ class testabl languag formul sucient condit contextfre languag testabl recal theorem 2 shown contextfre languag testabl one natur way describ larg class testabl combinatori properti put restrict logic formula dene particular restrict ariti particip relat number quantier altern order logic express rst order second order etc result present paper exampl approach sinc regular languag exactli express second order monad logic unari predic embed linear order anoth exampl found sequel paper 1 address testabl graph properti dene sentenc rst order logic binari predic complement class graph properti shown testabl goldreich et al 7 analog result predic higher ariti would desir obtain technic diculti aris ariti greater two long term goal propos systemat studi testabl logic dene class sinc mani dierent type logic framework known nd one suit studi challeng virtual singl problem look far perspect captur gener logic dene class member testabl properti dierent avenu tri develop gener combinatori techniqu prove lower bound queri complex test arbitrari properti possibl nding analog block sensit 12 fourier analysi 11 approach decis tree complex present candid combinatori condit would necessari sucient testabl acknowledg would like thank ode goldreich help comment also grate anonym refere care read r proof veri proof conjectur erd properti test connect learn approxim introduct automata theori bound solut linear diophantin problem new direct test degre boolean function real polynomi robust character polynomi applic program test probabilist comput tr ctr michal parna dana ron ronitt rubinfeld test membership parenthesi languag random structur algorithm v22 n1 p98138 januari beat bollig larg lower bound queri complex simpl boolean function inform process letter v95 n4 p423428 31 august 2005 beat bollig ingo wegen function readonc branch program quadrat size necessarili testabl inform process letter v87 n1 p2529 juli eldar fischer strength comparison properti test inform comput v189 n1 p107116 25 februari 2004 eldar fischer eric lehman ilan newman sofya raskhodnikova ronitt rubinfeld alex samorodnitski monoton test gener poset domain proceed thiryfourth annual acm symposium theori comput may 1921 2002 montreal quebec canada eli bensasson prahladh harsha sofya raskhodnikova 3cnf properti hard test proceed thirtyfifth annual acm symposium theori comput june 0911 2003 san diego ca usa alon test subgraph larg graph random structur algorithm v21 n34 p359370 octob 2002 eldar fischer ilan newman ji sgall function readtwic constant width branch program necessarili testabl random structur algorithm v24 n2 p175193 march 2004 alon asaf shapira everi monoton graph properti testabl proceed thirtyseventh annual acm symposium theori comput may 2224 2005 baltimor md usa asaf shapira combinatori character testabl graph properti regular proceed thirtyeighth annual acm symposium theori comput may 2123 2006 seattl wa usa alon asaf shapira test subgraph direct graph proceed thirtyfifth annual acm symposium theori comput june 0911 2003 san diego ca usa alon asaf shapira character easili testabl induc subgraph proceed fifteenth annual acmsiam symposium discret algorithm januari 1114 2004 new orlean louisiana