transform net intermedi languag use path logic program path logic program modest extens prolog specif program transform give inform introduct extens show use code standard compil optimis also number obfusc transform object languag microsoft net intermedi languag il b introduct optimis obfusc refactor tool need appli program transform automat furthermor applic desir one easili experi transform vari applic condit also strategi transform appli paper introduc variat logic program call path logic program specifi program transform declar yet execut manner separ languag strategi use control applic order permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee ppdp02 octob 68 2002 pittsburgh pennsylvania usa illustr idea consid net intermedi languag il type represent use backend compil mani dierent program languag 15 22 il quit close highlevel lan guag particular c 2 17 eas one convert il c obfusc il import 8 main exampl therefor drawn literatur obfusc also consid standard compil optimis structur paper follow first provid brief introduct il variant il use appli program transform inde write decompil next introduc main idea path logic program extens standard prolog explain use idea transform il pro gram preliminari present concret exampl first simpl optimis complex obfusc transform 2net core microsoft net platform intermedi languag varieti dierent sourc languag compil similar java bytecod although rather complex specif design conveni compil target multipl sourc lan guag program distribut intermedi languag justintim compil nativ code target platform paper shall concern rel small subset languag ongo work expand scope transform system il stackbas languag fragment shall consid instruct load liter valu onto stack ldc creat new array alloc heap newarr load store valu local variabl method argument stack ldloc ldarg stloc starg standard arithmet boolean comparison oper intuit name oper sole stack valu final instruct noth branch condit uncondit return method nop brfals brtrue br ret program must verifi purpos mean possibl establish static type item stack posit instruct sequenc also mean particular posit stack must height time flow control reach posit stackbas natur il make dicult formul even quit simpl condit il code exampl assign might repres il sequenc add sub stloc result condit recognis assign would need quit long problem becom much wors complic express especi branch controlflow occur valu stack therefor first step take convert il express il eil languag abstract il stack replac stackbas comput expr sion introduc new local variabl hold valu would previous store stack fact deal verifi il make translat possibl first stage simpli introduc one extra local variabl stack locat replac il instruct appropri assign thu would becom someth like left transform describ later merg assign togeth give origin assign 1 eil analog jimpl grimp languag soot framework 29 30 initi translat produc code similar threeaddress code jimpl assign merg leav us proper express like grimp concret syntax omit mani signific detail eil exampl express type arithmet oper multipl version dierent overflow han dling shall return structur eil section 4 fragment eil consid enabl us make mani simplifi assumpt would invalid whole languag particular ignor alias problem paper 3 path logic program simpl optimis perform atom propag case atom valu taken constant local variabl paramet pass valu method intent local variabl assign atom valu neither variabl valu redefin use variabl replac atom valu essenc atom propag rewrit rule sx stand statement contain variabl x v statement x replac natur valid rule requir x variabl hold valu v whenev statement x reach formul x v metavari instanti appropri fragment program wish transform wish appli propag v atom valu introduc repeat comput easi implement rewrit logic program languag make particularli easi keep track bind metavari see eg 16 28 deed observ prompt de volder propos use prolog appropri framework program transform 13 go one step extend prolog new primit help us express side condit found transform atom propag prolog program interpret rel flow graph object program transform new primit predic hold true n node flow graph path n form specifi pattern q furthermor least one path satisfi pattern q shall justifi slightli nonintuit condit later pattern regular express whose alphabet consist logic program goal illustr let us return atom propag predic propagaten x v hold true transform applic node n flow graph appropri bind x v exampl predic evalu rel flow graph figur 1 possibl bind definit propag term new primit setx v localx usex entri n definit say path program entri node n satisfi particular pattern path figur 1 exampl flow graph sequenc edg flow graph path pattern regular express exampl consist four compon path first start zero edg particularli care indic shall see shortli interpret predic hold true alway next encount edg whose target node assign form x v x local variabl v atom worth attempt propag next zero edg node redefin x valu v final reach edg point use variabl x pattern satisfi one particular bind path entri n fragment curli bracket ordinari logic program goal except use tick mark front predi cate predic properti edg exampl predic take two argument variabl x edg e hold true edg point node x assign similarli usex e true target e node label statement make use x place tick mark front predic insid path pattern current edg ad final paramet predic call return requir least one path node n predic q n hold suppos insist restrict node n exist path entri node propagaten succeed valu x v would lead nonsens situat tri appli tran format could cours specif add check definit propag avoid would requir mani predic found requir hindranc also pragmat reason requir implement primit demand 12 may seem rather unnatur repres path sequenc edg rather sequenc node given pattern usual examin target node edg rather edg howev use edg rather node give us slightli power particular allow us specifi path goe els branch statement although thu far made use extra power wish rule possibl futur 31 syntax semant figur 2 summaris syntax extend version prolog two new form predic name exist take path pattern two term term meant design node say predic p b hold true path b form indic p exist least one path form predic exist p b simpli requir exist one path form pattern regular express whose alphabet given tempor goal oper repres sequenti com posit repres choic zero occurr empti path tempor goal list tempor predic enclos curli bracket tempor predic either ordinari predic like atom exampl examin tick predic like use think pattern usual way au tomata edg label tempor goal turn tempor goal interpret properti edg flow graph pattern hold edg e constitu hold edg e check whether tick predic hold e simpli add e paramet given predic nontick predic ignor e shall write g e interpret tempor goal g edg e precis mean exist exist mean word exist path flow graph sequenc goal pattern lead initi state final state automaton q goal hold correspond edg univers path pattern similarli defin except requir least one path satisfi given pattern wit mean exist word exist path desir form addit path form predic pattern term term exist pattern term term predsymterm term notpred predic pattern tpred tpred pattern pattern pattern tpred predic predsymterm term figur 2 syntax path logic program point worth mention propos add tempor featur prolog mean new idea 25 applic featur specif program transform howev appear novel 4 transform eil graph 41 logic term eil remark earlier abstract syntax eil carri quit lot detail inform express reflect represent express logic term thu integ liter 5 becom logic term expr type constructor reflect fact express type first paramet express second type type inttru b32 32bit sign integ true would becom fals want unsign one construct constant liter constructor ldc use take type paramet redund simplifi process eil part transform system liter valu slightli complic exampl express x local variabl repres inttru b32 inttru b32 inttru term localvarsnamex refer local variabl x seemingli redund constructor sname reflect fact also possibl use dierent constructor refer local variabl posit method declar list although facil current use constructor applyatom exist simplifi relationship il eil term addfals true directli correspond il instruct add add top two item stack sign valu without overflow thu mean applyatom summaris ap pli il instruct first paramet rest paramet stack final remain explain eil instruct defin shall use label edg node flow graph instruct either expr sion branch return statement combin list label statement use constructor instr label exampl follow defin condit branch label target branchcond note borrow notat list function program write lieu x xs current instruct express exp enclos express would use place branch similarli return use case return statement eil constructor shall introduc encount 42 defin condit eil term node graph label logic term correspond eil instruct node ad dition describ earlier edg label term eil instruct node edg point label use solv existenti univers queri anticip futur version system complex analysi inform store node edg inform dier node edg logic languag provid primit access relev label given node edg elabel hold instruct edg e vlabelv hold instruct node v use convent give primit name begin thu defin set predic use section 3 follow e expexpr elsewher adopt prolog convent singleton variabl name identifi start underscor straightforward defin def term set e setx also need defin use base predic occursr x check whether x occur r obviou recurs travers defin usex e want distinguish use x definit x whilst still find use variabl x express ax usex e elabel occurss x usex e set l r e occursr x 43 modifi graph although logic languag describ make conveni defin side condit program transfor mation would rather dicult use languag actual appli transform sinc would requir program flow graph repres logic term approach take success logic queri also bind paramet list symbol action defin correct transform flow graph highlevel strategi languag respons direct order logic queri tri appli result transform strategi languag similar found literatur rewrit 5 31 shall discuss action term either form replac vertexv w new localt n former replac vertex v vertex w latter introduc new local variabl name n type thu overal propag rewrit defin follow propag rewritereplac vertex n predic buildn v creat new vertex copi old vertex n replac use x vlabeln old listof new vertex new es alreadi discuss primit vlabel predic construct term new old replac use x v use defin appli definit x replac x 0 x x 1 want end x 01 new vertic construct use new vertex primit take vertex label list outgo edg bind new vertex final paramet case use list edg old vertex sinc wish replac label predic sourcen e true vertex n sourc edg e whilst listof predic standard prolog predic take three paramet term predic involv free variabl third paramet bound list instanti solv predic thu overal eect listof e sourcen e es bind es outgo edg node n requir 5 optimis remaind paper consist exampl intend evalu design sketch shall first examin number typic compil optimi sation present context transform use clean code result either translat il eil obfusc partic ular examin dead assign elimin form constant fold dead branch elimin chosen repres list howev exhaust essenti appli conjunct transform embark detail code therefor summaris one transform particularli import discuss section 2 transform il eil creat mani extra local variabl exampl il instruct stloc x translat someth form easili seen assign combin give newli creat local variabl gener use except origin il code control flow split program point valu stack local variabl use assign propag regardless whether valu assign atom long valu chang meantim transform carri propag follow similar pattern atom propag defin section 3 shall spell detail 51 dead assign elimin propag atom valu remov uniqu variabl use describ place code variabl assign valu use afterward assign replac nop subsequ transform remov nop complet conveni two phase mani transform remov code would otherwis care preserv label remov instruct case jump label exist let us look condit need transform pure exist setx v localx entri n note although use exist queri realli need case look singl node satisfi certain condit entir path howev turn conveni express queri way predic use alreadi defin respect edg first part condit state need express form x v node n also requir x local method v pure ie side eect condit defin standard prolog predic second part condit requir node n x longer use except node n anoth definit x exit method bodi reach first defin predic unus captur first half requir note permiss use negat sinc x alreadi bound ground term unus atn x e isnoden e unus atn x e notusex e defin path condit unus unus atn x word path node n exit use node n unless first redefin x transform appropri use build produc new vertex sinc entir assign need replac nop instead vertex creat manual dead codereplac vertex n pure assignmentx v n unus listof vlabeln instr label new vertex instr label l expexpr typeapplyatomnop void es nopvert 52 evalu elimin uniqu use variabl atom valu propag perform often left express involv constant could evalu exampl z would transform z would like right hand side assign replac 52 need predic tri evalu arithmet oper constant express tri evalu bind result integ j base case state valu constant constant evalapplyatomldcinttru b32 n n anoth claus eval evalu addit eval v1 evalr v2 v v1 v2 note inspect overflow sign bit ov semant dictat futur version implement employ reflect ensur semant compiletim evalu exactli runtim evalu use eval eil express leav us integ succe convert back eil inttru b32 appli evalu node look nonatom express node allow atom express evalu constant valu would repeatedli transform replac express valu eval succe evaluatereplac vertexn exist usef entri n buildn ce f use build replac origin express f ce 53 dead branch elimin one obfusc see section 622 add condit branch program evalu condit branch elsewher may find constant condit therefor redund keep specif il assum true defin nonzero integ first need find suitabl condit branch specifi predic test whether vertex condit branch instruct cond branchcond label e labellabel branchcondcond use find true branch look constant condit whose valu nonzero replac branch vertex nop point true branch dead assign elimin simpler overal replac branch statement true vertex dead branchreplac vertex branchvert exist cond branch applyatomldcinttru b32 n inttru b32 label entri branchvert listof edg sourcebranchvert edg trueedg new vertex instr label label expexpr typeapplyatomnop void nopvert use listof discuss earlier obtain list outgo edg branchvert graph represent guarante edg order true branch first fals branch repeat definit requir n equal 0 condit replac trueedg falseedg construct nopvert 6 obfusc rel easili decompil il code back highlevel languag c therefor softwar distributor wish avoid sourc code reveal exampl prevent tamper protect secret algorithm need take step make harder one possibl obfusc il code distribut although prevent decompil complet like imposs especi case verifi il code appli transform make sourc code result decompil dicult understand might accept altern section show path logic program use give formal execut specif two repres exampl collberg taxonomi obfusc transform 8 variabl transform array split 61 variabl transform idea variabl transform pick variabl local method replac occurr method new variabl j relat need function f biject domain z subset z potenti valu known rang z could subset also need f invers f exist f biject transform need perform two type replac express form e definit transform j f use ie definit replac f 1 j 611 exampl let us take f program brif 15 loop transform brif j 2 15 loop could also defin transform conduct algebra simplif would turn brif j 30 loop 612 implement transform initi phase transform find suitabl variabl requir variabl assign somewher local choos variabl oldvar gener fresh variabl name use fresh name take type paramet name gener reflect type well produc action add new local variabl method follow introduc local predic return old new local variabl need next phase actual transform use definit old variabl introduc localoldvar newvar new localinttru b32 exist setoldvar v inttru entri oldvarvert fresh nameinttru b32 newvarnam snamenewvarnam inttru b32 new local introduc carri obfusc exhaust replac use definit old variabl appropri first specifi predic build represent function f outlin section 611 predic use fna b bind b represent f 1 use fn applyatomcdivtru ldcinttru b32 2 inttru b32 inttru similarli defin assign fnc bind represent f c simpl replac use oldvar replac useoldvar newvar replac vertex oldvert newvert exist useoldvar entri oldvert use fnnewvar newus buildoldvert newus oldvar newvert similarli replac assign oldvar 62 array transform method use one array rearrang array exampl permut element one merg two array one split one two separ array essenc array transform type variabl transform key point access use definit element one origin array translat access element one transform array one origin array use entireti exampl assign anoth array would need replac code dynam appli transform entir array could major impact runtim perform program therefor avoid appli array transform situat would necessari consid arraytyp local variabl array transform appli everi path method reach particular initialis variabl newli creat array use il instruct newarr occurr array variabl reach initialis access element array rather use definit array variabl 621 array split obfusc go specifi array split idea array split take array place element two new array necessari defin function determin element origin array map ie array posit array let us look simpl exampl suppos array size n want split two new array b1 b2 want b1 b2 size possibl dier one ele let b1 size n 1 div 2 b2 size n div 2 relationship b1 b2 given follow rule b1 div 2 even program int new int20 int brif 20 loop transform int b1 new int10 int b2 new int10 int i2 els b2i 12 brif 20 loop els strictli part eil implement term branch obviou 622 specifi transform gener suppos array size n defin array split two array need three function c f 1 f 2 two new array b1 b2 size m1 m2 respect m1 m2 n type function follow relationship b1 b2 given follow rule ensur index clash new ar ray requir f 1 f 2 inject also make sure element fairli distribut b1 b2 mean c partit 0n approxim equal piec 623 find suitabl array show implement array split use transform outlin exampl section 621 let us look condit necessari transform first need find place array initialis array initialiseinitvert oldarray type exist setoldarray applyatom newarrt inttru b32 arraytyp arraytyp ctype type spectyp entri initvert condit state initvert instruct form oldarray newarrtypes oldarray local variabl array type standard represent type il use far known ctype howev type paramet newarr take slightli dierent form known type spec use predic ctype type spec compar two thu make sure deal welltyp array initialis next step check everi path method reach initialis point array variabl use except access array element predic unindexedoldarray e hold oldarray use without index node point edg e give us follow condit ok transforminitvert oldarray isnodeinitvert unindexedoldarray entri exit 624 initialis new array next need creat two new array correct size size old array n size new array n 12 n2 defin predic div two plu one div two construct appropri express given origin array size sinc express comput origin array size might side eect quit complic first introduc new local variabl hold valu express repeat comput thu need construct three new vertic replac initvert one initialis local variabl two initialis new ar ray omit detail minor diculti new vertex requir list outgo edg construct new edg requir target vertex must construct vertic revers order appear graph 625 replac old array next step exhaust replac occurr old array occurr follow newli insert initialis need insert dynam test index old array access access one two new array depend result dynam test find occurr straightforward defin predic array occursa e look occurr form ai e search node occur initialis second new array whose vertex bound secondinitvert find old arrayoldarray exist array occursoldarray index secondinitvert occursvert use newli bound valu index construct necessari node replac occursvert omit detail 7 relat work paper contribut extens literatur specifi program analys transform declar style section shall survey close relat work directli prompt result present apt system paig 26 major sourc inspir work present apt program transform express rewrit rule side condit express boolean function abstract syntax tree data obtain program analys function way similar present gone littl embed variant prolog contrast apt analys code hand norm similar system construct highperform comput commun mt1 4 tool restructur fortran program anoth dierenc system transform tree structur rather flow graph learnt idea take graph rewrit basi transform toolkit work assmann 3 whitfield soa 32 assmann work base gener notion graph rewrit highli declar natur littl dicult ever express properti program path whitfield soa system allow express properti number primit specialis predic p main contribut rel work generalis embed prolog use path pattern examin graph struc ture contain logic variabl borrow literatur queri semistructur data 6 existenti path pattern consid rel work contribut explor util univers path pattern well liu yu 20 deriv algorithm solv regular path queri use predic logic languag inclus although pattern yet support free variabl purpos essenti appli transform case use prolog vehicl express program analys forc made 11 research team went emb model checker prolog 10 inde inspir implement exist primit tabl kri de volder work taught us use prolog appli program transform 13 8 discuss present modest extens prolog name path logic program extens modest syntact semant term introduc two new form predic easi compil standard prolog primit result program use tabl conduct depthfirst search product automaton determinis pattern flow graph 12 could chosen give specif term modal logic instead regular express inde modal logic specif start point line research 19 believ regular express littl conveni may due familiar formal comparison express altern style would valuabl 81 shortcom number problem need overcom idea present appli practic transform need take account alias recent updat implement add prolog primit conduct alia analysi demand altern approach would annot graph alia inform ecienc would desir prolog interpret proce increment work done transform reus afterward current implement oblivi previou work therefor ineci current develop algorithm address concern hope abl report result soon deal mutual recurs procedur would accur describ path program contextfre grammar instead tradit flow graph 23 engag implement system three problem main idea compil logic goal form q standard analysi 1 allow smooth integr standard data flow analys also reus previou work increment comput analys howev requir us make step standard logic program prolog inequ constraint program languag path logic program would greatli benefit static type disciplin experi program error come build syntact wrong eil term could easili caught type system mercuri 27 fact mercuri alreadi net implement 14 argument integr new featur languag rather standard prolog current implement languag standard ml transform involv scope inform tricki keep track exact bind inform possibl variabl captur framework provid support handl diculti automat diculti solv higherord logic program 24 hope integr idea work later stage transform sidecondit quickli becom quit complex readabl result descript prolog someth concern hope judici modularis prolog program appropri use strategi languag separ dierent transform address issu experi requir determin whether actual work practic larg set complex transform 82 applic path logic program might applic beyond present exampl aspectori program one need specifi set point dynam call graph 18 current languag propos specif pointcut somewhat ad hoc path logic program could provid principl alterna tive furthermor could use transform technolog present achiev compiletim improv aspectori program 21 anoth possibl applic path logic program static detect bug path queri could use look suspect pattern code inde natur pattern dawson engler work bug detect 7 similar present first note variant logic program would wellsuit applic area roger crew design languag astlog inspect annot abstract syntax tree 9 suggest work extend inspect program path thu make connect extens literatur softwar model check 83 acknowledg would like thank colleagu program tool research group oxford mani enjoy discuss topic paper would also like thank david lacey krzysztof apt hidehiko masuahara paul kwiatkowski three anonym ppdp review mani help comment stephen drape ganesh sittampalam support research grant microsoft research 9 r insid c specifi program analysi transform graph rewrit system transform mechan mt1 queri languag algebra semistructur data base structur recurs check system rule use systemspecif taxonomi obfusc transform astlog languag examin abstract syntax tree logic program model check practic program analysi use gener purpos logic program system case studi univers regular path queri compil mercuri logic program approach implement higherord term rewrit programm introduct c imper program transform rewrit solv regular path queri compil semant aspectori program technic overview commmon languag infrastructur interconvert class set constraint contextfre languag reachabl overview tempor modal logic program view program transform system work logic program programm optim java bytecod use soot framework feasibl languag program transform base rewrit strategi approach explor code improv transform tr compil principl techniqu tool logic program approach implement higherord term rewrit practic program analysi use gener purpos logic program systemsmyampersandmdasha case studi approach explor code improv transform interconvert class set constraint contextfreelanguag reachabl programm introduct c 2nd ed insid c univers regular path queri overview tempor modal logic program logic program model check uniformli specifi program analysi transform graph rewrit system optim java bytecod use soot framework imper program transform rewrit solv regular path queri view program transform system work unql queri languag algebra semistructur data base structur recurs soot java bytecod optim framework ctr mathieu verbaer ran etting oeg de moor jungl script languag refactor proceed 28th intern confer softwar engin may 2028 2006 shanghai china yanhong liu tom rothamel fuxiang yu scott stoller nanjun hu parametr regular path queri acm sigplan notic v39 n6 may 2004 ganesh sittampalam oeg de moor ken frii larsen increment execut transform specif acm sigplan notic v39 n1 p2638 januari 2004