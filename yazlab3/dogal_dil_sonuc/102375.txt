debug larch share languag specif checkabl design lsl larch share languag describ two tool help perform check discuss lp larch power princip debug tool design develop motiv primarili work lsl also use eg reason circuit concurr algorithm use also tend use lp analyz larch interfac specif author tri make lp lslspecif instead chosen build second tool lslc lsl checker serv frontend lp lslc check syntax static semant lsl specif gener lp proof oblig claim proof oblig fall three categori consist specif contradict theori contain specif intend consequ rel complet set oper adequ defin extend exampl illustr lp use debug lsl specif present b introduct propon formal specif argu suscept formal specif machin analysi manipul increas valu reduc cost larch project 9 10 11 12 seek support posit build use tool facilit construct formal specif program modul suffici specif precis also accur reflect specifi intent without accuraci precis useless mislead mistak mani sourc crop specif practic methodolog reli specif must provid mean detect correct flaw short debug pars typecheck use easi dont go far enough hand prove correct specif absolut standard judg correct seek tool help detect local kind error commonli observ larch style specif emphas breviti clariti rather execut usual imposs valid larch specif test instead larch allow specifi make precis claim specificationsclaim true verifi specif time verif guarante specif meet specifi intent power debug techniqu remov flaw reveal confid accuraci specif claim allow larch specif undecid gener case imposs build tool automat certifi arbitrari specif howev feasibl build tool assist specifi check claim debug specif paper describ two tool fit work lsl larch share languag lp larch prover princip debug tool design develop motiv primarili work lsl also use exampl reason circuit concurr algorithm 6 19 use also intend use lp analyz larch interfac specif tri make lp lslspecif instead chosen build second tool lslc lsl checker serv frontend lp lslc check syntax static semant lsl specif gener lp proof oblig claim proof oblig fall three categori consist specif contradict theori contain specif intend consequ rel complet set oper adequ defin section 2 provid brief introduct larch section 3 4 describ checkabl claim made lsl specif section 5 8 describ lp use check claim section 9 contain extend exampl illustr lp use debug lsl specif conclud section summar current state research plan addw indow proc v modifi v ensur v 0 addwv w c except w figur 1 sampl larchclu interfac specif 2 larch famili specif languag larch famili specif languag support twotier definit approach specif 12 specif compon written two languag one design specif program languag anoth independ program languag former call larch interfac languag latter larch share languag lsl larch interfac languag use specifi interfac program compon specif provid inform need use interfac write program implement critic part interfac compon commun environ commun mechan differ program languag program languag sometim subtl way found easier precis commun interfac specif languag reflect program languag specif written interfac languag gener shorter written univers interfac languag also clearer programm implement compon programm use larch interfac languag deal observ behavior compon written particular program languag incorpor program languagespecif notat featur side effect except handl iter concurr simplic complex depend larg upon simplic complex observ state state transform program languag figur 1 contain sampl interfac specif clu procedur window system larch share languag specif use provid semant primit term use interfac specif specifi limit fix set primit term use lsl defin special vocabulari suitabl particular interfac specif exampl lsl specif would use defin mean symbol 2 addw figur 1 therebi precis answer question mean window view visibl possibl obscur mean add window view may contain window locat larch approach encourag specifi keep complex specif lsl tier sever reason z lsl abstract like reusabl interfac specif linearcontain e c trait introduc next rest assert c gener new insert c partit next rest isempti nextinsert new e dd e restinsert new e dd new emptynew impli emptyc convert 2 empti figur 2 sampl lsl specif z lsl simpler underli semant program languag henc interfac languag specifi less like make mistak z easier make check claim semant properti lsl specif semant properti interfac specif paper concentr problem debug lsl specif 3 semant check larch share languag precis definit larch share languag includ associ semant check contain 9 11 section inform describ lsl check consid claim specifi make sampl traitslsl basic unit specif trait specifi properti collect oper trait linearcontain figur 2 exampl specifi properti common number abstract data type object sort c contain element sort e definit order type exhibit properti includ stack queue prioriti queue sequenc vector trait use specifi addit gener oper data type special specifi particular data type assert claus associ multisort firstord theori trait axiom theori consist equat follow quantifi foral assert claus equat form dd true abbrevi induct scheme associ gener axiom associ partit exampl theori linearcontain axiomat six equat axiom schema obtain gener instanti firstord formula axiom obtain partit theori lsl trait close logic consequ semant lsl base firstord logic rather initi final algebra two reason first import abl construct reason specif increment treat assert trait axiom firstord theori ensur ad assert even new oper trait remov fact associ theori initi final algebra interpret set equat monoton sens provid less suitabl semant firstord logic second gener partit construct lsl natur interpret firstord logic provid greater flexibl axiomat trait initi final algebra interpret semant claim lsl claim lsl trait fall three categori consist theori contain rel complet consist alway requir say lsl theori contain inconsist equat true dd f als claim two categori made specif lsl construct impli claus add noth theori trait instead make claim theori contain enabl specifi includ inform believ redund either check understand call attent someth reader might otherwis miss redund inform two kind statement like assert claus convert claus describ extent specif claim complet initi design lsl incorpor builtin notion complet quickli conclud howev requir complet better left specifi discret use check certain aspect complet long prioriti queuee q trait assum otalord e includ linearcontain e q assert foral q q e e nextinsert q e dd emptyq e els nextq e nextq els e restinsert q e dd emptyq new els nextq e insert restq e els q impli convert next rest empti 2 exempt next new restnew figur 3 lsl specif prioriti queue specif finish finish specif left intent incomplet place lsl allow specifi make checkabl claim complet intend specif claim usual valuabl specif revis first written specifi dont usual make erron claim complet first write specif hand edit specif frequent delet chang someth without realiz impact complet convert claus linearcontain claim trait contain enough axiom defin 2 isempti exactli mean defin oper one delic design issu lsl chang recent version languag convert claus claim given fix interpret oper interpret 2 isempti satisfi trait axiom convert claus priorityqueu figur involv subtl check exempt claus indic lack equat nextnew restnew intent oper next rest claim defin uniqu rel interpret term nextnew restnew section 7 describ check entail convert claus detail check compos lsl specif two mechan combin lsl specif defin oper text specif rather theori model 3 17 mechan theori combin specif axiomat union axiomat individu specif oper constrain axiom trait appear trait inclus trait assumpt differ check entail introduc assert foral x x x x dd x impli otalord e f f figur 4 lsl specif total order trait priorityqueu includ linearcontain constrain interpret next rest insert assum claus indic theori also contain trait totalord shown figur 4 use assum rather includ entail addit check name assumpt must discharg whenev priorityqueu incorpor anoth trait exampl check trait natpriorityqueu trait includ priorityqueuenat natq naturalnumb involv check assert trait priorityqueu linearcontain naturalnumb togeth impli totalordernat figur 5 summar check beyond consist lsl requir sampl trait introduc section 4 proof oblig lsl specif anlsl specif gener consist hierarchi trait includ assum impli other use lsl checker lslc check syntax static semant trait formul proof oblig requir check semant claim trait discharg proof oblig section describ lslc extract proof oblig next sever section describ use lp discharg proof oblig lslc discharg inspect lslc extract proof oblig specif check cycl trait hierarchi let c transit closur relat defin set includ assum let c transit closur relat defin set impli lslc check follow two condit natpriorityqueu check assumpt otalord nat priorityqueu use assert trait except totalord priorityqueu naturalnumb check implic check use assert priorityqueu use theori linearcontain totalord linearcontain totalord check implic check implic use local assert use local assert figur 5 summari requir check condit 1 c strict partial order condit 2 trait c c condit ensur trait check separ sound separ check shown induct trait hierarchi defin condit 1 must satisfi condit 2 also satisfi implic trait trait hierarchi safe use check note c need strict partial order specif may want assert two trait equival say impli impli may even case trait totalord see figur 4 wish assert like total order relat extract six set proposit equat gener claus partit claus trait trait hierarchi follow z assert consist proposit assert claus trait transit includ z assumpt consist assert trait transit assum z axiom consist assert assumpt z immedi consequ consist proposit impli claus axiom trait explicitli impli z explicit theori consist axiom proposit impli claus explicit theori trait c c explicit theori unlik theori defin section 3 finit set close logic consequ lsl trait lslc lsl checker diagnost oblig user lp larch prover success diagnost figur use lslc lp check lsl trait z lemma avail check condit 2 satisfi consist explicit theori trait c check hierarchi trait must prove axiom trait consist must discharg follow proof oblig z immedi consequ must follow axiom condit 2 satisfi sound use lemma avail perform check z convert claus must follow explicit theori preced proof oblig ensur explicit theori follow axiom z assumpt trait explicitli includ must follow axiom lslc discharg proof oblig inspect exampl proposit prove occur textual among fact avail use proof time lslc must formul command lp initi proof proposit sometim lp abl carri requir proof automat sometim requir user assist figur 6 show lslc lp use togeth check lsl trait consid exampl trait priorityqueu assum totalord natpri orityqueu includ priorityqueu naturalnumb naturalnumb explicitli includ impli totalord assert totalord among axiom naturalnumb lslc discharg assumpt requir includ priorityqueu natpriorityqueu hand naturalnumb simpli assert properti binari relat lslc formul lp command initi proof conjectur properti impli assert totalord provid small set axiom trait specifi make easier check trait impli includ trait assum provid larg set implic specifi make easier reason particular check trait includ assum without time make harder check trait impli includ trait assum translat lsl trait lp basi proof lp logic system section contain overview compon logic system lp discuss relat compon lsl trait follow section discuss compon use lp discharg proof oblig associ lsl trait logic system lp consist signatur given declar equat rewrit rule oper theori induct rule deduct rule express multisort fragment firstord logic system close relat lsl theori handl somewhat differ way axiom lp oper content well semant content present lp increment rather declar sort oper variabl play role lp lsl lsl oper variabl must declar oper overload minor differ sort must declar lp lp doesnt provid scope variabl lp syntax term yet rich lsl plan rectifi paper use lsl term syntax throughout lslc produc lp declar shown figur 7 introduc foral claus trait linearcontain equat rewrit rule like lsl lp base fragment firstord logic equat play promin role lp infer mechan work directli equat howev requir equat orient rewrit rule lp use reduc term normal form usual essenti rewrit relat termin term rewritten infinit mani time lp provid sever mechan automat orient mani set equat termin rewrit system exampl respons command declar declar sort e c declar variabl c c declar oper next rest figur 7 lp declar produc lslc linearcontain declar variabl x declar oper e g g g assert e dd x l ix e l x dd x enter usual firstord axiom group lp produc rewrit rule automat revers second equat prevent nontermin rewrit sequenc discuss oper theori treat issu termin system rewrit theori say proposit prove reduct normal form alway subset equat theori say proposit follow logic equat rewrit rule consid equat proof mechan discuss section 6 compens incomplet result usual case system rewrit theori includ equat theori case group theori exampl equat e dd ie follow logic second third axiom rewrit theori three rewrit rule irreduc yet ident lp provid builtin rewrit rule simplifi term involv boolean oper j equal oper condit oper rewrit rule suffici prove mani ident involv oper unfortun set rewrit rule known complet proposit calculu requir exponenti time space furthermor expand rather simplifi proposit reduc ident seriou drawback debug specif often attempt prove conjectur true none complet set rewrit rule built lp instead lp provid proof mechan use overcom incomplet rewrit system allow user add complet set choos use lp treat equat true dd f als x dd term contain variabl x inconsist inconsist use establish subgoal proof case contradict aris situat indic axiom logic system inconsist oper theori lp provid special mechan handl equat x c dd c x orient termin rewrit rule lp command assert ac c say c associ commut logic assert mere abbrevi two equat oper lp use match unifi term modulo associ commut increas number theori lp reason also reduc number axiom requir describ variou theori number reduct necessari deriv ident need certain kind user interact exampl case analysi main drawback term rewrit modulo oper theori much slower convent term rewrit lp recogn two nonempti oper theori associativecommut theori commut theori contain mechan base usersuppli polynomi interpret oper order equat contain commut associ commut oper termin system rewrit rule mechan difficult use user reli simpler order method base lpsuggest partial order oper simpler order method guarante termin equat contain commut associativecommut oper work well practic like manual order method give user complet control whether equat order left right right left easi use strike contrast manual order method yet caus difficulti produc nontermin set rewrit rule induct rule lp use induct rule gener subgoal prove basi induct step proof induct syntax induct rule lp lsl 1 user specifi multipl induct rule singl sort exampl lp command 1 semant induct stronger lsl lp arbitrari firstord formula written declar sort e declar oper set name setinduction1 assert gener fg insert set name setinduction2 assert gener fg f g use appropri rule attempt prove equat induct exampl prove x x induct x use setinduction2 lsl axiom trait typic one gener sort often use howev put other trait implic deduct rule lp subsum logic power partit construct lsl deduct rule lp use deduc equat equat rewrit rule like formula lp deduct rule may assert axiom prove theorem partit trait linearcontain express equat gener partit equival universalexistenti axiom express deduct rule lp exampl lp command declar sort e declar oper 2 declar variabl e e x assert f oral e e 2 x dd e 2 yield x dd defin deduct rule equival axiom set extension also express assert partit 2 lp lsl deduct rule enabl lp deduc equat x dd x x automat equat e 2 x dd e 2 x x deduct rule also serv improv perform lp reduc need user interact exampl deduct rule builtin split law declar variabl p q bool cancel law addit declar variabl x x c dd x c z yield dd z lp automat appli deduct rule equat rewrit rule whenev normal sampl proof section 7 illustr logic power deduct rule well benefit appli automat case induct hypothes proof 6 proof mechan lp section provid brief overview proof mechan lp next two section discuss use check semant claim lsl specif lp provid mechan prove theorem use forward backward infer forward infer produc consequ logic system backward infer produc lemma whose proof suffic establish conjectur four method forward infer lp z automat normal produc new consequ rewrit rule ad system lp keep rewrit rule equat deduct rule normal form equat rewrit rule normal ident discard hypothesi deduct rule normal ident deduct rule replac equat conclus user immun equat rewrit rule deduct rule protect automat normal enhanc perform lp preserv particular form use proof user also deactiv rewrit rule deduct rule prevent automat appli z automat applic deduct rule produc new consequ equat rewrit rule system normal deduct rule also appli explicitli exampl immun equat z comput critic pair knuthbendix complet procedur 13 16 produc consequ ie dd e incomplet rewrit system three rewrit rule group rare complet rewrit system reason discuss 5 howev often make select use critic pair discuss section 9 also use complet procedur look inconsist z explicit instanti variabl equat rewrit rule deduct rule also produc consequ exampl system contain rewrit rule b c c true b c c true instanti deduct rule x dd true z dd true yield x z dd true x b c c z produc deduct rule whose hypothes normal ident therebi yield conclus true also six method backward infer prove equat lp method invok prove command method lp gener set subgoal prove lemma togeth suffici impli conjectur method also gener addit axiom may use prove particular subgoal z normal rewrit conjectur conjectur normal ident theorem otherwis normal conjectur becom subgoal prove z proof case rewrit conjectur command prove e case direct lp prove equat e divis case two case 1 one subgoal prove addit 1 n lp substitut new constant variabl e form 0 creat subgoal e 0 addit hypothesi 0 true inconsist result ad case hypothesi 0 case imposs e 0 vacuous true case analysi two primari use conjectur theorem proof case may circumv lack complet rewrit rule conjectur theorem attempt proof case may simplifi conjectur make easier understand proof succeed z proof induct base induct rule describ section 5 z proof contradict provid indirect method proof inconsist follow ad negat conjectur lp logic system conjectur theorem z proof implic carri use simplifi proof case command prove direct lp prove subgoal 0 2 use hypothesi 0 obtain proof case suffic implic vacuous true 0 1 fals z proof conjunct provid way reduc expens equat term rewrit command prove direct lp prove subgoal lp allow user determin method backward infer appli automat order lp command set proofmethod normal direct lp use first three name method appli given conjectur set name totalord declar declar variabl x declar oper assert x x x dd x figur 8 file totalord assertionslp proof interest conjectur hardli ever succeed first tri sometim conjectur wrong sometim formal incorrect incomplet sometim proof strategi flaw detail enough attempt proof fail use varieti lp facil exampl case analysi tri understand problem mani proof attempt fail lp design fail rel quickli provid use inform design find difficult proof automat unlik boyermoor prover 1 perform heurist search proof unlik lcf 15 allow user defin complic search tactic strateg decis tri induct must suppli explicit lp command either user frontend lslc hand lp proof checker sinc requir proof describ minut detail mani respect lp best describ proof debugg 7 check theori contain proof oblig trigger impli assum claus lsl trait requir us check theori contain check claim follow axiom section discuss lslc formul proof oblig theori contain lp well use lp discharg oblig next section discuss check consist prove equat proof oblig equat easi formul consid exampl proof oblig must discharg check trait totalord shown figur 4 figur 8 display lp command lslc extract trait order axiomat theori figur 9 display lp command lslc extract order discharg execut totalord assert set name totalord consequ prove implic totalord prove x x qed prove x z qed prove x j x j x qed prove x dd x qed prove impli equat prove x x qed figur 9 file totalord obligationslp proof oblig execut command obtain axiom totalord file totalord assertionslp prove command initi proof five immedi consequ totalord lp discharg proof oblig except last without user assist user alert need suppli assist last proof diagnost incomplet proof print respons last qed command point user complet proof enter command criticalpair totalord totalord qed proof equat requir vari amount assist exampl check linearcontain impli emptyc e 2 c singl lp command resum induct c suffic finish proof check priorityqueu impli guidanc requir proof also proce induct lp prove basi subgoal without assist induct subgoal lp introduc new constant q 0 take place universallyquantifi variabl q add induct hypothesi attempt prove prove e 2 q e next q induct q resum case emptyq 0 handl case emptyq 0 criticalpair casehyp linearcontain handl case isemptyq 0 resum case v 0 nextc 0 handl case v 0 nextc 0 resum case e 0 v 0 handl case e 0 6d v 0 complet handl case v 0 next c 0 resum case e 0 v 0 handl case e 0 6d v 0 criticalpair implieshyp inducthyp figur 10 guidanc proof priorityqueu implic reduc lp assum hypothesi implic introduc new constant e 0 v 0 take place variabl e v attempt prove conclus implic hypothesi point guidanc requir command resum case emptyq 0 direct lp divid proof two case base boolean express first first case emptyq 0 conclus reduc e 0 v 0 command criticalpair caseh yp linearcontain lead lp deduc e 2 q 0 first implic linearcontain avail use proof linearcontain priorityqueu trait hierarchi fact lp abl finish proof first case automat appli builtin deduct rule conclud e 2 als use rewrit rule anoth builtin deduct rule deriv e hypothesi implic use rewrit rule help simplifi conclus implic ident second case user assist figur 10 show entir proof script prove partit prove partit claus amount prove valid associ deduct rule lp exampl lslc formul lp proof oblig associ partit impli claus figur 11 execut set assert prove partit lp translat partit deduct rule f oral z x z dd z z x dd z yield x dd deduct rule contain two hypothes binari oper either hypothesi suffici present way indic lsl lp lp gener subgoal prove deduct rule introduc two new constant x 0 0 sort assum x 0 z dd 0 z z x 0 dd z 0 addit hypothes attempt prove subgoal x 0 dd 0 lp prove x 0 dd 0 directli equat irreduc user guid proof type command instanti z feg whenhyp yield lemma e 2 x 0 dd e 2 0 lp automat complet proof appli deduct rule associ assert partit 2 prove gener prove gener claus involv prove set element gener given oper contain element sort exampl lslc formul lp proof oblig associ gener impli claus figur 11 execut set assert prove gener fg f g lp introduc new oper isgener add hypothes isgener fg isgener feg isgener x isgener isgener x attempt prove subgoal isgener x user guidanc requir complet proof exampl enter command resum induct x complet introduc assert gener fg insert partit 2 insert impli gener fg f partit insert e dd feg insert insert e e 0 dd insert insert e 0 e insert e fg convert f g 2 convert insert 2 figur 11 lsl trait finit set direct lp use induct scheme obtain assert gener fg insert run complet procedur draw necessari infer addit hypothes prove convert prove trait convert set oper involv show axiom trait defin oper set rel oper trait exampl show linearcontain convert isempti 2 must show given interpret fg insert uniqu interpret isempti 2 satisfi assert linearcontain equival must show theori linearcontain togeth theori linearcontaineri empti 0 empti 2 0 2 impli equat empti 0 c dd emptyc e 2 0 c dd e 2 c lslc formul proof oblig lp make two copi file lin contain explicit theori linearcontain second copi linearcontain convertslp occurr isempti 2 replac empti 0 produc two file lslc formul proof oblig follow lp command execut linearcontain execut linearcontain convert prove empti 0 c dd emptyc qed prove qed user guidanc requir prove convert claus command proceed induct c proof oblig convert claus priorityqueu similar must show given interpret fg insert well exempt term next new restnew uniqu interpret next rest isempti 2 satisfi assert priorityqueu lslc formul proof oblig lp make requir copi priorityqueuelp gener follow lp command execut priorityqueu execut priorityqueu convert assert next 0 new dd next new assert rest 0 new dd restnew prove next 0 q dd next 0 q qed prove rest 0 q dd restq qed prove empti 0 q dd emptyq qed prove qed user guidanc requir complet proof command proceed induct q check consist check theori contain fall typic pattern use theorem prover check consist harder formul involv nonconsequ rather consequ still evalu sever approach check seem probabl techniqu detect check fail use techniqu certifi succe standard approach logic prove consist involv interpret theori check anoth theori whose consist assum exampl peano arithmet establish previous 18 approach user assist requir defin interpret proof interpret satisfi axiom trait check becom problem show theori contain lp well suit approach cumbersom unattract practic promis approach base metatheorem firstord logic use restrict class specif exampl extens definit see 18 consist theori consist equat trait say trait pure equat axiomat rel question consist translat question critic pair case use lp answer question run complet procedur comput critic pair action gener inconsist axiom inconsist complet axiom without gener equat true dd f als trait consist proof strategi usual succeed prove consist mani equat theori complet complet accept amount time space howev prove use debug specif equat nonequ trait gener use lp forward infer mechan search presenc inconsist specif complet procedur search inconsist automat instanti axiom focu object sens mcallest 14 provid complet procedur basi search even though unsuccess search certifi specif consist increas confid specif test increas confid program recent lsl allow anoth kind claim also involv check nonconsequ name claim one trait incorpor anoth without constrain mean oper howev none approach certifi falsifi claim conserv extens prove practic without promis mean check inclin consid claim modul independ comment rather checkabl claim therefor remov lsl import construct made claim 9 extend exampl illustr approach check specif slightli realist set show one might construct check trait use specif simpl window system 8 preliminari version trait would like expand specif includ interfac part develop first three trait declar signatur basic oper coordin trait introduc assert foral cd coord cd cd origin assum coordin introduc r true point cd region r noth assum shape contigu region assum coordin includ regiont introduc repres appear object point cd proof oblig associ trait easili discharg lp complet procedur run coordin termin without gener critic pair sinc coordin gener partit claus suffici guarante consist check inclus region display region assumpt coordin discharg syntact use display assumpt trait next trait defin window object compos content clip region foreground background color window identifi 2 qualifi signatur last line trait overload necessari say 2 convert assum coordin includ region displayablew assert w tupl cont clip r fore back color id wid foral w w cd coord impli convert 2 coord three proof oblig associ trait assumpt coordin region display syntact discharg use window assumpt convert claus discharg lp without user assist proof oblig consist discuss previou section use complet procedur search inconsist run short time neither uncov inconsist prove consist view trait figur 12 defin view object compos window locat sever proof oblig associ trait assumpt window display discharg syntact assumpt view use complet procedur search inconsist uncov problem howev check convert claus turn problem convers inw 2s easili prove induct object sort v howev induct base case reduc emptyv cd defin problem solv either defin emptyv cd ad exempt foral cd coord emptyv cd convert claus choos latter obviou definit emptyv cd ad exempt induct proof convers without interact attempt prove first explicit equat impli claus view run difficulti automat appli proof method implic lp reduc conjectur cd 0 cd 0 els view trait assum coordin includ introduc inw v w coord bool assert gener emptyv addw view window offset origin impli ad new window affect appear part view lie outsid window appear within newli ad window independ view ad convert inw 2 coord figur 12 sampl view specif reduc assum hypothesi implic point ask hypothesi suffici reduc conjectur ident problem seem order operand lead us look care second equat inw trait view discov written cd cd 0 written cd 0 cd consist form equat revers role cd cd 0 left hand side equat chang axiom proof first implic goe without interact second conjectur lp appli proof method implic reduc cd 0 cd 0 els cd 0 cd 0 els resum proof divid two case base boolean express outermost if express true conjectur reduc true fals conjectur reduc sinc v 0 variabl v 0 fresh constant know go abl reduc true necessarili mean proof fail sinc could imposs case say current hypothes could lead contradict howev examin current hypothes implic hypothesi give us obviou reason believ contradict exist lead us wonder valid conjectur tri prove ask thought true ad trait inform reason 1 hypothesi conjectur inw addwv cd 0 w wid cd guarante coordin cd window w view addwv cd 2 w ad place v 0 v cd must also addwv 3 furthermor cd cd 0 rel coordin w addwv cd addwv 4 therefor equat trait view guarante conclus first step formal inform argument attempt prove lemma lp reduc conclus implic use normal implic hypothesi case first disjunct hypothesi reduc conjectur fals implic case hypothes thu stuck place attempt proof origin conjectur lead us question valid first step inform proof discov flaw v contain window id w implic sound problem implicitli assum invari view would contain two window id specif guarante correct problem tri ad addit oper three addit axiom trait view unfortun run lp complet procedur revis specif view quickli get inconsist sever way around problem among 1 trait view could chang addw choos uniqu id whenev window ad 2 trait view could chang addw ident function id window ad alreadi associ window view 3 preserv invari could left interfac level cartesianview trait includ view naturalnumb assert coord tupl x nat nat origin dd 0 0 impli convert origin figur 13 sampl cartesian view specif third altern consist interfac specif given section 2 one chosen caus us weaken second implic trait v iew appear within newli ad window independ view ad provid window alreadi present view prove small amount user interact final figur 13 introduc coordin system lp use fact trait naturalnumb shown automat discharg assumpt coordin carri level level lp requir assist complet proof coordin oper inde convert cours expositori purpos use artifici simplifi exampl also deliber seed error lp find howev error discuss occur unintent wrote exampl notic actual attempt mechan proof larger specif expect bug frequent harder find conclus larch share languag includ sever facil introduc checkabl redund specif facil chosen expos common class error give specifi better chanc receiv diagnost specif unintend mean much way type system give programm better chanc receiv diagnost erron program primari goal larch provid use feedback specifi someth wrong specif henc design lp primarili debug tool overli troubl detect inconsist gener quicker easier certifi consist expect discov flaw specif attempt proof fail lp automat appli backward infer techniqu requir user guidanc prover much guidanc highli predict eg prove hypothes deduct rule lemma although tempt suppli lp heurist would gener lemma automat feel better leav choic user mani point proof mani heurist appli experi choos next step proof exampl case split proof induct decid proof attempt abandon often depend upon knowledg applic lp reason expect possess knowledg especi search counterexampl conjectur rather attempt prove case lslc may abl use knowledg structur specif gener guidanc exampl use induct prove convert claus user must current provid lp checkabl redund lsl encourag specif also support regress test specif evolv chang part specif exampl strengthen assert one trait import ensur chang unintend sideeffect lp facil detect inconsist help us discov total erron chang claim trait specif impli assum chang trait help us discov subtl problem claim alreadi check lp facil replay proof script make easi recheck proof changean import activ one like neglect without mechan assist encourag earli experi use lp check lsl specif clear work must done lslc lp nonexpert use costeffect plan investig lslc discharg proof oblig textual provid guidanc lp discharg other plan enhanc lp includ mani syntact amen present lsl provid facil proof manag fundament plan enhanc logic lp enabl reason formula embed quantifi final plan continu improv perform lp reduc amount guidanc requir particularli use reason theori includ standard subtheori boolean natur number acknowledg wish thank andr modet martn abadi help understand semant larch design sever semant check andr modet respons first implement lslc jame rauen alexand esterkin second jame sax jrgen staunstrup provid help comment suggest base use lp r put theori togeth make specif induct method reason abstract data type overview lp larch prover verif vlsi circuit use lp use lp debug specif formal specif design tool report larch share languag larch share languag handbook revis report larch share languag overview larch famili specif languag simpl word problem univers algebra ontic knowledg represent system mathemat logic comput interact proof cambridg lcf complet set reduct equat theori observ equival algebra specifica tion mathemat logic composit verif vlsi circuit tr report larch share languag larch share languag handbook observ equival algebra specif logic comput interact proof cambridg lcf comput logic handbook induct method reason abstract data type ontic knowledg represent system mathemat complet set reduct equat theori formal specif design tool local verif circuit descript overview lp larch power ctr geoffrey r hird toward reus verifi ada softwar proceed confer triada 90 p1421 decemb 0306 1990 baltimor maryland unit state huim yu albert esterlin joseph monro objectori formal specif support ada 95 reus proceed confer triada 96 disciplin softwar develop ada p125131 decemb 0307 1996 philadelphia pennsylvania unit state daniel jackson aspect econom bugdetector proceed 13th intern confer softwar engin p1322 may 1317 1991 austin texa unit state daniel jackson craig damon element style analyz softwar design featur counterexampl detector acm sigsoft softwar engin note v21 n3 p239249 may 1996 j wing use larch specifi avalonc object ieee transact softwar engin v16 n9 p10761088 septemb 1990 daniel jackson somesh jha craig damon faster check softwar specif elimin isomorph proceed 23rd acm sigplansigact symposium principl program languag p7990 januari 2124 1996 st petersburg beach florida unit state antoy j gannon use term rewrit verifi softwar ieee transact softwar engin v20 n4 p259274 april 1994 daniel jackson craig damon element style analyz softwar design featur counterexampl detector ieee transact softwar engin v22 n7 p484495 juli 1996 barbara liskov histori clu histori program languagesii acm press new york ny 1996 barbara liskov histori clu acm sigplan notic v28 n3 p133147 march 1993