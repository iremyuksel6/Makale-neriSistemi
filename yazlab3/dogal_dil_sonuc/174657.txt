elus atom regist present construct singlewrit multipleread atom regist singlewrit singleread atom regist complex construct asymptot optim om2 share singlewrit singleread safe bit requir construct singlewrit mreader nbit atom regist b introduct current accept theori concurr comput deepli root concept atom regist atom regist data object read written one process accord follow assumpt sever read write oper regist enabl simultan differ process oper execut sequenc one concurr assumpt strongli suggest wellknown interleav semant concurr comput valid assumpt thu cornerston justifi present theori concurr comput one way check valid assumpt show atom regist construct use set realist regist read written concurr differ process construct process read write construct atom regist invok program within program regist realist kind read written differ program invok differ process concurr requir howev net effect resembl serial invoc program restrict waitfre ie synchron primit p v await unbound busywait loop allow restrict guarante process read write construct atom regist finit amount time regardless activ process also mean read write process immun failur process also access regist waitfreedom restrict distinguish problem construct atom regist classic readerswrit problem 6 peterson 16 first suggest problem construct atom regist safe regist safe regist data object read written concurr differ process read oper overlap write oper may return valu valu domain regist read oper overlap oper obtain recent written valu leap safe regist atom regist quit larg fortun divid number smaller step figur 1 depict two chain regist construct lead singlewrit singleread singlebit safe regist kwriter mreader n bit atom regist notat kmn denot regist written k process read process store n bit valu step figur label refer paper given construct present henceforth concern singlewrit atom regist problem construct multipleread atom regist singleread atom regist mention open problem lamport 12 vitanyi awerbuch 23 first solut problem present us 2 tworead construct given gener construct mreader regist gamma 1reader regist solut though easi explain understand use exponenti number singl safe atom atom atom kmn atom 12 20 2 4 7 10 13 15 19 3 13 17 18 23 2 4 7 10 13 15 19 16 21 figur 1 two chain regist construct reader atom regist subsequ sever solut polynomi complex present 4 10 13 15 includ one given us 19 latter construct gener tworead construct paper present construct multipleread atom regist base upon solut 19 present construct differ 19 two respect first solut present optim complex wherea one given 19 actual optim solut attain combin solut 19 construct lamport 12 peterson 16 see 19 detail second correct proof present paper rigor formal hope easier understand proof present 19 rest paper organ follow section 2 formal defin problem construct mreader atom regist singleread atom regist section 3 present construct inform descript construct present section 4 formal correct proof present section 5 proof make use sever lemma state prove appendix conclud remark appear section 6 regist construct regist construct defin number differ way choic definit base simplic conveni order avoid confus henceforth capit term read write appli construct regist leav uncapit appli variabl use construct 2 view writer reader construct program invok process order write read valu regist program writer one input paramet indic valu written similarli program reader one output paramet indic valu read exampl see construct depict figur 2 3 variabl construct singleread singlewrit atom regist restrict aris sinc aim construct multipleread regist singleread regist also requir variabl bound size simpl solut variabl unbound 23 mention introduct program construct waitfre ie synchron primit busywait loop allow formal definit waitfreedom refer 1 next defin sever concept need state correct condit multipleread construct definit appli given construct state assign valu variabl construct note program program counter consid variabl construct one state design initi state 2 event execut statement program 2 u two state construct state u result execut statement state e event correspond statement execut say e enabl state write e u histori construct sequenc 0 initi state 2 preced anoth event f histori iff e occur f historydefinit set event histori correspond complet program execut call oper oper p preced anoth oper q histori iff event p preced event q 2 observ preced relat irreflex total order event irreflex partial order oper proof correct construct suffici consid histori initi write oper preced oper incomplet program execut ie oper deal histori note assum initi write oper valu read read oper match written write oper equival defin initi state equal result initi write oper note also histori incomplet oper extend one complet oper possibl sinc program requir wait free deal complet oper valu read written construct regist oper welldefin notat denot ith oper writer denot initi write 2 follow lamport 12 defin correct condit construct follow let h histori construct h said atom iff exist function oe map everi read oper h natur number w write oper h follow three condit hold ffl integr read oper r h valu read r valu written w oer ffl proxim read oper r h r preced write oper write oper w oer1 preced r ffl preced two read oper r h r preced oer oesdefinit regist construct correct iff histori atom 2 3 multiread construct propos construct depict figur 2 consist writer program program reader 1 share variabl construct singleread kind interfac writer reader consist variabl wri written writer read reader variabl rw written reader read writer interfac across reader consist set variabl rri j j variabl rri j written reader read reader j 1 explan field name appear type definit follow alt bit altern valu oper writer done bit distinguish two valu written write oper variabl wri new current valu construct regist valtyp type construct regist old previou valu construct regist 1 possibl elimin variabl rri construct howev includ variabl simplifi proof correct rrtype rang 1 initi new valtyp initi begin 0 old new alt new val alt 1 k 1 read qk rw k od 2 k 1 seqk qk phi 1 od 3 k 1 write wrk old new seq1m alt fals od 4 k 1 write wrk old new seq1m alt true od return valtyp var defin lag initi begin 0 read x wri 1 write rw xseqi 2 k 1 read vk rrk od 3 read wri 4 f lag 5 k write rri k f lag yseqi yalt od lag returnynew els returnyold fi figur 2 multipleread construct f lag bit indic whether read oper return old new valu seq modulo3 integ sequenc number phi denot modulo3 addit variabl local program declar either var block variabl declar block assum retain valu across invoc correspond program variabl declar var block assum retain valu across invoc initi assert follow variabl declar serv defin appropri initi valu variabl construct state satisfi assert suitabl initi state howev recal assumpt initi write oper preced read oper program construct use special syntax order distinguish read write share variabl read write local variabl program read given share variabl z execut statement form read u z u local variabl type z program write share variabl z execut statement form write z u variabl z consist field u mtupl ith compon u local variabl whose valu store ith field z use similar name sometim ident compon u field z correspond obviou sequenc number share writer reader form basi construct includ everi valu written writer set sequenc number one per reader write oper writer read variabl rw k obtain recent sequenc number reader k new sequenc number reader k obtain increment read rw k use modulo 3 addit writer write reader two pass first pass writer write reader order 1 second pass order revers done bit distinguish two pass valu writer write reader includ previou current valu construct regist aforement set sequenc number alt done bit reader read two valu writer x read sequenc number obtain first read written back writer valu read reader k k valu read writer reader use comput f lag bit indic whether old new valu return note f lag assign valu base upon express express introduc shorthand defin defin section return valu reader write valu reader k k valu includ reader f lag bit also sequenc number reader alt bit writer obtain reader second read wri calcul space complex construct determin number share singlewrit singleread safe bit requir size share variabl construct follow consist 2m consist 2 bit consist 4 bit use construct 22 singlewrit singleread bbit atom regist construct use share singlewrit singleread safe bit construct yield space complex 6m 2 6mn 26m 19m 12 well known lower bound space problem construct asymptot optim given correct proof section 5 construct establish follow theorem theorem possibl construct singlewrit mreader n bit atom regist use share singlewrit singleread safe bit 2 4 inform explan section explain intuit behind algorithm discuss proof oblig establish next section appendix howev introduc notat use ensu discuss oper program p label statement p loop denot event correspond execut statement oper p otherwis loop denot event correspond iter loop loop counter equal j 2 exampl write oper w construct figur 2 w 1i denot event w read rw w 4i denot event w write wri second time next defin three type control predic 11 oper program p histori let event p p true state histori iff event true state iff state occur event true state iff state occur event n label loop program p use p n shorthand 8i p ni use p n shorthand 8i p ni use p n shorthand 9i p ni observ loop p impli p particular p strengthen p also requir p enabl hand loop possibl p p assert hold event loop first enabl follow assert consequ preced definit let p given definit ffl p exampl control predic observ write oper w construct figur ffl w 1i denot w read sequenc number reader ffl w 4 denot w begun second pass write ffl w 4i denot w complet write reader second pass ffl w 4 denot w complet second pass write let b two state assert assert unless b hold iff everi pair consecut state histori ab hold first state ab hold second state 2 notion unless borrow uniti logic chandi misra 5 inform unless b mean becom true remain true unless b becom true particular falsifi event b either true state prior occurr event true state follow occurr event requir b eventu becom true howev case remain true forev oper z local variabl p pz denot final valu variabl z assign oper p 2 readi explain intuit idea algorithm let us examin write oper w writer assum w chang valu regist old new possibl identifi two point b within execut w reader return new reader return old b let us call interv b uncertainti interv w establish correct construct main difficulti ensur preced condit definit atom histori given section 2 violat uncertainti interv write oper w amount prove newthenold conflict aris interv avoid newthen old conflict difficult fact singleread regist use construct result limit w must inform reader new valu written one time thu uncertainti interv w exist certain point reader inform w valu new current written difficulti encount construct multipleread atom regist singleread one solut uncertainti interv begin writer write wr1 second pass end writer write wrm second pass word uncertainti interv exist predic w 4 w 4 true solut therefor guarante follow three properti read begin interv return new valu read end interv return old valu read interv result newthenold conflict state properti precis defin predic cue relat valu written particular write oper exist valu variabl rri j inform predic cuew j thought cue reader reader j reader return new valu w predic defin follow cuew lag rri accord reader program valu read wrj reader j written write oper w valu read rri j satisfi predic reader j find predic p true subsequ return valu new return discuss uncertainti interv properti a0 ensur cuew j fals begin interv word control predic w 1i ad conjunct ensur valu wseqi use definit cuew j avail reader prove properti lemma 4 appendix base lemma reader return new valu begin uncertainti interv properti a0 hold consid oper r reader assum valu read wri r written w r begin uncertainti interv w r find p 0 true consequ r return valu new thu reader return old valu end interv henc properti a1 hold final ensur properti a2 hold ie newthenold conflict avoid within uncertainti interv consid success read oper reader reader j two case consid either j j former case difficult oper reader return valu new uncertainti interv w upon complet establish cuew j show predic remain stabl uncertainti interv reader j also return valu new newthenold conflict aris stabil cuew j captur follow properti w 4 cuew prove lemma 5 appendix latter case interest direct commun reader reader j j order avoid newthenold conflict case reli upon either writer complet write reader j reader k j set cuew k j true word show w 4 cuew l let us examin assert detail state uncertainti interv w reader cu reader l henc return new valu smaller j reader write valu either w written final valu reader j case reader j return new valu reader j turn cu reader k case stabil cuew k j reader j return new valu properti prove lemma 9 appendix complet last remain oblig a2 proof newthenold conflict occur formal proof next section mirror intuit explan present 5 proof correct prove construct correct defin function oe given histori show defin oe meet three condit integr proxim preced defin section 2 follow notat convent definit use proof notat order avoid use mani parenthes defin bind order symbol use follow list symbol group bind power group order highest bind power lowest gamma phi 6 oe let e f two event histori e oe f j e preced f e event correspond execut statement read z oper p z local variabl share variabl valu p read written oper q say oper q determin pz 2 let r two oper reader reader j respect ry determin write oper sy determin write oper preced proof fdefinit determinesg preced sg determin sy definit determinesg ftransit oeg oper occur sequenti historyg ng let r read oper suppos write oper ry oer defin follow lag otherwiseobserv oer nonneg see recal initi write oper assumpt preced read oper thu ry determin w 0 rydon hold impli rf lag hold henc proof integr let r read oper suppos write oper determin ry lag true definit oe r return valu rynew ie valu written w lag fals definit oe r return valu ryold ie valu written w proof proxim let r oper reader suppos write oper ry preced preced r thu proxim satisfi case sinc r preced w clearli r 1 next show preced r definit impli rf lag fals henc rp 0 also fals definit p 0 impli rydon fals rxseqi 6 ryseqi rydon fals 3i thu either case preced r 2 proof preced proof preced quit complic consist somewhat lengthi case analysi releg appendix make use lemma 6 10 11 prove three lemma base lemma 4 5 9 discuss inform descript previou section let r oper reader oper reader j r preced proof oblig show oer oe assum write oper determin ry sy respect observ follow ng fbi definit oe ffrom observ prove earlier r preced fbi definit oe appendixg fbi definit oe fbi definit oe fbi definit oe oe ng fbi definit oe f lag flemma 6 11 appendixg true 6 discuss shown singlewrit mreader n bit atom regist construct waitfre manner use singlewrit singleread atom regist construct requir om 2 mn share singlewrit singleread safe bit asymptot optim definit atom equival given misra 14 axiom atom essenc requir read write oper shrunk point shrink oper possibl iff function oe meet three condit definit exist recent herlihi wing 8 extend idea atom arbitrari abstract data type defin concept lineariz though akin serializ usual correct criterion concurr execut transact subtl differ two concept one import distinct lineariz local correct condit wherea serializ refer reader 8 detail order prove correct multipleread atom regist construct function oe meet three condit integr proxim preced defin everi possibl histori lead long somewhat tediou proof mainli proof must take account possibl way read write overlap keep result case analysi proof minimum chose function oe simpl depend boolean variabl f lag proof appear formid spite simplif formal reason leav doubt valid proof howev given length proof seem reason inquir whether exist approach construct mreader regist facilit simpler correct argument briefli describ approach next main idea behind approach develop construct mreader 2 regist collect gamma 1reader regist mreader regist implement singleread regist recurs appli construct first replac gamma 1reader regist gamma 2reader one replac regist gamma 3reader one simpl implement mreader regist gamma1read regist depict figur 3 construct writer reader 1 denot w r respect remain reader denot 1 sm reader execut program call construct use two singleread share variabl wr rw two share variabl ws rs variabl name indic program read write respect exampl ws written writer w read reader 1 sm gamma1 observ reader share variabl fact crucial exploit recurs applic construct local variabl use construct similar use construct figur 2 primari advantag recurs construct proof correct simplifi assum two reader name r specif ignor possibl interleav may aris among reader 1 sm gamma1 consid proof integr proxim preced follow quit easili proof integr proxim condit relat individu read oper oper writer proof preced note preced condit restrict valu return read oper strict preced relationship one anoth reader 1 sm gamma1 initi lag program new valtyp begin old new alt new val alt read q rw program r return valtyp program return valtyp var begin begin read x wr read x ws read wr read ws f lag lag returnxnew returnynew els returnyold figur 3 recurs construct execut ident program write share variabl preced relationship interest follow read oper r preced read oper read oper r preced anoth read oper r read oper j preced read oper r read oper j preced read oper k case precis aris special case 2 thu proof correct mreader regist reduc much simpler task prove correct tworead construct consist reader r formal proof correct construct figur 3 appear 2 construct first present remaind section inform describ construct work two reader compar gener construct given earlier figur 2 gener construct consid assum variabl remov see footnot begin section 3 henc reader program loop index statement 2 1 loop index statement 5 1 begin comparison consid variant tworead version gener construct figur 2 variant shown figur 4 variant statement combin larger atom statement denot enclos within angl bracket h note also renam program variabl coincid name given figur 3 also move assign seq1 occur immedi read rw chang origin construct clearli affect construct correct thu origin construct correct construct shown figur 4 also correct consid code w figur 4 fifth atom statement w alway assign valu true wrdone henc done field wr remov without affect construct correct chang w fifth atom statement replac singl write wr next consid reader first atom statement assign valu local variabl x thu reader ss calcul f lag depend p 0 p 1 defin figur 2 tautolog remov chang seq2 field construct serv use purpos henc remov final condit reader ss comput f lag also tautolog instead remov choos replac anoth tautolog chang clearli affect construct correct yield code given figur 4 b figur shown reader r code chang note construct figur 4 b statement read write multipl share variabl first statement reader statement elimin turn slight chang code reader r first statement reader broken three separ statement requir program begin old new alt new val alt read q1 rw hread q2 sw hwrite wr old new seq1 seq2 alt fals program r return valtyp program return valtyp begin begin read x wr hread x ws read wr read v rs f lag p0 read ws lag p0 p1 f lag returnynew f lag returnynew els returnyold fi els returnyold fi program return valtyp begin begin read q1 rw read v rs lag ydone lag lag returnynew els returnyold fi b figur 4 two intermedi construct chang reader r follow reader r comput f lag f lag f lag ydone assign f lag xseq1 xalt rs rather f lag yseq1 yalt reader r alway return xnew last chang turn writer longer need write old valu reader r result construct given figur 3 complet comparison two construct although construct figur 3 simpler correct proof figur 2 simplic come price particular shown 2 construct multipleread regist requir number bit exponenti number reader acknowledg would like thank ted herman ut distribut system discuss group comment paper would also like thank nanci lynch anonym refere help comment appendix remaind correct proof prove lemma use proof given section 5 outlin inform discuss algorithm section 4 lemma 4 5 9 relat uncertainti interv write oper valu variabl rri j use commun reader lemma 1 2 3 state elementari result use prove subsequ lemma lemma 7 8 use prove result use proof lemma 9 lemma 6 10 11 consid valu return two success read oper use proof preced present section 5 word concern structur proof order junctur proof reason base upon sequenc state event word assum total order read write intern variabl construct wherev possibl proof simplifi introduct invari establish invari usual proceed case analysi order event may affect one anoth exampl consid write oper w read oper r reader oper w read sequenc number reader oper r write sequenc number writer possibl case analysi whether ws read sequenc number occur rs write sequenc number whole proof difficult due numer interleav event may potenti occur rather lengthi follow definit use proof first repeat section 4 let w write oper let 1 cuew lag rri consid histori 0 say state prior event e i1 state follow e similarli e event prior state i1 e i1 event follow state i1 2 lemma 1 let r oper reader rp k hold k let w write oper determin ry hold state prior event r 2k proof program writer 3 therefor transit w 1i oe r 3 impli wqi determin either r predecessor r show r determin wqi rp k hold w determin ry therefor transit r determin wqi w assign seqi qi phi 1 impli contrari 1 therefor r determin wqi thu conclud wqi determin predecessor r ie w 1i oe r 1 second part proof assum k 6 0 let state prior event 2k rp k true k 0 follow assert hold state rrk lag rrk k 0 definit p k w determin ry impli walt thu transit follow assert hold state rrk lag rrk therefor definit cue cuew k hold state 2 follow lemma relat sequenc number read two consecut oper reader state valu differ one intuit follow order reader sequenc number increment 1 must first written reader rw read writer increment writer written wri final read reader two read wri two consecut read oper complet sequenc event happen lemma 2 let r consecut oper reader proof prove lemma first show follow assert invari prove b invari consid assert b0 b4 defin show b0 invari assert refer local variabl qi seqi writer xseqi reader see b0 invari observ follow ffl b0 initi true statement possibl falsifi read writer rw execut statement b0 true establish b1 ffl statement possibl falsifi b1 assign seqi writer execut statement b1 true establish b2 ffl statement possibl falsifi b2 first write writer wri execut statement b2 true establish b3 ffl statement possibl falsifi b3 read reader wri execut statement b3 true establish b4 ffl statement possibl falsifi b4 write reader rw execut statement b4 true establish b0 thu conclud b0 delta delta delta b4 invari also impli b invari sinc use invari b show lemma hold proof oblig follow let denot state prior event r consecut valu rw state equal rxseqi valu wriseqi state equal sxseqi sinc b invari either state case 1 state case follow lemma relat valu written rri j oper r reader valu written overlap succeed write oper w proof lemma make use lemma 2 lemma 3 let r oper reader let w write oper state w 1i hold valu appear rri j j state written r cuew j fals proof let state w 1i hold j indic j assum valu appear rri j state written r proof oblig show cuew j fals first show rxseqi 6 wseqi let e event prior state w 1i hold w therefor wqi determin either r successor r former case rxseqi w assign seqi qi phi 1 impli wseqi 6 rxseqi latter r write valu appear rri j state state follow event e r consecut oper reader henc lemma 2 wqi equal rxseqi rxseqi phi 1 therefor wseqi equal rxseqi phi 1 rxseqi phi 2 phi modulo3 addit impli wseqi 6 rxseqi thu case wseqi 6 rxseqi r write valu appear rri j state hold state consid two valu ryseqi wseqi equal wseqi 6 rxseqi rxseqi 6 ryseqi consequ rf lag fals therefor 2 rri jf lag fals henc cuew j fals hand ryseqi 6 wseqi 2 rri jseq 6 wseqi therefor fals 2 follow lemma ensur new valu return write oper uncertainti interv state reader cue reader j return new valu unless writer begun second pass write reader proof make use lemma 1 3 lemma 4 let w write oper j proof prove lemma induct assum result indic less prove consid state interv w 1i w 4 hold need show cuew j fals interv j consid state interv question assum cuew j fals state interv occur note could first state interv show cuew j also fals j rri jf lag fals cuew j clearli fals remaind proof assum rri jf lag true sinc rri jf lag fals initi exist oper r reader write valu appear rri j consid event fals requir remaind proof assum w 1i oe r 1 let e event prior state program reader r write valu appear rri j state r 5j e w 4 hold e oe therefor ry determin w write oper immedi preced w latter case ryalt 6 walt therefor cuew j fals remaind proof consid case ry determin w therefor rydon fals henc definit p 0 rp 0 fals show l fals well r write valu appear rri j impli rri jf lag fals henc cuew fals consid l rang program writer w assumpt w 1i oe r 1 program reader 3 thu 3 consid state prior event r 2l preced assert w 1l w 4 hold state l cuew l fals state follow assumpt cuew j fals j state occur interv w 1i w 4 hold fals state induct hypothesi thu either case cuew l fals state sinc w determin ry contraposit lemma 1 rp l fals establish remain proof oblig 2 follow lemma assert stabil cuew uncertainti interv state cuew true interv remain true interv end proof make use lemma 3 lemma 5 let w write oper let j w 4 cuew proof state safeti properti preserv trivial event writer reader differ reader show also preserv event reader let oper reader consid event 5j event may falsifi predic cuew state prior event let u state follow event assum w 4 cuew hold proof oblig show cuew j hold u w 4 hold u trivial program reader follow assert hold u thu prove cuew j hold u suffic prove follow lag cuew j fals initi rri jf lag initi fals valu appear rri j state written oper r reader immedi preced consid event w 1i r 1 contraposit lemma 3 w 1i hold w 1i oe r 1 assumpt w 4 hold therefor show w determin ry program reader sinc r preced w 4 hold ie state prior 5j r 5j oe therefor ry determin either w write oper immedi preced w latter case ryalt 6 walt therefor rri jalt 6 walt consequ fals contrari assumpt therefor w determin ry program writer therefor appli 6 therefor w determin sx sy latter impli walt meet two three proof oblig 5 left proof oblig sf lag hold prove next cuew hold r write valu appear rri j state rf lag hold sinc w determin ry impli cuew hold state follow event r 5i consequ sinc r consecut oper reader also hold state prior event 2i definit cue impli follow assert hold state lag rri program reader rri also hold state therefor lag w determin sx sy shown earlier consequ 7 therefor use 8 definit p sp true consequ sf lag hold final proof oblig 2 follow lemma consid case oper reader preced oper reader j j lemma formal follow properti variabl read determin write oper impli assign variabl uncertainti interv write oper first read return new valu second read also return new valu lemma base lemma 1 4 5 turn use proof preced lemma r oper reader oper reader j preced assum ry sy determin write oper proof assum write oper w determin ry sy rp k hold k proof oblig show sp l hold l j first establish w determin sx sy j program reader therefor w determin sy 9 w determin sx sy consid event first dispos former case show sp 0 true w determin sx sy sydon true therefor definit p 0 sp 0 true remaind proof assum 9 assumpt rp k hold k thu lemma 1 program reader 3 therefor 10 next show cuew true state prior event 2i let state follow event r 5j rp k hold rf lag true therefor follow assert hold state lag rri w determin ry walt thu follow assert hold state lag rri henc cuew true state thu contraposit lemma 4 w 1i w 4 hold state program reader r preced r 5j oe thu 11 therefor w 1i hold state consequ w 4 hold ie w 4 w 4 hold preced assert w 4 hold thu w 4 hold ie w 31 oe r 5j therefor observ w 4 hold state r 5j 3 thu lemma 5 hold state interv particular hold state prior program reader j rri hold state prior event impli follow assert hold lag account 10 fact sx sy determin walt therefor lag henc definit p sp true proof oblig 2 writer write higher number reader first lemma need ensur newthenold conflict aris histori oper higher number reader follow oper lower number one requir properti given later lemma 9 lemma 7 8 given next take care subcas aris proof lemma 9 lemma 7 state reader cu reader j new valu uncertainti interv write oper w either account read final valu writer ie w 4i hold account cu turn reader ie hold proof lemma make use lemma 1 3 4 5 lemma 7 let w write oper j w 4 cuew proof consid reader state interv w 4 hold need show properti hold state interv consid state interv question assum properti 12 hold state interv occur note could first state interv show properti also hold state assum cuew 4i hold state j proof oblig show cuew k hold state k sinc rri jf lag fals initi state cuew j initi fals therefor assum valu appear rri j state written oper r reader consid event w 1i r 1 contraposit lemma 3 w 1i hold w 1i oe r 1 assumpt w 4 hold therefor program reader r write valu appear rri j state r 5j e e event prior state w 4i hold e oe w 4i therefor therefor ry determin either w immedi predecessor w immedi predecessor w determin ry account true state w determin ry cuew hold state rri jf lag also hold henc r write valu appear rri j rf lag hold program reader impli rp k true k k show k 0 observ assert 13 impli r 3 oe e oe w 4i thu w determin ry rydon fals impli rp 0 fals thu k 0 k 1i program reader 5j thu 13 let u denot state prior event r 2k rp k hold k 0 lemma 1 cuew k hold state u thu contraposit lemma 4 w 1k w 4 hold u assert 14 w 1k hold u consequ w 4 hold u ie w 4 w 4 hold u 14 w 4 hold u thu w 4 hold u impli w 31 oe r 2k thu assert 14 observ w 4 hold state r 2k w 4i sinc cuew k hold state u lemma 5 cuew k hold state interv particular hold state state follow event e establish proof oblig k case hold state u 15 u lie within interv w 4 hold u occur consequ assumpt properti 12 hold state prior interv w 4i hold state u hold state u k howev 15 w 4i hold state u therefor cuew k hold state u k consequ appli lemma 5 previou paragraph cuew k also hold state desir 2 accord next lemma reader cu reader j uncertainti interv write oper w also cu reader indic j proof follow essenti fact reader write reader order increas indic lemma make use lemma 3 4 5 turn use proof lemma 9 lemma 8 let w write oper j w 4 cuew proof assum w 4 cuew hold state let k j show cuew hold state rri jf lag fals initi state cuew j initi fals therefor assum valu appear rri j state written oper r reader let u state follow event r 5k sinc cuew hold sinc r write ident valu rri j rri k cuew hold u consid event w 1i r 1 contraposit lemma 3 w 1i hold w 1i oe r 1 assumpt w 4 hold therefor program reader r write valu appear rri j state r 5j e e denot event prior state sinc w 4 hold e oe w 4m therefor sinc w 1i cuew hold state u lemma 4 w 4 hold u word w 4 w 4 hold u 16 w 4 hold state u thu w 4 hold u consequ lemma 5 cuew hold state interv r 5k w 4m particular state establish proof oblig 2 lemma 9 relat valu rrl rrk j state reader l cu reader uncertainti interv write oper w reader indic lower either inform new valu writer ie w 4j hold turn cu reader ie hold proof lemma make use lemma 7 8 lemma 9 let w write oper l w 4 cuew l proof assum w 4 cuew l hold state breviti let p j shorthand show w 4j p j hold state proof induct induct step given follow assert shown later hold state w 4 cuew given assumpt w 4 cuew l hold induct step impli one disjunct consequ hold second disjunct hold induct step appli time use w 4 cuew l 1 anteced number reader finit reader indic l appear second disjunct consequ smaller indic l induct step appli way finit number time thu finit number applic eventu obtain consequ first disjunct hold sinc assert p j accumul second disjunct applic induct step impli follow assert hold induct termin 4j assert follow state combin rang two univers quantif get state impli hold state requir proof oblig proof induct step follow state predic refer state w 4 cuew l w 4l assumpt w 4g w 4l w 4l fdefinit p jg w 4l assumpt w 4 cuew l ig w 4l w 4l fdefinit p jg w 4l w 4l fpredic calculu l ig w 4l fdefinit p 1 g w 4l assumpt w 4g w 4l follow lemma consid two success read oper r r though preced read recent write oper order writer write reader situat aris index r greater lemma ensur r comput f lag fals comput f lag true lemma base lemma 1 4 turn use proof preced lemma 10 let r oper reader oper reader j preced assum ry sy determin write oper lag fals sf lag true program reader w determin sy w preced w therefor henc rydon fals sydon true thu definit p 0 rp 0 fals sp 0 true sp 0 true program reader j sf lag true meet half proof oblig remaind proof show rp k fals k rang impli remain proof oblig name rf lag fals consid two event 1 former case contraposit lemma 1 rp k fals k desir assum remaind proof k program reader 3 thu use 17 note w 0 1k w 0 4 hold state prior r 2k henc lemma 4 hold state therefor contraposit lemma 1 rp k fals requir proof oblig 2 final lemma proof construct consid case oper reader preced oper reader j j lemma counterpart lemma 6 consid case j lemma base lemma 1 4 5 9 turn use proof preced lemma 11 let r oper reader oper reader j preced assum ry sy determin write oper proof assum write oper w determin ry sy rp k hold k proof oblig show sp l l j consid two event first dispos former case r preced program reader therefor thu sinc w determin sy sydon true therefor definit p 0 sp 0 true establish proof oblig remaind proof assum r 3 ry determin impli rydon fals definit p 0 impli rp 0 fals 1 program reader therefor let denot state prior event r 2k show w 4 hold rp k true k 0 lemma 1 cuew k hold state henc contraposit lemma 4 w 1k w 4 hold thu previou preced assert follow therefor w 1k hold state consequ w 4 hold ie w 4 w 4 hold preced assert w 4 hold thu w 4 hold sinc w 4 cuew k hold state j lemma 9 w 4j hold cuew j hold j former case r preced impli repeat reason follow 18 impli sp 0 hold requir remaind proof assum cuew j hold sinc w 4 hold state 2k program reader therefor consid two event first dispos former case r preced r henc 19 sydon true moreov sinc therefor definit p 0 sp 0 true establish proof oblig remaind proof assum 3 r preced r 3 oe 3 thu 19 follow assert hold therefor assert 20 w 4 hold state interv r 2k 3 recal cuew j hold state ie state prior event r 2k therefor lemma 5 cuew hold state interv particular hold state follow event 2m program reader j rrm state therefor lag w determin sy sy syalt therefor lag consequ definit pm sp true proof oblig 2 r virtu patienc concurr program without wait elus atom regist construct twowrit atom regist construct multiread atom valu nonatom valu parallel program design foundat concurr control reader writer counterexampl one writer multiread atom variabl construct burn peterson lineariz correct condit concurr object atom multiread regist hoar logic part ii construct waitfre variabl axiom memori access asynchron hardwar system protocol waitfre concurr read write concurr read write ii multiwrit case correct atom multiwrit regist elus atom regist revisit construct atom variabl convert lamport regular regist atom regist concurr read write revisit atom share regist access asynchron hardwar tr axiom memori access asynchron hardwar system elus atom regist revisit construct multiread atom valu nonatom valu protocol waitfre atom multiread share variabl convert lamport regular regist atom regist construct twowrit atom regist parallel program design foundat lineariz correct condit concurr object concurr read write concurr control myampersandldquoreadersmyampersandrdquo myampersandldquowritersmyampersandrdquo atom multiread regist construct atom variabl extend abstract share concurr asynchron waitfre varaibl preliminari version virtu patienc concurr program without wait elus atom regist ctr haldar k vidyasankar construct 1writer multiread multivalu atom variabl regular variabl journal acm jacm v42 n1 p186203 jan 1995 cynthia dwork orli waart simpl effici bound concurr timestamp traceabl use abstract journal acm jacm v46 n5 p633666 sept 1999 alessandro panconesi marina papatriantafil philippa tsiga paul vitnyi random name use waitfre share variabl distribut comput v11 n3 p113124 august 1998 jame h anderson yongjik kim nonatom mutual exclus local spin proceed twentyfirst annual symposium principl distribut comput juli 2124 2002 monterey california rida bazzi gil neiger gari l peterson use regist achiev waitfre consensu distribut comput v10 n3 p117127 april 1997 ming li john tromp paul b vitnyi share concurr waitfre variabl journal acm jacm v43 n4 p723746 juli 1996 paul c atti e allen emerson synthesi concurr program atom readwrit model comput acm transact program languag system topla v23 n2 p187242 march 2001 john tromp paul vitnyi random twoprocess waitfre testandset distribut comput v15 n3 p127135 juli 2002 yehuda afek david greenberg michael merritt gadi taubenfeld comput faulti share object journal acm jacm v42 n6 p12311274 nov 1995 jame h anderson lamport mutual exclus 27 year plant seed proceed twentieth annual acm symposium principl distribut comput p312 august 2001 newport rhode island unit state