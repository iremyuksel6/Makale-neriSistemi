selftest without gener bottleneck suppos p program design comput function f defin group g task selftest p test p comput f correctli input usual involv test explicitli p comput f correctli everi gener g case multivari function number gener henc number test becom prohibit larg refer problem gener bottleneck develop techniqu use overcom gener bottleneck function certain nice structur specif relationship valu function set gener easili checkabl use techniqu build first effici selftest mani linear multilinear nonlinear function includ fft variou polynomi function selftest present make o1 call program test consequ techniqu also obtain effici program resultcheck problem b introduct notion program resultcheck selftest selfcorrect introduc 4 17 5 power tool attack problem program correct method offer realist effici tool softwar verif variou use mathemat function shown selftest selfcorrector exampl found 5 3 17 9 14 18 1 19 21 6 theoret develop area heart recent breakthrough result probabilist checkabl proof subsequ result show nonapproxim hard combinatori problem suppos given program p design comput function f inform selftest f distinguish case p comput f correctli alway case p err frequent resultcheck function f take input program p input q p output pass p correctli comput f alway output fail p q 6 fq given program p comput f correctli input selfcorrector f program p sc use p oracl comput f correctli everi input high probabl 11 definit basic discuss result present basic definit tester checker etc state desir properti program let f function domain let p program purport comput f tester corrector checker defin probabilist program take p oracl addit take one follow paramet input accuraci paramet ffl specifi condit p expect paper unifi preliminari version appear 27th annual symposium theori comput 10 15th annual foundat softwar technolog theoret comput scienc 16 depart comput scienc cornel univers ithaca ny 148537501 erguncscornelledu work partial support onr young investig award n000149310590 alfr p sloan research award nsf grant dmi91157199 z depart comput scienc cornel univers ithaca ny 148537501 ravicscornelledu work partial support onr young investig award n000149310590 alfr p sloan research award nsf grant dmi91157199 x depart comput scienc univers houston houston work perform author sunybuffalo support part k regan nsf grant ccr9409104 un r kumar sivakumar meet confid paramet ae upper bound probabl testercorrectorcheck fail job follow definit formal notion selftest 5 selfcorrector 5 17 resultcheck 4 definit 11 selftest fflselftest f probabilist oracl program given ae 0 satisfi follow condit ffl pr x2d p definit 12 selfcorrector fflselfcorrector f probabilist oracl program p sc given input ae 0 satisfi follow condit ffl pr x2d p definit 13 resultcheck checker resultcheck f probabilist oracl program c given input ae 0 satisfi follow condit ffl pr x2d p output pass list three import properti requir selftest self corrector resultcheck definit state case self tester first selftest comput differ effici program comput f 4 restrict ensur implement obviou algorithm comput f henc could harbor set bug comput ineffici furthermor ensur run time asymptot better run time best known algorithm f second import properti requir requir knowledg mani correct valu f particular rule possibl mere keep larg tabl correct valu f input third import properti requir selftest effici effici selftest make o1ffl lg1ae call p constant ffl ae effici selftest make o1 call program rest paper often write o1 shorthand o1ffl lg1ae particularli discuss depend paramet interest follow wellknown lemma summar relationship notion selftest selfcorrector resultcheck reader conveni sketch idea proof lemma suppress detail accuraci confid paramet lemma 14 5 f selftest selfcorrector make o1 call program f resultcheck make o1 call program b f resultcheck selftest proof sketch part suppos f selftest selfcorrector given input oracl access program p first selftest p ensur doesnt err often selftest find p erron output fail otherwis comput fy use selfcorrector p sc program p output pass iff p clearli perfect program alway pass suppos p 6 fy one follow two case must occur program erron case selftest henc checker output fail program erron case selfcorrector comput fy correctli high probabl checker detect p 6 p sc output fail part b suppos f resultcheck use resultcheck test p randomli chosen input x fraction input x p x 6 fx estim output pass iff fraction less ffl use tool construct selfcorrector notion random selfreduc fine detail notion beyond scope paper refer reader paper 3 17 see also survey paper 11 inform function f randomli selfreduc evalu f input reduc effici evalu f one random input quick exampl note linear function randomli selfreduc comput fx suffic pick random r comput fx r fr final obtain function consid paper effici randomli selfreduc therefor whenev requir alway assum effici selfcorrect possibl 12 build selftest use properti process selftest whether program p comput function f correctli input usual twostep strategi first perform test verifi p agre input function g belong certain class f function contain f perform addit test verifi function g fact intend function f standard way test whether p agre function class f function base notion robust properti inform properti said robust character function famili f follow two condit hold 1 everi f 2 f satisfi 2 p function program satisfi input p must agre g 2 f input exampl blum lubi rubinfeld 5 establish properti linear serv robust properti class linear function use build selftest linear function gener techniqu first formal 19 robust properti properti predic f properti f x ffl ffirobust class function f domain satisfi follow condit theta ffl function program p satisfi pr x2d k p function g 9g 2 f p agre g ffi fraction input outlin process build selftest use robust properti cf 5 let finit group gener e class function rang r assum function f possess properti random selfreduc henc selfcorrect effici suppos p program purport comput specif function f 2 f let f x robust properti character f mention earlier process build selftest twostep process first step ensur program p agre function 2 f input use fact f robust properti character f specif selftest estim fraction ktupl hold fraction least 1 gamma ffl robust f follow g 2 f agre p ffi fraction requir estim carri random sampl x test properti f un r kumar sivakumar next step verifi function g function f p purport comput achiev test ge gener group true easi induct would follow g j f import point mention selftest access p g function g guarante exist nevertheless requir valu g may obtain use selfcorrect version p sc p anoth point worth mention carri step selftest need know valu f everi gener 13 gener bottleneck immedi applic basic method outlin function whose domain vector space larg dimens suffer major effici drawback exampl input function f ndimension vector n theta n matric number gener domain n resp n 2 straightforward approach exhaust test p sc agre f gener make n resp furthermor selftest built approach requir knowledg correct valu f n resp larg make overhead selftest process high issu call gener bottleneck problem paper address gener bottleneck problem solv fairli larg class function satisfi nice structur properti self tester build use also use build effici resultcheck import practic applic 14 result present fairli gener method overcom gener bottleneck test multivari function make o1 call program test first investig problem multivari linear function ie function f satisfi show gener techniqu appli natur vector space set main idea obtain easi uniform way gener gener singl gener use idea give simpl power condit linear function f effici selftest larg vector space appli scheme obtain effici selftest mani function includ polynomi differenti arbitrari order polynomi integr polynomi mod function etc also obtain first effici selftest fourier transform extend method case multilinear function ie function f linear variabl variabl fix build effici tester polynomi multipl consequ anoth applic give larg finit field show multilinear function finit field extens dimens n effici selftest o1 call independ dimens n also provid new effici selftest matrix multipl next extend result nonlinear function give selftest exponenti function avoid gener bottleneck exampl consid function comput squar polynomi finit field linear properti crucial proof linear function instead use fact lagrang interpol ident cf fact 41 polynomi give robust character exhibit selftest function make od call program test extend techniqu f constant degre exponenti case f constant degre polynomi eg polynomi finit field much harder first show reduct multipl comput lowdegre polynomi use reduct notion resultcheck construct selftest degre polynomi finit field extens dimens n make o2 call program test 15 relat work one method use get around gener bottleneck exploit properti downward selfreduc 5 selftest use properti howev makeomegagamma383 n call program depend way problem decompos smaller problem instanc tester perman function n theta n matric make call program wherea tester polynomi multipl use similar principl make olog n call 5 bootstrap tester polynomi multipl make olog n call program test given alreadi known matrix multipl test without call program use result checker due freivald 13 idea freivald matrix multipl checker also adapt build tester polynomi multipl make call program test approach howev requir underli field larg least 2 degre polynomi multipli fl posit constant moreov scheme requir tester perform polynomi evalu wherea fourier transform differ resultcheck use preprocess given independ 6 use fact follow fact variant wellknown chernoffhoeffd bound often use obtain errorbound sampl 01 random variabl 15 fact 16 let independ ident distribut 01 random variabl mean let 2 n 14 e organ paper section 2 discuss scheme linear function vector space x3 extend scheme multilinear function x4 outlin approach nonlinear function 2 linear function vector space section address problem selftest linear function vector space without gener bot tleneck demonstr gener techniqu selftest without gener bottleneck provid sever interest applic techniqu definit let v vector space finit dimens n field k let f function v ring r interest build selftest case fdelta linear function fcff c 2 k unit vector 1 ith posit 0s posit vector e 1 collect basi vector span v view abelian group vector addit v gener e assum field k finit sinc clear choos random element infinit field properti linear f ff fi shown robust 5 use gener construct selftest robust properti one obtain follow selftest function f 6 f erg un r kumar sivakumar properti test repeat 1 ae time pick ff fi 2r v verifi reject test fail gener test verifi p sc p pass properti test guarante exist linear function g close p howev two problem gener test one selftest inefficientif input vector size n selftest make call program desir secondli selftest need know correct valu f n differ point also undesir primari interest avoid gener bottleneck solv problem mention key idea find easi uniform way convert one gener next gener illustr idea follow exampl exampl let pn denot addit group degre n polynomi field k element multipli gener x k x give next gener x k1 polynomi q 2 pn scalar c 2 k let denot function evalu qc clearli e c linear satisfi simpl relat e c suppos p program purport comput assum p pass properti test given know robust linear linear function g agre p input note g comput correctli high probabl via self corrector easi construct linear function 5 rather verifi gx k pn may instead verifi g satisfi properti easi induct impli g agre e c gener linear g follow g agre e c input face task verifi expens tri explicitli exhaust instead prove suffic check o1 test almost everywher look pick mani random q 2 pn ask program p sc comput valu gq gxq crosscheck hold word prove properti j g q j robust restrict sens assumpt g linear gener interpret robust guarante exist h satisfi agre g larg fraction input actual show h j g henc restrict sens notic number point selftest need know valu f one contrast n origin approach 5 gener via basi rotat function note idea natur gener vector space let denot basi rotat function ie linear oper vector space v rotat coordin axe span view matrix defin onetoon correspond set basi vector everi e comput payoff achiev simpl relat fff fff vector specif show gener bottleneck avoid easili comput function h f ff 2 v instanc polynomi evalu e c obviou drop suffix f simpli denot h f h function f linear linear impli h linear second argument follow sens h ff import h easi comput given ff fff use scheme show mani natur function f suitabl candid h gener test 5 replac basi test verifi p sc induct test repeat 1 ae time pick ff 2r v verifi p sc reject test fail follow theorem prove replac valid theorem 21 suppos f linear function vector space v ring r suppos p program f let ffl 12 suppos p satisfi follow condit function g defin linear function v g agre p least 1 gamma 2ffl fraction input b furthermor suppos h ff satisfi follow condit 3 pr ff2v gff 6 h ff gff ffl ff ff defin remark theorem mere list set properti fact set yield selftest present theorem 22 note hypothes 1 2 3 condit p g test perform selftest proof proof function g linear p sc comput g high probabl due 5 rest proof assum g linear satisfi condit 2 3 first argu suffic prove condit hold everi agre f first basi vector 1 basi vector e obtain e would follow g comput f correctli basi vector final sinc g linear comput f correctli v sinc vector v linear combin basi vector show condit 3 impli 8ff 2 v arbitrari element ff 2 v show probabl random un r kumar sivakumar posit sinc equal independ fi hold nonzero probabl must true probabl 1 pr theta first equal rewrit second equal follow linear third equal follow fact g linear random variabl fi distribut uniformli v random variabl fi ff gamma fi distribut ident uniformli v therefor assumpt g satisfi condit 3 fourth equal fail probabl 2ffl fifth equal use fact h linear last equal use fact g linear forego theorem show p g satisfi certain condit g comput use p ident equal function f selftest compris follow test linear test basi test induct test theorem 22 ae 1 ffl 12 three test compris 2fflselftest f program p comput f correctli input selftest output pass probabl 1 p comput f incorrectli 2ffl fraction input selftest output fail probabl least 1 gamma ae proof perform three test selftest essenti estim probabl list condit 1 2 3 hypothesi theorem 21 note condit 2 involv probabl rather selftest use p sc comput ge 1 choos o1ffl log1a sampl linear test induct test use selfcorrector confid paramet ae3 basi test selftest ensur confid check condit least 1 gamma ae3 correctli tester alway output pass con vers suppos tester output pass probabl ae hypothes theorem 21 true conclus theorem 21 follow function g ident f exist g equal p least 1 gamma 2ffl fraction input 21 applic present applic theorem 22 remind reader linear function f vector space v effici selftest without gener bottleneck linear function h easili comput satisfi applic f show suitabl function exist satisfi condi tion recal exampl polynomi evalu function e c ident e c hold applic establish similar relationship also sake simplic give technic paramet requir comput routin calcul follow proof theorem last section applic concern linear function polynomi obtain selftest polynomi evalu fourier transform polynomi differenti polynomi integr mod function polynomi moreov vector space set let us state result term matric comput linear transform vector space let pn k x denot group polynomi x degre n field k group pn form vector space usual polynomi addit scalar multipl element k polynomi polynomi vector represent q basi rotat function case multipl x thu multipli q x result polynomi degre n 1 handl minor detail assum program work domain pn1 conclud correct pn polynomi evalu c 2 k let e c q denot describ function return valu qc function linear moreov relat e c xq e c q simpl linear e c selftest program p claim comput e c induct test simpli choos mani random qs verifi p sc hold oper discret fourier transform distinct element k one may wish evalu polynomi q 2 pn simultan point idea e c extend easili case u 2 k relat hold simultan let princip n 1st root uniti k oper convert polynomi coeffici represent pointwis evalu power known discret fourier transform dft dft mani fundament applic includ fast multipl integ polynomi nota tion dft polynomi q 2 pn simpli f dft f linear f function h realli n coordin function h n selftest simpli choos qs randomli request program comput f q f xq verifi hold suggest follow gener case arbitrari vector space simultan evalu polynomi correspond multipli vector p idea use test simultan evalu polynomi dft extend give selftest linear transform repres vandermond matrix matrix dft written vandermond matrix f invers dft convert polynomi pointwis represent coeffici form also vandermond matrix whose entri given e gammaij follow invers fourier transform selftest effici anoth point worth mention carri induct test selftest comput det f need verifi mani randomli chosen qs ident e f qi hold oper elementari jordan canon form linear oper said elementari jordan canon form diagon entri c element left main diagon first nonprincip diagon lower triangl 1s easi verifi 0 matrix gamma1 top left corner 1 bottom right un r kumar sivakumar corner zero elsewher therefor everi vector space give easi way implement induct test selftest attempt extend matric jordan canon form even diagon matric seem work howev diagon shift diagon matrix special structur obtain selftest avoid gener problem exampl matrix correspond differenti polynomi special structur contain entri n diagon main diagon differenti integr polynomi differenti polynomi linear function explicit form integr polynomi linear function pn pn1 explicit form h even though readili fit framework sinc form proof theorem 21 easili modifi handl case use linear complet spell detail robust induct test chang requir lemma 23 g pn pn1 linear function satisfi pr q2pn gxq 6 proof pr r2pn theta sinc event hold posit probabl independ r hold probabl one thu avoid gener bottleneck function consid special case previou applic higher order differenti polynomi let k denot kth differenti oper easi write recurrencelik ident k term give us selftest librari set describ 5 20 one assum program comput differenti oper wish selftest program comput k librari lowerord differenti assumpt valid remedi use follow lemma prove appendix lemma 24 q polynomi x degre k use ident selftest perform induct test robust induct test establish proof theorem 21 complet outlin key step let c denot coeffici term sum lemma 24 thu c gammax kgammai lemma 25 g linear function satisfi pr q2pn proof pr r2pn theta x first equal rewrit second equal hold probabl 1gamma2ffl assumpt pr q event hold posit probabl independ r hold probabl one thu test g satisfi ident q suffic ensur g satisfi ident everywher g satisfi ident know follow conclud g j k induct need modifi basi test test k base case mod function let ff 2 k x monic irreduc polynomi let ff q denot mod function respect ff ff ff linear function addit interpret mod ff addit sinc ff monic degre ff q alway less deg ff c 2 k coeffici highest degre term ff q ae xm ff q deg xm ff q deg ff test program p comput function ff step 3 selftest choos mani qs random comput p sc q p sc xq verifi one ident p sc hold depend degre q 3 multilinear function section extend idea x2 multilinear function kvariat function f call klinear linear variabl variabl fix ie fff main motiv exampl multilinear function polynomi multipl bilinear note domain f gener n 2 gener form ie pair gener suppos wish test p purport comput f naiv approach would requir gener test n 2 gener requir 2 call p render selftest highli ineffici blum lubi rubinfeld 5 give effici bootstrap selftest make olog ok n call p seen gener klinear function method extend yield tester make olog ok n call p context allow think k constant sinc chang k result entir differ function f interest reduc number call p respect un r kumar sivakumar problem size n specif function f complex tester present independ n selftest requir know correct valu f one point previou section result appli mani gener multilinear function larg vector space defin set properti depend f satisfi p would necessarili impli p must particular multilinear function f simplic present follow theorem f bilinear analog theorem 21 multilinear function theorem 31 suppos f bilinear function v 2 ring r suppos p program f let ffl 14 suppos p satisfi follow condit function g defin gff bilinear function v 2 g agre p least 1 gamma 2ffl fraction input b furthermor suppos g satisfi follow condit proof simpl extens proof 5 show g bilinear better bound ffl via differ test obtain appeal 2 proof theorem 21 suffic show given three condit stronger version condit 3 hold gff 1 h 2 addit last properti shown g j f take condit 2 ge 1 base case induct obtain e via applic either gener 1 shown ge base element combin bilinear properti g impli correct g everi input proceed show requir intermedi result given condit 1 2 g satisfi stronger version condit 3 requir pr theta h 2 first equal rewrit term multilinear g impli second third equal probabl prgff fourth equal fail probabl less 4ffl rest equal follow multilinear h 2 g ffl 14 probabl nonzero sinc first last term independ equal nonzero probabl result follow similar approach work h 1 well multilinear test repeat 1 ae time pick verifi reject test fail basi test verifi p sc induct test repeat 1 ae time pick verifi verifi reject test fail note latter two test use selfcorrect version p sc p notion selfcorrector multilinear function vector space impli random selfreduc easi see theorem 31 extend arbitrari klinear function long ffl 12 k thu obtain follow theorem whose proof mirror theorem 22 theorem 32 f kvariat linear function ae 1 three test compris 2 k fflselftest f succe probabl least 1 gamma ae 31 applic let q 1 q 2 denot polynomi x function mq multipli two polynomi symmetr linear variabl moreov sinc polynomi multipl effici selftest interest applic polynomi multipl togeth mod function describ x21 follow wellknown degre n finit extens k finit field f isomorph field fxff ff irreduc polynomi degre n f isomorph element k view polynomi degre n f addit two element sum polynomi multipl q q 1 q 2 mod ff follow field arithmet addit multipl finit extens finit field selftest without gener bottleneck number call made program test independ degre field extens 32 matrix multipl let mn denot algebra n theta n matric mn mn denot matrix multipl matrix multipl 14 f erg un r kumar sivakumar bilinear function howev sinc matrix oper rather vector oper ation requir slightli differ treatment gener multilinear function mn view addit group n 2 gener one possibl set gener gener e ij matrix 1 posit note gener e ij convert gener e k via sequenc horizont vertic rotat obtain multipl special permut matrix pi rotat oper correspond oper model multilinear func tion howev two differ kind rotationshorizont vertic due twodimension natur input function h defin behavior function respect rotat alway easili comput short actual perform matrix multipl therefor exploit addit properti problem come set condit suffici p comput matrix multipl f let 0 n denot subgroup mn contain matric column allzero theorem 33 let p program f ffl 18 suppos p satisfi follow ffl function g defin gx bilinear function 2 n g agre p least 1 gamma 2ffl fraction input b furthermor suppos g satisfi follow condit abl prove theorem first need show condit recount stronger implic statement show strengthen version condit impli theorem 33 first show condit 2 impli stronger version lemma 34 condit 2 theorem 33 hold ge proof fact show someth stronger show gx pr theta gx second equal hold probabl condit 2 rest hold linear g f result follow sinc ffl 14 lemma follow sinc n immedi adapt proof lemma 34 use extend condit 3 hold input next show linear g make possibl conclud hypothesi 4 g associ lemma 35 condit 4 theorem 33 hold g alway associ proof pr theta first equal hold linear g expand xy z respect second one true condit 8ffl last one recombin term use linear tool prove theorem 33 proof bilinear g follow proof theorem 31 lemma 34 35 condit 2 extend condit 3 4 hold input show properti suffici identifi g matrix multipl note multilinear g write 1ijn 1kn 1ijkn impli g f use assumpt proceed show former hold first equal rewrit two gener term gener second one follow strengthen condit 3 g comput f whenev one argument equal power pi third one follow associ g fourth one hold g f first input power pi rewrit e kj gamma2 fifth equal true g comput f correctli first argument e i1 consequ condit 2 see lemma 34 last one rewrit previou equal use associ multipl therefor g function f present test associ un r kumar sivakumar associ test repeat 1 ae time pick xy z 2r mn verifi p sc x p sc reject test fail selftest built test condit 1 2 3 4 correspond properti test basi test induct test associ test respect note test condit 2 3 involv know valu f random input input howev come restrict subspac make possibl comput f easili effici follow theorem immedi theorem 36 ae 1 ffl 18 fflselftest matrix multipl succe probabl least 1 gamma ae 4 nonlinear function section consid nonlinear function specif deal exponenti constant degre polynomi ring polynomi finit field z p obviou exponenti constant degre polynomi clearli defin ring 41 constant degre exponenti first consid function q rais polynomi dth power suppos program p claim perform exponenti degre n polynomi q 2 pn k x use lowdegre test rubinfeld sudan 19 see also 14 first test function comput p close degre polynomi g use selfcorrect version p sc p also verifi ge 1 induct ident appli one test whether p satisfi properti input remain show impli follow strategi similar case linear function time use lagrang interpol formula robust properti identifi degre polynomi note idea similar use interpol formula gemmel et al 14 extend 5 result linear function lowdegre polynomi proceed proof state follow fact concern lagrang interpol ident fact 41 let g degre polynomi q 2 pn distinct element pn also selftest compris follow test degre test verifi p close degre polynomi g lowdegre test reject test fail basi test verifi p sc induct test repeat 1 ae time pick ff 2r v verifi p sc reject test fail let fi denot probabl random choic domain produc distinct element assum domain larg enough fi close 1 assum p pass degre test p sc pass basi test agre degre polynomi g input note lowdegre test 19 make o1ffl log1a call render decis confid o1ffl log1a call comput g correctli probabl ae3 sketch proof ffl p sc pass induct test g satisfi time taken tester thetad ae constant pr first equal fact 41 appli sinc g verifi degre polynomi sinc q uniformli ident distribut induct test second equal fail probabl 1ffl third equal rewrit fourth equal due fact 41 interpol ident appli long q distinct event occur probabl fi sinc equal hold independ q ffl hold probabl 1 theorem 42 function o1dselftest make od queri 42 constant degre polynomi next consid extend result x41 arbitrari degre polynomi f pn p nd clearli lowdegre test basi test work interpol ident valid miss ingredi avail ident like f shown robust properti effici test show get un r kumar sivakumar around difficulti idea base suggest due r rubinfeld privat commun nd degre polynomi eg suppos program p purport comput f strategi design selfcorrector r p estim fraction input q p q 6 rq difficulti implement idea directli use random selfreduc f use selfcorrector comput f correctli everi input depend critic abil certifi p correct input sinc check whether p correct input precis task selftest seem go cycl circumv problem design intermedi multipl program q use p oracl design program q prove follow technic lemma help us express dari multipl term fthat establish reduct multilinear function nonlinear function f reduct gener degre elementari polar ident slightli stronger work arbitrari polynomi degre degre exponenti lemma 43 x 2 f0 1g let x denot ith bit x polynomi degre x2f01g g use reduct given lemma 43 show construct fflself tester f follow outlin sketch 1 first build program q perform cari multipl c simpli multipli extra 1s program q selftest effici without gener bottleneck use 12 d1 selftest dvariat multilinear multipl function x3 number queri made p process o1 constant depend degre f n dimension domain f thu q pass selftest step comput multipl correctli 12 d1 fraction input q fail selftest process selftest reject 2 next build reliabl program q sc selfcorrect q use random selfreduc multilinear multipl function q sc use comput cari multipl c correctli everi input probabl least 1 gamma ae constant ae 0 particular make o2 log call henc o2 2d log call p q sc use comput multipl correctli everi input probabl least 1 gamma 110d 3 next use q sc build program r comput fq straightforward way use q sc comput requir multipl q sc comput multipl correctli probabl correctli input probabl least 09 final randomli pick o1ffl log1a mani sampl q check output pass iff p chosen valu q easi see p comput f correctli input selftest output pass probabl one convers suppos output pass upper bound probabl event ae sinc q pass selftest step step 1 comput multipl correctli 12 d1 fraction input therefor use selfcorrector q sc describ step 2 justifi turn impli guarante made r step 3 everi input q probabl least 09 step 4 probabl p q 6 rq singl random q least 09ffi probabl p everi random input q chosen step 4 therefor 1 gamma 09ffi thu probabl output pass given pr q p q 6 fq ffl ae follow theorem proven modulo proof lemma 43 theorem 44 function fq f polynomi q 2 pn degre o12 selftest make o2 queri even though selftest make o2 queri test degre exponenti number queri independ n dimension domain thu selftest attract n larg small particular conjunct tester finit field arithmet describ x31 selftest describ help us effici selftest constant degre polynomi finit field extens larg dimens remain prove lemma 43 lemma direct corollari follow lemma illustr method express dari multipl term f proof next lemma given appendix lemma 45 let distinct variabl x 2 f0 1g let x denot ith bit x x2f01g appendix proof lemma 24 lemma 45 lemma 24 q polynomi x degre k proof induct k base case obvious true let k 0 sinc differenti linear sinc first term 0 first sum vanish sinc delta first sum evalu 1q induct hypothesi henc suffic show second sum evalu 0 summat written titi sum split term xdq second term seen un r kumar sivakumar gammaxkdq use induct hypothesi first third term combin obtain kxdq use induct hypothesi thu entir lemma 45 let distinct variabl x 2 f0 1g let x denot ith bit x x2f01g proof proof use fourier transform boolean cube f0 1g us ing standard isomorph f0 1g z denot space function z c f finit vector space function dimens 2 defin inner product function f x fxgx defin function ff z x ff denot ith bit respect x ff easi check whenc everi ff charact z furthermor easi check h ff therefor charact ff form orthonorm basi f everi function f z uniqu expans basi ff f ff ff call fourier transform f coeffici b f ff call fourier coeffici f orthonorm basi b h ff fi easi properti fourier transform ff 6 0 fact true nontrivi charact group proof lemma note suffic prove lemma complex number p fix list complex number defin function left hand side statement lemma 2 b thu x2z f ff x x 0n1 n c 0n1 n c x 0n1 n c x innermost sum zero ff everi n imposs sinc way happen otherwis n 1 sinc easi see 2 b acknowledg grate ronitt rubinfeld valuabl suggest guidanc thank manuel blum mandar mitra use discuss thank dexter kozen comment grate two anonym refere valuabl comment result mani improv exposit idea describ proof lemma 45 use fourier transform also due one refere r check approxim comput real hide instanc multioracl queri design program check work theori test meet test theori reflect pentium divis bug function equat model scienc engin ing note selftestingcorrect method trigonometr function local random reduct interact complex theori approxim cliqu almost npcomplet fast probabilist algorithm selftest without gener bottleneck new direct test test polynomi function effici ration main robust character polynomi applic program test mathemat theori selfcheck robust function equat applic selftest correct role algebra effici verif proof tr ctr kiwi algebra test weight distribut code theoret comput scienc v299 n13 p81106 marco kiwi frdric magniez miklo santha exact approxim testingcorrect algebra function survey theoret aspect comput scienc advanc lectur springerverlag new york inc new york ny 2002