random name use waitfre share variabl name protocol assign uniqu name key everi process set commun process construct random waitfre name protocol use waitfre atom readwrit regist share variabl process intercommun primit process privat regist read other addressesnam one use other possibl differ process ipi iqi address regist process iri way known ini process 0 protocol use name space size 1 ini ioiini log ini log log ini run time readwrit share bit probabl least 1ioi1 ioiinilogsup2supini overal expect run time protocol base waitfre implement novel testsetonc object randomli fast select winner set iqi contend probabl least face strongest possibl adapt adversari b introduct name protocol concurr execut process subset n process select host process uniqu name common name space name space small prefer size n process may may name start result variant name problem call renam problem distribut concurr system distinct name use sometim mandatori varieti situat includ mutual exclus resourc alloc leader elect choic coordin case name protocol put good use process creat termin dynamicallya common occurr distribut concurr systemsth name space may grow number process remain bound renam procedur use size name space exampl network protocol crash duplic name perform effici small name rang found 27 30 name protocol also use alloc ident resourc name permit resourc sinc algorithm waitfre see also highli faulttoler manag assign resourc compet process correspond repetit variant name problem 7 sequel also write key name key rang name space interprocess commun use interprocess commun share memori allow arbitrarili initi share memori dirti memori model 23 share memori primit waitfre atom readwrit regist 21 22 wide use theori distribut algorithm 16 determinist protocol execut n process waitfre finit function f everi nonfaulti process termin protocol execut number fn step regardless process execut speed crash failur word waitfre solut 1resili process crash failur random protocol waitfre fn upper bound expect number step expect taken random system execut worstcas adversari class adversari consid result adapt adversari construct use singlewrit multiread waitfre atom regist construct 29 22 use 8 9 19 also write share variabl regist anonym commun model everi regist written exactli one process read processesthi way write process send messag process process use common index scheme process regist initi consist number among process call 8 9 19 optim name trivial everi process rank number among valu choos ranknumb key make problem nontrivi everi process privat regist read regist process use possibl differ index scheme process p q address regist own process r possibl differ way known may happen larg dynam chang system consist requir difficult imposs maintain 23 cryptograph system consist avoid model use consensu protocol 5 6 18 testandset implement outlin 2 symmetr share memori anoth way prevent trivial rank use symmetr share memori model share memori symmetr consist set ident process commun pool share variabl read written 20 13 complex measur comput complex distribut determinist algorithm use share memori commonli express number type intercommun primit requir maximum number sequenti readwrit singl process system execut local comput usual ignor use waitfre atom readwrit regist primit primit must ultim implement waitfre singleread singlewrit waitfre atom readwrit bit turn implement mathemat version hardwar flipflop 21 effici implement use 22 reduc multius multivalu regist singleread singlewrit multivalu regist 21 reduc latter singleread singlewrit waitfre atom readwrit bit standard complex make comparison algorithm unambigu express time space complex term readwrit elementari share bit random algorithm execut process random process flip coin access random number gener random algorithm answer alway correcteach process alway get uniqu keybut small probabl protocol take long time finish use customari assumpt coin flip subsequ write share memori separ atom action express comput complex algorithm use worstcas complex probabl ii expect complex system execut respect random process worstcas schedul strategi adapt adversari previou work agreement problem determinist model comput share memori messag pass unsolv presenc fault 15 17 24 sur prisingli 7 show renam problem requir nontrivi form interprocess agreement solvabl messag pass model solut tresilientup crash failur toleratedand use name space size nt take exponenti time n protocol later transform 8 two solut asynchron share memori model waitfre achiev run time n key rang size recent 10 demonstr waitfre longliv share memori implement renam k n process use achiev key rang size ok 2 determinist waitfre solut asynchron share memori model key rang size 2n gamma 1 necessari 19 result use asymmetr share memori form singlewrit multi reader waitfre atom readwrit regist step read write one regist moreov global address regist known plethora work name problem use share memori cite 23 20 13 discuss relev paper 20 shown use bound symmetr share memori determinist solut random waitfre solut adapt adversari appendix imposs give waitfre random unbound symmetr share memori solut fair adapt adversari key rang size n logarithm expect number roundstim unit everi process make least one stepassum log nbit regist show unbound memori also necessari adapt adversari also give olog n expect time solut key rang size n fair oblivi adversari use share memori consist log nbit regist independ 13 gave random solut bound symmetr memori model key rang size n run expect 6 fair oblivi adversari use 4 share atom multiwrit multiread bit summar asynchron bound share memori determinist waitfre solut expens term achiev key rang asymmetr case imposs symmetr case even allow random assum adapt adversari remain case treat result show random yield waitfre inexpens solut term time space key rang asynchron asymmetr bound share memori model singlewrit multiread waitfre atom share regist use anonym commun model process initi name equival global consist index processor construct requir sever algorithm end give random waitfre name algorithm assum adapt adversari strongest adversari first algorithm implement fftestsetonc object oneshot test andset guarante among q n compet process invok uniqu winner probabl ff ff paramet chosen arbitrarili close 1 object safe one process winner invok q n process use olog q 1writer nreader share bit per process run time log q readwrit bit properti shown theorem 1 applic typic n high probabl use complex primit object implement use n copi 1writer nreader olog log q bit readwrit regist run time log q readwrit regist b singl nwriter nreader 1writerpercompon ncompon composit regist log log nbit compon snapshot memori 4 1 run time olog q readwrit composit regist second algorithm waitfre name algorithm segment use fftestsetonc object given ffl 0 segment use name space size 1 ffln n number process protocol alway correct sens nonfaulti process receiv distinct name run time random variabl whose valu log n log log n bit oper high probabl high probabl mean probabl run time exce valu o1 quantiti tend 0 n grow lemma 3 fact prove maximum run time among noncrash process log n log log n bit oper probabl still possibl expect run time coin flip sequenc infinit next theorem 2 show minor modif proof similar lemma 3 demonstr expect run time modifi protocol involv process bound log 2 n henc segment waitfre paper organ follow section 2 appendix spell assumpt model comput appendix b show simpl approach doesnt work motiv introduct fftestsetonc object section 3 object use section 4 obtain name protocol preliminari sequenti execut finit program bound local variabl commun singlewrit multiread bound waitfre atom regist share variabl latter common model interprocess commun share memori discuss briefli section 1 detail see 21 22 use motiv distribut protocol see 8 9 19 21 share regist anonym commun atom everi readwrit regist own one process owner regist write process read one step process either read valu regist ii write valu one regist iii flip local coin invok random number gener return random bit follow local comput commun anonym process privat regist read other addressnam use other possibl differ process p q address regist process r way known requir system atom everi step process thought take place indivis instanc time everi indivis time instanc one step one process execut atom requir induc actual system execut total order set step differ process set step everi individu process set readwrit oper execut individu regist state system give process content program counter content local variabl content own share regist sinc process execut sequenti program state everi process singl step execut next step enabl state adversari schedul demon state decid enabl step execut next thu determin sequenc step system execut two main type adversari oblivi adversari use fix schedul independ system execut much stronger adapt adversari dynam adapt schedul base past initi segment system execut result hold adapt adversaryth strongest adaversari possibl comput complex random distribut algorithm adversari set correspond notion waitfre requir care definit distract reader deleg rigor novel formul adversari restrict measur set system execut appendix believ interest right use elsewher assum notion system execut waitfre adapt adversari expect complex familiar random distribut algorithm waitfre expect number readwrit share memori everi particip process bound finit function fn n number process expect taken probabl measur random system execut worstcas adapt adversari 22 obviou strategi doesnt work appendix b analyz name strategi first come mind show doesnt work sens fn bound expect number readwrit share memori least exponenti name soon one process claim key adversari make process fail problem resolv testandset mechan ensur winner among set claim process howev exist construct 2 requir process consist numberingth model anonym point introduct would render name problem trivial rank number choos rank key see also 8 9 19 resolv problem introduc probabilist fftestsetonc object select winner high probabl doesnt requir consist initi number among process 3 probabilist fftestsetonc object fftestsetonc object share n process probabilist waitfre object function everi ff construct object concurr invok subset user process select winner probabl ff q n process compet object maximum number share bit access perform process expect log q typic q olog n expect log log n object base follow properti geometr distribut 1 suppos 1 refere point collis resolut analysi distribut network algorithm 12 q random variabl x ident geometr distribut prx good probabl uniqu maximum j 6 31 synchron algorithm consid n process number 1 n n theta 1 matrix n enter competit express initi set 1p fill remaind zero entri game divid round k round everi process still game independ flip ident coin probabl success gamma 1 failur round k everi process p kp coin p coin flip success step forward set k1p round three mutuallyexclus possibl outcom exactli one process step forward other backoffth process declar winner game end ii process backoff case game end winner iii one process step forward case game continu one two aforement event occur let fq denot probabl game end winner initi number q compet process exact behavior fq seem hard analyz fortun next lemma give easi proof statement good enough purpos defin ii q 2 fq f2 proof suppos first coin flip k q initi process step forward sinc number row avail game unbound probabl winner point exactli fk let x random variabl denot number process step forward probabl game end winner recal equat rewritten 11 14 3 paper appar address differ issu method analys one present probabl exactli k q process step forward next row given case two equat give impli first part lemma prove second part lemma induct base case f2 f2 trivial induct step assum fk f2 2 k q use 1 2 follow induct hypothesi last inequ equival verifi use 2 3 2 next lemma show high probabl game end quickli winner probabl winner within r row least ns r proof let w r event winner within r row 1 valu q prthere prthere winner r row process make least r row ns r import corollari lemma choos r appropri probabl winner within olog q row set arbitrarili close 1 word infinit mani row need simplifi analysi want probabl success need satisfi 2s ns r set number row need would r 2ffl lognffl instanc need r need 32 asynchron implement let entri matrix correspond state 1writer nreader bit let r row r theta n matrix jth bit array written process j read process definit 1 process step forward row row k first set privat bit row k 1 read bit row k 0 process said luckyatrow k even though asynchron system process determin whether reach certain row alon whether slower process eventu reach row suffic determin whether lucki geometr distribut ensur process backedoff mani row say k log n high probabl one left trivial luckyatrow k 1 k r necessari winner show lucki row r suffici winner theorem 1 everi fftasonc protocol implement fftestsetonc object select uniqu winner among set invok process probabl least never select one winner object invok repeatedli key assign provid crash occur object invok q n process invoc use log q 1writer nreader atom singl bit regist worst case run time log q readwrit share bit proof figur 1 process p own array atom bit denot a1r pone bit row game ith row ai 1n one bit ai p own process n initi line 1 figur 1 process check whether object current occupi process tri grab key whether initi memori dirti possibl previou competit exit report failur way line 9 line 9 reset bit ai p 1 r own process 0 clean possibl dirti memori futur tri cours need done start process add line code effect line 2 8 implement follow algorithm determin lucki current row ye step forward probabl 1 otherwis probabl valu process process win luckyatrow r otherwis fail show one process win henc protocol safe exit report failur protocol clean privat bit row line 9 done make object reusabl process win crash occur eventu everi non faulti process get name probabilist point view immateri whether coin flip synchron asynchron coin flip independ rate process back remain essenti unchang key probabilist analysi asynchron process anoth main ingredi proof simpl upper bound number lucki process per row notic also process actual winner rowal process back offfrom step one row next probabl 1 relev properti protocol live everi non faulti process execut protocol bound number step regardless process speed crash failur safeti one process win number row olog q probabl among q n compet process winner ffa paramet set arbitrarili close 1 2 fftasonc waitfre use 2nr r readwrit 1writer nreader share bit proof process p invok protocol either back immedi execut join competitit either win execut 2nr step back lose execut 2nr remaind section consid system q n process execut protocol figur 1 execut system crash occur show case process get keyand henc capturedwith probabl ff set process back execut let b jbj row number lucki process b 1 one outsid b proof process exit right away execut line 1 call compet process everi row row 1 row r everi still compet process p first set arow p 1 execut writearow p 1 line 3 protocol subsequ 2 case crash need bother estim probabl adversari forc sacrific process everi invok either process crash one process win game probabl ff 1 given enough object nonfaulti process sooner later get key problem discuss make happen fast process use object possibl fshare declarationsg param r int fnumber row game olog qg param 0 var share array boolean fa1r p own process p g procedur invok processg var var tmp1n array boolean begin 1 row startedmemori dirtyg od 2 row 0 fjoin gameg 4 fcheck content row g 5 fif alon rowg els 7 row r goto l2 8 els goto l1l2 probabl 9 l2 row 0 writearow p figur 1 protocol fftasonc q n process p invok process read bit row execut loop line 4 suppos way contradict two process p p 0 back luckyatrow row assum p execut writearow p 1 p 0 execut writearow p 0 1 sinc back bit stay 1 order atom event contradict p 0 lucki arow time p 0 read 2 consequ among process back one lucki certain row process back could lucki consid instanc process 3 stand row row suppos adversari freez first two possibl b 3 step ahead luckyatrow row eventu b 3 process ahead b 1 b 2 back reiniti bit zero line 9 protocol figur 1 afterward b 2 could unfrozen adversari lucki row row later one process win proof process luckyatrow r backoff particular clean row bit line 9 protocol henc two lucki process row r contradict 2 2 consid set execut process crash occur bit fftestsetonc object initi correctli 0 success probabl fftasonc q n invok process least ff 2s proof intuit aim adversari prevent process win bound probabl adversari succe increas power sinc assum crash occur two way adversari prevent win occur either two process reach row r process back prior row r make two copi game allow adversari play consid two object invok number process one game adversari tri maxim probabl first two spoil event occur tri maxim probabl second spoil event adversari succe win least one two game clearli upper bound probabl succe play one game consid first case focu subset c process backoff adversari bring one process p row r probabl 1 probabl anoth process p 0 2 c reach row r process c reach row r definit claim 2 row one process c lucki therefor p 0 reach row r sequenc coin toss bring process p 1 row 1 row 2 anoth process p 2 row 2 row 3 process might differ case probabl consecut success r henc probabl adversari spoil game case prsome reach row r reach row reach row consid case sinc assum crash occur particip process must toss coin either back reach row r long take immateri coin flip independ sinc interest probabl back row r disadvantag adversari process step forward probabl 1 inde probabl 1 event increas number forward step process henc probabl winner bound synchron game name ns r 2 set r log q theorem proven 2 analysi use 1writer nreader 1bit regist intercommun primit cours use complex primit complex figur decreas corollari 1 everi implement fftestsetonc object succe probabl least ff invok q n process use n copi 1writer nreader olog log qbit share readwrit variabl run time log q readwrit share bit proof replac array a1r p fftasonc singl olog log qbit variabl use counter count log q modifi protocol obviou way implement would impli slightli higher run time measur access 1writer 1reader share bit advantag fftasonc point view space complex share variabl implement use 1writer 1reader share bit 22 29 31 2 4 notion composit regist snapshot object construct multius waitfre atom readwrit regist composit regist use obtain snap shot state set share variabl system waitfre readwrit regist r written process without chang process atom read r atom linearli order definit read process give snapshot content share variabl r corollari 2 everi implement fftestsetonc object succe probabl least ff q n process use singl nwriter nreader 1writerpercompon ncompon composit regist log log nbit compon run time olog q readwrit composit regist proof array counter previou corollari replac composit regist aka snapshot object defin 4 1 improv complex figur would simplifi protocol given avail snapshot object implement 2 4 waitfre name protocol base waitfre random name protocol fftestsetonc object compet process key space consist fftestsetonc object one key param n int fnumber processesg param ffl real fspecifi keyrang g f segment size l bc delta log ncg procedur var start begin start l bstartl cl fbegin segment g repeat fphase 1 tri get key within segmentg succeed fftasonc key succeed 0 fphase 2 linear searchg succeed fftasonc key od figur 2 protocol segment process p 41 simpl hard analyz strategi first glanc simpl strategi appendix b may suffic process repeatedli invok object select uniformli random succe get key process get key averag expect ffm object fire correctli sens assign key one invok process choos nfffi take care random fluctuat ensur everi process eventu get key run time simpl strategi seem hard analyz point time set process still vy key match set avail object key number avail object determin probabl get key randomli select object must least avail turn probabl determin number round need slowest process get key problem number empti object given round depend adversari process stop let go occupi object clear us frame possibl adversari strategi 42 trickier easi analyz strategi segment impos littl bit structur way object invok possibl come simpl effici protocol segment amen clean analysi set ff reliabl fftestsetonc object fi paramet take care random fluctuat show fi therefor set taken arbitrarili small must fix divid key space segment length l c constant specifi later ln denot natur logarithm think segment ring object ith il th object segment protocol shown figur 2 follow process select random key start automat determin segment whose initi posit denot l process start invok key walk around segment process first tri get key invok fftestsetonc object correspond first random choic start necessari invok next modulo l object ring get back start point start shall see high probabl everi process get key reach point extrem unlik event process find key segment whole key rang scan repeatedli key found phase 2 protocol ensur process eventu get name lemma 3 everi solv name problem n use fftestsetonc object protocol safe correct run time log n log log n readwrit 1writer nreader share atom bit proof show high probabl process segment captur find key crash insid segment therefor everi fftestsetonc object invok ol time high probabl well consequ appli theorem 1 q olog n nonfaulti process mean find key within segment first show process distribut evenli among segment let segment prprocess p select l prprocess p select sinc segment chosen independ invok chernoffbound estim tail binomi distribut follow form see exampl set c ensur probabl segment receiv 1 ffl process also need ensur everi segment captur process need take care adversari basic problem follow whenev object invok adversari may may crash process object invoc happen say object corrupt consid case one process walk around whole segment without find key happen object segment invok number corrupt object l gamma amani noncorrupt object succe probabl ff independ object word consid l gamma bernoulli trial probabl success equal ff success mean invok process given key notic small valu l gamma larg deviat mean like therefor advantag adversari crash process therebi corrupt object hope segment captur process aim ensur segment captur process show appropri choic constant c almost sure never happen notat recal definit captur expect number captur process least least corrupt object adversari must crash least one process chernoff bound true number captur process least probabl least know high probabl segment p process straightforward comput show p everi 0 long left verifi matter chosen adversari segment captur process high probabl end notic p therefor impli probabl segment fail captur process bound independ adversari straightforward comput show except probabl 2n 2 provid sinc ml n segment probabl segment fail togeth equat 5 give probabl process find key within olog n object invoc similarli everi object invok ol time probabl theorem 1 everi object invoc run time olog log n readswrit 1writer nreader 1bit atom regist probabl protocol safe everi process obtain distinct key everi circum stanc process fail find key segment scan whole key space key found saw section 3 fftestsetonc object safe never give key one process sinc object process noncorrupt object invok repeatedli assign key sooner later everi correct process find key probabl 1 lemma proven 2 prove maximum run time among noncrash process log n log log n bit oper probabl impli averag run time coin flip sequenc outcom use process involv expect run time log n log log n bit operationsth expect run time may still infinit expect bound meet definit wait freeness protocol achiev bound expect run time requir waitfre protocol need use log n bit oper per object invoc rather log log n see problem recal theorem 1 state object succe probabl ff provid log q bit use q number compet process thetan log n bit must use otherwis bound given lemma 2 becom worthless although unlik event entir possibl linearli mani process fail segment start scan whole key space case averag run time high would take exponenti long time scan process get key will use log n bit per fftestsetonc object averag run time still log 2 n bit oper theorem 2 everi solv name problem use fftestsetonc object protocol waitfre safe correct expect run time log 2 n readwrit 1writer nreader share atom bit proof saw proof lemma 3 probabl process resort scan whole key space o1 denot total number corrupt key time process scan whole space corrupt object fire independ probabl ff probabl least bound independ least 1 object assign key impli gamma correct process receiv uniqu key defin p kn fffflkn3g probabl p 2n second scan need averag run time bit oper log 2 n1 clear togeth claim 3 claim 1 impli protocol segment waitfre solut process name problem even averag sens theorem proven 2 remark 1 practic protocol much faster key expect number process per object first random object select mn 1 also larg fraction process need one invoc get wellknown result martingal inequ state n process select random key key fraction key chosen process nearli henc high probabl nearli ffn1 gamma 1e process get key one invoc fftestsetonc object result hold implement fftestsetonc object 1writer n reader olog log nbit share readwrit variabl nwriter nreader 1writerpercompon ncompon composit regist log log nbit compon acknowledg thank refere construct comment result substanti improv present system execut adversari comput complex system execut infinit sequenc altern step state c satisfi enabl state c igamma1 c configur system execut 0 technic process halt enter infinit mani time distinguish idl state c 1 idl step 1 regist initi zero content uniqu start state c 0 initi dirti share memori regist arbitrari initi content set system execut denot omegagamma adversari best explain identifi condit probabl densiti function c je initi segment e step enabl state c igamma1 c state result execut step state c igamma1 probabl initi execut segment realiz given e igamma1 happen adversari random cs asc je summat taken differ enabl step state c igamma1 state c result step singl state random state random step coin flip adversari determinist choos determinist step cs asc je start e 0 c 0 adversari induc measur legal system execut defin ae lim i1 adversari adapt sinc schedul process execut next step base complet knowledg initi segment system execut includ random outcom past coin flip arbitrarili delay process even crash execut enabl step particular process express strongest adversari adapt infinit comput power probabl measur set execut 32 without loss gener assum random step protocol use fair coin flip assum notat adapt adversari probabl measur 1 initi execut segment 2 summat enabl step state c c result execut step state c 3 coinflip step c h state result c outcom head c state result c outcom tail denot finit initi segment execut andomega set infinit execut e tradit notat instead ae cylind g use first two conditionsalreadi impli notion probabl measurear includ complet third condit ensur adversari control outcom fair coin flip outcom equal like definit readili gener bias coin multibranch decis adversari de fine defin expect length ee process p j final execut follow finit initi execut segment e let e infinit execut start number nonidl step process definit 3 assum notat defin sinc summat includ case expect length infinit necessarili set infinit histori oper execut infinit mani event posit measur normal wrt e give adversari free choic start configur run time determinist protocol maximum number nonidl step taken legal execut execut non faulti process definit 4 implement concurr object share n process wait free finit bound fn adversari expect length ee approach work relat observ made respect symmetr commun model 13 case use method bound differ mobd 25 suppos n independ random variabl x take valu finit set let measur function vector b differ ith coordin use ballandbin scenario x denot bin end measur thing number bin exactli k ball number bin least k ball like case easi see c bound becom n process name space size 1 name algorithm good want c run time small possibl param n int fnumber processesg param c real 2 0 fspecifi key rangeg var share int share array boolean feach b1m p own process pg procedur begin readbkey i1 writebkey p 0 returnfailur fi fnot aloneg od procedur simpnam int 2 f0mg begin repeat key random 2 f1mg figur 3 simpl approach name protocol process p obviou name algorithm work follow process choos uniformli independ tent random key check whether process claim key process secur key otherwis tri anoth random key check whether process claimant key use follow mechan key k vector bk 1n bit bk p own process p 1 p n bit read process upon choos specif key valu k process set bit bk p 1 subsequ read bit vector see whether claimant figur 3 process alon success return otherwis failur notic bit bk p reset 0 case failur process tri easi verifi solut safe sens two process ever get key difficult see run time unsatisfactori c 1 adversari strategi forc process take exponenti mani step high probabl problem adversari know key k chosen process p execut subsequ writebk p 1 step therefor adversari postpon execut step process q choos key k point adversari schedul step p q dont secur key k adversari strategi step writebkey p 1 enabl process p adversari delay execut say p frozen p chosen k yet execut writebk p 1 say process claim k let c adversari schedul process turn perform first random choic defin event least ffln key chosen exactli two process standard applic mobd show probabl occur e gammac 1 n c 1 constant depend ffl adversari select ffln key freez set f 1 correspond process adversari schedul oper remain process claim one remain key key claim one process one process claim one key adversari schedul event one back tri uniqu claimant key point least 1 gamma claim uniqu process call red key process f 1 unfrozen adversari schedul oper first attempt fail second tent random key choic defin event b ffln red key claim exactli one process f 1 let f 2 set process claim key key claim exactli two process jf adversari repeat scenario f 2 substitut f 1 tediou standard applic mobd show probabl b occur e gammac 2 n c 2 constant depend ffl therefor high probabl adversari abl forc process tri exponenti number key r atom snapshot share memori elect anonym network distribut comput 6 fast random consensu use share memori random consensu expect log 2 n oper per processor renam asynchron environ tree algorithm packet broadcast channel free synchron access packet broadcast channel feedback estim multipl conflict speed resolut multipl access channel imposs distribut consensu one faulti processor distribut algorithm acm tran random waitfre concurr object asynchron comput theorem tresili task lasvega processor problem uniqu distribut comput share concurr waitfre variabl solv processor ident problem space memori requir agreement among unreli asynchron process method bound differ random algorithm choic coordin problem optim time random consensu make resili algorithm fast practic elus atom regist revisit comput network construct atom variabl random waitfre testandset tr sharedmemori vs messagepass asynchron distribut environ renam asynchron environ fast random consensu use share memori processor ident problem waitfre synchron random waitfre concurr object extend abstract optim time random consensusmyampersandmdashmak resili algorithm fast practic atom snapshot share memori immedi atom snapshot fast renam asynchron comput theorem italictitalicresili task elus atom regist random algorithm imposs distribut consensu one faulti process longliv renam made fast share concurr waitfre variabl distribut algorithm comput network construct atom variabl extend abstract waitfre testandset extend abstract ctr harri buhrman alessandro panconesi riccardo silvestri paul vitanyi import ident consensu realli univers distribut comput v18 n3 p167176 februari 2006 jame aspn faith ellen fich eric ruppert relationship broadcast share memori reliabl anonym distribut system distribut comput v18 n3 p209219 februari 2006 john tromp paul vitnyi random twoprocess waitfre testandset distribut comput v15 n3 p127135 juli 2002