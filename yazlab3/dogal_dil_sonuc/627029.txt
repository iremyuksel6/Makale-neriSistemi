distribut memori compil design spars problem abstractthi paper address issu compil concurr loop nest presenc complic array refer irregularli distribut array array access within loop may contain access make imposs precis determin refer pattern compil time paper propos run time support mechan use effect compil gener effici code situat compil accept input fortran 77 program enhanc specif distribut data output messag pass program run node distribut memori machin runtim support compil consist librari primit design support irregular pattern distribut array access irregularli distribut array partit varieti perform result intel ipsc860 present b introduct modern scalabl multicomput wide recogn addit detect exploit avail parallel reduc commun cost crucial achiev good perform exist system dino 34 fortran 12 superb 44 commun optim presenc regular array refer pattern within loop messag block collect commun util messag coalesc aggreg parallel loop nest howev often contain array refer analyz compil time array refer classifi irregular method describ deal parallel loop loop contain reduct type output depend method work loop contain cross processor loopcarri depend crossprocessor loopindepend depend crossprocessor depend one whose end point cross processor loopcarri depend involv write locat one iter follow read locat later iter loopindepend depend involv write locat follow read locat loop iter data parallel achiev partit array across node machin processor perform comput part array parallel achiev partit loop iter processor cross processor loop independ depend occur runtim optim techniqu develop design reduc commun cost irregular refer follow way judici partit data comput work ffl combin element messag larger messag therebi reduc number messag transmit elimin redund commun array element demonstr optim perform automat compil prototyp compil call arf arguabl fortran develop arf accept simplifi fortran 77 program enhanc specif distribut data output program execut directli node distribut memori machin case intel ipsc860 compil partit comput analyz array refer classifi regular irregular irregular refer perform runtim optim reduc commun cost sinc develop arf signific amount work done standard extens fortran languag high perform fortran forum hpff joint effort academ commun industri agre preliminari set data parallel program languag extens 16 20 heavili influenc experiment languag fortran 12 vienna fortran 45 crystal 7 24 23 25 kali 22 dino 32 cm fortran 9 hpff decid defer consider languag extens target irregular problem next year hpff plan consid possibl irregular problem languag extens 11 overview parti arf runtim optim implement use parti parallel autom runtim toolkit icas runtim preprocess procedur embed com piler procedur 1 support share name space 2 provid infrastructur need implement nonuniform data map effici 3 coordin interprocessor data movement 4 manag storag access copi offprocessor data compil consist two distinct layer bottom layer librari parti runtim procedur design support irregular pattern distribut array access effici top layer compil carri program transform embed call parti primit origin program parti procedur support varieti oper global name distribut array indic distribut array partit nonuniform manner distribut array element assign arbitrari processor oper includ offprocessor data fetch data store accumul offprocessor memori locat multicomput program gener distribut memori access carri use embed procedur emphas goal project develop product qualiti compil demonstr run time optim gener automat effici compil complex system parti procedur parti procedur develop transform need emb appropri primit implement rel eas distribut memori compil paper begin descript languag accept relat fortran outlin compil phase describ section 3 section 4 describ parti run time primit implement incorpor runtim system employ compil section 5 provid detail code gener optim perform compil compil describ context two exampl code kernel kernel written arf translat compil messag pass code section 6 report experiment perform measur code compil arf section 7 describ relationship research relat project arf compil develop demonstr feasibl approach irregular problem compil consequ arf languag extens limit scope sake clariti better understand show languag extens relat real dataparallel languag like fortran first describ syntax fortran languag extens provid function arf extens go describ correspond arf languag extens 21 fortran languag fortran version fortran 77 enhanc data decomposit specif section present brief descript featur fortran use support irregular problem align decomposit two key fortran data decomposit construct decomposit abstract problem domain align use map array respect decomposit align guarante element differ array map element decomposit resid processor simplest align occur array exactli map onto decomposit distribut statement specifi map decomposit physic machin distribut regular exampl consid block distribut nproc processor n element decomposit nproc divid n block distribut divid decomposit contigu chunk size nnproc assign one block processor fortran also allow user specifi irregular distribut use map array typic di tribut map array contain processor number use specifi processor own individu decomposit element exampl specifi irregular partit fortran s5 set valu map array use map method s6 align x irreg exampl array x data array map map array array map map onto decomposit reg statement s4 decomposit reg turn distribut block across processor statement s5 array x align decomposit irreg statement s6 final decomposit irreg irregularli partit across processor use distribut map array map statement s7 result statement array element xi yi assign processor mapi sometim conveni ignor certain array dimens map array decomposit array element unassign dimens collaps map index decomposit instanc align zij mapj mean second dimens z align map exampl mean map column j z processor mapj fortran also provid direct claus 21 specifi processor execut iter loop instanc nproc processor i1n modinproc assign loop iter processor roundrobin fashion 22 arf extens distribut array declar arf either partit processor regular manner eg equal size block contigu array element assign processor irregular manner arf extens explicitli specifi array partit processor arf make use decomposit statement like one found fortran arf array irregularli partit across processor use distribut map array arf code fragment effect first code fragment present previou section irregular distribut specifi follow distribut regular use block integ map1000 set valu map array use map method distribut irregular use map real x1000y1000 statement s1 declar integ array map state array distribut blockwis across processor statement s2 declar real array x assign array element yi processor mapi arf array distribut singl dimens distribut dimens must last declar array dimens instanc arf statement distribut irregular use map real x101000 would assign column x processor mapi arf also contain claus exampl distribut i1n partit mean work associ iter carri processor partitioni 3 compil support irregular comput compil time analysi make possibl gener highli effici code compil gather enough inform analysi sourc code order gener effici code compil need tractabl represent array subscript func tion also need tractabl represent data comput work partit 18 15 19 35 instanc consid fortran exampl align xy block s5 i1750 assum processor respons comput valu data own ie owner comput rule 18 4 processor processor contigu chunk 250 element array x sinc subscript function xi ident owner comput rule impli three processor execut 250 iter loop s5 exampl clear inspect nonloc access occur processor last two loop iter addit easi determin nonloc data must obtain instanc processor respons loop iter 1 250 need first two valu store processor respons loop iter 251 500 varieti research 18 15 implement techniqu gener optim call messag pass routin given compiletim inform array subscript function array distribut distribut loop iter paper deal situat compil time analysi fail crucial inform avail program execut varieti applic array subscript function known compil time mani case subscript function given integ array consid refer yiai code fragment align xyia block s5 ia get assign valu runtim s6 i1750 s8 end compil time analysi difficult irregular array distribut irregular partit loop iter exampl imposs predict compil time data need commun distribut x known runtim s5 set valu map array use map method s6 align x irreg s8 i1750 arf compil abl handl parallel loop mark distribut array refer subscript given function 1 loop index 2 scalar redefin loop bodi 3 array index loop index exampl index function assum index distribut ia could distribut regular irregular manner arf compil gener handl loop refer pattern simpl form instanc compil present could deal follow loop distribut 1100 partit s5 end s6 end one difficulti aris refer xcolj statement s4 valu subscript array colj comput statement s3 statement s3 turn lie within loop s2 whose upper bound determin valu taken array num da et al 11 describ program slice techniqu use extend method describ broader set construct except one special case arf compil unabl handl loop loop carri depend special case involv accumul type depend decis includ special case greatli expand number irregular applic code method appli arf compil abl recogn accumul indirectli address array shown follow exampl distribut partit commut associ properti oper allow arf compil postpon accumul distribut array x end loop comput 31 inspectorsexecutor inspector executor perform optim reduc commun cost nonloc access aris irregular array refer processor precomput data send receiv commun volum reduc prefetch singl copi offprocessor datum even referenc sever time number messag reduc prefetch larg quantiti offprocessor data singl messag 32 inspector inspector loop carri preprocess need reduc volum commun number messag transmit figur 1 illustr inspector gener arf compil parallel loop hash tabl call hashedcach use temporari storag run time primit initi hash cach store retriev data flush hash cach appropri program execut hash tabl record offprocessor fetch store enabl user recogn one refer made offprocessor distribut array element way one copi element must fetch store inspector phase carri set interprocessor commun allow us anticip exactli send receiv commun call processor must execut execut loop carri inspector loop describ must abl find owner distribut array element regular distribut compris requir simpl function comput processor local offset particular array element exampl one dimension array distribut block manner simpl function use comput processor local offset particular array element hand irregular distribut attempt partit way balanc follow two object 1 processor perform approxim amount work 2 minim commun overhead foreach processor p ffl gener clone partit loop nest ffl insert code perform follow foreach rh irregular array refer gener list offprocessor data fetch foreach lh irregular array refer gener list data store offprocessor exchang messag processor determin copi nonloc data sent receiv executor phase figur 1 simplifi inspector singl loop nest typic possibl express result array partit simpl way allow arbitrari assign distribut array element processor take addit burden maintain data structur describ partit size data structur must size irregularli distribut array call data structur distribut translat tabl distribut translat tabl partit processor simpl manner describ section 43 distribut translat tabl access inspector phase determin data element resid preprocess complet everi processor know exactli nonloc data element need send receiv processor finish posit carri necessari commun comput 33 executor loop transform executor loop figur 2 outlin step involv natur distribut array distribut affect executor initi data exchang phase follow plan establish inspector processor obtain copi nonloc distribut array element copi written processor hash cach commun phase processor carri comput processor use local store portion distribut array along nonloc distribut array element store hash cach insert code loop ffl commun local data referenc processor ffl receiv non local data referenc local insert code insid loop ffl obtain non local data hash cach ffl store non local write hash cach insert code loop ffl updat offprocessor store figur 2 executor singl loop nest comput phase finish distribut array element store offprocessor obtain hash cach sent appropri offprocessor locat next section describ detail parti run time primit may invok inspector executor phase 4 parti primit parti run time primit divid three categori primit may invok inspector phase executor phase inspector executor phase schedul primit invok inspector phase determin send receiv call need executor phase call may scatter data gather data perform reduct oper executor phase distribut translat tabl mention earlier use inspector phase hash cach primit use inspector executor phase next section describ detail schedul distribut translat tabl scatter gather reduct hash cach primit 41 schedul primit use simpl exampl illustr preprocess carri schedul assum distribut array partit among three processor irregular fashion depict figur 3 loop comput access local array 0 offset 2142global array processor p3 figur 3 map global array processor pattern array shown figur 4 processor store element distribut array local array thu processor p 1 need fetch array element a3 element 0 2 local array processor p 2 processor p 2 p 3 need fetch a4 element 0 2 local array p 1 recal task schedul anticip exactli send receiv commun must carri processor schedul first determin mani messag processor send receiv data exchang take place executor phase gather inform processor need know total number processor execut code defin processor p array nmsg processor set valu nmsg j 1 need data processor j 0 schedul updat nmsg processor elementbyel sum nmsg j j oper use fanin tree find sum end fanin processor entri nmsg ident valu nmsgsj equal number messag processor p j must send exchang phase exampl scenario see end fan valu nmsg processor 210 figur 5 thu p 1 abl determin need send data two yet unspecifi processor need send data one processor p 3 need send data point processor transmit appropri processor list requir array element list contain local offset global array element irregular access pattern array a21 local array 0 global array processor p3 figur 4 irregular access pattern exampl send messag p 2 request element 2 local array 0 p 3 send messag p 1 request element 2 local array 0 processor inform requir set send receiv messag need carri schedul commun figur 6 schedul gener schedul reus schedul also use carri ident pattern data exchang sever differ ident distribut array schedul reus carri particular pattern data exchang singl distribut array data exchang primit make use given schedul 42 data exchang primit data exchang call processor ffl gather data processor ffl scatter data processor ffl perform global reduct oper exchang use state inform store schedul describ previou section schedul determin send receiv call need carri data processor distribut sum tree output tree input sum data need data need data need figur 5 comput number send messag exchang schedul given inform memori locat involv processor local indic processor p call data exchang pass exchang routin start address first local array element memori call address p exchang routin use p base address read write distribut array element 43 translat tabl allow user assign global number distribut array element processor irregular pattern use distribut translat tabl recal schedul data exchang deal indic array local processor translat primit howev assum distribut array element assign global indic procedur buildtranslationt construct distribut translat tabl processor pass buildtranslationt set global number indic respons distribut translat tabl may stripe block across processor stripe translat tabl translat tabl entri global data sent processor local array messag sent processors2send receiv processor p3 processor p3 figur final messag pattern index store processor mod p p repres number processor block translat tabl translat tabl entri partit number equal size rang contigu integ rang place consecut number processor derefer access distribut translat tabl construct buildtranslationt given distribut array derefer pass set global indic need access distribut memori derefer return processor memori locat specifi global indic store illustr primit use simpl two processor exampl processor assign indic 1 4 processor p 2 assign indic 2 3 exampl assum translat tabl partit two processor block depict translat tabl data structur tabl 1 entri translat tabl assign processor local array index global index distribut array element exampl translat tabl inform global indic 1 2 store processor 1 inform global indic 3 4 store processor 2 continu exampl assum processor use derefer primit find assign processor local indic correspond particular global distribut tabl 1 translat tabl entri global assign local index processor index processor 1 processor 2 tabl 2 result obtain derefer processor global assign local number index processor index array indic tabl 2 depict result obtain processor 1 derefer global indic 1 3 processor 2 derefer global indic 2 3 4 44 hash cach use parti primit describ section 4 enhanc coupl primit hash tabl hash tabl record numer valu associ distribut array element hash tabl also record processor local index associ element derefer use hash tabl reduc volum interprocessor commun recal derefer return processor assign memori locat correspond given list distribut array indic distribut array index may appear sever time list pass derefer hash tabl use remov duplic list offprocessor distribut array element pass schedul may contain multipl refer element schedul use hash tabl identifi uniqu offprocessor data refer data exchang procedur use hash tabl store copi offprocessor distribut array element gatherexchang fetch copi offprocessor distribut array element place valu hash tabl similarli scatterexchang obtain copi offprocessor distribut array element hash tabl write valu obtain specifi local array element design processor primit support accumul nonloc memori use hash tabl way scatterexchang parti suppli number primit support read well write accumul hash tabl offprocessor accumul must perform first carri possibl accumul copi distribut array element hash tabl perform accumul data exchang use hash function hash cach size 2 k mask lower k bit key key form concaten processorloc index pair correspond distribut array refer 45 summari parti primit section summar parti primit describ present exampl use consid follow parti procedur call ttabl build translat tabledistributionmappingnum element call dereferencett idglob indic processorsloc indicesnum indic call setup hashedcachehashedcach processor local indic call scheduleridnhashedcacheloc indicesprocessor call gatherexchangeridhashedcachelocalarray exampl processor p arrang obtain copi specifi offprocessor data element copi place hash tabl hashedcach processor call build translat tabl function data map function return pointer structur store data layout p call derefer function find local address correspond global indic requir derefer call return processor number local address correspond global indic p call function setup hashedcach inform return derefer alloc hash tabl p pass schedul list offprocessor local array indic schedul build schedul make possibl p obtain data element p obtain data element 1 n processor processorsi local index local indicesi previous alloc hash tabl hashedcach use elimin duplic offprocessor indic irregular problem data access pattern loop data point referenc multipl time partit loop caus duplic offprocessor refer schedul return integ id use subsequ call gatherexchang processor call gatherexchang processor gatherexchang primit pass pointer schedul id gener previou call schedul pointer alloc hash tabl hashedcach base address portion array localarray execut gatherexchang call copi offprocessor element array localarray resid hash tabl hashedcach 5 arf compil arf compil transform sourc program singl program multipl data spmd form data distribut specif use partit program gener appropri commun compil incorpor parti primit carri comput processor effici kernel present code fortran 77 enhanc arf data distribut statement compil run ipsc860 section 6 present perform data obtain kernel describ compil algorithm slightli gener algorithm actual use arf compil two algorithm produc equival code test data set 51 code gener arf compil compil use distribut specif gener code set distribut translat tabl call build translat tabl embed sequenti code one call gener distribut translat tabl pointer array store symbol tabl array distribut regular manner translat tabl contain function evalu runtim find processor local index particular datum array irregularli distribut index processor local index store explicitli distribut translat tabl order describ algorithm use gener inspector executor figur 7 simpl irregular loop loop descriptor must defin descriptor descriptor tupl give complet descript subscript consist follow compon descriptor sd name array index subscript identifi array distribut block cyclic irregular etc type type refer subscript express use one exchang type gather scatter accumul list subscript express express use determin array dex implement assum singl dimens access use type index function shown section 3 figur 7 array x ia ib distribut array ia ib use index array x respect compil time possibl figur indic x access depend valu store array ia ib data access pattern becom avail runtim algorithm assum loop crossprocessor loop carri depend later section describ loop contain reduct handl first basic algorithm produc inspector executor given loop present loop l ffl find array refer loop figur 7 array refer xiai yib ffl use refer subscript express form list descriptor oe sd loop shown figur 7 two descriptor gener one refer xiai yibi gener list oe sd readi gener inspector executor code sd 2 oe sd ffl gener declar statement temporari array temp store valu assign subscript correspond sd ie sd4 insid l note two descriptor gener exampl loop store refer trace temporari array skip array ia ib use directli dereferenc ffl gener clone loop l loop l 0 l ffl bodi loop l 0 consist statement record temp valu taken subscript express sd4 ffl gener call derefer pass array temp translat tabl pointer associ array sd1 exampl loop dereferenc done array ia ib ffl next gener call schedul use array pa la return derefer form schedul ffl gather call gatherexchang gener use schedul runtim obtain offprocessor data put data hash tabl exampl loop offprocessor valu gather call scatterexchang gener use schedul call scatter exchang runtim take data hash tabl h send processor exampl loop data valu array x scatter accumul call scatterop exchang gener use schedul call scatterop exchang runtim take data hash tabl h accumul processor figur 8 irregular loop stage indirect index ffl replac subscript express index array sd1 insid loop l temporari array temp arf compil tailor recogn idiom use index distribut array mani irregular code see exampl figur 8 programm assign express would otherwis use subscript array refer scalar use array subscript type index pattern scalar defin insid loop use index distribut array precis ffl scalar defin iter loop definit may function loop index b scalar defin loop bodi c array index loop index ffl use index distribut dimens distribut array loop bodi one carri forward substitut subscript express loop written use idiom properti outlin section 3 note forward substitut transform exampl figur 8 exampl figur 7 52 optim two main optim perform first optim reduc schedul overhead identifi set distribut array refer make use optim array distribut subscript type name express common schedul elimin dont match match dont care care common exchang match match match match elimin tabl 3 optim pattern schedul second optim reduc data transfer cost identifi distribut array refer make use precis exchang invoc optim carri sort descriptor equival class sever distribut array refer share schedul long array question 1 ident distribut 2 match subscript express set distribut array refer share exchang call refer ident descriptor tabl 3 summar condit 53 arf compil exampl section present two exampl use demonstr arf compil work section 531 present arf use program distribut memori block spars matrix vector multipli kernel section 532 present exampl comput fluid dynam 531 spars block matrix vector multipli figur present arf program carri block spars matrix vector multipli kernel iter solver produc program design calcul fluid flow geometri defin unstructur mesh 40 matrix assum size 4 4 block nonzero entri statement s4 s5 loop sweep nonzero entri block assum array partit pass spars matrix vector multipli kernel gener elsewher figur present specif data decomposit spars block matrix vector multipl exampl written fortran fortran use write exampl chang figur 10 replac statement s1 s2 statement s1 s10 figur 11 array map figur 11 specifi map data array data array singl dimens distribut rest compress figur 10 integ array partit local processor enumer list indic assign processor mention earlier current implement partit one dimens last dimens array parti primit howev support broader class array map 6 thu partit describ partit last dimens array declar statement s1 s2 arf compil use inform partit make call primit initi distribut translat tabl distribut translat tabl use describ map x col ncol f statement s1 s2 partit comput work specifi statement s3 use claus exampl distribut array partit use specifi loop iter carri processor refer xmcolsji s6 may requir processor refer arf consequ gener inspector produc schedul hash tabl handl access distribut array x refer irregularli distribut array f occur statement s6 note distribut array f irregularli distribut use array partit partit also use claus partit loop iter s3 therefor deduc refer f statement s6 onprocessor partit specifi distribut array element loop iter distribut processor separ partit routin gener partit arf compil gener inspector executor run processor code execut processor gener inspector shown figur 9 statement s1 show gener translat tabl use partit array statement s2 show derefer call made figur address variou data element next two statement inspector code gener data commun schedul hash tabl structur executor gener arf processor p depict figur 12 fortran 90 notat use appropri enhanc readabl offprocessor element x gather place hash tabl h step figur 12 valu x obtain h local memori step iia figur 12 array pa la use distinguish build translat tabl use map defin array partit call derefer find processor assign pa local indic la consecut refer xm colsj employ partit call setup hashedcachehashedcach pa la call scheduleridnhashedcachelapa figur 9 inspector gener arf spars block matrix vector multipli local offprocessor array access step iib accumul note declar s1 s3 figur 10 allow compil determin accumul local 532 fluxro kernel kernel taken program comput convect flux use method base roe approxim riemann solver 41 42 refer fluxro kernel paper fluxro comput flux across edg unstructur mesh fluxro access element array yold carri flux calcul accumul result array case spars block matrix vector multipli kernel four section array distribut access ident manner figur 13 depict outlin fluxro kernel indic two vertic compris edg note comput flux f luxk across ith edg access yoldk n1 yoldk n2 1 k 4 part figur 13 flux comput add newli comput flux valu f luxk yk n1 subtract f luxk yk n2 part iii figur 13 note array yold irregularli distribut use ypartit distribut array node irregularli distribut use edgepartit sinc claus distribut statement also use edgepartit specifi loop iter partit offprocessor refer made node part figur 13 inspector comput schedul n1 offprocessor addit yk n1 part iiia figur 13 differ schedul n2 offprocessor subtract distribut irregular use partit real8 x4n y4nf44maxcolsn distribut irregular use partit integ cols9n ncolsn initi local variabl distribut partit s5 distribut enddo figur 10 arf spars block matrix vector multipli s5 align map reg s7 align fijkl mapl s8 align ncolsi mapi figur 11 fortran data distribut statement spars block matrix vector mul call gatherexchang use schedul obtain offprocessor element x gatherexchang place gather data hash tabl h ii row assign processor p k 14 iia pacount p els use pacount lacount get vx14 hashtabl h endif m14 iib figur 12 executor gener arf spars block matrix vector multipli distribut irregular use ypartit real8 yold4numbernod y4number node distribut irregular use edgepartit integ node2numberedg initi local variabl distribut 1numberedg edgepartit k14 ia ib ii calcul flux use vak vbk iii k14 iiia iiib distribut enddo figur 13 arf kernel riemann solver build translat tabl use map defin array ypartit call derefer find processor assign pa n1 local indic la n1 consecut refer yk n1 employ ygammapartit call derefer find processor assign pa local indic la consecut refer yk n2 employ ygammapartit call setup hashedcachehash gamma cach n1 s5 call setup hashedcachehash gamma cach s7 call scheduleridnhash gamma cach figur 14 inspector gener arf fluxro kernel figur 13 parallel fluxro read well accumul offprocessor distribut array locat data exchang primit use schedul schedul n1 gather offprocessor refer yoldk n1 part ia figur use schedul use gather offprocessor refer yoldk n2 part ib figur 13 inspector code gener arf compil fluxro kernel shown figur 14 statement s1 show call build translat tabl function store inform array partit statement s2 s3 call derefer function find address variou refer array derefer call use translat tabl setup statement s1 statement s4 s5 gener hash tabl structur last two statement code fragment show build commun schedul figur 15 outlin executor produc arf processor p figur 15 fortran 90 notat use appropri enhanc readabl step ia ib two set offprocessor element yold gather use schedul n1 n2 step ii appropri element yold access either local memori appropri hash tabl step iii yold valu use calcul flux newli comput flux accumul local element distribut array appropri addit subtract carri step iva ivc figur 15 flux must accumul offprocessor element accumul flux copi store hash tabl step ivb ivd figur 15 flux calcul local accumul complet call scatteradd scattersubtract exchang exchang carri need offprocessor accumul current version arf compil attempt minim number schedul comput singl schedul offprocessor yold data access could produc comput singl schedul refer yold lead effici executor cost expens inspector 54 memori util section overview memori requir exact method describ given suggest made way requir reduc mani spars unstructur program use larg integ array determin refer pattern respect kernel depict typic figur 10 9n element integ array col use purpos figur 13 size array node employ executor depict figur 12 figur replac col node local array store processor assign local indic refer irregularli distribut array kernel figur sum number element use processor store processor assign local indic larger 18n figur 13 parallel code use total 4 number gamma edg element amount addit storag need parallel code reduc follow simpl manner iter loop divid two disjoint set first set iter local memori refer local store array element second set offgammaprocessor iter contain processor distribut array refer case list processor assign loop iter offgammaprocessor necessari sinc frequent possibl map problem memori refer local processor substanti memori save result scheme describ thu far would use larg quantiti extra memori attempt handl loop small number distribut array element access mani time instanc consid follow loop f function defin 1 fi 2 ia call gatherexchang use schedul sn1 obtain first set offprocessor element yold gatherexchang place data hash tabl h n1 ib call gatherexchang use schedul sn2 obtain second set offprocessor element yold gatherexchang place data hash tabl h ii edg assign processor p i1numb edg assign p pan1 count p els get va14 hash tabl h n1 endif pan2 count p els get vb14 hash tabl h endif iii calcul flux flux14 use va14 vb14 iv pan1 count p iva yold14la n1 els ivb accumul flux14 hash tabl h n1 endif pan2 count p ivc yold14la els ivd accumul flux14 hash tabl h endif va call scatteradd exchang use schedul n1 hash tabl h n1 vb call scattersubtract exchang use schedul hash tabl h figur 15 executor gener arf fluxro kernel distribut irregular partit yfi refer pattern distribut array determin f two distinct element referenc loop loop sort handl use hash tabl store processor local index assign distinct memori refer exampl processor would store processor local index assign two refer distribut array perform penalti use hash tabl find processor local index assign distribut array element examin varieti spars unstructur code decid implement method describ section arf compil see analysi 30 time space tradeoff outlin section 6 experiment result section present rang perform data summar effect preprocess measur overal effici also discuss perform effect problem irregular partit comput experi employ fluxro kernel block spars matrix vector multipli kernel kernel code arf parallel benchmark number obtain program gener arf compil note syntax accept arf compil differ minor way present previou section experi describ paper use either 32 processor ipsc860 machin locat icas nasa langley research center 128 processor ipsc860 machin locat oak ridg nation laboratori processor 8 megabyt memori greenhil 185 beta version c compil use gener code 80860 processor 61 unstructur mesh data input data varieti unstructur mesh use includ actual unstructur mesh obtain aerodynam simul synthet gener mesh unstructur mesh aerodynam two unstructur mesh gener aerodynam simul use mesh 21672 element mesh gener carri aerodynam simul involv multiel airfoil land configur 28 mesh 11143 point mesh b 37741 element mesh gener simul 42 circular arc airfoil channel 14 mesh 19155 point mesh point associ x coordin physic domain domain inform use partit mesh three differ way strip orthogon binari dissect algorithm 5 13 anoth mesh partit algorithm jag partit 38 partit mesh done sequenti map array gener distribut data structur synthet mesh templat finit differ templat link k point squar two dimension mesh connect pattern distort increment random edg introduc subject constraint new mesh point still requir inform k mesh point mesh gener make follow assumpt 1 problem domain consist 2dimension squar mesh n point 2 point initi connect k neighbor determin finit differ templat 3 probabl q mesh link replac link randomli chosen mesh point note q equal 00 mesh link modifi chang introduc q equal 10 random graph gener two templat use one templat connect point four nearest neighbor k4 templat connect point four nearest neighbor four diagon neighbor k8 refer five point templat k8 templat nine point templat experi describ section 256 256 point mesh employ 62 overal perform data present give overview perform obtain ipsc860 arf compil output block distribut translat tabl use tabl 4 present inspector time time requir carri inspector preprocess phase b comput time time requir perform comput iter portion program c commun time time requir exchang messag within iter portion program inspector time includ time requir set need distribut translat tabl well time requir access distribut translat tabl carri preprocess unstructur mesh b partit use orthogon binari dissect experi ratio time requir carri inspector time requir singl iter commun time rang factor 07 factor 36 preprocess time repres set use distribut translat tabl instanc consid block matrix vector multipli 64 processor use 21672 element mesh total preprocess cost 122 millisecond millisecond repres work relat translat tabl parallel effici given number processor p defin sequenti time divid product execut time p processor time p sequenti time measur use separ sequenti version kernel run singl node ipsc860 algorithm sequenti code parallel code tabl 4 column singl sweep effici depict parallel effici would obtain requir preprocess kernel time calcul carri realiti preprocess time amort multipl mesh sweep time requir preprocess problem comput parallel effici neglect second set parallel effici measur obtain executor effici present tabl 4 executor effici 64 processor rang 048 059 singl sweep effici rang 010 017 experi depict tabl 4 comput time least factor 2 greater commun time executor effici effect fact comput parallel code carri less effici sequenti program parallel code spend time access hash cach also need perform indirect sequenti program tabl 4 perform differ number processor nproc inspector comp comm singl sweep executor timem timem timem effici effici spars block matrix vector multipli mesh spars block matrix vector multipli mesh b tabl 5 summar perform fluxro kernel mesh vari degre regular vari mesh map experi conduct use processor tabl 5 depict synthet mesh deriv 5 9 point stencil probabl edg move q equal either 00 04 mesh map 1d strip 2d block one might expect synthet mesh commun cost increas dramat increas q dramat increas present volum commun requir number messag sent per node much higher larg q preprocess cost also increas q commun cost went least factor 16 preprocess cost went factor 18 tabl 5 summar result mesh b partit three way strip orthogon binari dissect algorithm jag partit binari dissect jag partit algorithm break domain two dimension rectangular region two method produc similar perform result tabl 5 perform 32 processor differ mesh nproc inspector comp comm singl sweep executor timem timem timem effici effici 5 point templat synthet mesh partit strip q04 310 293 361 025 037 5 point templat synthet mesh partit 2d block q04 463 291 319 023 040 9 point templat synthet mesh partit strip q04 385 620 530 031 042 9 point templat synthet mesh partit 2d block q04 595 624 527 028 042 mesh binari 134 80 22 024 057 jag 135 81 22 024 056 strip 148 83 26 022 053 binari 191 136 23 028 061 jag 186 137 21 028 062 strip 219 149 31 024 054 63 breakdown inspector overhead tabl 6 summar cost dereferenc schedul fluxro kernel differ number processor use block translat tabl five point templat use mesh partit either 1d strip 2d block mesh partit strip derefer involv mostli local data access sinc domain data translat tabl ident partit strip partit use translat tabl initi involv commun measur present tabl 6 defin follow manner ffl executor time comput commun time requir execut includ time requir preprocess ffl tabl initi time time need initi distribut translat tabl ffl derefer time time taken derefer parti primit ffl schedul time time requir produc commun schedul requir processor locat local indic found derefer major cost incur inspector due translat tabl initi derefer see tabl 6 instanc consid case 64 processor use carri sweep 2d block partit mesh 5 point templat translat tabl initi derefer togeth requir 183 executor time gener schedul requir 12 executor time problem commun cost compris small fraction executor time consequ method use partit domain make signific perform impact executor time tabl 6 cost translat tabl initi derefer strongli depend domain partit 2d block partit lead higher translat tabl relat cost almost certainli due increas commun requir need translat tabl initi derefer strip partit per se necessarili lead low translat tabl relat cost tabl 5 note strip partit actual lead higher inspector cost mesh mesh b translat tabl partit block contigu number indic assign processor howev mesh mesh b mesh point number regular fashion indic correspond domain strip contigu number tabl cost dereferenc schedul differ number processor nproc executor tabl init derefer schedul time 5 point templat synthet mesh partit strip 5 point templat synthet mesh partit 2d block 64 cost translat tabl section 43 discuss two straightforward way map distribut translat tabl onto processor consid question distribut translat tabl minim cost associ translat tabl access tabl 7 compar time requir carri derefer block stripe translat tabl depict ffl time requir carri particular call derefer ffl averag number nonloc access tabl entri requir derefer ffl averag number nonloc processor access call derefer result unstructur mesh b examin consist perform differ cost requir derefer block stripe translat tabl seen similar number offprocessor tabl entri need access either translat tabl distribut block translat tabl lead superior perform synthet mesh use reason describ section 63 particularli good result obtain stripe partit block translat tabl use interest block translat tabl also prove superior synthet mesh partit 2d block use tabl 7 cost derefer processor problem indirect block indirect stripe time nonloc nonloc time nonloc nonloc ms data proc ms data proc synthet 5 point templat strip partit q02 157 1045 17 365 2862 31 q04 218 1825 17 368 3350 31 synthet 5 point templat 2d block partit q04 mesh binari 97 768 21 96 743 31 jag strip binari jag 139 1293 24 130 1263 31 strip 159 1519 31 172 1513 31 65 schedul data exchang perform quantifi commun cost incur parti schedul data exchang primit time requir carri schedul gatherexchang scatterexchang procedur call measur compar handcod version ipsc860 suppli send receiv send receiv commun amount data parti procedur experi conduct two processor repeatedli exchang w singl precis word inform exchang carri use gatherexchang scatterexchang ipsc860 suppli send receiv call tabl 8 summar result experi present time millisecond requir carri requisit data exchang use send receiv messag ratio time taken schedul gatherexchang parti primit call time taken equival send receiv call scatter exchang call also time result virtual ident correspond gatherexchang call gatherexchang exceed 20 explicitli code sendrec pair move w word inform two processor addit overhead requir schedul carri data exchang factor 21 10 time tabl 8 overhead parti schedul gatherexchang primit number send gather schedul data receiv exchang element timem ratio ratio 400 10 11 14 900 18 11 13 1600 29 12 13 43 12 11 cost use explicitli code sendrec pair move w word 7 relat work program design carri rang irregular comput 2 26 4 43 13 includ spars direct iter method requir mani optim describ paper sever research develop program environ target particular class irregular adapt problem william 43 describ program environ dime calcul unstructur triangular mesh use distribut memori machin baden 3 develop program environ target particl comput provid facil support dynam load balanc one key distinct present work baden william parti runtim support design use compil handl parallel loop irregular array refer addit use programm wide rang applic contrast program environ describ baden william highli custom use specif applic area varieti compil target distribut memori multiprocessor 44 8 33 31 1 39 except kali project 22 parti work describ 36 29 37 compil attempt deal loop irregular refer effici work describ paper also relat scheme carri distribut memori runtim parallel 29 27 scheme ambiti describ paper includ mechan carri runtim partit parallel chen 27 suggest optim similar one describ propos reduc schedul overhead identifi distribut array refer one employ ident schedul point hand code base time experi carri studi scheme propos 29 27 prototyp compil describ abl gener code capabl effici handl kernel parallel loop contain irregular array refer procedur carri runtim optim coupl distribut memori compil via set compil transform compil describ test paper qualit differ effort cite number import respect mechan develop demonstr support irregularli distribut array make possibl map data comput work arbitrari manner irregularli distribut array support possibl compar perform effect differ problem map support arbitrari distribut propos 29 37 first implement compilerbas distribut translat tabl mechan irregular scientif problem mani unstructur nasa code must carri data accumul offprocessor memori locat one demonstr kernel address primit compil design handl situat compil effort uniqu abil carri irregular pattern offprocessor data accumul effici primit augment hash tabl design elimin duplic data access addit hash tabl manag copi offprocessor array element research use differ data structur manag offprocessor data copi 22 8 conclus paper describ experiment character compil runtim support procedur embodi method capabl handl import class irregular problem aris scientif comput examin number complet nasa code two kernel extract demonstr method kernel involv comput unstructur mesh kernel code arf dialect fortran gener code run node ipsc860 detail time carri kernel use unstructur mesh aerodynam along mesh gener use random number increment distort matric obtain fix finit differ templat benchmark suit stress commun capabl ipsc860 parti primit varieti way experi report section 62 ratio time requir carri preprocess time requir singl iter either kernel rang factor 07 factor 36 section 63 major preprocess cost aros need support irregularli distribut array section 65 perform schedul data exchang parti primit quantifi dataexchang demonstr maximum increas 20 analog send receiv call provid intel one virtu layer approach distribut compil design captur set critic optim runtim support primit primit henc optim migrat varieti compil target distribut memori multiprocessor intend implement primit parascop parallel program environ 17 addit parti primit use directli programm applic code 6 10 applic describ 10 particularli noteworthi applic explicit multigrid unstructur euler solver employ comput flow full aircraft configura tion explicit unstructur euler solver achiev comput rate 15 gflop 512 processor intel touchston delta multigrid unstructur euler solver achiev comput rate 12 gflop 512 delta processor case cost inspector preprocess approxim equal cost singl iter euler solver amount less 3 total time complex system parti procedur parti procedur develop transform need emb appropri primit implement rel eas distribut memori compil primit use implement runtim support includ commun procedur design support irregular pattern distribut array access procedur find locat irregularli map distribut array data use distribut translat tabl primit also support mainten hash tabl store copi offprocessor data 9 acknowledg would like thank harri jordan bob voigt donna meisel care edit manuscript would also like thank advanc comput laboratori oak ridg nation laboratori na nasa ame provid access 128 node intel ipsc860 hypercub wish thank dimitri mavripli david whitak suppli unstructur mesh david whitak p venkatkrishnan access code r pandor system manag data distribut program abstract dynam partit coordin local scientif calcul run multiprocessor experiment studi method parallel precondit krylov method partit strategi pde across multi processor execut time support adapt scientif algorithm distribut memori architectur design methodolog synthes parallel algorithm architec ture paragon multicomput environ first implement cm fortran refer manual design implement parallel unstructur euler solver use softwar primit slice analysi indirect access distribut array fortran languag specif solv problem concurr comput numer method comput inviscid transon flow shock wave gamm workshop updat distribut variabl local comput high perform fortran forum compil support machineindepend parallel program fortran compil optim fortran mimd distributedmemori machin compil program nonshar memori machin compil global namespac program distribut execut support share data structur distribut memori architectur gener explicit commun sharedmemori program refer comput model task schedul parallel spars choleski factor parallel loop indirect array refer pointer multigrid solut twodimension euler equat unstructur triangular mesh principl runtim support parallel processor scheme support automat data migrat multicomput process decomposit local refer overview dino new languag numer comput distribut memori multiprocessor express complex parallel algorithm dino massiv parallel process contract dino dino parallel program languag crystal runtim system perform effect irregular commun pattern massiv parallel multiprocessor parallel compil distribut memori parallel comput parallel precondit iter method compress navier stoke equat solut algorithm twodimension euler equat unstructur mesh distribut irregular finit element superb tool semiautomat mimdsimd parallel vienna fortran languag specif tr ctr manuel ujaldon emilio l zapata effici resolut spars indirect dataparallel compil proceed 9th intern confer supercomput p117126 juli 0307 1995 barcelona spain ayon basumallik rudolf eigenmann optim irregular sharedmemori applic distributedmemori system proceed eleventh acm sigplan symposium principl practic parallel program march 2931 2006 new york new york usa rongguey chang tyngruey chuang jenq kuen lee effici support parallel spars comput array intrins function fortran 90 proceed 12th intern confer supercomput p4552 juli 1998 melbourn australia roxana e diaconescu distribut compon architectur scientif applic proceed fortieth intern confer tool pacif object internet mobil embed applic februari 01 2002 sydney australia vladimir kotlyar keshav pingali paul stodghil compil parallel code spars matrix applic proceed 1997 acmiee confer supercomput cdrom p118 novemb 1521 1997 san jose ca kevin b theobald gagan agraw rishi kumar gerd heber guang r gao paul stodghil keshav pingali land cg earth case studi finegrain multithread evolutionari path proceed 2000 acmiee confer supercomput cdrom p4e novemb 0410 2000 dalla texa unit state renato ferreira gagan agraw joel saltz data parallel languag compil support data intens applic parallel comput v28 n5 p725748 may 2002 gagan agraw joel saltz interprocedur compil irregular applic distribut memori machin proceed 1995 acmiee confer supercomput cdrom p48e decemb 0408 1995 san diego california unit state peizong lee zvi meir kedem automat data comput decomposit distribut memori parallel comput acm transact program languag system topla v24 n1 p150 januari 2002