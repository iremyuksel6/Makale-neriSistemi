new worstcas upper bound sat 1980 monien speckenmey prove satisfi proposit formula consist ik claus arbitrari length check time order 2ik 3 recent kullmann luckhardt prove worstcas upper bound 2il 9 il length input formula algorithm lead bound base isplit method goe back davisputnam procedur itransform rule pure liter elimin unit propag etc constitut substanti part method paper present new transform rule two algorithm use rule prove algorithm worstcas upper bound 20 30897 ik 20 10299 il respect b introduct sat problem satis proposit formula conjunct normal easili solv time order 2 n n number variabl input formula earli 1980 trivial bound reduc formula 3cnf monien speckenmey 20 see also 22 independ dantsin 1 see also 4 2 mani upper bound sat subproblem obtain 21 17 25 13 14 26 16 8 23 24 author consid bound wrt three main paramet length l input formula number k claus number n variabl occur confer proceed version paper 9 best known worstcas upper bound sat pl2 l9 16 pl2 k3 21 see also 16 p polynomi also upper bound pl2 l4 satis problem gener boolean formula ie necessarili cnf known 28 recent paturi pudlak sak zane 24 prove 3sat checkabl random time o2 0446n still work describ paper present 9th acmsiam symposium discret algorithm soda98 9 steklov institut mathemat stpetersburg 27 fontanka 191011 stpetersburg russia email hirschpdmirasru url httplogicpdmirasruhirschindexhtml support part grant inta rfbr unknown whether trivial upper bound 2 n gener sat problem improv kullmann luckhardt 16 simpli algorithm monien speckenmey 21 present also improv algorithm complex pl2 k3 work better ratio number claus number variabl greater 264557 confer proceed version paper 9 present two algorithm improv bound pl2 pl2 030897k pl2 010537l respect journal version improv second algorithm prove worstcas upper bound pl2 010299l new algorithm use pl2 030897k time algorithm subroutin proof correspond upper bound much simpler proof confer proceed version 9 popular method solv sat local search method split method mani experiment averagecas result show signic power local search method refer see survey 7 howev best known worstcas upper bound sat npcomplet subproblem obtain use split method 21 16 8 worstcas upper bound local search method see 10 11 12 split method also use prove worstcas upper bound exact approxim maxsat solv 18 3 19 split method goe back davisputnam procedur 6 let l liter occur formula f let f l formula obtain f assign valu rue liter l ie remov claus contain l delet occurr l claus short main idea davisputnam procedur f satis least one formula f l f l satis wider sens 5 split algorithm construct tree reduc satis formula f satis sever formula f 1 f obtain f assign 1 spectiv split algorithm simpli formula f 1 f accord transform rule chang satis transform take polynomi time role reduc paramet l k n formula f 1 f simplifi formula elimin pure liter liter pure negat occur formula 1claus 1claus claus consist one liter easi piec recurr equat often use complex analysi algorithm kullmann luckhardt 16 describ similar simpler techniqu use estim run time split algorithm one consid execut split algorithm branch tree ie tree formula label children simpler formula label parent leav label simplest formula node tree associ branch vector nonneg number polynomi construct vector one estim number leav tree use largest posit root polynomi precis denit formul given sect 3 transform rule play import role split algorithm two simplest rule propos origin paper davi putnam 6 elimin pure liter 1claus transform rule use describ sect 4 paper introduc new transform rule goe follow simpl observ claus formula contain least one neg liter formula trivial satis assign variabl valu f als let p l f properti liter formula exampl f contain exactli two occurr l least three occurr l addit suppos variabl v formula f one liter v v satis p given f liter satisfi properti p refer p liter black white liter principl let f formula cnf least one follow two altern hold 1 claus f contain p liter contain negat p liter 2 satis f equival satis formula obtain f remov claus contain negat p liter formal proof black white liter principl given lemma 43 figur 1 illustr principl white circl denot p liter black circl denot negat circl dot denot liter ie liter neither p liter negat p liter note negat liter neither p liter negat p liter column correspond claus formula gure contain two formula rst one satis condit 1 second one satis condit 2 1 z 2 figur 1 two altern black white liter principl principl key point algorithm correspond upper bound pl2 030897k algorithm use presenc claus contain p liter contain negat p liter certain properti p black white liter principl kind insur guarante nd requir claus replac f simpler formula f contain p liter principl one reformul follow simpl properti partial assign ie set liter contain simultan x x variabl x formula f cnf either claus f contain liter set valu liter f als chang satis f anoth known reformul properti gener sign principl 16 autark principl 20 22 17 see also 16 comprehens studi autark principl found 15 use black white liter principl lead two new bound sat present paper also sever upper bound satis problem formula cnf11 8 formula cnf11 liter occur posit satis problem formula npcomplet sect 2 give basic denit section 3 contain techniqu allow us estim size branch tree sect 4 explain transform rule use algorithm sect 5 sect 6 describ algorithm upper bound pl2 030897k pl2 010299l respect correspond proof 2 basic denit let v set boolean variabl negat variabl v denot v given set u denot ug liter member set posit liter member set v neg liter negat w denot neg liter v w denot variabl v claus nite set liter contain simultan variabl togeth negat empti claus interpret f als formula cnf cnfformula nite set claus empti formula interpret rue length claus cardin length formula sum length claus length claus c denot jcj kclaus claus length k k claus claus length least k k claus claus length k say liter v occur claus formula mean claus formula contain liter v howev say variabl v occur claus formula mean claus formula contain liter v contain liter v assign nite subset w contain variabl togeth negat inform speak assign contain liter w mean w valu rue obtain f f assign remov f claus contain liter w delet occurr liter w claus short write f w assign satisfi formula f f empti formula formula satis exist satisfi assign say two formula f g equisatis satis unsatis let w liter occur formula f liter iliter f contain exactli occurr w ijliter f contain exactli occurr w exactli j occurr w ij liter f contain exactli occurr w least j occurr w ij liter f contain exactli occurr w occurr w similarli dene denot number occurr liter w formula f w sum length claus contain w w mean f clear context omit f liter w iliter similarli dene 3 estim size branch tree kullmann luckhardt introduc 16 notion branch tree intend estim time complex split algorithm sinc tree formula algorithm split branch tree one consid execut split algorithm tree whose node label cnfformula node label cnfformula f son label simpli formula f 1 f 2 assign suppos tree whose node label formula cnf formula f attach nonneg integ tree branch tree node complex formula label node strictli greater complex formula label son paper use number variabl f number claus f length f prove two upper bound wrt k wrt l howev section x concret measur complex let us consid node tree label formula f 0 suppos son label formula f 1 f 2 fm branch vector node mtupl posit number exceed characterist polynomi branch vector dene characterist polynomi h x monoton function x interv 0 1 h exactli one posit root denot root call branch number suppos leav omit one pair parenthes write exampl 31 exampl 069424 golden ratio branch number tree largest branch number node denot maxt follow lemma prove kullmann luckhardt allow us estim number leav branch tree use branch number lemma 31 kullmann luckhardt 16 let branch tree let root label formula f 0 number leav exceed maxt lemma alreadi allow us estim run time split algorithm know branch number split tree algorithm process leaf polynomi time howev algorithm correspond upper bound call algorithm correspond upper bound pl6 7 6 7 k subroutin thu process leav exponenti time estim overal run time use follow simpl gener lemma 31 lemma 32 8 let branch tree let root label formula f 0 let g l denot object label leaf l tree let l leaf proof induct construct tree base tree consist uniqu node case step consid tree present fig 2 let branch tupl root l leaf l leaf j fg l denit tupl figur 2 split tree denit h max maxt monoton h ut know branch number tree correspond split algorithm estim run time explicitli requir algorithm perform split branch number greater wish need prove alway exist split satisfi condit purpos algorithm compar branch number correspond dierent vector cours done examin constant number case use monoton howev gener statement hold lemma 33 kullmann luckhardt 16 let k natur constant x 1 posit ration number problem whether 1 solvabl time polynomi maxx 1 x follow estim run time algorithm use frequent inequ like 7 15 5 17 5 17 6 7 6 7 13 without proof one check inequ approxim calcul branch number howev sever simpl observ may help prove inequ easier lemma 34 kullmann luckhardt 16 1 permut compon branch vector aect correspond branch number 2 branch number strictli decreas one compon branch vector increas 4 transform rule section f denot formula cnf lemma 31 32 allow us take consider dierenc complex input formula complex formula obtain split higher dierenc smaller number leav thu obtain good algorithm reduc much possibl complex formula obtain split explain transform rule allow us precis explain certain case nd simpler formula equisatis f follow use rule never increas paramet consider number claus formula length formula elimin 1claus f contain 1claus fag formula f f equisatis sinc assign contain unsatisfi subsumpt f contain two claus c c f f nfdg equisatis sinc assign satis claus c satis also claus resolut subsumpt suppos given liter claus c liter satisfi condit 2 c 2 case claus c n fa ag call resolv liter claus c denot rc let f contain claus c clear ad rc formula chang satis howev increas size avoid eect use rule rc case reduc satis problem formula f satis problem dg elimin variabl resolut given liter construct formula dp ad f resolv remov f claus contain lemma 41 davi putnam 6 formula f dp equisatis transform increas size formula orand number claus use rule increas paramet consider number claus formula length formula note particular transform increas paramet f pure liter thu elimin pure liter elimin block claus claus c block liter wrt f c contain liter liter occur claus f contain negat least one liter occur c n fag note f may may contain c word resolv claus c claus formula f cnfformula f liter occur dene assign ag j claus fa xg block wrt fg mean f clear context omit f write ia notion block claus introduc investig kullmann 13 14 use follow two fact block claus lemma 42 kullmann 13 14 1 claus c block liter wrt f f f n fcg f fcg equisatis 2 given liter formula f satis least one formula f f ia satis applic black white liter principl let p binari relat liter formula cnf variabl v formula f one p v f p v f hold lemma 43 suppos claus f contain liter w satisfi p w f contain also least one liter b satisfi p b f f f fl j p l f g equi proof particular case autark principl 20 22 17 16 denot suppos g satis consid satisfi assign formula g clear assign hand assign satisfi f satis also g ut 5 bound wrt number claus section present algorithm 51 check satis formula f time polynomi algorithm two subroutin function reducek function splitk function reducek simpli input formula use transform rule see sect 4 function splitk intend reduc satis problem input formula satis problem sever simpler formula execut algorithm view follow function reducek simpli input formula splitk split sever formula reducek sim pli follow denot reducek formula function reducek output input f similarli dene splitk function reducek input formula f cnf output simpli formula cnf method kr1 elimin 1claus f contain 1claus repeat step f contain 1claus kr2 applic black white liter principl claus c f contain 23 contain also 3 f f fa j 3 elimin variabl resolut choos liter occur f maxim sever liter choos liter minim 0 f dp repeat step f satis condit f chang step kr1kr3 go step kr1 otherwis return f ut function splitk input formula f cnf output f satis rue otherwis f als method ks1 empti formula contain empti claus 2 f return f als split two subproblem liter occur f construct two exist liter kf choos formula f 1 f 2 correspond liter splitk return rue least one return rue otherwis return f als split four subproblem choos liter occur f two liter b c occur f f respect construct four formula f 11 reducek f 21 reducek f 22 reducek exist liter b c choos formula f 11 f 12 f 21 f 22 correspond liter return rue least one return rue otherwis return f als ut algorithm 51 input formula f cnf output f satis rue otherwis f als method return splitk reducek ut sect 4 explain none step reducek chang satis formula step kr1kr4 repeat kf sinc none increas number claus number variabl iter kr1kr4kr1 least one quantiti decreas step take polynomi time thu reducek chang satis formula return answer polynomi time construct tree ect behaviour algorithm 51 togeth function reducek splitk intern node label formula algorithm 51 split step ks3 ks4 leav label formula satisfi condit step ks1 ks2 intern node label f two son label f 1 f 2 four son label f 11 f 12 f 21 f 22 sinc condit step ks3 ks4 guarante correspond branch number exceed 6 7 6 7 lemma 31 number leav tree input formula thu algorithm 51 return answer time plf 6 7 6 7 kf p polynomi remain prove algorithm 51 perform correctli ie formula cnf reduc reducek satis least one condit step ks1ks4 prove statement need two simpl lemma concern output reducek lemma 51 let f 1 valu f step kr1 function reducek point time mayb elimin sever 1claus f 2 correspond output formula function reducek e liter occur f 1 1 1 1 2 e 1 1 claus f contain e simultan 2 proof 1 reducek modi formula step kr1 kr2 least one claus delet otherwis least one claus elimin step kr3 sinc kf 1 kdp 2 wlog suppos f 1 contain one 1claus claus contain 1liter elimin claus formula f 1 contain 1claus f 1 contain exactli one 1claus elimin step kr1 one claus elimin 1 sinc least one liter e remain let f 1 contain 1claus reducek modi formula step kr2 least one claus ie least two occurr elimin f valu f 1 step kr3 wlog suppos step kr3 step kr3 1 liter chosen rst applic dp least one liter e remain 1 liter negat liter remain formula henc 1 least one claus elimin ut lemma 52 let f formula cnf formula reducek contain 1claus 1 liter 22liter proof function reducek elimin 1claus step kr1 1 liter 22liter kdp elimin liter step kr3 ut theorem 51 algorithm 51 perform correctli stop time pl6 7 6 7 k pl2 030897k l length input formula k number claus p polynomi proof shown suce prove formula f cnf reduc reducek satis least one condit step ks1ks4 suppos f satisfi condit step ks1ks4 consid possibl case prove case imposs symbol mean correspond step function splitk key observ formula f contain frequent variabl transform f f f liter appli lemma 51 prove formal case 1 formula f contain 3 claus formula f contain liter disappear f claus contain liter disappear f sinc 3 4 thu term step ks3 ie condit step ks3 case 2 formula f contain claus contain 33liter 23 b three claus formula f contain disappear f three claus contain disappear f addit b becom 1 1 liter f thu term step ks3 1 1 lemma 51 henc ie condit step ks3 satis case 3 formula f contain 2claus consist 2liter claus formula f contain disappear f claus contain disappear f lemma 52 23 3 similarli case 2 term step ks3 1 1 addit c becom 1claus f elimin step kr1 ie 2 1 4 ie condit step ks3 satis case 4 formula f contain 3 consist 2liter sg claus formula f contain disappear f claus contain disappear f lemma 52 23 addit 2 3 becom f 1 c claus contain 2 3 simultan lemma 51 kf 1 kreducek 2 otherwis 3 becom 03 f 2 ie kf 2 kreducek 2 depend two altern take place choos 1 2 term step ks3 ie condit step ks3 satis case 5 condit case 14 satis sinc step kr2 chang f contain 3liter sinc f satisfi condit step ks3 liter 3 let liter occur f prove exist liter b c condit step ks4 satis consid three subcas rst two similar case 24 case 51 exist claus f 1 33liter 2 2liter suppos term step ks4 similarli case 2 11 4 12 3 case 52 exist claus f 1 23liter 2liter suppos term step ks4 similarli case 34 11 3 12 4 11 4 12 3 note 51 liter j occur togeth two claus case 53 condit case 5152 satis sinc 51 step kr1kr3 reduc number claus formula f condit case 5152 satis formula consist claus contain 22liter claus contain 33liter sinc exactli three claus formula f disappear f occurr 33liter disappear f henc contain least one 22liter b 1 let b 1 2liter formula f contain 2claus 51 similarli contain two claus contain liter b 1 simultan thu f contain 3 2liter choos liter b 1 b claus formula f contain b 1 disappear f b 1 addit claus contain 22liter becom liter thu lemma 51 3 hand two claus f contain b 1 disappear f b 1 two claus disappear lemma 51 sinc b 2 b 3 becom liter note 51 formula f contain one claus contain b 2 b 3 simultan thu case 5153 exist liter b f 7 liter c chosen similarli henc condit step ks4 satis ut 6 bound wrt length formula section present algorithm 61 check satis formula f time plf 2 010299lf p polynomi previou section dene two subroutin function reduc l function split l use similarli reducek splitk function reduc l simpli input formula split l split sever formula reduc l simpli function reduc l input formula f cnf output simpli formula cnf method lr1 elimin 1claus f contain 1claus repeat step f contain claus subsumpt f contain two claus c c f fdg repeat step f contain claus elimin block claus f contain block claus c f fcg repeat step f contain block claus resolut subsumpt f contain two claus c rc dd f frcdg repeat step f contain claus elimin variabl resolut choos liter occur f repeat step f satis condit f chang step lr1lr5 go step lr1 otherwis return f ut function split l input formula f cnf output f satis rue otherwis f als method ls1 empti formula contain empti claus 2 f return f als contain 2claus f contain 2claus appli algorithm 51 f return answer split two subproblem liter occur f construct two exist liter lf choos formula f 1 f 2 correspond liter split l return rue least one return rue otherwis return f als ut algorithm 61 input formula f cnf output f satis rue otherwis f als method return split l reduc l ut similarli reducek function reduc l chang satis formula return answer polynomi time construct tree ect behaviour algorithm 61 togeth function reduc l split l leav label formula satisfi condit step ls1ls3 algorithm 61 process polynomi time formula satisfi condit step ls1 ls2 pass formula satisfi condit step ls3 algorithm 51 process formula f time polynomi note f contain 2 claus sinc 1claus elimin step lr1 intern node tree label formula algorithm 61 split step ls4 intern node label f two son label f 1 f 2 sinc condit step ls4 guarante correspond branch number exceed 32 run time algorithm 61 upper bound qlg6 7 6 7 lg3 input formula g q polynomi remain prove algorithm 61 perform correctli ie formula cnf reduc reduc l satis least one condit step ls1ls4 need three simpl lemma concern output reduc l prove statement lemma 61 let f formula cnf liter occur 1 12 liter occur 3 claus ldp 2 11 liter occur 2 claus ldp 2 3 11liter ldp 2 proof straightforward calcul ut lemma 62 let f 1 valu f one step lr1lr5 function reduc l f 2 correspond output formula function reduc l liter occur 1 12 liter occur 3 claus 2 11 liter occur 2 claus 2 proof 1 note chang formula step lr1lr4 remov claus andor chang claus subset thu result decreas length formula least one occurr formula chang step lr5 least one occurr remov lemma 611 2 suppos f get valu f 1 function reduc l modi formula step lr4 modifi result increas length claus increas number occurr liter moreov formula chang step least one occurr remov one occurr remov least one liter remain formula occurr lemma 611 least one occurr remov step lr5 2 hold otherwis becom pure liter remov step lr5 thu 2 hold suppos reduc l modifi formula step lr5 2 follow lemma 612 ut use follow simpl properti formula reduc function reduc l proof 61 without explicit mention lemma 63 let g 1 f satisfi condit step lr1lr5 2 1claus f 3 pure liter 11liter f 4 2claus f contain 1liter 5 liter occur f 1liter occur f 7 7 liter occur f 5 proof 1 trivial 27 sinc f satisfi condit step lr1and see also lemma 61 ut theorem 61 algorithm 61 perform correctli stop time pl6 7 6 7 l3 pl2 010299l l length input formula p polynomi proof shown sucient prove formula f cnf reduc reduc l satis least one condit step ls1ls4 suppos f satisfi condit step ls1ls3 consid two possibl case f contain least one 1liter contain 1liter prove case f satis condit step ls4 inform done follow rst case show assign ia contain mani liter second case handl care examin subcas choos 2claus fc dg f examin follow subcas mani occurr claus contain liter c f contain mani occurr liter c two subcas show mani occurr elimin transform f f c f c f f subsequ elimin 1claus obtain claus contain liter c c third subcas none previou subcas hold subcas one c 22liter occur 2 3claus allow us use lemma 61 one occurr liter elimin split anoth liter follow denot f 2 liter mean step ls4 algorithm 61 case 1 formula f contain 1liter claus contain let 7 lemma 63 max7 number 3 claus among claus contain transform formula f f 2 occurr liter claus contain elimin thu 5 transform formula f f 1 claus occurr liter elimin 2claus contain elimin step lr1 sinc block wrt f exist claus f fa g claus elimin sinc claus fa g block wrt f ie fa claus contain claus claus distinct thu r7 r ie condit step ls4 satis 1 case 2 formula f contain 1liter sinc f satisfi condit step ls3 contain 2claus dg let us note formula f contain claus contain liter liter c liter liter c liter liter c simultan proposit true sinc f satisfi condit step lr2 lr4 also case ic fcg id fdg 62 denit let us denot one liter c shall choos later one denot remain liter b let number 3 claus among claus contain note 1 let number 3 claus among claus contain count occurr disappear transform formula f f ia f f subsequ elimin 1claus result 2claus contain liter transform formula f f 1 occurr liter claus contain elimin 2claus contain elimin step lr1 claus 1 kullmann luckhardt 16 prove similar algorithm case thu 5 17 condit step ls4 replac 8 12 howev would improv upper bound would make proof longer thu present simpler proof formula f contain 1claus fbg obtain 2claus elimin step lr1 f contain 2claus contain claus obtain elimin step lr1 number claus 1 transform formula f f 2 occurr liter claus contain b elimin 62 claus contain b liter occur thu even count occurr disappear claus contain rst applic step lr2 consid sever subcas case 21 c 6 6 63 64 thu ie condit step ls4 satis case 22 c 3 3 let 2 fc dg liter 3 hold let b remain liter fc dg thu 22 thu ie condit step ls4 satis case 23 5 let 2 fc dg liter remain liter fc dg 4 b 5 b case b 2liter occur one 2 3claus denot claus c b liter b becom 12liter f ia f complet proof show sever liter occurr elimin addit occurr count 63 three subcas case 231 least two occurr elimin rst applic step lr2 addit occurr count 63 case 9 20 case 232 exactli one occurr elimin rst applic step lr2 addit occurr count 63 remind 63 count occurr claus contain one liter aa 62 occurr liter b claus c b occurr liter b elimin transform formula f formula f count occurr term 63 elimin 1claus fbg obtain 2claus fa bg sinc imposs two distinct ident claus fa bg formula two occurr anoth occurr liter b occurr liter b c b elimin moment count 63 fact contradict assumpt case 232 thu case b remain 12liter rst applic step lr2 lemma 621 least one occurr elimin thu 6567 hold case 233 occurr elimin rst applic step lr2 addit occurr count 63 similarli case 232 b remain 12liter rst applic step lr2 transform formula f function reduc l thu jc b two occurr elimin lemma 622 6567 hold howev jc appli lemma 621 case thu 10 henc three subcas 231233 ie condit step ls4 satis ut 7 conclus work paper improv exist upper bound sat respect k number claus l length formula key point algorithm proof black white liter principl new transform rule view reformul two previous known principl autark 20 22 17 15 gener sign principl 16 proof well proof previou upper bound 21 16 neither short eleg would kind breakthrough nd compact way present proof upper bound split algorithm believ way could lead even better bound sinc current possibl creat new heurist prove correspond upper bound limit length comprehens proof hand challeng problem prove tight lower bound class split algorithm current exponenti lower bound resolut proof see eg 27 far enough known upper bound split algorithm split algorithm view resolut proof vice versa anoth direct work nd random algorithm give better upper bound sat nd way appli modern random algorithm alreadi invent 3sat recent breakthrough paper 23 24 also remain challeng problem nd lessthan2 n upper bound n number variabl r tautolog proof system base split method less 2 n sati approxim algorithm max sat better perform ratio cost longer run time exponenti upper bound sati machin program theoremprov comput procedur quanti algorithm sati separ sign sati two new upper bound sat local search algorithm sat worstcas analysi hard formula sat local search algorithm sat local search algorithm worstcas studi new method 3sat decis worstcas analysi investig autark assign algorithm complex ober komplexit parametr guarante valu maxsat maxcut new upper bound maxsat upper bound cover problem solv sati improv exponentialtim algorithm ksat solv 3sati abil less 1579 n step pure liter look ahead o1497 n complex proposit proof sati tr ctr rainer schuler algorithm satisfi problem formula conjunct normal form journal algorithm v54 n1 p4044 januari 2005 bolett ammitzbl madsen algorithm exact satisfi analys number claus paramet inform process letter v97 n1 p2830 januari 2006 evgeni dantsin andrea goerdt edward hirsch ravi kannan jon kleinberg christo papadimitri prabhakar raghavan uwe schning determinist 2 2k 1n algorithm ksat base local search theoret comput scienc v289 n1 p6983 23 octob 2002 ramamohan paturi pavel pudlk michael e sak franci zane improv exponentialtim algorithm ksat journal acm jacm v52 n3 p337364 may 2005 tobia rieg jrg roth holger spakowski masaki yamamoto improv exact algorithm domat number problem inform process letter v101 n3 p101106 februari 2007 ryan william algorithm quantifi boolean formula proceed thirteenth annual acmsiam symposium discret algorithm p299307 januari 0608 2002 san francisco california haiou shen hantao zhang improv exact algorithm max2sat annal mathemat artifici intellig v44 n4 p419436 august 2005 jen gramm edward hirsch rolf niedermei peter rossmanith worstcas upper bound max2sat applic maxcut discret appli mathemat v130 n2 p139155 15 august edward hirsch worstcas studi local search maxksat discret appli mathemat v130 n2 p173184 15 august laurent simon daniel le berr edward hirsch sat2002 competit annal mathemat artifici intellig v43 n14 p307342 januari 2005 oliv kullmann lean clauseset gener minim unsatisfi clauseset discret appli mathemat v130 n2 p209249 15 august rolf niedermei peter rossmanith effici fixedparamet algorithm 3hit set journal discret algorithm v1 n1 p89102 februari