design program check work program correct checker algorithm check output comput given program instanc program run checker certifi whether output program instanc correct paper defin concept program checker design program checker specif care chosen problem class fp function comput polynomi time problem fp checker present paper includ sort matrix rank gcd also appli method modern cryptographi especi idea probabilist interact proof design program checker group theoret computationstwo structur theorem proven one character problem check theorem establish equival class problem whenev one problem class checkabl problem class checkabl b introduct paper introduc concept program checker program checker program p program c instanc program p run c run subsequ c either certifi program p correct declar p buggi method propos gain confid output program exampl program verification9 seek achiev prove program correct program verif suffer problem hard prove program correct also argu proof correct program improv confid correct natur proofs13 recent discuss role verif softwar develop see 3 program testing12 run program test input output known see program output match expect output test fairli ad hoc techniqu gener method gener test data theorem proven behavior program pass test addit work theoret comput scienc commun concept helping27 35 may regard determinist version check program check easier verif yield mathemat proof program behavior unlik test allow cointoss greatli enhanc power checker comparison model help idea paper aris cryptographi probabilist algorithm program test particularli import work interact proof goldwass micali rackoff19 subsequ relat work seen sever correct checker construct paper use probabilist interact proof first step design equal import work paper random algorithm rabin33 freivalds16 latter remark enough includ excel program checker integ polynomi matrix multi plicat work budd angluin10 weyuker38 relev seek give program test rigor mathemat basi notion program check use paper first formal defin blum kannan6 paper draw heavili 6 6 concept program check defin checker exhibit grouptheoret problem select problem p class problem polynomialtim checker character sinc sever paper shed light problem blum lubi rubinfeld7 extend notion program check one step sever direct focu larg collect numer problem includ integ multipl modular multipl problem show possibl detect error program also correct error program mostli correct also provid effici test determin whether program mostli correct process result yield program tester provabl perform program pass selftest la 7 instanc size n possibl prove theorem say high probabl p correct instanc size n precis quantifi anoth concept introduc 7 librari program allow checker one problem librari call program problem librari long program librari check mean extens allow design effici simpl checker problem hitherto much complex checker adleman huang kompella1 provid checker sever numbertheoret problem includ integ greatest common divisor 6 conjectur effici checker gcd would hard find lipton29 consid program test way ensur mostli correct show one correct error program transform given instanc sever random instanc comput answer given instanc answer random instanc lipton29 build work beaver feigenbaum4 show polynomi gener perman particular amen techniqu rubinfeld34 extend notion check parallel check blum et al8 extend program store retriev data unreli memori kannan yao24 consid problem check cointoss program produc specifi output probabl distribut sever concept complex theori intim relat check two concept coher randomselfreduc concept consid extens literatur definit concept relat program check found exampl 5 14 rest paper organ follow formal descript program check model given section 2 section 3 illustr concept prototyp exampl graph isomorph problem section 4 deriv structur theorem allow us deriv checker one problem checker other section 5 present program checker grouptheoret problem section demonstr close connect design program checker design interact proof section 6 present checker number common function comput fp specif problem consid extend gcd sort matrix rank final section 7 character class problem polynomialtim checker checker let denot comput decis search problem x input let x denot output let p determinist program supposedli halt instanc say program p bug instanc x p x 6 x defin effici program checker c problem follow c p probabilist expectedpolytim oracl ture machin satisfi follow condit program supposedli halt instanc instanc posit integ k socal secur paramet present unari 1 p bug ie p instanc x probabl 2 p 6 probabl probabl comput sampl space finit sequenc coin flip c could toss remark order run time c includ whatev time take c submit input receiv output p exclud time take p comput ii definit p bug p give correct output input c p may output correct buggi assum program p problem halt instanc done order help focu problem hand gener howev program alway halt definit bug must extend cover program error slow program caus diverg altogeth case definit program checker must also extend requir addit condit 3 p x exce precomput bound phix run time valu x submit checker oracl program checker sound warn name c p remaind paper assum program p problem halt instanc condit 3 everywher suppress possibl extend notion program check probabilist algorithm bpp order simpli run program suffici often make probabl error correct program much smaller 12 k simpli treat program though determinist program check accordingli rest paper consid determinist program assur result checker determinist program extend checker probabilist program approach program correct question natur aris one sure program correct one sure checker correct seriou problem one solut prove checker correct sometim easier prove origin program correct case extend gcd checker section 6 anoth possibl tri make checker extent independ program check end make follow definit say probabilist program checker c littl oh properti respect program p expect run time c littl oh run time p shall gener requir checker littl oh properti respect program check princip reason ensur checker program differ program check instanc two program problem run time definit disallow checker run one check desir checker howev definit necessarili constrain us design effici checker although run time checker littl oh program run time account time spent call program checker made one call program run checker would result increas asymptot run time program gener hard achiev signific subclass problem one consid 7 one design checker run time wors constant time run time program check take account time spent run program check 3 exampl graph isomorph present exampl good checker checker adapt goldreich micali interact proof system graph isomorph see 18 model 18 reli exist allpow prover prover replac program check power program turn suffici simul prover applic checker result practic way check comput program graph isomorph graph isomorph problem lot heurist work instanc append checker heurist give us confid output possibl unproven heurist graph isomorph decis problem defin follow graph isomorph gi input two graph g h output ye g isomorph h otherwis checker c p check program p input graph g h begin comput p g h ye use p bugfre search isomorph g h done standard selfreduct hoffmann22 page 2427 check whether result correspond isomorph return buggi ye return correct p g h time toss fair coin gener random permut g 0 g comput p g g 0 return buggi gener random permut h 0 h comput enddo return correct end program checker correctli check comput program whatsoev purport solv graph isomorph problem even bizarr program design fool checker caught run input caus output incorrect answer follow theorem prove formal theorem 31 p correct program graph isomorph c p gi alway output correct p g h incorrect probc p gi output correct 1 moreov c p gi run polynomi time gi run polynomi time way count run time checker p bug g isomorph h c p construct isomorph g h correctli output correct p bug g isomorph h c p coin discov output correct p g h incorrect two case 1 p g h ye g isomorph h c p gi fail construct isomorph sinc none exist correctli output buggi 2 p g h g isomorph h way c return correct p g g 0 orh 0 ye whenev coin come head come tail g isomorph h sinc g h permut randomli produc g 0 h 0 g 0 h 0 probabl distribut therefor p correctli distinguish g 0 chanc ie 1 2 k possibl sequenc coin toss 4 beigel theorem follow theorem due richard beigel theorem 41 beigel let two polynomialtim equival decis problem polynomi time checker 1 possibl construct polynomialtim checker proof simplic assum initi 1 2 decis problem reduc karp reduct checker c 1 1 program p 2 2 also two way polynomialtim transform f 12 f 21 go 1 2 2 1 respect exist f 12 give us program p 1 1 defin term f 12 p 2 p 1 x defin p 2 f 12 x way count run time checker check program p 2 call p 1 accomplish polynomi time sinc f 12 polynomialtim function call p 2 count 1 step check p 2 instanc comput p 2 transform instanc z 1 use function f 21 use checker c 1 check correct p 1 z call checker make p 1 includ call instanc z transform polynomi time call p 2 procedur describ convinc correct p 1 z convinc us correct p 2 p 2 correct p 1 defin term p 2 thu checker find p 1 correct z convinc us p 2 correct p 2 wrong two case p 1 correct z discov contradict immedi p 1 wrong z checker c 1 design catch precis situat declar p 1 buggi therebi convinc buggi p 2 checker 2 describ run polynomi time let n length instanc 2 check run time checker 2 broken follow three compon ffl run time checker 1 instanc whose length polynomi n ffl one applic transform f 21 input length n ffl polynomi number applic transform f 12 input whose length polynomi n show theorem hold even problem possibl search problem reduct problem cook reduct case also program p 1 defin term p 2 proof correct checker essenti follow along line proof case karp reduct detail check program make polynomi mani call p 2 input transform f 12 replac program take instanc 1 polynomi time produc set instanc 2 queri also transform f 21 one particular applic beigel theorem graph isomorph sinc graph isomorph known polynomialtim checker problem polynomialtim equival graph isomorph also checker import note statement beigel theorem requir equival 1 2 follow exampl suggest reduct one direct suffici observ group isomorph gi reduc extend group isomorph egi 1 group given multipl tabl 2 gi differ egi ye answer former explicit isomorph latter know effici checker egi gi 41 gener beigel theorem let f complex class let 1 2 problem reduc f suppos checker 1 f condit give us checker 2 f consid situat f determinist time complex class situat similar replac time complex circuit size circuit depth time complex class nc n time complex function suppos algorithm whose run time bound fn input length n put problem f call f time complex function f call complex class f robust two time complex function f g f time complex function f word f robust class sum product composit two time complex function f time complex function f exampl robust time complex class includ p log o1 n theorem 42 let f robust time complex class 1 2 two problem reduc f c 1 checker 1 f checker c 2 2 f proof sketch checker c 2 construct along line checker construct beigel theorem run time analysi note definit robust precis one need guarante c 2 lie f use fact algorithm run time fn make fn call oracl program check produc output transform instanc whose length bound fn input length n thu run time checker 2 bound sum product composit run time two reduct checker 1 true even case reduct problem cook reduct corollari 41 1 2 equival ncreduct 1 ncchecker 2 proof although nc time complex class proof follow robust class nc complex function nc thought order pair function depthn sizen function class p depthn function log o1 n sum product composit complex function comput componentwis order pair repres function sinc argument theorem robust time complex class hold depth size well robust class p log o1 n establish robust complex function nc turn impli checker 2 nc 42 ncchecker problem p use gener version beigel theorem prove pcomplet problem checker nc theorem 43 p complet problem checker nc proof light gener version beigel theorem suffici prove pcomplet problem checker nc pcomplet problem nc reduc particular pcomplet problem provid ncchecker lexicograph first maxim independ set lfmi 11 problem 43 ncchecker lfmi lexicograph first maxim independ set lfmi input graph g vertic number 1 n vertex v graph output ye lfmi contain vertex v lfmi present ncchecker inform algorithm pram detail pram model see instanc 26 step 1 th processor ask whether v lfmi thu processor determin lfmi step 2 step associ vertex group n processor th group processor associ v assum answer obtain step 1 queri correct assumpt check see answer queri v correct done o1 time sinc v lfmi iff edg v smaller number vertex lfmi thu crcw pram model checker run o1 time use 2 proce sor step 2 care allow us reduc processor count alreadi mention find nc checker lfmi give us ncchecker pcomplet problem interest prove difficult problem p checker nc although dont know whether decis problem p checker nc ncchecker pcomplet problem big open question whether npcomplet problem checker p fact neg evid question15 5 checker group theoret problem mani group theoret problem checker resembl graph isomorph subsect 51 show two fairli gener class exampl 52 give gener approach checker construct work particularli well group theoret problem work group theoret problem group theori rich sourc problem checker elementari properti group lagrang theorem often exploit design checker structur group often impli relationship among correct answer differ instanc relationship use check consist program sometim consist check proven suffici ensur correct program instanc checker graph isomorph describ introduct view group theoret checker sinc problem graph isomorph polynomialtim equival problem determin automorph group graph31 graph isomorph essenti check consist program case program say input graph g h isomorph structur problem impli 1 g random permut g isomorph 2 g isomorph h g isomorph random permut h 0 h comput use extens tool group theori fact classif finit simpl groups21 motiv aid comput calcul classif shown 26 group belong infinit famili group 26 group refer sporad group exist sporad group confirm comput construct reason check group theoret problem fruit endeavour 51 equival search canon element problem problem correspond checker describ subsect state term set element group g act b defin jg b g let esp g denot equival search problem otherwis proposit 51 let esp g equival search problem given g suppos exist effici probabilist algorithm find random g 2 g accord uniform distribut effici program checker c p problem esp g exampl equival search problem includ graph isomorph quadrat residuos gener discret log game rubic cube exampl aris knot theori block design code matric gf q latin squar 28 page 32 applic burnsid polya theorems32 relat equival search problem equival decis problem defin equival decis problem edp instanc question jg b would nontrivi prove similar proposit edp esp seem reduc edp follow argument indic recal n posit integ z n denot group posit integ less n rel prime n group oper multipl mod n p prime let action g 2 g 2 map g mod p observ jg b b g mod p g z suppos given oracl factor find g b g mod p essenti solv discret log problem cryptograph circl believ solvabl polynomi time even given oracl factor hand edp solvabl polynomi time given oracl factor proof consist show mod p g orderbjordera x exactli ordera solut name final ordera orderb determin factor p gamma 1 canon element problem cep input 2 output c g c uniqu canon element equival class g 2 g proposit 52 effici program checker canon element problem provid probabilist procedur select random g 2 g effici remark cep program fail two canon element class defin true canon element class uniqu element half element class map program 52 group intersect problem use twostep approach design checker group intersect first design interact proof system show interact proof system convert checker babai moran2 independ earlier provid interact proof system group intersect use checker group intersect beigel trick obtain checker sever problem known polynomi equival group intersect first briefli discuss variou represent group comput three common represent use increas order difficulti manipul multipl tabl represent permut group represent abstract group represent multipl tabl represent explicitli specifi product pair group element permut represent group thought act set group element permut group oper composit usual group specifi specifi polynomi mani size set gener permut abstract group represent group present gener relat relat specifi amongst relat impli specifi relat hold gener complet specifi group describ checker group intersect problem follow group intersect problem input two permut group g h specifi gener output gener g h let n size set g h act gener specif gener set g n bit done polyn bit henc take input length n probabilist polynomialtim algorithm known solv group intersect problem surpris sinc graph isomorph polynomialtim reduc group intersect follow interact proof protocol work group intersect 521 ip protocol 1 prover send verifi set permut supposedli gener 2 verifi check element sent prover actual lie g h involv test membership g h verifi method 17 consequ verifi convinc element sent prover either gener proper subgroup 3 verifi send prover element 2 gh obtain select random element multipli togeth 4 prover send back factor 0 b 0 0 2 g b 0 2 h 5 verifi check gamma1 0 element group gener gener prover provid step 1 theorem 51 protocol step 35 repeat k time allow prover 12 k probabl cheat verifi proof denot group gener gener prover send step 1 clear step 2 g h step 3 4 aim give verifi random element g h follow lemma effect lemma 51 notat protocol gamma1 0 random element g h ab 2 g b 2 h x thu two factor element recov comput gamma1 0 x thu x uniqu factor along remain prove everi pair factor correspond element g h suppos two factor ab rearrang gamma1 left hand side last equat element g right hand side element h sinc equal element must belong g h random factor ab impli random element g h obtain procedur sinc prover know factor ab use verifi proof lemma 51 essenti complet proof theorem use lagrang theorem note proper subgroup g h random element g h belong probabl half perform k repetit step 35 reduc error probabl 12 k 522 convert ip protocol checker verifi protocol ask prover factor certain element gh convert ip protocol checker one must show program group intersect use factor element gh factor search problem fsp shown equival group intersect problem one could use program group intersect factor fsp follow problem factor search problem input two permut group g h permut output gh 2 g b 2 h ab otherwis associ factor decis problem fdp known equival group page 236241 follow lemma show equival fsp fdp lemma 52 fdp equival fsp proof obviou fdp reduc fsp remain shown fsp reduc fdp proof reli notion strong gener introduc 17 assum strong gener g h defin furst hopcroft luks17 assum without loss gener set gener convert set strong gener polynomi time brief descript notion strong gener mg group g mg size permut domain matrix entri diagon diagon posit ij entri permut g fix pointwis element move j case permut exist ij th entri permut g conveni customari make diagon entri ident permut properti represent given without proof everi element g express uniqu way product n row mg use convent string permut leftmost one act first rightmost one last consequ previou fact jgj product number nonempti entri row mg anoth consequ random element g obtain multipli togeth random element row mg also g 1 subgroup g fix point 1 gener entri row 2 n mg final membership g permut oe test follow oe move 1 j look posit 1j entri none exist oe g otherwis 1 entri oe 1 fix point 1 move second row check membership g 1 proceed thu either find oe g find express oe product entri mg suppos gh consid h 1 subgroup h consist permut fix point 1 sinc gh ab g b h also b equal product oe n oe th row mh thu permut oe 1 first row mh abo 1 gh 1 use oracl fdp find entri first row mh properti entri oe 1 consid oe 1 factor gh 1 factor gh 1 yield factor gh seen techniqu appli recurs yield factor gh complet reduct show ip protocol describ convert checker 6 problem fp section program checker use oracl determin sever time case instead program checker denot c p denot c k latter notat advantag clarifi must test case checker nonprobabilist denot c instead mani problem fp effici program checker challeng find follow give fairli complet descript program checker three problem one oldest nontrivi algorithm book sort one frequent solv problem matrix rank unusu seem requir multical checker twosid error 61 extend gcd problem integ gcd given two integ b find gcd b adleman huang kompella1 recent given probabilist checker problem extens problem make easi check idea extend problem without incur addit run time solv extend problem import one area program check extend gcd input two integ b output integ integ u v check gcd checker perform 5 arithmet oper ffl check divid b valid check obviou definit gcd point convinc divisor b ffl check b done three arithmet oper justifi check show two check convinc us gcd refer follow standard lemma lemma 61 let b posit integ smallest posit integ express integ combin b gcd 62 sort hardli necessari mention sort one commonli solv problem comput scienc larg number algorithm avail sort fairli complex program thu necessari check output sort program sort trivial check comparison tree model model input output given order input variabl permut oe output x checker sort confirm output inequ valid done use fact use linear number oper reason model comput gener assum output point input came check sort mere check output right order ram model comput easi check sort linear time ram reflect mani sort scenario defin problem sort provid reason model comput sort input array integ x x repres multiset output array consist element x list nondecreas order model comput comput fix number tape includ one contain x anoth contain x n element element rang 0a random access memori olog nlog word memori word capabl hold integ rang 0a particular word hold element ffl singl precis oper gamma theta take one step denot integ divid ffl multiprecis oper gamma step integ word long step addit machin usual oper shift tape copi word tape ram vice versa take 1 step model comput describ easi check output list order step need also check multiset done probabilist step right method depend rel size n n 2 simpl bucket sort work need bucket number rang 0 sinc log n random access memori space enough bucket thu could run valu x put one appropri bucket could run element take one appropri bucket time bucket tri take valu turn empti checker declar program buggi situat interest case present follow two method check multiset equal method 1 method specif import choic hash function first suggest wegman carter39 comput check jy select x 6 probabl least 12 sum differ see remov x largest submultiset element common result x still size intersect empti comput two sum equal set hx 1 1 distinguish x sum differ set hx 1 0 distinguish two either case h probabl 12 distinguish two set sinc random function requir enorm number random bit replac random function h suitabl chosen hash function choos easi comput hash function difficult wegmancart hash function particular requir random access memori henc implement model comput differ hash function work recal select random prime p interv 1 3 delta delta log set inde prime p x 6 point karp rabin25 least half prime interv 1 3deltaa delta log choic interv size aris estim larg get sinc sum n term term bound sum bigger n delta sinc bound sum a1 interv chosen suitabl constant time log a1 thu 25 show prime randomli chosen interv 1 3 delta delta log hash function probabl least 12 catch error method 2 idea first suggest lipton29 recent ravi kannan23 multiset iff g sinc f g polynomi degre n either n gamma 1 valu z probabilist algorithm decid select k valu random set 2n possibl say 12n compar fz gz k valu comput kept reason size arithmet oper modulo randomli chosen small prime comput product fz term bound absolut valu 2n henc product bound accord 25 prime chosen approxim rang 1 n loga compar two method show regardless rel valu n one method alway run time log n comparison method 1 2 recal multiset n integ rang 0a also recal n 2 bucket sort use check comput sinc word size model olog n 2 prime method 1 fit constant number word number word w requir hold prime method 2 omax1 log n log run time method 1 log need perform log multipl comput constant time oper sinc prime moduli constant number word long run time method 2 function number word w equal nw 2 sinc n multipl perform number w word long overrid cost method 2 describ transit one method anoth decreas function n use bucket sort n becom less 2 long n log log n use method 1 run time log instanc could use method 1 long n greater log log threshold valu n log n log log log log henc log olog n n dip threshold prime method 2 fit log log word method 2 run time onlog log 2 notic typic case sort n case method 2 run linear time thu algebra finagl mainli prove exist littl oh checker rel valu n 63 check matrix rank subsect describ checker matrix rank checker rank mainli theoret interest satisfi littl oh properti requir howev make 2 call program check henc would highli ineffici implement practic blum lubi rubinfeld7 subsequ discov practic checker matrix rank howev checker conform origin definit check instead use idea program matrix multipl check check rank one call matrix multipl program count call one step consid matric whose entri drawn finit field f let p program take matrix input output integ r supposedli rank describ checker p checker given integ k unari k desir confid checker output ie probabl checker wrong o12 k describ checker three part first part checker produc r x r submatrix supposedli full rank process selfreduct use program obtain intermedi answer part 2 checker check result r x r matrix inde full rank incident prove rank origin matrix least r final also need ensur rank r done part 3 checker 631 selfreduct let n x matrix input p suppos p output r let u um column delet u feed result matrix p p say rank endfor number column remain 6 r return selfreduct obtain r column vector supposedli linearli independ r column nvector selfreduct row n x r matrix arriv r x r matrix supposedli full rank cours want take program word matrix full rank need check matrix actual full rank thu even program return wrong answer cours selfreduct detect declar program bad done part 2 checker 632 lower bound rank r x r matrix full rank column matrix form basi f r case everi vector f r uniqu represent linear combin column vector matrix part checker exploit uniqu represent r column r x r matrix supposedli full rank idea creat k linear combin x r column matrix suppos exampl toss fair coin come head subtract c 1 v 1 x 1 otherwis choos random 6 c 1 f subtract av 1 x 1 expect x basi x clearli true v form basi suppos v form basi let v j first v nonzero coeffici depend relat among v v j could coeffici linear combin produc x 1 coeffici v j affect valu coeffici v 1 thu program way distinguish situat subtract c j time v j situat subtract multipl v j thu linear combin x program probabl 12 escap undetect wrong claim independ idea yield requir algorithm describ gener k random linear combin let k random combin x 1 k j 1 r begin toss fair coin head els random 6 c j replac v j origin matrix ask program rank new matrix head rank 6 r gamma 1 return program bad tail rank6 r return program bad endfor endfor clear program wrongli claim independ probabl 12 k escap detect 633 upper bound rank go back origin matrix column um selfreduct left r column say supposedli linearli independ ndimension space randomli pick vector x vector u basi n dimension space use program help decid set n column full rank program say redo experi pick vector x follow lemma lemma 62 r independ probabl greater posit constant 1delta4 delta 7 delta n vector obtain augment r random vector b form basi f n proof worstcas occur f gf 2 requir build random basi scratch case number good choic th vector total 2 n choic work probabl th vector independ first gamma 1 yield result lemma clear lemma random trial constant probabl succeed ie produc basi perform experi ok time program alway say set vector depend report program buggi know correct overwhelm probabl howev small chanc 12 k program right unlucki enough hit upon basi next need follow lemma lemma 63 u depend u linear combin u depend u one u depend u linear combin u depend u probabl half proof first statement lemma obviou second part suppos u rj independ u linear combin x depend chang coeffici u rj anyth els besid one x make new vector independ count establish least mani independ combin depend one equal occur case vector space gf2 lemma 63 suffic check k random linear combinationsi u depend u ensur probabl program correct suppos one independ u denot 1 follow let uniqu express linear combin u r lemma 64 represent c r probabl 1 1of nonzero probabl choic random extens basi although program influenc distribut random extens statement lemma still hold vector space gener first vector basi let w complement v r take appropri compon vector w problem restat follow suppos random basi z l w ldimension space nonzero vector w basi vector coeffici uniqu represent linear combin basi vector nonzero probabl 1we prove statement fix vector respect random basi thought equival random vector respect random basi let random nonsingular l x l matrix consid 11 correspond set base set base take basi z l basi az ay imag linear transform nonsingular 0 random vector w new basi random basi w 11 correspond given basi random vector w gener randomli pick coeffici basi vector thu random vector probabl coeffici zero 1 result translat back fix vector result lemmata 63 64 note u depend high probabl one replac one x basi u idea yield follow checker repeat k time toss fair coin head w random linear combin origin basi nonzero coeffici x j els w random linear combin origin basi without x j nonzero coeffici replac x j w feed result matrix p head rank 6 r reject program tail rank reject program endrepeat endfor endfor clear program wrong origin claim u um depend escap detect probabl 12 k thu checker error probabl o12 k number place overal probabl error bound sum probabl therefor o12 k 634 analysi run time expens oper creation random linear combin mani vector care taken keep number oper part 1 checker self reduct run time part 2 gener k linear combin take time okn 2 loop repeat onk time run loop take time thu overal run time part 2 okn 2 part 3 gener random basi take okn 2 time sinc might gener kn differ vector finish creat k linear combin take okn 2 time bottleneck howev loop repeat ok 3 time pass take 2 time thu overal complex checker ok 3 n 2 point discuss amount time charg call program analysi made call charg 1 step justifi least theoret sens follow assum model checker queri tape write instanc program run call program could justifi charg amount time take modifi queri tape order produc new instanc previou instanc queri possibl use suitabl data structur implement modif o1 step comput 7 checker character theorem section character set problem check polynomi time purpos section checker run polynomi time call effici take definit ip interact proofsystem definit appear gold wasser micali rackoff 19 except replac suffici larg x definit x modif 19 conform commonli accept definit ip appear exampl goldwass sipser 20 tompa woll 37 functionrestrict ip cofunctionrestrict ip set decis problem interact proof system yesinst noinstanc satisfi condit prover honest prover must comput function prover dishonest prover must function set instanc fye nog restrict impli two thing 1 verifi may ask question instanc 2 prover prover must answer verifi question answer independ prover prover previou histori question answer theorem 71 effici program checker c exist decis problem lie function restrict ip cofunctionrestrict ip proof theorem immedi definit effici program checker complex class functionrestrict ip let npsearch denot class problem x x noinstanc ye togeth proof x yesinst otherwis corollari 71 let np search problem effici program checker c exist functionrestrict coip main purpos corollari point np 6 cofunctionrestrict ip seem like effici program checker c sens npcomplet problem note result lund et al 30 shamir36 give functionrestrict ip proof npcomplet languag 8 overview conclus thrust paper show mani case possibl check program output given input therebi give quantit mathemat evid program work correctli input allow possibl incorrect answer one would comput done hand program design confront possibl bug consid answer wrong give altern prove program correct may achiev suffici mani situat one way develop theori would requir program checker prove correct paper howev pure check mean proof correct whatsoev instead requir checker c differ program p check two way first inputoutput specif c differ p c get p output respond correct buggi second demand run time checker os run time program check prevent programm undercut approach could otherwis simpli run program second time call check whatev els programm must think problem 9 acknowledg grate ronitt rubinfeld mani long convers marvel idea includ extens check idea parallel comput sandi irani raimund seidel design interest checker variou problem comput geometri convex hull wish thank well russel imapagliazzo shafi goldwass len adleman idea enthusiast support r effici checker numbertheoret problem mathemat proof comput system correct hide instanc multioracl queri incoher without hard design program check work check correct memori correct problem comput scienc two notion correct relat test taxonomi problem fast parallel algorithm softwar test evalu social process proof theorem program local random reduct interact complex theori fast probabilist algorithm proof yield noth valid languag np zeroknowldeg proof system knowledg complex interact proof system public coin vs privat coin interact proof system finit simpl group introduct classif person commun program checker probabl gener effici random pattern match algorithm parallel algorithm sharedmemori machin help robust oracl machin comput automorph group combinatori object new direct test algebra method interact proof system note graph isomorph count problem combinatori enumer group probabilist algorithm design checker program run parallel robust algorithm differ approach oracl random selfreduc zero knowledg interact proof possess inform evalu programbas softwar test data adequaci criteria new hash function use authent set equal tr taxonomi problem fast parallel algorithm softwar test evalu combinatori enumer group graph chemic compound help robust oracl machin arthurmerlin game random proof system hierarchi complex class evalu programbas softwar test data adequaci criteria knowledg complex interact proof system design program check work hide instanc multioracl queri selftestingcorrect applic numer problem program checker probabl gener parallel algorithm sharedmemori machin proof yield noth valid languag np zeroknowledg proof system check correct memori algebra method interact proof system randomselfreduc complet set incoher without hard effici checker numbertheoret comput social process proof theorem program correct problem comput scienc ctr christian collberg stephen g kobourov jessica miller suzann westbrook agovista tool enhanc algorithm design understand acm sigcs bulletin v34 n3 septemb 2002 thoma sterl daniel katz larri bergman high perform comput system autonom spaceborn mission intern journal high perform comput applic v15 n3 p282296 august 2001 edgar f leder romeo dumitrescu specificationconsist coordin model comput proceed 1998 acm symposium appli comput p122129 februari 27march 01 1998 atlanta georgia unit state christian collberg stephen g kobourov suzann westbrook algovista algorithm search tool educ set acm sigcs bulletin v36 n1 march 2004 dick hamlet continu softwar system acm sigsoft softwar engin note v27 n4 juli 2002 ronitt rubinfeld madhu sudan selftest polynomi function effici ration domain proceed third annual acmsiam symposium discret algorithm p2332 septemb 1992 orlando florida unit state dick hamlet dave mason denis woit theori softwar reliabl base compon proceed 23rd intern confer softwar engin p361370 may 1219 2001 toronto ontario canada zhizhong chen mingyang kao reduc random via irrat number proceed twentyninth annual acm symposium theori comput p200209 may 0406 1997 el paso texa unit state chen h tse zhiquan zhou semiprov integr method base global symbol evalu metamorph test acm sigsoft softwar engin note v27 n4 juli 2002 paul ammann dahlard l luke john c knight appli data redund differenti equat solver annal softwar engin 4 p6577 1997 arbaugh jame r davin david j farber jonathan smith secur virtual privat intranet comput v31 n9 p4855 septemb 1998 amit paradkar toward modelbas gener selfprim selfcheck conform test interact system proceed acm symposium appli comput march 0912 2003 melbourn florida chen fc kuo zhi quan zhou effect test method endus programm acm sigsoft softwar engin note v30 n4 juli 2005 daniel lewin salil vadhan check polynomi ident field toward derandom proceed thirtieth annual acm symposium theori comput p438447 may 2426 1998 dalla texa unit state christian collberg todd proebst problem identif use program check discret appli mathemat v144 n3 p270280 15 decemb 2004 peifeng hu zhenyu zhang w k chan h tse empir comparison direct indirect test result check approach proceed 3rd intern workshop softwar qualiti assur novemb 0606 2006 portland oregon w k chan cheng c cheung h tse automat goalori classif failur behavior test xmlbase multimedia softwar applic experiment case studi journal system softwar v79 n5 p602612 may 2006 borislav nikolik test suit oscil inform process letter v98 n2 p4755 fast approxim probabilist checkabl proof inform comput v189 n2 p135159 march 15 2004 fast approxim pcp proceed thirtyfirst annual acm symposium theori comput p4150 may 0104 1999 atlanta georgia unit state ronen shaltiel christoph uman lowend uniform hard vs random tradeoff proceed thirtyninth annual acm symposium theori comput june 1113 2007 san diego california usa dan gutfreund ronen shaltiel amnon tashma np languag hard worstcas easi find hard instanc comput complex v16 n4 p412441 decemb 2007 manindra agraw somenath biswa primal ident test via chines remaind journal acm jacm v50 n4 p429443 juli dan gutfreund ronen shaltiel amnon tashma uniform hard versu random tradeoff arthurmerlin game comput complex v12 n34 p85130 septemb 2004 taejoon park kang g shin soft tamperproof via program integr verif wireless sensor network ieee transact mobil comput v4 n3 p297309 may 2005 rahul santhanam circuit lower bound merlinarthur class proceed thirtyninth annual acm symposium theori comput june 1113 2007 san diego california usa shafi goldwass dan gutfreund alexand heali tali kaufman guy n rothblum verifi decod constant depth proceed thirtyninth annual acm symposium theori comput june 1113 2007 san diego california usa valentin kabanet russel impagliazzo derandom polynomi ident test mean prove circuit lower bound proceed thirtyfifth annual acm symposium theori comput june 0911 2003 san diego ca usa lori clark david rosenblum histor perspect runtim assert check softwar develop acm sigsoft softwar engin note v31 n3 may 2006 luca trevisan salil vadhan pseudorandom averagecas complex via uniform reduct comput complex v16 n4 p331364 decemb 2007 christian collberg clark thomborson watermark tamperprof obfusc tool softwar protect ieee transact softwar engin v28 n8 p735746 august 2002 valentin kabanet russel impagliazzo derandom polynomi ident test mean prove circuit lower bound comput complex v13 n12 p146 januari 2004 marco kiwi frdric magniez miklo santha exact approxim testingcorrect algebra function survey theoret aspect comput scienc advanc lectur springerverlag new york inc new york ny 2002