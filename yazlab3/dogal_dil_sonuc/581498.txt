metaprogram name necess metaprogram languag provid infrastructur gener execut object program runtim type set contain modal type constructor classifi object code code type gener come two flavor close open close code express invok runtim comput rigid typic produc less effici residu object program open code provid better inlin partial evalu object program construct express type gener evaluatedrec work area focus combin two notion sound system present novel way achiev base ad notion name work nomin logic freshml calculu proof term necess fragment modal logic s4 result languag provid finegrain control free variabl object program compar exist languag metaprogram addit approach lend well addit intension code analysi ie abil meta program inspect destruct object program runtim typesaf manner also undertak b introduct metaprogram broadli defin disciplin algorithm manipul program written certain object languag program written anoth meta languag oper object program meta program may describ divers may includ among other gen erat inspect special cours execut object program runtim illustr concept present follow scenario refer sheard 2001 comprehens treatment exampl rather use one gener procedur solv mani dierent instanc problem program gener special henc ecient subroutin particular case languag capabl execut thu gener procedur program choos dynam depend runtim valu certain variabl express one suitabl invok idea behind work runtim code gener lee leon 1996 wicklin et al 1998b wicklin et al 1998a function program concept stage comput ershov 1977 gluck jrgensen 1995 davi pfen 2001 nanevski f pfen languag object program compos execut also structur inspect add advantag particular e cienci may benefit variou optim perform know structur code exampl griewank 1989 report way reus common subexpress numer function order comput valu certain point valu ndimension gradient way complex evalu perform togeth grow n applic well seem call capabl execut certain function also inspect structur see roza 1993 exampl comput graphic numer analysi ramsey pfeer 2002 exampl machin learn probabilist model paper concern type function languag metapro even precis limit consider homogen metaprogram especi simpl case object meta languag recent develop direct center around two particular modal lambda calculi calculu proofterm languag modal logic s4 whose necess constructor annot valid proposit davi pfen 2001 pfen davi 2001 type use runtim code gener classifi gener code type wicklin et al 1998b wicklin et al 1998a calculu proofterm languag discret lineartim tempor logic type classifi term associ subsequ time moment intend applic partial evalu type annot program seen bindingtim specif davi 1996 calculi provid distinct level stage term explain use meta program lowest level meta languag use manipul term next level term type meta languag subsequ level contain anoth stratum box circl type etc purpos metaprogram type also associ close code classifi close object term type hand type type postpon code classifi object term type associ subsequ time moment oper semant allow reduct objectlevel binder postpon code frequent conflat notion open code dichotomi close open code inspir recent type system metaprogram abstract concept open code necessarili gener close code specif program environ alreadi observ davi 1996 work open code flexibl result better optim residu object program howev also want run gener object program close thu need type system integr modal type close open code sever propos type system provid express notabl metaml moggi et al 1999 taha 1999 calcagno et al 2000 calcagno et al 2001 metaml defin notion open code name necess 3 postpon code introduc close code refin open code happen contain free variabl approach calculu call opposit rather refin notion postpon code relax notion close code start system provid addit express allow code contain specifi object variabl free rudiment idea alreadi consid nielsen 2001 given code express depend set free variabl reflect type object variabl repres separ semant categori name also call symbol atom admit equal treatment name inspir work nomin logic freshml gabbay pitt 2002 pitt gabbay 2000 pitt 2001 gabbay 2000 design choic lead logic motiv easili extend type system exampl describ nanevski 2002 extens intension code analysi allow object express compar structur equal destruct via patternmatch much way one would work abstract syntax tree paper organ follow section 2 brief exposit prior work type system properti describ section 3 section 4 describ parametr polymorph set name illustr type system exampl program discuss relat work section 5 modal calculu section review previou work modal calculu use metaprogram separ mechan type realm metalevel program objectlevel program calculu proofterm calculu necessit fragment modal logic s4 pfen davi 2001 davi pfen 2001 chronolog came consid function program context special purpos runtim code gener wicklin et al 1998b wicklin et al 1998a exampl consid exponenti function present mllike notat function exp1 int int int written curri form appli part input known exampl actual paramet n avail exp1n return function comput nth power argument practic implement scenario howev outcom partial instanti closur wait receiv actual paramet x proce evalu thu one argu follow reformul exp1 prefer 4 nanevski f pfen els let val xint x ux inde n provid x express exp2n perform comput step base valu n produc residu function special comput nth power argument particular obtain residu function perform oper take decis runtim base valu n fact even depend n comput step depend n taken special use intuit understand program idiom ex ampl view exp2 program gener suppli n gener special function comput nth power immedi suggest distinct calculu two stage level meta object stage object stage express encod term view data result process code gener exp2 function term would xint1 xint x ux meta stage describ specif oper perform express object stage aboveillustr program style refer stage comput idea behind type system make explicit distinct meta object stage allow programm specifi intend stage term annot objectlevel subterm program type system check whether written code conform stage specif make stage error type error syntax present use b stand predetermin set base type c constant type type b 1 2 erm e c x u xa e e 1 e 2 alu variabl context xa express variabl context ua alu v c xa e box e sever distinct featur calculu aris desir dierenti stage import new type constructor usual refer modal necess logic side necessit modifi proposit pfen davi 2001 metaprogram applic use classifi objectlevel term introduct elimin form term constructor box let box respect figur 1 show e object term type box e would meta term type box term constructor wrap object term e access manipul meta part program elimin form let box name necess 5 opposit take object term enclos e 1 bind variabl u use e 2 type system distinguish two kind variabl consequ two variabl context variabl bound meta term variabl bound object term implicitli assum exchang hold order variabl context immateri figur 2 present smallstep oper semant decid callbyvalu strategi addit prohibit reduct object level thu express box evalu suspend box express consid valu choic mean canon necessari applic paper use type system make explicit stage exp2 els let box box xint x ux applic exp3 argument 2 produc objectlevel function squar val xint x yint zint elimin form let box bound variabl u belong context objectlevel variabl use e 2 object posit ie box meta posit way calculu capabl compos object program also explicitli forc evalu exampl use gener function sqbox follow way val val exampl demonstr object express reflect coerc objectlevel metalevel opposit coercion refer reific howev possibl suggest given specif model reflect natur exist reific possibl interpret exhibit behavior consid object term actual syntact express abstract syntax tree sourc program calculu meta term compil execut type scenario object term repres syntax higherord syntax pfen elliott 1988 well oper reflect correspond 6 nanevski f pfen fig 1 type rule xa let box let box fig 2 oper semant natur process compil sourc code execut opposit oper reconstruct sourc code compil equival usual feasibl interpret support reific requir modal calculu name 31 motiv syntax overview adher interpret object term higherord syntax stage exp3 rather unsatisfactori problem residu object program produc exp3 eg sqbox contain unnecessari variablefor variabl redex henc optim one would want may seriou critic perspect runtim code gener inde variableforvari redex easili elimin compil object term view higherord syntax argu previou section natur model calculu limit sever exhibit restrict allow arbitrari composit higherord syntax tree reason defici requir box object term must alway close sens type type close syntact express type observ type rule figur 1 introduct rule eras meta variabl typecheck argument term allow object level variabl runtim alway substitut close object express produc close object express end name necess 7 unfortun type close syntact express dispos cant ever type bodi objectlevel abstract isol binder subterm close term necessarili close thu would imposs ever inspect destruct recurs objectlevel express bind structur solut extend notion object level includ close syntact express also express free variabl need long recogn metaprogram commun section 5 discuss sever dierent metaprogram system solut problem techniqu predominantli use solut goe back davi calculu davi 1996 type constructor calculu correspond discret tempor logic modal proposit true subsequ time mo ment metaprogram setup modal type stand open object express type free variabl object express model metavari subsequ time moment bound somewher outsid express calculu adopt dierent approach seem purpos higherord syntax one equat bound metavari free variabl object express imagin recurs two syntax tree bind structur compar syntact equal modulo convers whenev abstract encount express need introduc new entiti stand bound variabl abstract recurs proceed compar bodi abstract introduc new entiti stand bound variabl must chang type surround term word free variabl object express introduc comput type introduct form like abstract case languag base thu start calculu introduc separ semant categori name motiv pitt gabbay 2000 gabbay pitt 2002 also oderski 1994 object meta stage separ modal object term use name encod abstract syntax tree variabl name appear object term appar type addit type system must instrument keep track occurr name name prevent slip scope introduct form inform term depend certain name name appear metalevel part term set name term depend call support term situat analog polynomi algebra one given base structur set indetermin gener freeli adjoin structur polynomi setup indetermin name build polynomi base structur express exampl assum moment x name type int usual oper addit multipl exponenti integ 8 nanevski f pfen primit term would type int support set x name x appear e 1 meta level inde notic order evalu e 1 integ first need provid definit x hand box term e 1 obtain type xy int support empti set name x appear object level ie box thu support term case e 1 becom part type term box way type maintain inform support subterm stage exampl assum languag pair term would type int int support x also interest compil evalu syntact entiti empti support ie close thu need mechan elimin name given express support eventu turn nonexecut express execut one purpos use explicit substitut explicit substitut provid definit name appear metalevel certain express note emphasi metalevel explicit substitut substitut box name appear object level term contribut term support way explicit substitut provid extens ie definit name still allow name box use intension inform ident util relat develop describ nanevski 2002 next present syntax calculu discuss constructor name x n type b 1 2 1 2 ca substitut x e erm e c x x u xa e e 1 e 2 x e choos e alu variabl context xa express variabl context uac name context x calculu make distinct meta object level interpret level compil code level sourc code abstract syntax express respect two level separ modal type constructor except whole famili modal type name necess 9 constructor one finit set name c sens valu type ca abstract syntax tree calculu freeli gener set name c refer finit set c support set syntax tree name drawn countabl infinit univers name n distinct level forc split variabl context context metalevel variabl also call valu variabl context objectlevel variabl also call syntact express variabl express variabl context must keep track type given variabl also support set set term includ syntax calculu section 2 ever two import distinct first explicitli refer name level term second requir refer express variabl certain term make alway prefix explicit substitut exampl u express variabl bound let box u appear e 2 prefix explicit substitut dierent occurr u dierent substitut associ explicit substitut suppos provid definit name express bound u refer variabl u prefix empti substitut instead u simpli write u explicit substitut use calculu simultan substitut assum syntact present substitut never defin denot name twice exampl 1 assum x name type int code segment creat polynomi x evalu point 2 val term xa e choos e introduct elimin form type constructor b term x e bind name x type subsequ use e term choos pick fresh name type substitut name bound argument abstract type b proce evalu bodi abstract prevent bound name x e escap scope definit thu creat observ eect type system must enforc disciplin use x e occurr x certain posit e allow type system establish occurr x encount evalu possibl aris two way x eventu substitut away explicit substitut nanevski f pfen x appear comput irrelev ie deadcod part term needless say decid question practic languag imposs type system provid conserv approxim use fairli simpl analysi base propag name encount typecheck final enlarg appropri context new variabl name subject usual variabl convent new variabl name assum distinct renam order clash alreadi exist one term dier syntact represent bound variabl name consid equal bind form languag xa e let box x e usual captureavoid substitut e 1 xe 2 express e 1 variabl x express e 2 defin renam bound variabl name descend scope given term e denot fve fne set free variabl e set name appear e metalevel addit overload function fn given type support set c fnac set name appear c exampl 2 illustr new constructor present version stage exponenti function write calculu exampl resort concret syntax ml fashion assum presenc base type integ recurs function letdefinit choos x int let fun exp els let box let box box xint x x v end val function exp take integ n gener fresh name x integ type call helper function exp build express z type int support x final turn express v function explicitli substitut name x v newli introduc bound variabl x name necess 11 notic gener residu code sq contain unnecessari redex contrast version program section 2 32 explicit substitut section formal introduc concept explicit substitut name defin relat oper alreadi outlin substitut serv provid definit name thu eectiv remov substitut name support term appear term empti support compil evalu domain rang explicit substitut function set name set term given substitut domain dom set name substitut fix word rang substitut imag dom purpos work consid substitut finit domain substitut finit domain finitari syntact represent set order pair x e relat name x dom substitut express e opposit also hold finit function set order pair name express determin uniqu substitut frequent equat substitut set repres result ambigu customari denot fv set free variabl term rang set name appear either dom rang denot fn substitut uniqu extend function arbitrari term follow way given substitut term e oper e appli meta level e defin recurs structur e given substitut nanevski f pfen applic captureavoid xa let box choos choos e import aspect definit substitut applic recurs descend box properti utmost import sound calculu preserv distinct meta object level also justifi explicit substitut intend remov name support term name appear box contribut support oper substitut applic depend upon oper substitut composit defin next definit 3 composit substitut given two substitut 1 2 finit domain composit 1 2 substitut defin composit two substitut finit domain welldefin result map name term finit inde everi name x finit syntact represent composit easili comput set occasion benefici repres set disjoint union two smaller set 1 defin import notic though definit substitut applic substitut composit mutual recurs oper ter minat substitut applic defin induct structur argument size term oper alway decreas compos substitut finit domain also termin 1 2 requir appli 1 defin term 2 name necess 13 33 type system type system calculu consist two mutual recurs judgment hypothet work three context context name context express variabl context valu variabl syntact structur three context given section 31 first judgment type judgment express given express e check whether e type gener support set c second judgment type explicit substitut given substitut two support set c substitut type c map express support c express support intuit prove section 34 context deserv word type calculu depend name type name depend name well must impos condit wellformed context henceforth variabl context wellform rel declar name appear type name context wellform everi type use name declar left often abus notat defin set obtain remov name x context obvious wellform context type may depend x alway transform wellform context use thu alway take care also implicitli assum context judgment wellform hold type support set use rule type rule present figur 3 pervas characterist type system support weaken name term set express type freeli gener support set c certainli among express freeli gener support set c make properti admiss judgment type system prove lemma section 34 explicit substitut substitut empti syntact represent ident substitut ident substitut appli term contain name c result term obvious contain name c support result term extend support weaken superset discuss bake properti side condit c ident substitut rule implicitli requir set wellform contain name alreadi declar name context rule nonempti substitut recurs check compon term well type given context support worth notic howev substitut given type c domain support set c complet unrel set dom word sub 14 nanevski f pfen explicit substitut hypothesi calculu modal name fig 3 type rule calculu stitut provid definit name fewer name type judgment actual express exampl substitut domain dom x given among other type well x z z inde map term anoth term support term support x term support term support x z term support z hypothesi rule three kind variabl context three hypothesi rule first rule name name x use provid declar account suppli support set implicit assumpt support set c wellform c dom rule valu variabl straightforward type xa infer xa declar actual support term support set c long wellform implicitli assum express variabl occur term alway prefix explicit substitut rule express variabl check express variabl declar context correspond substitut appropri type name necess 15 calculu fragment rule abstract quit standard implicit assumpt argument type wellform name context introduc variabl context applic rule check function applic argument support set modal fragment calculu mean rule introduct ensur box express e repres abstract syntax tree check e given type context without valu variabl support e match suppli index constructor hand support whole express box e empti express obvious contain name meta level thu support arbitrarili weaken wellform support set elimin rule also straightforward extens correspond rule dierenc bound express variabl u context store support annot name fragment introduct form name x e correspond type b introduc irrelev name x comput determin e assum type wellform rel context term constructor choos elimin form b pick fresh name substitut bound name abstract word oper semant redex choos x e formal section proce evalu e runtim context fresh name pick x justifi x bound convent renam fresh name irrelev x exampl mean x never encount evalu e comput signific posit thu 1 necessari specifi runtim behavior 2 never escap scope introduc observ way sidecondit introduct serv exactli enforc irrelev eectiv limit x appear deadcod subterm e subterm eventu remov explicit substitut exampl consid follow term xint yint box let box end contain substitut occurr x deadcod occurr therefor welltyp type int int int one may wonder use entiti like name suppos appear comput insignific posit comput fact howev name insignific import lie ident exampl relat develop intension analysi syntax nanevski 2002 compar name equal someth done nanevski f pfen ordinari variabl ordinari variabl placehold val ue compar variabl equal valu variabl stand sens say abstract parametr abstract deliber design name appear irrelev forc certain disciplin upon usag particular leav local scope name x determin introduc close result express depend significantli x closur achiev turn express abstract mean explicit substitut otherwis introduct new name observ eect paraphras leav scope x turn polynomi depend x function illustr techniqu program alreadi present exampl 2 previou version work nanevski 2002 use constructor choos rather combin singl constructor new also case pitt gabbay 2000 decomposit given equat new x choos x e decid reformul order make type languag follow close intend mean term thu provid stronger logic foundat calculu 34 structur properti section explor basic theoret properti type system lemma develop use justifi oper semant ascrib calculu section 35 ultim lead proof type preserv theorem 12 progress theorem 13 lemma 4 structur properti context 1 weaken let 2 contract variabl xa b xa c uad vad uad proof straightforward induct structur type deriv name necess 17 contract name hold inde identifi two dierent name term may make term syntact illform typic exampl explicit substitut oneon correspond syntact represent identifi two name may make syntact represent assign two dierent imag name would break correspond substitut next seri lemma establish admiss support weaken discuss section 33 lemma 5 support weaken support weaken covari righthand side contravari lefthand side judgment formal let c c dom dom wellform support set follow hold 1 2 3 uad 4 proof first two statement prove straightforward simultan induct given deriv third fourth part prove induct structur respect deriv lemma 6 support extens let dom wellform support set follow hold 1 uac 1 2 proof induct structur deriv lemma 7 substitut merg dom proof induct structur follow lemma show intuit behind type judgment explicit substitut explain section 33 inde valid lemma 8 explicit substitut principl follow hold 1 2 proof nanevski f pfen simultan induct structur deriv present proof second statement given substitut split represent two disjoint set set show two type impli result substitut merg lemma lemma 7 establish observ type clear 1 dom definit dom fix thu either x appear syntact represent syntact represent contain sequenc map second case x substitut term xn thu first case x c induct appeal type rule substitut empti substitut reach either way c 1 dom c furthermor c 1 dom c dom result follow support weaken lemma 54 establish b observ x dom x c first induct hypothesi x type b obtain induct appli type rule substitut x c 1 dom follow lemma establish hypothet natur two type judgment respect ordinari valu variabl lemma 9 valu substitut principl c follow hold 1 xa e 2 proof simultan induct two deriv situat simpl express variabl simpl substitut express express variabl result syntact wellform term reason discuss occurr express variabl alway prefix explicit substitut form kind closur explicit substitut calculu occur part closur freeli appli arbitrari term 1 henc substitut express e express variabl u produc syntact valid term need follow 1 albeit extens seem particularli hard omit simplic name necess 19 applic e explicit name substitut pair u oper also give us control extension also intension form box express definit gener captureavoid substitut express variabl order handl problem substitut express variabl captureavoid substitut e express variabl u defin recurs follow choos e note first claus u definit result express obtain carri explicit substitut lemma 11 express substitut principl let e 1 express without free valu variabl e follow hold 1 uac e 2 proof simultan induct two deriv present one case proof first statement case 1 deriv 2 second induct hypothesi e 3 explicit substitut lemma 81 e 1 4 exactli equal 35 oper semant defin smallstep callbyvalu oper semant calculu judgment e e nanevski f pfen e1 e2 e2 e 2 v1 e2 xa e v vxe let box let box e e choos e choos e choos xa e xa e fig 4 structur oper semant calculu relat express e onestep reduct e relat defin express free variabl express contain free name must empti support word consid evalu term whose name appear exclus object level comput irrelev posit remov explicit substitut free name allow oper semant account keep track runtim name context rule judgment given figur 4 valu languag gener grammar alu v c xa e box e x e rule standard import observ redex type constructor extend runtim context fresh name proceed extens need sound purpos freshli introduc name may appear comput insignific posit reduct must keep name type runtim context evalu relat sound respect type never get stuck follow theorem establish theorem 12 type preserv extend e proof straightforward induct structur e use substitut principl theorem 13 progress 1 e valu 2 exist term e context e e proof name necess 21 straightforward induct structur e progress theorem indic reduct e context uniqu given e fact fresh name may introduc cours comput two dierent evalu one term may choos fresh name dierent determinaci theorem show choic fresh name account dierenc two reduct term customari denot n nstep reduct relat theorem 14 determinaci e exist permut name fix dom proof induct length reduct use properti e n e permut name e n e interest case choos x e case must fresh obvious involut two name requir properti frequent necessari write program polymorph support syntact objectlevel argument intend manipul abstract syntax tree whose support known compil time typic exampl would function recurs syntax tree bind structur encount abstract place fresh name instead bound variabl recurs continu scan bodi abstract syntact express depend newli introduc name 2 use extend calculu notion explicit support polymorph style girard reynold girard 1986 reynold 1983 addit support polymorph simpl calculu start syntact chang summar support variabl p q set c pn type p erm e p e e c name context p alu v p e 2 calculu describ support scenario full gener yet lack type polymorph typepolymorph recurs support polymorph necessari step direct 22 nanevski f pfen introduc new syntact categori support variabl intend stand unknown support set addit support set allow contain support variabl express situat portion support set unknown consequ function fn must updat return set name support variabl appear argument languag type extend type p express univers support quantif introduct form p e abstract unknown support set p express e abstract also valu extend oper semant correspond elimin form applic e c whose mean instanti unknown support set abstract e provid support set c type depend name well support variabl name context must declar assum convent wellformed name context type judgment instrument new rule type support polymorph abstract applic introduct rule requir bound variabl p escap scope constructor bind particular must p c convent also assum implicitli p ad rule elimin substitut argument support set type assum wellform rel context dom oper semant new construct also surpris e e extend languag satisfi follow substitut principl lemma 15 support substitut principl oper substitut p follow hold 1 2 proof simultan induct two deriv present one case proof second statement case 1 deriv 2 first induct hypothesi 3 second induct hypothesi 4 c 1 x c 1 x support weaken lemma 54 name necess 23 5 result follow 2 4 type rule nonempti substitut structur properti present section 34 readili extend new languag support polymorph true type preserv theorem 12 progress theorem 13 whose addit case involv support abstract applic handl use lemma 15 exampl 3 supportpolymorph calculu slightli gener program exampl 2 pull helper function exp parametr exponenti express follow program use p function definit concret syntax abstract support variabl p els let box choos x int let box box xint x x w end val exampl 4 exampl realist program present regular express matcher davi pfen 2001 davi 1996 exampl assum declar datatyp regular express datatyp empti plu regexp regexp time regexp regexp star regexp const char nanevski f pfen val acc1 regexp char list bool char list bool acc1 plu e1 acc1 time e1 acc1 e1 acc1 e2 k acc1 star e k els acc1 star e k acc1 const c k case nil fals xl val accept1 regexp char list bool fig 5 unstag regular express matcher also assum primit predic null char list bool test input string empti figur 5 present ordinari ml implement matcher version found davi pfen 2001 davi 1996 would like use calculu stage program figur 5 special respect given regular express purpos use view helper function acc call acc1 figur 5 code gener take regular express e emit code pars accord e end append k gener code main idea behind program figur 6 simplic use name input string pars code acc gener also want allow continu code k contain name stand yet unbound variabl henc supportpolymorph type acc regexp p sp bool sp bool support polymorph pay gener code altern pluse 1 e 2 iter stare inde observ altern case gener code duplic continu k rather k emit separ function join point comput branch correspond e 1 e 2 similarli case iter set loop output code would attempt zero match e support polymorph acc enabl us produc code chunk without know exact ident abovement join loop point part output code gener stitch togeth mean explicit substitut name necess 25 val accept regexp char list bool choos list sp bool let fun acc empti p acc plu e1 e2 p choos list bool let box acc e1 join boxjoin acc e2 join boxjoin boxlet fun join orels end acc time e1 e2 p acc e1 acc e2 acc star e p choos list choos list bool let box acc e loop els loop boxlet fun loop orels loop end acc const c p let box boxcas xx nil fals box schar list sscode fig 6 regular express matcher stage calculu point may illustr trace execut program concret input figur 7 present function call intermedi result occur stage matcher appli regular express starempti note result special program contain variabl forvari redex perform unnecessari boolean test possibl improv match algorithm avoid emit extran code improv involv examin preprocess input regular express thorough descript beyond scope paper refer harper 1999 insight analysi 5 relat work work present paper lie intersect sever relat ar ea stage comput partial evalu runtim code gener meta program modal logic higherord abstract syntax earli refer stage comput ershov 1977 introduc 26 nanevski f pfen els loop null orels loop end box let fun loop null orels loop end fig 7 exampl execut trace regular express matcher function call mark correspond return result mark align stage comput name gener extens gener extens purpos partial evalu also foreseen futamura 1971 concept later explor eventu expand multilevel gener extens jone et al 1985 gluck jrgensen 1995 gluck jrgensen 1997 work done untyp set type calculu provid direct motiv foundat system calculu evolv type theoret explan stage comput davi pfen 2001 wicklin et al 1998a runtim codegener lee leon 1996 wicklin et al 1998b describ section 2 anoth import type calculu metaprogram formul davi 1996 proofterm calculu discret tempor logic provid notion open object express free variabl object express repres meta variabl subsequ tempor level origin motiv develop type system bindingtim analysi setup partial evalu quickli adopt metaprogram develop metaml moggi et al 1999 taha 1999 taha 2000 metaml adopt open code type constructor gener languag sever featur import one addit type refin close code valu classifi close code type open code express happen depend free meta variabl might interest point certain relationship concept name phenomenon occur extens metaml refer calcagno et al 2000 calcagno et al 2001 refer metaml name necess 27 must assign open code express inde case eventu free variabl express may escap scope binder introduc technic reason howev actual prohibit author resort hygien handl scope extrus annot term list free variabl allow contain deadcod posit deadcod annot type constructor metaml deadcod variabl belong syntact categori ordinari variabl nevertheless much compar name abstract anoth interest calculu metaprogram nielsen describ nielsen 2001 base idea calculu instead defin notion close code refin open code metaml relax notion close code use name stand free variabl object express use variabl introduc box thu becom bind construct variabl bound box treatment bound variabl typeconstructor updat reflect type name variabl correspond box bind properti make unclear extend concept correspond support polymorph nielsen taha present anoth system combin close open code nielsen taha 2003 base explicitli name object stage comput notion environ classifi stage explicitli name stage revisit multipl time variabl declar previou visit reus featur provid function open code environ classifi relat support variabl sever respect bound univers quantifi abstract set inde support polymorph explicitli abstract set name environ classifi use name part variabl context thu implicitli abstract set variabl come direct higherord abstract syntax probabl first work point import nonparametr binder like abstract miller 1990 connect higherord abstract syntax modal logic recogn despeyroux pfen schurmann system present despeyroux et al 1997 later simplifi twolevel system schurmann dissert schurmann 2000 also hofmann discuss variou presheaf model higherord abstract syntax fior et al 1999 explor untyp abstract syntax categor setup extens arbitrari type fior 2002 howev work explicitli motiv develop seri paper nomin logic freshml gabbay pitt 2002 pitt gabbay 2000 pitt 2001 gabbay 2000 name nomin logic introduc urel fraenkelmostowski set theori freshml languag manipul object syntax bind structur base model primit notion swap two name use defin oper name abstract produc equival class respect abstract name name concret provid specif repres equival class earlier version paper nanevski 2002 contain 28 nanevski f pfen two oper almost orthogon add name abstract use encod abstract syntax tree depend name whose ident known unlik calculu freshml keep track support term rather complement freshml introduc name comput construct new x e roughli interpret calculu new x choos x e except deadcod posit name x appear e scope abstract hide x one main dierenc freshml name freshml runtim valu possibl freshml evalu term nonempti support hand name arbitrari type freshml name must singl type atm though gener arbitrari famili type disjoint type valu languag calculu allow gener type name thank modal distinct meta object level exampl without modal name arbitrari type function defin integ alway perform runtim check test argument valid integ case function appli argument name case evalu suspend whole express becom syntact entiti ad bonu support explicit name substitut primit substitut must userdefin freshml logic side direct motiv paper come pfen davi 2001 present natur deduct formul proposit s4 gener interact modal syntax name interest logician quit time exampl logic encod syntax topic godel incomplet theorem refer direct montagu 1963 smorynski 1985 viewpoint attardi context mccarthi 1993 similar notion support use express relativ truth final name resembl nonrigid design fit mendelsohn 1999 name kripk 1980 virtual individu scott 1970 also touch issu exist ident explor scott 1979 classic work seem indic metaprogram higherord syntax concret instanc much broader abstract phenomenon hope draw cite work futur develop 6 conclus futur work paper present calculu type function languag meta program employ novel way defin modal type syntact object program free variabl system combin calculu pfen davi 2001 notion name inspir develop freshml nomin logic pitt gabbay 2000 gabbay pitt 2002 pitt 2001 gabbay 2000 motiv combin name come longrecogn name necess 29 need metaprogram handl object program free variabl davi 1996 taha 1999 moggi et al 1999 setup calculu provid way encod close syntact code express name serv stand eventu free variabl taken togeth provid way encod open syntact program express also compos evalu inspect destruct name oper thought locat track type system name escap scope introduct form set name appear meta level term call support term support term reflect type term term evalu support empti also consid construct support polymorph calculu reformul calculu present nanevski 2002 adopt chang involv simplif oper semant construct handl name furthermor decompos name introduct form new two constructor choos introduct elimin form new type constructor b design choic give stronger logic foundat calculu level type follow much close behavior term languag hope investig logic properti immedi futur work direct would includ embed discretetim tempor logic monoton discret tempor logic logic type also consid proofirrelev modal pfen 2001 awodey bauer 2001 classifi term unknown support anoth import direct explor concern implement calculu present paper develop particular semant interpret mind object level express abstract syntax tree repres templat sourc program need interpret quit possibl box express calculu support polymorph store runtim intermedi even compil form might benefit ecienc program remain import futur work explor implement issu acknowledg would like thank dana scott bob harper peter lee andrew pitt help comment earlier version paper robert gluck point miss refer r formal viewpoint proposit close type simpl approach safe imper multistag program close type safe imper metaml tempor logic approach bindingtim analysi modal analysi stage comput journal acm primit recurs higherord abstract syntax partial comput principl semant analysi normal evalu type lambda calculu abstract syntax variabl bind partial evalu comput process approach compilercompil new approach abstract syntax variabl bind system f variabl type automat program gener multilevel special automat di semant analysi higherord abstract syntax experi partial evalu gener compil gener name necess optim ml runtim code gener page 137148 confer program languag design implement extens ml handl bound variabl data structur page 323335 proceedingsproceed first esprit bra workshop logic framework syntact treatment modal combin close open code function theori local name judgment reconstruct modal logic mathemat structur comput scienc nomin logic first order theori name bind page 219242 kobayashi metalanguag program bound name modulo renam transluc procedur advic modal logic exist intuitionist logic accomplish research challeng metaprogram page 244 sound reduct semant untyp cbn multistag compu tation tr function theori local name modal analysi stage comput runtim code gener modalml modal type stage specif runtim code gener firstord modal logic sound reduct semant untyp cbn mutlistag comput theori metaml nontriv extend abstract stochast lambda calculu monad probabl distribut accomplish research challeng metaprogram nomin logic primit recurs higherord abstract syntax metalanguag program bound name modulo renam ideal metaml temporallog approach bindingtim analysi transluc procedur abstract without opac multistag program ctr marco viera alberto pardo multistag languag intension analysi proceed 5th intern confer gener program compon engin octob 2226 2006 portland oregon usa chiyan chen hongwei xi implement type program transform acm sigplan notic v38 n10 p2028 octob kevin donnelli hongwei xi combin higherord abstract syntax firstord abstract syntax at proceed 3rd acm sigplan workshop mechan reason languag variabl bind p5863 septemb 3030 2005 tallinn estonia iksoon kim kwangkeun yi cristiano calcagno polymorph modal type system lisplik multistag languag acm sigplan notic v41 n1 p257268 januari 2006 geoffrey washburn stephani weirich box go banana encod higherord abstract syntax parametr polymorph acm sigplan notic v38 n9 p249262 septemb chiyan chen rui shi hongwei xi implement type program transform fundamenta informatica v69 n12 p103121 januari 2006 yosihiro yuse atsushi igarashi modal type system multilevel gener extens persist code proceed 8th acm sigplan symposium principl practic declar program juli 1012 2006 venic itali mark r shinwel andrew pitt murdoch j gabbay freshml program binder made simpl acm sigplan notic v38 n9 p263274 septemb chiyan chen hongwei xi metaprogram type code represent acm sigplan notic v38 n9 p275286 septemb derek dreyer type system wellfound recurs acm sigplan notic v39 n1 p293305 januari 2004 chiyan chen hongwei xi metaprogram type code represent journal function program v15 n6 p797835 novemb 2005 aleksandar nanevski frank pfen stage comput name necess journal function program v15 n6 p893939 novemb 2005 walid taha michael florentin nielsen environ classifi acm sigplan notic v38 n1 p2637 januari