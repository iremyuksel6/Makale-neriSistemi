product help bit decis tree investig two problem concern complex evalu function f k distinct input k parallel decisiontre algorithmsin product problem fix depth bound seek maxim fraction input ktupl k decis tree correct assum singl input f best depthd decis tree correct fraction p input prove maximum fraction ktupl k depthd algorithm correct pk trivial lower bound show replac restrict depth expect depth result need holdin helpbit problem decisiontre comput begin k1 arbitrari binari question helpbit queri ask ktupl input second stage possibl k1tupl answer helpbit queri ktupl decis tree ith tree suppos correctli comput valu function ith input input consist help bit complex maximum depth tree algorithm show k suffici larg complex equal degsf minimum degre multivari polynomi whose sign equal f b introduct pick favorit comput model complex measur eg boolean circuit size commun complex decis tree depth interact proof length tensor rank etc attempt understand model complex measur requir understand way unreason comput effici reason one cours reason chang understand model improv suppos given sever unrel instanc problem solv reason approach solv instanc separ intuit comput use solv one instanc irrelev other extent intuit valid given model follow question common way formal directsum problem suppos complex comput function f c true comput f twice two unrel input requir complex 2c comput f k unrel input question first studi context boolean circuit ulig paul gf subsequ work concern bilinear circuit j bsh boolean circuit fkn commun complex krw paper consid two relat problem similar flavor product problem let f function suppos complex c comput fraction input correctli comput f p suppos two independ comput take input order pair b input f first comput tri comput f second tri comput f b two comput complex c fraction input pair b correct exceed analog question k independ comput k input first comput use input second use input b p 2 upper bound trivial intuit suggest advantag comput access other input variant problem seek comput f two input singl comput studi recent irw helpbit problem suppos complex comput boolean function f c suppos one wish comput f two input b allow free one helpbit ie arbitrari function two input possibl choos helpbit function given helpbit f f b comput comput complex less c much comput f k input helpbit problem introduc knowl edg context constant depth circuit cai also studi context boolean circuit abg point k input k help bit use obtain valu f input comput necessari instanc obtain valu f still need complex c comput f last input effect use help bit paper consid problem context boolean decis tree complex perhap simplest comput model cost comput decis tree simpli number input variabl read depth decis tree precis definit given section 2 easi exercis see directsum hold decis tree depth two problem difficult answer product problem qualifi ye theorem 1 let f nvariabl boolean function suppos depth decis tree comput f correctli fraction p input let decis tree access set nk variabl correspond ktupl 1 2 k input f depth fraction ktupl 1 2 k correctli output f p k theorem seem complet obviou howev reader might test intuit follow variat suppos theorem chang complex measur depth av erag depth ie averag input depth leaf reach input modifi statement theorem seem similarli obvi ou see fals recent work irw done independ includ substanti differ proof weaker variant theorem name singl depth tree tri comput k function correct p k fraction input result show even use k parallel decis tree cant better help bit problem answer com plicat nathan linial lin shown complex comput f two input one help bit least degf degre uniqu multilinear real polynomi equal f sinc almost boolean function nvariabl degf say help bit dont help function result seem extend k 3 fact suffici larg k result impli fals manag prove lower bound hold k alway tight k number instanc solv suffici larg need follow definit f nvariat boolean function say nvariat real polynomi p signrepres f input take boolean set fgamma1 1g signdegre f deg f minimum degre polynomi sign repres f theorem 2 let f nvariat boolean function suppos optim decis tree comput f depth k 1 solut help bit problem f k input help bit requir depth least deg f furthermor suffici larg k decis tree algorithm bit whose depth deg f case f equal product n variabl correspond pariti function f0 1gvalu variabl deg f lower bound impli helpbit dont help case actual function neg function deg f ordinari decis tree complex boolean function n mean larg enough k complex k instanc given bit less ordinari decis tree complex func tion particular f major function deg f lower bound vacuou upper bound say k suffici larg possibl ask question given answer valu function one k input comput probe one vari abl remark save typic recent shown rr almost function satisfi next section review decis tree model section 3 give gener formul product problem decis tree prove gener theorem 31 theorem 1 section 4 discuss help bit problem prove theorem 2 proof appendic techniqu develop appli decis tree model may appli model well fact suffic obtain mani known result boolean circuit model sketch applic last section preliminari section present basic definit notat notion discuss familiar case notat nonstandard 21 boolean function purpos paper conveni use boolean domain instead f0 1g x set boolean assign x map ff x b set boolean assign x denot b x refer element x variabl consid probabl distribut set assign specifi distribut random assign chosen accord denot place identifi eg ff boolean function variabl set x rang r xrfunction function b x r paper rang r alway equal b k integ k 22 decis tree tree paper root order binari tree tree everi intern node v exactli two children two children distinguish 1child 1child v depth dt v node v usual number edg along path v root depth dt maximum depth node formal decis tree variabl set x rang r xrdecis tree tripl root binari tree p map associ intern node v variabl set x map associ leaf v element v r label p v call queri associ v node v said probe variabl gener say xrdecis tree keep map p implicit set x rdecis tree x denot x r simpli let xrdecis tree ff assign b x comput ff uniqu path root leaf start root v 0 induct defin defin v ffp v child v output comput label l ff thu view boolean function x rang r trivial everi xrfunction f comput xrdecis tree usual cost function comput perform ff length number intern node comput path denot ct ff worst case complex ct maximum ff ct ff cf decis tree depth f minimum ct decis tree comput f distribut assign distribut complex cd averag ct ff respect distribut given x r function f complex bound b respect complex measur interest well f approxim tree complex b close approxim defin respect probabl distribut boolean assign x thu xrdecis tree agreement probabl q f f rel probabl respect random assign ff chosen accord decis tree approxim problem f du f x rfunction distribut boolean assign x u set decis tree determin q f u defin maximum agreement probabl q f particular interest case u set x r decis tree depth final decis forest f x rang order sequenc xr decis tree f comput boolean function b x r theta r k 3 product problem disjoint set vari abl let respect distribut assign assign fi x view ktupl assign x let denot distribut assign x given probd product distribut theta k suppos k decis tree approxim problem optim agreement probabl u f rel conveni sometim view f function entir variabl set x ignor variabl except consid problem simultan approxim decis forest simultan agreement probabl q f denot prob abil ff chosen accord 1 famili x r tree q f denot maximum q f choic tree sinc f depend x choos assign ff k depend would seem q f product probabl q clearli case tree queri variabl x howev shown exampl allow queri variabl outsid x need case intuit would seem variabl outsid x could help approxim f inde trivial true tri approxim f seek approxim function simultan longer obviou crossqueri irrelev nevertheless one might expect reason abl class u decis tree optim simultan agreement probabl attain sequenc tree queri variabl x thu equal product individu optim agreement probabl main result section prove case u set tree fix depth theorem 31 let 1 2 k nonneg integ note theorem 1 special case give proof present two exampl show multipl fail natur altern choic class u exampl 31 theorem 31 fail replac class class tree restrict queri variabl x along path queri variabl outsid x free consid follow trivial exampl let g distribut 1 assign x 1 1 probabl 12 2 assign x 2 1 probabl 12 function f 1 f 2 given mean allow 1 look variabl x 1 allow 2 look variabl ever achiev simultan agreement probabl better 14 let 1 tree queri x 2 output x 2 2 tree queri x 1 output x 1 probabl 1 f 1 agre 2 f 2 agre probabl assign valu 12 somewhat subtl exampl given exampl 32 distribut b x let class tree whose expect depth respect ie 2 averag number variabl queri respect ff chosen theorem fals replac see let x set four vari abl f pariti function x let u uniform distribut assign x 3 first show maximum agreement probabl f attain decis tree expect depth 3 equal 34 agreement probabl 34 attain tree queri particular variabl x 0 return 0 otherwis queri remain three variabl return pariti see best possibl note decis tree al gorithm leaf l depth less 4 agre f exactli half input reach l thu p probabl random input ff end leaf depth agreement probabl q f bound suffic show p 4 12 1 expect depth tree least 4p 4 mean let copi f u disjoint variabl set show possibl choos decis tree expect depth 3 whose agreement probabl exce describ let x 1 denot variabl x 1 probe first 1 let 2 follow tree first probe x 1 0 output 0 one read four variabl x 2 output pariti expect depth tree 3 sinc half path depth one half path depth five let us consid probabl event 1 1 condit probabl given x 14 x must agre f 1 2 must agre f 2 thu probabl simultan agreement happen exampl variabl x 1 act share random coin partial coordin two comput like simultan correct proof theorem 31 fix sequenc decis tree depth denot event event tree index evalu respect function cor rectli seek prove probck bound proof induct k fix k induct ktupl 1 result vacuou assum k 2 consid first case may assum k th parti must guess valu f k ff k without look variabl k consist singl leaf label 1 1 condit valu vector ff k probabl p ck hold written let fl assign ff k maxim probabl last express defin tree u contract use ff fl may rewrit last term probu 1 f tree u depth may bound first factor induct hypothesi equal desir result follow assum 0 defin direct graph f1 2 kg edg first variabl probe input f j sinc direct graph outdegre one direct cycl let j 1 length cycl let us renam set indic cycl set way first probe variabl denot x i1 first probe j variabl denot intuit behind rest proof possibl replac tree tree depth first probe decreas probabl simultan agreement denot function obtain f fix x distribut set obtain condit x event ff 1 write probabl comput correctli condit b follow seek upper bound express show claim b 2 b j condit probabl ck given ab assum claim moment substitut express 1 obtain follow bound probabl tree correct sum rewritten equal th term product correspond probabl correctli comput f first probe x depend outcom use optim depth tree evalu residu function thu upper bound term express 3 upper bound express 2 requir suffic prove claim defin f ab function f b f otherwis similarli distribut ab equal b otherwis observ mutual independ given ab product distribut ab 1 k let ab tree obtain contract assumpt ab hold condit probabl ab equal probabl respect product distribut ab depth ab j may appli induct say probabl respect product distribut ab ab f ab f ab equal express claim prove claim theorem remark proof theorem extend gener model decis tree comput model case singl function given function f arbitrari domain r want comput f unknown input given set q admiss queri queri q 2 q partit set q r respons queri q index 2 q node decis tree label queri branch node correspond answer queri collect function f disjoint domain formul product problem gener model statement proof theorem go assum 1 allow queri depend variabl one function 2 distribut independ 4 help bit help bit problem k boolean function disjoint variabl set given unknown assign ff variabl set evalu f ff decis forest allow ask free arbitrari set l binari question assign ff answer l question vector 2 b l decis forest f k requir f ff agre assign ff consist thu algorithm specifi l arbitrari boolean function h help bit variabl set x togeth 2 l decis forest complex algorithm maximum depth 2 l k decis tree forest gener decis tree comput f ff ff consist allow probe variabl outsid x conceiv use togeth help bit probe could impli inform variabl x instanc one help bit function f ff theta ff j x x variabl x j probe variabl x deduc probe variabl x say pure 2 l k decis tree pure algorithm pure paper restrict attent case variabl set x boolean function f x x copi x function f copi f help bit problem h kl f evalu k copi f given l help bit complex optim algorithm solv also defin problem pure f h kl f except requir algorithm pure defin c kl pure f complex optim pure algorithm goal obtain bound c kl f c kl pure f main result section slight refin theorem 2 theorem 41 boolean function f n variabl posit integ k pure f k suffici larg pure f first reformul problem h kl f pure f given function f decis forest f say f cover assign ff x respect f 1 minimum number forest consist tree depth need cover input respect f let k pure f correspond minimum restrict forest pure proposit 41 let f boolean function k l nonneg integ 1 c kl f k f 2 l 2 c kl pure f k pure f 2 l word dlog 2 k f de minimum l h kl solv tree depth pure f de minimum l h kl pure solv tree depth proof prove first assert proof second complet analog c kl f 2 l forest given algorithm also cover k f 2 l suppos k f 2 l collect 2 l forest cover assign x index forest f z z rang b l order forest lexicographi calli defin az set assign cover f z cover f z set partit set assign x defin help bit function h l ff uniqu index z ff 2 az function togeth solv h kl concentr obtain bound k pure f need yet anoth definit random xrdecis tree algorithm probabl distribut q xr decis tree algorithm said approxim f probabl p assign ff random decis tree chosen accord q probabl fff least p defin pf maximum p distribut q set decis tree depth approxim f probabl p easi see pf 12 ordinari decis tree complex f pf 1 follow result relat f pf lemma 41 boolean function f n variabl k 0 havepf k f pure f nk k e proof middl inequ trivial last inequ use standard probabilist argument show famili k pfd e pure forest depth cover assign ment let q distribut rdecis tree depth approxim f probabl pf correspond distribut set x tree consid distribut theta q k forest suppos select forest accord p given assign ff j probabl cover ff least pf k thu probabl none forest cover ff 1 gamma pf probabl exist assign ff cover none forest 2 nk e express 1 posit probabl forest cover assign must collect forest depth cover assign turn lower bound f need follow relationship pf agreement probabl q f respect particular distribut assign lemma 42 rboolean function f integ 0 exist distribut assign q variant fundament observ yao y1 follow minmax theorem two person zero sum game distribut lemma suppos famili forest cover assign ff x consid distribut p assign ff product theta copi x theorem 31 forest f probabl cover ff pf k expect number assign cover tpf k sinc f 1 cover assign expect must least 1 1pf k immedi corollari lemma proposit 41 get follow bound complex help bit problem corollari 41 boolean function f n variabl integ k l 0 1 2 l 1pf k c kl f 2 2 l nkpfd k c kl pure f next need connect quantiti pf signdegre deg f proposit 42 boolean function f pf 12 proof let deg f nvariat polynomi degre gff 0 f ff 1 shift polynomi small constant may assum gff never 0 may assum without loss gener sum absolut valu coeffici g 1 consid follow random decis tree algorithm choos monomi g random probabl given monomi chosen absolut valu coeffici probe variabl monomi output product valu easili seen assign ff probabl correctli evalu f ff minu probabl incorrectli evalu fff equal jgffj 0 use domain fgamma1 1g thu ff algorithm correctli evalu f ff probabl exceed 12 suppos pf 12 must exist random decis tree algorithm q depth tree evalu f ff correctli probabl exceed 12 well known easi see induct look two subtre root decis tree depth variabl fx 1 xng polynomi degre gt assign ff defin polynomialgx 1 sum qt g gamma 12 sum tree depth qt probabl select distribut q 12 choic q latter term posit theorem 41 follow easili proof theorem 41 corollari 41 would follow 2 hold suffici larg k sinc pf deg f also corollari 41 show c pure deg f suffic show k follow immedi fact proposit 42 pf deg f remark 1 interest note k larg enough possibl construct obtain optim algorithm decis tree particularli simpl form random algorithm proof proposit 42 use decis tree correspond comput monomi g use random algorithm proof upper bound lemma 41 decis tree use help bit algorithm form remark 2 note introduct f major function deg f decis tree use optim algorithm h larg k depth 1 case f major function three variabl manuel blum gave follow construct protocol solv h enumer subset k size least 2k3 number set 2 ck c 1 fix encod set ck bit given k separ input majorityof3 function imagin input arrang k theta 3 array row least two three entri agre major valu column least 2k3 entri agre function valu col umn help bit ask lowest index column requir 2 bit set row column give function valu requir ck bit arm inform valu function row r equal entri row design column r 2 neg entri otherwis remark 3 proof lower bound lemma 41 use theorem 31 order deduc forest f depth probabl respect particular distribut p assign f correct k function pf k special case relev case prove c theorem 41 altern argument sketch argument benefit extend model besid decis tree seen next section note pf 12 thu ff select distribut lemma 42 decis tree depth agre f probabl exactli 12 particular shown impli fix valu variabl either partial assign occur probabl 0 valu f condit assign unbias defin random variabl c 0 want show probabl c fact distribut uniform f0 1g k xor lemma vaz see also cghfr distribut f0 1g k uniform subset j k random variabl c j defin xor c j probabl c j 0 event c event j equal f j combin decis tree ft ji 2 jg get singl decis tree depth jj jd comput j claim decis tree must agre f j probabl exactli 12 enough finish argument prove claim show leaf tree j reach nonzero probabl f j ff condit ff reach leaf unbias leaf tree variabl x appear path recal valu f unbias condit valu variabl condit valu f j valu variabl x f still unbias therefor f j remark 4 one implic theorem 41 larg enough k best algorithm h use pure tree reason specul case h kl f k l open case interest note case hard show pure tree algorithm better cf ordinari decis tree complex f see note help bit partit set assign two group 1 2 hard see either set assign x 1 induc 1 b x1 set assign induc 2 must b x2 first case given 1 pure tree comput f 1 hard problem without help bit second case given 2 pure tree comput f x 2 hard problem without help bit 5 model idea use far also relev model comput get result model similar neither precis strong obtain decis tree conveni describ result follow gener framework fix comput model comput function f input ff 2 x class fea feasibl algorithm result hold class certain closur properti class fea close kcount k algorithm fea algorithm run k algorithm input accept reject base number comput k accept also fea exampl class polynomi size circuit close polycount polylogbit commun complex protocol close polylogcount class defin multiinput algorithm feasibl algorithm comput function f pair input ff said rectangularlyfeas fea everi fix valu ff 1 induc algorithm f fea everi fix valu ff 2 induc algorithm f fea notic two exampl mention essenti model one may think fea ae fea thu exampl case polys circuit lower bound given twoinput algorithm appli polys circuit well 51 product product theorem set may proven use yao xorlemma y2 observ appli gener set let 1 2 distribut lemma 51 yao assum fea close kcount one deduc approxim product theorem theorem 51 assum fea close k count proof fix algorithm fea denot py probabl correct input pnn probabl incorrect py n probabl correct first input pni probabl correct second input sinc everi fix valu ff 1 probabl correct f 2 averag ff 1 similarli final yao xorlemma impli omegagamma10 inequ togeth fact p yy p n directli impli omegagamma1 prove lemma 52 help bit use approxim product theorem get helpbit result random algorithm given class feasibl algorithm fea say function randomli feasibl comput rfc exist probabl distribut algorithm fea input algorithm chosen distribut correct f probabl least 23 constant 23 import usual amplif lemma work gener case lemma 52 fea close kcount constant 23 replac 12 2 gammak without chang class rfc case fea class polynomi size circuit known random increas power thu rfc exactli equal function comput determinist poli size circuit case fea polylog bit commun protocol rfc function comput random polylogbit protocol twosid error let us defin feasibl comput helpbit let fea given class algorithm 1helpbitfeas algorithm fea 1 set two algorithm 0 1 fea boolean function h whose valu input ff output hff function rfc 1 fea 1 algorithm comput two copi f everi pair input correct probabl least 23 prove random help bit theorem theorem 52 fea close o1 count rfc proof assum f 62 rfc amplifi similarli lemma 42 exist distribut q f fea 051 use approxim product theorem fea algorithm two copi f correct 051 2 o1 fraction input distribut theta follow fea 1 algorithm correct probabl twice probabl smaller 23 probabl taken pair input chosen theta turn impli f 62 rfc 1 case boolean circuit proven abg 53 log k barrier approxim product theorem ran domiz helpbit theorem natur gener log k function famili fea close kcount techniqu break unknown exampl whether polynomi size circuit use n helpbit comput n1 copi function doesnt polynomi size circuit one show black box model altern rel particular oracl gener fals use log consid model polynomials circuit access blackbox theorem 53 blackbox exist boolean function f cant comput polynomials circuit famili helpbit allow polynomials circuit alway comput answer n disjoint copi f n input size f proof well know random f cant comput polynomials circuit fix f success circuit would take input output vector v blackbox way circuit without helpbit cant find circuit helpbit goe directli let n size x choos n input tupl output v follow let random lnbit string place v locat index place sorri locat standard count argument one show polynomi size circuit famili access black box answer correctli ntupl input howev given l helpbit easi queri oracl locat reveal answer tupl interest note yao xor lemma fail rel blackbox sens xor ln variabl pariti stop get harder comput word xor lemma log n barrier acknowledg author mani convers sever peopl regard search would especi like acknowledg contribut richard beigel nati linial russel impagliazzo avi wigderson r connect bound queri class nonuniform complex extend direct sum conjectur lower bound constant depth circuit presenc help bit bit extract problem tresili function amort commun complex complex 2output boolean network advanc comput complex theori fraction cover commun com plexiti prove superlogarithm depth lower bound via direct sum commun complex direct product theorem round commun complex revisit realiz boolean function disjoint set variabl synthesi selfcorrect scheme function element small number reliabl compon theori applic trapdoor function probabilist comput toward unifi measur complex tr ctr ronen shaltiel toward prove strong direct product theorem comput complex v12 n12 p122 juli 2004 paul beam toniann pitassi nathan segerlind avi wigderson strong direct product theorem corrupt multiparti commun complex disjoint comput complex v15 n4 p391432 decemb 2006 anna gl peter bro miltersen cell probe complex succinct data structur theoret comput scienc v379 n3 p405417 june 2007