portabl perform data parallel languag portabl program execut differ platform yield consist perform focu portabl paper present indepth studi perform three na benchmark ep mg ft compil three commerci hpf compil apr pgi ibm ibm sp2 benchmark evalu two version use loop use f90 construct andor hpf foral statement baselin comparison provid version benchmark written fortranmpi zpl data parallel languag develop univers washingtonwhil f90foral program achiev scalabl perform compil result indic consider portabl problem hpf program two sourc problem identifi first fortran semant requir extens analysi optim arriv parallel program therefor reli compil capabl alon lead unpredict perform second wide differ parallel strategi use compil may requir hpf program custom particular compil improv compil optim may help reduc perform variat result suggest foremost criteria portabl concis perform model compil must adher user reli b introduct portabl defin abil use program differ platform achiev consist perform develop parallel program portabl scalabl well recogn challeng endeavor howev difficulti necessarili intrins properti parallel comput assert especi clear case data parallel algorithm provid abund parallel tend involv comput regular data parallel model adequ gener parallel program howev simplic coupl preval data parallel problem scientif applic research support ibm resid studi program darpa grant n0001492j4041 motiv develop mani data parallel languag goal simplifi program achiev scalabl portabl perform languag high perform fortran 10 constitut widespread effort involv larg consortium compani univers one hpf distinct first parallel languag recogn standard inde hpf regard integr sever similar data parallel languag includ fortran vienna fortran cm fortran 6 14 22 attract hpf manifold first use fortran base languag promis quick user accept sinc languag well establish target commun second use direct parallel sequenti program impli eas program sinc direct ad increment without affect program correct particular case compil may even abl parallel program without user assist hand hpf also potenti disadvantag first extens sequenti languag like inherit languag featur either incompat parallel difficult compil analyz second portabl program must affect differ technolog compil machin sinc princip purpos creat standard ensur program portabl hpf design present potenti conflict goal portabl instanc hide aspect commun programm conveni forc user reli complet compil gener effici commun differ compil alway present howev maintain program portabl languag differ must forc user make program modif accommod specif compil word user abl use compil develop program scale option migrat differ machin compil better scalar perform requir tight coupl languag specif compil sens compil implement must provid consist behavior abstract provid languag end languag specif must serv consist contract compil programm call contract perform model languag 18 robust perform model dual effect program perform 1 predict user 2 portabl across differ platform focu portabl issu studi indepth perform three na benchmark compil three commerci hpf compil ibm sp2 benchmark embarrassingli parallel ep multigrid mg fourier transform ft hpf compil includ appli parallel research portland group ibm evalu effect data depend compil analysi consid two version benchmark one program use loop second use f90 construct andor hpf foral statement comparison also consid perform benchmark written mpi zpl 16 data parallel languag develop univers washington sinc messag pass program yield scalabl perform conveni mpi result repres level perform hpf program use point refer motiv includ zpl result follow zpl data parallel languag develop first principl lack parent languag allow zpl introduc new languag construct incorpor robust perform model creat concret delin parallel sequenti execut consequ program model present user clear compil rel unhind artifici depend complex interact languag featur one may expect easier develop zpl compil write zpl program scale well natur downsid design new languag without legaci challeng gain user accept studi zpl measur give indic whether consist scalabl perform achiev compil hamper languag featur unrel parallel comput result show program scale well use particular hpf compil may perform similarli differ compil indic lack portabl f90foral program achiev scalabl perform result uniform program result suggest fortran sequenti natur lead consider difficulti compil er analysi optim commun analyz detail implement hpf compil find wide differ parallel strategi vari degre success contribut portabl problem hpf program improv compil optim may help reduc perform variat clear robust solut requir matur compil technolog result suggest foremost criteria portabl concis perform model compil must adher user reli perform model serv effect contract user compil relat work apr publish perform hpf compil suit hpf pro gram along detail descript program restructur process use apr forg tool improv code 3 11 program well tune apr compil mani case reli use aprspecif direct rather standard hpf direct although approach apr advoc program develop follow profilerbas program restructur success instanc result program may portabl respect perform particularli case employ apr direct fore believ suit apr benchmark well suit evalu hpf compil gener similarli paper vendor describ individu hpf compil typic show perform number howev remain difficult make comparison across compil 8 12 13 lin et al use apr benchmark suit compar perform zpl version program correspond hpf perform publish apr found zpl gener outperform hpf 17 howev without access apr compil time detail analysi possibl limit comparison aggreg time paper make follow contribut 1 indepth comparison analysi perform hpf program three current hpf compil altern approach mpi zpl 2 comparison loop f90 array syntax foral construct 3 assess parallel program model present hpf remaind paper organ follow section 2 describ methodolog studi includ descript algorithm benchmark implement section 3 examin analyz benchmark perform detail commun gener implement quantifi effect data depend hpf program section 4 provid observ conclus 21 zpl overview zpl array languag design univers washington expressli parallel ex ecut context paper serv two purpos first set bound perform expect high level data parallel languag extens exist sequenti languag second illustr import perform model parallel languag zpl implicitli parallel ie direct concurr deriv entir semant array oper array decomposit specifi run time partit array either 1d 2d block processor perform comput valu scalar replic processor kept coher redundantli comput scalar comput zpl introduc new abstract call region use alloc distribut array specifi distribut comput zpl provid full complement oper defin region rel eg east r refer adjac element eg awest perform full partial prefix oper eg big max express stride comput establish boundari condit eg wrap accomplish power oper eg flood zpl also contain standard oper data type control structur use syntax similar modula2 22 benchmark select emphas portabl issu establish criteria 1 benchmark deriv independ sourc insur object 2 messag pass version includ studi establish target perform 3 hpf separ version employ f77 loop f90foral signific differ two type construct 4 algorithm parallel algorithm differ version benchmark 5 tune must adher languag specif rather specif compil capabl 6 support hpf featur uniform benchmark requir featur support hpf compil follow criteria prove challeng given dispar benchmark availabil iti na benchmark version 10 npb1 implement comput vendor intend measur best perform possibl parallel machin without regard portabl avail sourc npb1 gener sequenti implement although valid hpf program sequenti natur algorithm may difficult compil parallel may reflect natur approach parallel program instanc programm may simpli choos specif parallel algorithm implement hpf na version 21 npb21 intend measur portabl perform better choic sinc program implement inher parallel algorithm use mpi interfac compil studi npb21 contain 7 benchmark 1 ideal includ studi unfortun portabl hpf version benchmark avail sever limit independ comparison apr hpf vendor publish benchmark use acquir perform measur benchmark gener tune specif compil portabl limit forc us care deriv hpf version npb21 sourc focu portabl avoid extern effect algorithm differ among benchmark cg avail npb21 sp bt lu includ studi requir block cyclic 3d data distribut support hpf compil limit prevent benchmark implement hpf zpl howev implement algorithm differ factor perform leav ft mg potenti candid fortun ep definit highli parallel therefor sequenti implement trivial parallel 23 benchmark implement hpf implement deriv revers engin mpi program commun call remov local loop bound replac global loop bound parallel program hpf direct ad recreat data partit mpi version hpf compil thu present program fulli data parallel sequenti readi parallel conceptu task compil repartit problem specifi hpf direct regener commun benchmark chose requir basic block distribut support three compil use basic hpf intrins therefor stress compil without exceed capabl implement zpl languag deriv sourc hpf implement follow manner sequenti comput translat directli fortran correspond zpl syntax parallel execut express use zpl parallel construct one ad recent 231 ep benchmark ep gener n pair pseudorandom float point valu interv 01 accord specifi algorithm redistribut valu x j j onto rang 11 scale 2x pair test condit true independ gaussian deviat comput new pair x test see fall within one 10 squar annuli total count tabul annulu l maxjxj jy pseudorandom number gener accord follow linear congruenti recurs valu pair consecut valu recurs scale 01 rang valu x k divid 2 46 comput pair gaussian deviat proceed independ processor would maintain count gaussian deviat commun end obtain global sum random number gener howev present challeng two way comput random valu 1 x k comput quickli preced valu x use one multipl one mod oper lead complex howev major drawback true data depend valu x 2 x k comput independ use k defin valu x 0 result overal complex 2 fortun properti mod oper allow x k comput olog step use binari exponenti algorithm 4 goal balanc method 1 2 achiev parallel maintain cost ep avail npb21 suit use implement provid apr loop version version structur achiev balanc 1 2 batch random valu gener one sequenti batch time save seed batch comput use expens method 2 remain valu comput use less expens method 1 loop iter comput number batch requir constitut opportun parallel execut f90foral version deriv loop version follow modif ffl variabl main loop caus output depend expand array size loop iter word output depend elimin essenti renam variabl comput express fulli data parallel manner sinc iter count number sequenti batch expans excess ffl direct ad partit array onto 1d processor grid ffl loop final summat also recod use hpf reduct intrins complic aris involv subroutin call within foral loop must free side effect order loop distribut slight code rearrang done remov side effect origin subroutin pure direct ad assert freedom side effect zpl version translat straightforward manner loop version notabl differ use zpl region construct express independ batch comput 232 mg multigrid interest sever reason first illustr need data parallel languag hpf zpl npb21 implement contain 700 line code commun 30 program elimin program written data parallel languag second sinc main comput 27point stencil refer pattern requir commun simpli shift constant result simpl neighbor exchang processor grid compil zpl hpf recogn pattern well employ optim messag vector storag prealloc nonloc data 3 8 9 12 therefor although benchmark rather complex initi indic hpf zpl abl produc effici parallel program benchmark vcycl multigrid algorithm comput approxim solut discret poisson problem r 2 laplacian oper r 2 algorithm consist 4 iter follow three step residu correct appli correct trilinear finit element discret laplac oper r 2 k vcycl multigrid oper defin npb1 benchmark specif 1 4 algorithm implement npb21 version consist three phase first phase comput residu second phase set step appli k oper comput correct last phase appli correct hpf loop version deriv npb21 implement follow ffl mpi call remov ffl local loop bound replac global bound ffl use common block storag hold set hierarch array differ size incompat hpf therefor array renam declar explicitli ffl hpf direct ad partit array onto 3d processor grid array distribut maintain across subroutin call use transcript direct prevent unnecessari redistribut hpf f90foral version requir addit step rewrit data parallel loop f90 syntax zpl version similar structur hpf f90foral version notabl differ use stride region express hierarchi 3d grid stride region spars index set data declar comput specifi 233 ft consid partial differenti equat point x 3d space ffit ft benchmark solv pde 1 comput forward 3d fourier transform ux 0 2 multipli result set exponenti valu 3 comput invers 3d fourier transform problem statement requir 6 solut therefor benchmark consist 1 forward fft 6 pair dot product invers fft npb21 implement follow standard parallel scheme 5 2 3d fft comput consist travers appli 1d fft along three dimens 3d array partit along third dimens allow processor independ carri 1d fft along first second dimens array transpos enabl travers third dimens transpos oper constitut commun program program requir move third dimens first dimens transpos memori stride favor 1d fft therefor hpf redistribut function alon suffici 2 hpf loop implement deriv follow modif 1 hpf direct ad distribut array along appropri dimens tran scriptiv direct use subroutin boundari prevent unnecessari redistribut 2 commun transpos step replac global assign statement 3 scratch array recast array differ rank size subroutin replac multipl array constant rank size although pass array section formal argument legitim hpf hpf compil difficulti manag array section data distribut specifi partit processor map memori layout hpf f90foral version requir addit step rewrit data parallel loop f90 syntax zpl implement alloc 3d array region 2d array transpos oper realiz zpl permut oper 24 platform program portabl evalu across multipl platform differ compil machin studi elect factor differ due machin architectur focu compil differ although machin architectur set upper bound possibl perform languag compil determin achiev perform target parallel platform ibm sp2 cornel theori center hpf compil use studi includ ffl portland group pghpf version 21 ffl ibm xlhpf version 10 appli parallel research xhpf version 20 compil gener mpi call commun use mpi librari ensur commun fabric ident measur pgi apr hpf compil gener intermedi fortran code process standard ibm fortran compil xlf ibm hpf compil gener machin code directli otherwis base xlf compil zpl compil gener intermedi c code measur use compil option system environ na apr specifi public use sp2 wide node spotcheck confirm publish na apr perform reproduc 3 parallel perform section examin perform program figur 1 show aggreg time version mpi hpf zpl small larg problem size class class note ffl execut time may excess depend success compil first examin small problem size class program reason perform speedup larg problem size class ffl time axi use log scale wide perform spread ffl ep mpi version use class f90foral version shown ffl mg class apr f90foral version scale includ ffl ft class one data point avail ibm f90foral version processor timesec b ep class timesec ep class processor timesec c mg class processor timesec mg class timesec processor timesec f ft class mpi aprdo ibmdo pgido zpl aprf90 ibmf90 pgif90 figur 1 perform ep mg ft see note section 31 na ep benchmark figur 1a first surpris observ ibm pgi compil achiev speedup hpf loop version although apr compil produc program scale well recal ep loop version apr suit inspect code reveal distribut direct specifi array result default data distribut although default distribut implement depend convent choic replic array ibm pgi compil distribut comput strictli ownercomput rule therefor order program parallel data structur must distribut sinc array ep replic default comput partit among processor processor execut full program achiev speedup contrast apr parallel strategi strictli adher ownercomput rule allow main loop partit despit fact none array within loop distribut note hpf languag specif specifi default distribut data partit scheme comput omiss like intend maxim opportun compil optim howev observ ep suggest differ scheme adopt compil may result portabl problem hpf program direct insert distribut array found main array ep intend hold pseudorandom valu gener sequenti therefor exist true depend loop comput valu array distribut compil adjust loop bound local partit comput serial hpf f90foral version correct problem explicitli distribut array ibm pgi compil abl parallel class perform figur 1b show compil achiev expect linear speedup howev expand array express comput data parallel form seem introduc overhead degrad scalar perform possibl advanc compil optim loop fusion array contract remov overhead optim either avail success case zpl version scale linearli expect scalar perform slightli better apr version 32 na mg benchmark compar ep mg allow rigor test languag compil first discuss perform class figur 1c p1 column show consider variat scalar perform version show overhead 1 2 order magnitud mpi perform base case origin mpi program zpl version scale well zpl compil partit problem straightforward manner accord region stride region semant commun vector littl effort scalar perform howev show 6x overhead compar mpi version hpf loop version clearli scale hpf compil explain pgi compil perform poorli vector commun comput express loop commun call tend remain innermost loop result larg number small messag gener addit program use guard within loop instead adjust loop bound apr compil support 1d processor grid therefor 3d distribut specifi hpf direct collaps default 1d distribut limit affect asymptot speedup necessarili limit parallel 27point stencil comput one subroutin compil detect interprocedur analysi alia two formal argument constitut inhibitor loop parallel within subroutin howev analysi go detect index express array refer depend actual exist major loop program apr compil correctli partit comput along distribut array dimens gener conserv commun loop obtain latest valu rh loop updat lh result perform degrad number processor ibm compil parallel detect output depend number variabl although array replic case compil appear overli convers maintain consist replic variabl loop parallel contain statement independ direct treat differ compil pgi compil interpret direct liter parallel loop direct ibm compil hand ensur correct perform rigor depend check nevertheless detect depend parallel loop hpf f90foral version ibm pgi compil success ibm compil perform scalabl approach zpl pgi compil experi littl problem vector commun inde scalar perform exce ibm apr compil result slowdown achiev speedup either partit comput f90foral version similarli loop version abl reduc amount commun continu limit 1d distribut well alia problem one subroutin note version mg apr suit employ apr direct suppress unnecessari commun direct use studi part hpf worth note possibl use apr tool analyz program manual insert apr direct improv speedup apr compil given loop version fail scale compil one may conjectur whether program may written differ aid compil specif caus compil describ suggest apr compil would success apr direct use pgi compil may benefit hpf independ direct ibm compil would requir actual remov data depend therefor appear singl solut portabl across compil 33 na ft benchmark ft present differ challeng hpf compil term refer pattern ft consist dot product fft butterfli pattern former requir commun readili parallel compil latter index express far complex optim commun fortun index variabl limit one dimens time therefor task compil partit comput along appropri dimens intend data distribut 1d thu within capabl apr compil figur 1e show full set perform result small problem size mg mpi zpl version scale well scalar perform data parallel implement show overhead 1 2 order magnitud mpi implement hpf loop version apr compil exhibit problem mg gener conserv commun mani loop addit apr compil choos correct loop parallel discrep aris apr strategi choos partit base array refer within loop case main comput thu array refer packag subroutin call loop intent loop parallel subroutin oper local data compil proce analyz loop subroutin 1d fft find loop paralleliz pgi compil also gener suboptim commun although princip limit vector messag ibm compil parallel assign replic variabl hpf f90foral version requir consider experiment code restructur arriv version accept compil partli differ support featur among compil partli nest subroutin structur origin program hpf compil achiev speedup vari degre apr particularli success sinc princip parallel loop move innermost subroutin scalar perform approach mpi perform although commun overhead limit speedup pgi show good speedup ibm speedup limit 34 commun commun gener compil use indic effect parallel program version benchmark scale tabl 1 show total number mpi messag pass call differ commun scheme employ compil apr pgi compil use gener send receiv ibm compil also use nonblock call collect commun may ramif portabl compil platform zpl compil use nonblock mpi call overlap comput commun well mpi collect commun benchmark version pointtopoint collect type mpi call ep class allreduc barrier ibm f90 70 120 send recv bcast mg class mpi 2736 40 send irecv allreduc barrier zpl 9504 56 isend recv barrier apr f90 126775 8 send recv barrier bcast ft class mpi 0 104 alltoal reduc apr f90 58877 8 send recv barrier ibm f90 728 258048 send irecv bcast tabl 1 dynam commun statist ep class mg class ft class p8 35 data depend hpf compil deriv parallel data distribut loop oper data loop depend readili parallel adjust loop bound local bound loop depend may still paralleliz requir analysi instanc ibm compil recogn depend loop perform reduct gener appropri hpf reduct intrins instanc loop distribut may isol portion contain depend allow remaind origin loop parallel approxim quantifi degre difficulti program present parallel compil term depend analysi use follow simpl metric count loop depend count loop valu 0 would indic loop trivial parallel valu 1 would indic paralleliz loop depend analysi capabl compil use kapf tool collect loop statist benchmark major subroutin list tabl 2 metric complet sinc account data distribut instanc 3 nest loop 1d distribut 1 loop need partit parallel program 2 loop may contain depend ill effect addit metric static may correl directli dynam characterist program howev metric give coars indic demand compil loop depend statist show clear trend correl directli perform data observ expect reduct depend loop version f90foral version reduct greatli aid compil parallel f90foral program also highlight difficulti parallel program loop subroutin f90foral ep embar 35 131 get start seed 11 ft fftpde 216 216 cfft3 06 06 cfftz 35 14 subroutin f90foral mg hmg 12 127 psinv 44 06 resid 44 06 rprj3 44 06 norm2u3 33 00 tabl 2 statist depend ep mg ft count loop data depend subroutin call n total loop count f90foral count obtain array statement scalar mg differ signific array syntax elimin depend case hpf compil implement optim array refer affin function loop indic particularli function constant optim effect mg loop version howev appear success note loop subroutin norm2u3 replac altogeth hpf reduct intrins ft low number depend fftpde come dotproduct easili parallel topdown order subroutin list also repres nest level subroutin increas depend inner subroutin reflect need achiev parallel higher level explain earlier prove challeng apr compil focus analyz individu loop partit work data parallel applic recent progress languag compil allow us experiment evalu import issu program portabl recogn mani factor affect develop success parallel languag studi focus portabl factor three na benchmark studi across three current hpf compil examin differ style express comput hpf also consid benchmark written mpi zpl understand interact perform portabl conveni program hpf compil show gener difficulti detect parallel loop compil success f90 array syntax foral construct although even case success parallel uniform signific variat scalar perform also exist compil hpf direct construct provid inform data comput partit sequenti semant fortran leav mani potenti depend pro gram hpf compil must analyz depend unabl must make conserv assumpt analysi capabl differenti variou vendor impl mentat howev difficult compil parallel reliabl user consist estim parallel behavior thu speedup program addit parallel strategi compil vari wide differ way express comput lead drastic differ perform unpredict variat reflect shortcom perform model hpf result user need continu experi compil learn actual behavior user effect supplement perform model provid languag empir inform yet enhanc model tend platform specif portabl zpl program show consist scalabl perform illustr possibl incorpor robust perform model high level languag languag design ensur languag abstract behav predict manner respect parallel perform although zpl support multipl parallel system result studi directli show zpl portabl across platform multipl independ compil implement zpl avail howev exist perform model evid predict perform behavior ensur zpl program portabl across independ develop platform result also show signific overhead scalar perform remain implement compar mpi program one sourc overhead larg number temporari array gener compil across subroutin call parallel loop requir dynam allocationdealloc copi gener degrad cach perfor manc index comput also contribut significantli overhead clear becom viabl altern explicit messag pass compil data parallel languag must achiev much lower scalar overhead r david klepacki rick lawrenc effici parallel algorithm 3d fft na parallel benchmark appli parallel research na parallel benchmark rob van der wijngaart vienna fortran 90 compil fortran 90dhpf distribut memori mimd comput compil high perform fortran factorjoin uniqu approach compil array languag parallel machin high perform fortran forum fortran parallel hand book hpf compil ibm sp2 compil high perform fortran distributedmemori system evalu compil optim fortran zpl languag refer manual zpl array sublanguag zpl vs hpf comparison perform program style role perform model parallel program languag influenc program model share memori comput perform na parallel benchmark 21 result 896 zpl program guid cm fortran program guid tr compil fortran 90dhpf distribut memori mimd comput evalu compil optim fortran highperform parallel implement na kernel benchmark ibm sp2 compil high perform fortran distributedmemori system role perform model parallel program languag factorjoin zpl ctr bradford l chamberlain sungeun choi e christoph lewi lawrenc snyder w derrick weathersbi calvin lin case highlevel parallel program zpl ieee comput scienc engin v5 n3 p7686 juli 1998 bradford l chamberlain steven j deitz lawrenc snyder compar studi na mg benchmark across parallel languag architectur proceed 2000 acmiee confer supercomput cdrom p46e novemb 0410 2000 dalla texa unit state govett l hart henderson j middlecoff schaffer scalabl model system directivebas code parallel distribut share memori comput parallel comput v29 n8 p9951020 1 august bradford l chamberlain sungeun choi e christoph lewi calvin lin lawrenc snyder w derrick weathersbi zpl machin independ program languag parallel comput ieee transact softwar engin v26 n3 p197211 march 2000