find regular simpl path graph databas consid follow problem given label direct graph g regular express r find pair node connect simpl path concaten label along path satisfi r problem motiv observ mani recurs queri relat databas express form implement queri languag bf g base observ show problem gener intract present algorithm run polynomi time size graph regular express graph free conflict also present class languag whose express alway evalu time polynomi size graph express character syntact express languag b introduct much success relat model data attribut simplic make amen mathemat analysi easi user comprehend latter respect avail nonprocedur queri languag great asset howev fact queri especi use new applic domain express tradit queri languag led propos power queri languag logicbas languag datalog 23 queri languag g origin propos relat model includ two queri languag equival express power relat calculu relat algebra 7 languag use yardstick bywhich queri languag classifi queri languag said relat complet least express power relat calculu howev notion complet question sinc shown certain reason queri find transit closur binari relat express calculu 3 4 particular limit overcom languag datalog abil express recurs queri design g base observ mani recurs queri aris practiceand literatureamount graph travers exampl 1 12 19 g view databas direct label graph pose queri graph pattern answer queri set subgraph databas match given pattern use applic languag found system repres transport network commun network hypertext document prototyp implement queri drawn workstat screen databas queri result also display pictori exampl 1 let g graph describ hypertext document node chunk text edg link crossrefer reader read document follow link context one might interest queri way get section 31 section 52 conclus without read node correspond g queri shown figur 1 lefthand box figur contain pattern graph righthand box contain summari graph specifi preliminari version section paper appear proceed 15th intern confer larg data base amsterdam netherland august 2225 1989 page 185193 comput system research institut univers toronto toronto ont m5 1a4 canada z depart comput scienc univers cape town rondebosch 7700 south africa ae ae ae conc link ae ae conc fig 1 queri test exist simpl path hypertext document ae ae ac ae ae fig 2 queri find pair citi connect air canada flight output present user node case label constant match databas edg pattern graph label regular express case desir express link repres nonzero sequenc link regular express use match edg label along simpl path g therebi satisfi origin request exampl 2 let g graph repres airlin flight node g denot citi edg label citi b citi c mean flight b c airlin assum want find pair citi connect sequenc flight least one flight air canada ac b citi visit queri express graph pattern figur 2 pattern graph exampl compris two node time label variabl edg label regular express ac underscor match edg label g ac regard singl symbol fact simpl path match queri evalu ensur desir answer comput although queri g lot gener exemplifi two exampl special case suggest exampl 2 challeng enough algorithm point view want process queri effici problem address paper given regular express r graph g find pair node g connect simpl path p concaten edg label compris p languag denot r tri find effici solut problem incorpor implement g somewhat surpris discov queri exampl 1 2 fact npcomplet use result 11 17 show x2 certain fix regular express r exampl 2 problem decid whether pair node answer queri npcomplet make gener problem nphard first attack problem determin languag r make problem hard x3 present class languag queri evalu solvabl time polynomi length regular express size graph character languag syntact term regular express denot finit automata recogn character assum knowledg concern structur graph queri x4 consid extens given constraint cycl input graph known satisfi knowledg allow us character potenti larger class queri solv polynomi time design gener algorithm present x5 correct arbitrari graph queri guarante run polynomi time size graph regular express graph free conflict sens defin precis section special case queri free conflict acycl databas graph restrict express queri free conflict arbitrari graph sinc restrict prototyp work conflictfre queri graph expens test conflictfreedom beforehand quit conveni singl algorithm work case fact incorpor algorithm x5 implement 2 intract result section prove neg result regard complex find certain type simpl path particular class direct graph begin defin graph structur well class queri structur interest definit 1 databas graph dbgraph short direct label graph n set node e set edg incid function map e n theta n note multipl edg pair node permit dbgraph label g drawn finit set symbol call alphabet edg label function map e definit 2 let finit alphabet disjoint fffl g regular express r defin follow 1 empti string ffl empti set 2 regular express 2 b regular express regular express 3 noth els regular express express ab call alternationof b ab call concaten b call closur use underscor denot altern element also denot aa posit closur languag lr denot r defin follow 1 ffflg 2 3 4 lbg 5 lbg 6 regular express r 1 r 2 equival written r 1 length regular express r denot jrj number symbol appear string r definit 3 let g n e dbgraph path necessarili simpl path g call string e 1 path label p denot p 2 let r regular express say path p satisfi r p 2 lr queri qr dbgraph g defin set pair x simpl path x g satisfi r x 2 qr g x satisfi qr naiv method evalu queri qr dbgraph g travers everi simpl path satisfi r g exactli penalti algorithm take exponenti time g exponenti number simpl path nevertheless see gener expect algorithm perform much better sinc prove particular regular express problem decid whether pair node answer queri npcomplet hand refin lead guarante polynomi time evalu condit studi follow two section consid follow decis problem regular simpl path instanc dbgraph regular express r question g contain direct simpl path x p satisfi r e equival ask x 2 qr g instanc compris dbgraph refer problem fix regular pathr fix regular pathr measur complex term size dbgraph first prove certain regular express r fix regular pathr npcomplet refer follow two decis problem instanc direct graph e node x 2 n question direct simpl path even length even number edg x instanc direct graph e two pair distinct node w x z 2 n theta n question pair disjoint direct simpl path g one w x z follow theorem use two decis problem prove npcomplet fix regular pathr two particular regular express theorem 1 let 0 1 distinct symbol fix regular pathr r either 1 00 2 0 10 npcomplet proof 1 17 even path shown npcomplet reduc even path fix regular pathr given instanc g x even path construct dbgraph h isomorph g except everi edg h label 0 even simpl path x g simpl path x h satisfi r easi see fix regular pathr np conclud fix regular pathr 2 fact disjoint path npcomplet follow immedi result 11 reduc disjoint path fix regular pathr given instanc g w x z disjoint path construct dbgraph h isomorph g except everi edg h label 0 add new edg x label 1 h simpl path w z satisfi r h disjoint simpl path w x z g conclud fix regular pathr also npcomplet corollari 1 regular simpl path npcomplet proof nphard follow theorem 1 show regular simpl path np observ arbitrari regular express r given simpl path x g path label w check polynomi time length r w whether w lr 2 interest note g undirect even path disjoint path solv polynomi time even path solv polynomi time use match techniqu 17 polynomi time algorithm disjoint path given 20 two npcomplet result theorem 1 gener first gener regular express 00 express form w w 2 jwj 2 use follow npcomplet problem 17 use show npcomplet even path path via node instanc direct graph e node x question direct simpl path x via theorem 2 fix regular pathr r w w 2 proof membership np easi demonstr reduc path via node fix regular pathr use variat construct 17 given instanc g path via node construct dbgraph 1 f 2 f f proof divid two part depend whether w even odd length rather introduc addit node structur believ would obscur proof allow edg label string symbol length path length concaten edg label assum 1 two copi edg type 1 label w 1 w 2 edg type 3 label w 2 edg type 4 label w 1 claim simpl path x g simpl path x 1 2 satisfi r h path p x g let p 1 subpath p x p 2 subpath p let u predecessor p 1 v successor p 2 h travers simpl path x 1 u 2 satisfi w 1 follow edg label w 2 w 1 u 2 v 1 respect follow simpl path v 1 2 satisfi w overal path thu satisfi w 1 w 2 guarante simpl assum simpl path p x 1 2 h satisfi r string lr length mn even path x 1 2 pass must length kn k odd conclud p must pass h henc simpl path x via g consid case one copi edg type 1 h label 0 2n one copi edg type 2 label w 1 w 2 type 3 edg label w 1 type 4 edg label w 2 easi see simpl path x via g must simpl path satisfi r h direct suffic note simpl path h x 1 2 pass length m2n pass length k2n also length string lr two never equal n 0 conclud simpl path x 1 2 h satisfi r must simpl path x via g gener npcomplet result fix regular pathr let also denot altern element theorem 3 let r regular express form wt subset w addit assum either 1 w appear neither 2 symbol b 2 c 2 neither appear w fix regular pathr npcomplet proof fix regular pathr obvious np use essenti reduct disjoint path fix regular pathr theorem 1 gener case given instanc g w x z disjoint path construct dbgraph h isomorph g except two copi edg h made one label b 2 one label c 2 case 2 b c symbol mention statement theorem case 1 choos b 6 c 6 assum add along path e label disjoint simpl path w x z g easi see must simpl path w z satisfi r h assum simpl path p w z satisfi r h p must form p 1 pw p 2 sinc case 1 2 pw contain edg label appear nowher els h appear path h satisfi r conclud must disjoint simpl path w x z h henc g theorem 2 3 rather neg result sinc impli queri might requir time exponenti size dbgraph regular express evalu thu regular express theorem 2 3 certainli would expect evalu algorithm run polynomi time one exampl air canada queri use exampl 2 long alphabet contain least two symbol result howev function particular regular express rather natur languag denot regular express class languag regular simpl path p subject next section 3 restrict regular express section character class queri regular simpl path evalu polynomi time first introduc terminolog definit definit 4 nondeterminist finit automaton ndfam 5tupl finit set state input alphabet ffi state transit function map theta ffflg set subset 0 2 initi state f set final state extend transit function ffi defin follow 2 2 w 2 ndfa accept w languag lm accept set string accept determinist finit automaton dfa ndfa state transit function map theta definit 5 let ndfa transit graph associ direct label graph 2 edg e em confus represent sometim say transit state state successor 2 ffi path 2 ffi w ae ff phi 0ae ff phi 1ae ff phi 2fig 3 transit graph dfa definit appli dfa definit 6 given ndfa pair state 2 defin languag denot l st set string take state state state set state defin languag denot l st st particular state 2 suffix languag denot l sf short set string take final state clearli definit appli dfa given regular express r fflfree lr construct polynomialtim 2 assum ndfa fflfree exampl 3 figur 3 show transit graph dfa state 0 initi state state final denot doubl circl show reject state path initi state final state lm denot regular express 0 1 0 suffix languag state 1 1 regular express subsequ analysi use refer ndfa accept languag lr 1 r 2 construct ndfa defin follow definit 7 let ndfa call transit graph intersect graph 1 2 saw previou section certain regular express r unlik find algorithm evalu qr arbitrari graph g alway run time polynomi size g one regular express 0 10 howev turn regular express specifi instead qr evalu polynomi time dbgraph g reason arbitrari path node x node g satisfi r simpl path x satisfi r case need restrict look simpl path g instead look path satisfi r defin correspond decis problem regular path instanc dbgraph regular express r question g contain direct path necessarili simpl p satisfi r e lemma 1 regular path decid polynomi time ae x ae ff phi z ae fig 4 graph contain nonsimpl path proof given dbgraph g along node x g view g ndfa initi state x final state construct intersect graph g ndfa accept lr path x satisfi r path x 0 f f 2 f done polynomi time 14 22 tarjan provid polynomialtim algorithm construct regular express repres set path two node given graph altern procedur one could decid polynomi time whether path x g satisfi r first use tarjan algorithm construct regular express r xy repres path x g determin whether intersect lr lr xy nonempti use ndfa result previou section show unlik polynomialtim analogu tarjan algorithm exist describ set simpl path two node definit 8 let g dbgraph ndfa intersect graph g call node x 0 initi node node f final node interest condit regular simpl path appropri semant reduc regular path follow lemma state one condit lemma 2 regular simpl path decid polynomi time acycl db graph proof follow immedi lemma 1 fact everi path acycl graph simpl suppos want character class regular express guarante regular simpl path solvabl polynomi time assum know noth structur dbgraph ensur regular express r whenev string w lr everi string obtain w remov one symbol must also lr otherwis xay lr xy lr 2 x 2 construct graph g compris singl simpl path u v pass z loop z label path u z label x path z v label see figur 4 nonsimpl path u v g satisfi r simpl path u v satisfi r definit 9 abbrevi string w string obtain w remov one symbol w 6 look class regular express denot languag close abbrevi consid follow definit class restrict regular express definit 10 2 denot regular express done grep util unix 1 exampl given regular express r let r 0 regular express obtain replac occurr symbol 2 r r restrict r j r 0 r 0 obtain r defin note definit restrict regular express semant rather syntact two signific consequ one hand abl prove equival theorem theorem relat restrict regular express languag automata recognit problem restrict regular express becom difficult corollari 3 exampl 4 regular express 0 1 0 restrict equival 0 1 0 recal theorem 1 fix regular pathr npcomplet restrict r restrict sinc r 0 written 0 1 equival 0 10 definit 11 dfa exhibit suffix languag contain properti contain properti short pair 2 path 0 final state successor l sf l tf follow result although use elsewher provid interest restrict structur dfa exhibit contain properti proposit 1 let exhibit contain properti 1 everi state path 0 state f final 2 minimum dfa exhibit contain properti 3 minimum everi cycl loop proof 1 everi final state accept ffl transit everi state path 0 state f must also accept ffl henc must final minimum dfa equival state 0 repres set equival state assum 2 0 repres fs transit transit equival 3 consid cycl loop let two state cycl sinc u v everi pair consecut state cycl conclud transit j minimum contradict exampl 5 consid regular express dfa accept whose transit graph given figur 3 verifi exhibit contain properti note 2 denot 0 obvious easi check 1 note also proposit 1 state final sinc minim everi cycl loop fact exhibit contain properti r restrict coincid demonstr theorem 4 let r regular express accept lr follow three statement equival 1 r restrict regular express 2 lr close abbrevi 3 exhibit contain properti 1 unix trademark att proof proof use ndfa e construct regular express r lmr detail 2 ffltransit usual present onetoon correspond nonffltransit mr occurr symbol r make sens refer transit mr correspond occurr symbol r vice versa furthermor replac occurr r equival includ ffltransit sourc state target state transit mr correspond occurr assum r restrict lr close abbrevi symbol 2 string x 2 xay 2 lr xy 62 lr consid mr let set state mr read x sinc lmr r hand xay 2 lmr state p 2 0 q 2 p 2 q sinc r restrict ad ffltransit p q leav lmr unchang longer equal lr contradict conclud lr close abbrevi prove contraposit assum 6 pair reachabl state ffi 2 string 2 2 62 let x 2 string ffi follow xay 2 lm xy 62 lm sinc lm conclud lr close abbrevi prove contraposit assum r restrict atransit mr ad ffltransit alter string 2 string 2 62 r r 2 consid dfa assum must state q ffi p q 2 q howev 62 p otherwis xy 2 lm would mean lm exhibit contain properti theorem 5 regular simpl path decid polynomi time restrict regular express proof let dbgraph g regular express r r restrict constitut instanc regular simpl path lemma 1 suffici show whenev path x g satisfi r simpl path x satisfi r assum nonsimpl path g sinc p nonsimpl assum j lr path label p 0 abbrevi p theorem 4 lr close abbrevi henc p 0 remov cycl p leav simpl path x satisfi r thu class restrict regular express one queri evalu perform effici show even though class restrict regular express regular languag close abbrevi subclass regular counterpart least close regular oper theorem 6 let alphabet class regular languag close abbrevi also close altern concaten closur proof let l 1 l 2 regular languag close abbrevi immedi close abbrevi let w 2 abbrevi w clearli string abbrevi w sinc l 1 l 2 close abbrevi algorithm comput suffix languag contain relat dfa input output pair 2 whether 1 mark od 2 order pair distinct state 3 2 ffi ffi mark 4 mark 5 recurs mark unmark pair list list pair mark step els pair ffi ffi mark 6 2 7 put list ffi od od fig 5 comput suffix languag contain relat dfa l allow us conclud l close abbrevi let l regular languag close abbrevi sinc ffl 2 l regular languag close abbrevi also close concaten l must close abbrevi corollari 2 class restrict regular express close altern concaten closur exampl 6 one simplest restrict regular express 0 sinc class restrict regular express close altern concaten closur 0 0 1 0 alreadi seen restrict hand restrict express also sometim built express restrict exampl includ alreadi seen 00 given queri qr would like test whether r restrict order know safe use polynomi time evalu algorithm adapt algorithm minim number state dfa 13 comput suffix languag contain relat pair state dfa suffix languag contain relat use subsequ section also provid obviou method test whether regular express r restrict use theorem 4 algorithm comput suffix languag contain relat algorithm shown figur 5 line 3 7 algorithm taken directli algorithm 13 algorithm mark pair inequival state consid unord pair state line 1 2 algorithm alter appropri order consid order pair state mark algorithm 6 n state algorithm run 2 assum constant alphabet 13 altern almost lineartim algorithm given 2 sinc construct dfa accept lr may take exponenti time size r use algorithm test whether regular express restrict effici howev import stress tri avoid possibl spend exponenti time size dbgraph answer queri also turn determin whether r restrict hard problem consid follow result proposit 2 21 determin whether regular express alphabet f0g denot 0 npcomplet use result show problem decid whether regular express alphabet restrict nphard first prove follow theorem 7 let r star regular express alphabet f0g decid whether r restrict npcomplet proof first show problem np r restrict lr close abbrevi theorem 4 thu string 0 lr consid dfa accept lr seen must jrj 0 n 62 lr nondeterminist polynomi time algorithm verifi r restrict first guess binari represent n test whether path transit graph ndfa accept lr length n final state latter step done determinist time polynomi length r 21 reduc problem proposit 2 present problem show r restrict r denot 0 alreadi shown r restrict lr 6 0 convers assum r denot 0 let x shortest string 0 lr sinc r star lr infinit string xy 2 lr 6 ffl x abbrevi xy henc theorem 4 r restrict corollari 3 decid whether regular express alphabet restrict nphard 4 constrain cycl dbgraph instanc knowledg cyclic structur dbgraph g allow us determin without consult g particular queri qr evalu polynomi time g alreadi shown extrem case g acycl qr alway evalu polynomi time let us assum know cyclic structur g constrain regular express c everi cycl label g lc definit 12 let c regular express dbgraph let set cycl label g name cycl gg say g compli c ae lc regular express c call cycl constraint cycl constraint c defin class dbgraph whose cyclic structur satisfi c exampl way defin class bipartit graph loopfre graph acycl graph specifi regular express respect 2 class dbgraph unconstrain cycl defin express denot continu need introduc terminolog regard properti intersect graph dbgraph transit graph definit 13 let intersect graph dbgraph graph say path 2 recal underscor shorthand dbsimpl v word p dbsimpl v simpl path g addit call simplici whenev path dbsimpl path v first compon node form subset first compon node p definit lemma 1 clear intersect graph dbgraph transit graph correspond regular express r simplici qr evalu polynomi time size follow theorem character simplici intersect graph presenc cycl constraint theorem 8 let c cycl constraint queri qr let accept lr transit graph everi dbgraph g compli c intersect graph g simplici whenev path reachabl state satisfi c proof dbgraph compli c nonsimpl path satisfi r g henc path q v notat simplic let w w compli c w assum ffi path satisfi c path v henc assumpt string w 3 p satisfi r w 3 2 well follow w 1 w 3 2 lr therefor satisfi r process repeat obtain dbsimpl path q 0 v first compon q 0 form subset first compon q conclud simplici assum path p satisfi c constraint c otherwis p would satisfi c sinc reachabl string w 1 ffi otherwis let w 3 string w 2 path label p string w 2 ffl sinc p must length greater zero construct dbgraph compris singl nonsimpl path e 1 compli c sinc cycl g label w 2 lc path q lr henc path v howev path satisfi r sinc w 1 w 3 62 lr otherwis w 3 would consequ dbsimpl path v conclud simplici result depend particular dfa accept lr consid two accept lr let 2 2 pair state string x ffi g compli cycl constraint compat r r restrict g acycl fig 6 relationship regular express r dbgraph g queri qr lm 1 must case word fact theorem 8 true independ particular dfa chosen consequ myhillnerod theorem state languag accept dfa union equival class rightinvari equival relat finit index 13 lead us follow definit definit 14 let r regular express transit graph dfa accept lr say r compat cycl constraint c whenev path reachabl state satisfi c theorem 8 gener previou result case g acycl c path satisfi c result hold vacuous word everi regular express compat cyclic structur g unconstrain c denot everi path satisfi c must contain pair reachabl state correspond case restrict regular express regular express r compat c c denot r restrict relationship among properti shown figur 6 appeal result lemma 1 obtain follow corollari theorem 8 corollari 4 let c cycl constraint g dbgraph compli c queri qr g evalu polynomi time size r g r compat c simpl algorithm test whether regular express compat cycl constraint given figur 7 construct dfa regular express r c algorithm take exponenti time length r c howev decid whether r c compat nphard sinc decid whether r restrict special case test compat theorem 9 given regular express r cycl constraint c decid whether r c compat nphard exampl 7 let r 00 dfa mr accept lr shown figur 8a 6 b know r restrict fact saw theorem 1 decid x 2 qr g npcomplet dbgraph gener howev qr evalu polynomi time bipartit graph alreadi seen regular defin class bipartit graph dfa mc accept lc shown figur 8b intersect graph mr mc given figur 9 path satisfi c start node contain initi state mc end node contain final state mc b b sinc b b corollari 4 tell us qr evalu polynomi time bipartit graph given queri qr dbgraph g know g compli cycl constraint c test whether r compat c use algorithm use polynomi time algorithm evalu qr g hand know cyclic structur g seem might resort exponenti algorithm test whether regular express compat cycl constraint input regular express r cycl constraint c output whether r compat c 1 construct dfa accept lr accept lc 2 comput suffix contain relat mr algorithm x3 3 construct intersect graph mr theta mc 4 comput transit closur 5 edg otherwis answer fig 7 test whether regular express compat cycl constraint ae ae ae ae ae ae b fig 8 dfa mr bb ae ae ad ae ae ae bd fig 9 intersect graph mr mc figur 8 ae ff phi aae ff phi bae ff phi ff phi omega psi ae ff phi omega psi ae ae omega omega omega omega omega omega ae ae omega omega omega omega omega omega oe j j b fig 10 dfa dbgraph g time algorithm r restrict next section howev describ evalu algorithm run polynomi time size g g happen compli cyclic constraint r compat 5 evalu algorithm section describ algorithm evalu queri qr dbgraph g expect result x2 algorithm run polynomi time gener howev run polynomi time suffici condit identifi x3 x4 name g acycl r restrict g compli cycl constraint compat r fact show algorithm run polynomi time g r conflictfre condit impli evalu algorithm travers path g use dfa accept lr control search mark node visit must record state node visit sinc must allow node visit differ state correspond distinct node intersect graph g order avoid visit node twice state would like retain state mark node long possibl unfortun follow exampl show gener requir answer node connect simpl path g retain state mark lead incomplet queri evalu exampl 8 consid queri qr accept lr dbgraph g shown figur 10 note similar automaton figur 3 x3 assum start travers node g follow path b c node b c mark state b b respect answer c found sinc b final state mark c state c b c dc nonsimpl path backtrack node c result answer e found node still mark b shown figur 10 backtrack c howev mark b state c b c b nonsimpl path backtrack find e g r conflictfre g compli cycl constraint compat r r restrict g acycl fig 11 relationship regular express r dbgraph g queri qr alreadi mark state b consequ search termin without answer b found turn safe retain mark g acycl r restrict howev structur particular dbgraph g might case retain mark evalu qr polynomi time even g acycl r restrict definit 15 let intersect graph dbgraph g dfa path path form v initi path p conflictfre 1 p dbsimpl 2 p q delta v q conflictfre v appear q v q v q case conflict v everi simpl initi path conflictfre said conflictfre 3 g r obviou g acycl conflictfre matter regular express r appear qr also r restrict theorem 4 exhibit contain henc conflictfre irrespect structur g final g compli cycl constraint compat r theorem 8 g r conflictfre show qr evalu polynomi time conflictfre henc conflict freedom anoth weaker suffici condit qr polynomi time evalu see figur 11 result follow lemma use evalu algorithm lemma 3 let intersect graph dbgraph accept lr initi path p conflictfre 1 p dbsimpl 2 p q delta v q conflictfre v appear q first v q proof direct trivial assum p conflictfre dbsimpl furthermor assum p q delta v q conflictfre v appear q prove induct number occurr v q v first occurr v q basi v occur q trivial assum induct hypothesi true fewer n occurr v q let p q delta v sinc p conflictfre know definit v r q r induct hypothesi exampl 9 consid dfa dbgraph g exampl 8 shown figur 10 intersect graph g shown figur 12 recal mark retain answer b would found howev conflict initi path via b b c 6 c 3 strictli weaker definit conflictfreedom given 18 cc ae ba ae cb ae bc gammapsi r fig 12 intersect graph dbgraph g dfa figur 10 algorithm c evalu queri dbgraph input dbgraph queri qr output qr g valu qr g 1 construct dfa accept lr 2 initi qr g 3 node v 2 n set cm v pm v 4 test pair state 5 node v 2 n call searchv v 0 conflict see figur 14 b reset pm w mark node w 2 n fig 13 evalu queri dbgraph algorithm c detect conflict unmark node backtrack enabl answer b found proceed descript algorithm c shown figur 13 algorithm use dfa accept lr control depthfirst search db graph g line 1 two reason dfa rather ndfa use first ensur conflict encount r restrict second reason avoid detect unnecessari conflict ndfa 6 might case state q q ffi node v g first mark follow cycl v satisfi l st travers conflict would regist unnecessari sinc v would subsequ mark q simpl path v satisfi would found q algorithm c travers transit graph dbgraph g simultan effect perform depthfirst search intersect graph g often refer tree depthfirst search forest gener algorithm c line 5a tree forest root initi node final node reach line 8 add appropri pair node g qr g line 9 10 forc algorithm consid path g satisfi r path travers restrict simpl path necessarili restrict dbsimpl path prove safe travers nondbsimpl path procedur search u v var conflict u v node dbgraph state dfa dbcycl boolean flag 6 conflict fals 7 cm v cm v fsg 8 2 f qr g 9 edg g v w label 11 firstcm 12 conflict true els cm 13 search u w newconflict 14 conflict conflict newconflict od 15 cm v cm 16 conflict pm v pm v fsg fi fig 14 search procedur queri evalu absenc conflict node g mark state visit two set mark use node v 1 set current mark cm v indic state v associ current path stack procedur line 7 15 2 set previou mark pm v repres earlier mark v exclud current path line 16 current mark use avoid cycl detect conflict previou mark use possibl prevent node g visit state singl execut line 5a function first appli mark set cm v return first state mark v current path fals mark node w visit state previou mark w either w current unmark cm w empti first state mark q v current path q conflict q line 10 13 note may fact conflict later mark v current path affect correct algorithm demonstr line 6 11 12 implement conflict detect conflict true conflict state q node w conflict set true line 12 line 14 15 16 ensur mark node stack time conflict detect remov node unstack conflict occur path root v ad previou mark v line 16 proof follow often say v exampl stack procedur search variabl v refer middl two paramet search correspond node v correspond intersect graph reason exclud two paramet search u first remain unchang execut line 5a alway concern valu conflict b b b c e b c c c c b b c b c c c b c c c b c b fig 15 two possibl depthfirst search tree also sometim exclud conflict refer particular invoc search exampl searchu v prove correct algorithm c demonstr behaviour mean exampl exampl 10 consid intersect graph figur 12 two possibl depthfirst search tree dfst travers algorithm c shown figur 15 note node dfst repeat unmark exampl node b appear three time figur 15a dot edg figur lead node search call either conflict node alreadi mark via either cm pm b latter edg correspond forward back cross edg convent dfst 2 assum algorithm c start travers node searcha call line 5a order travers accord dfst figur 15a sinc initi node b c current mark line 11 evalu fals search call success b c b b b final state c ad qr g line 8 although c alreadi current mark name b fact b c mean line 11 evalu fals search call c c first mark b 6 c conflict regist line 12 algorithm backtrack remov current mark line 15 assign previou mark line 16 consid b c c b give rise conflict algorithm tri path via e b note b c c longer mark revisit give rise conflict time algorithm backtrack node unmark dbsimpl path b c final found b ad qr g path b c via e b chosen first algorithm c figur 15b conflict would detect result previou mark kept b e travers path c b line 10 would ensur b c b revisit conflict regist lemma 4 conflict fals line 16 searchu v algorithm c perform entir depthfirst search node v proof proof proce induct length longest simpl path p v p length zero result follow trivial assum result hold node longest simpl path length longest simpl path length n conflict fals line 16 searchu v must successor w v either 1 2 pm w line 10 2 newconflict must fals line 14 case 1 conflict must fals line 16 searchuw order ad pm w case 2 conflict must fals line 16 searchuw newconflict fals line 14 sinc longest simpl path w must length less equal n gamma 1 conclud induct hypothesi entir depthfirst search w perform algorithm c clearli line 9 10 consid everi successor v result follow definit 16 node v depthfirst search tree call conflict predecessor successor w v w appear ancestor v first occurr root say w q case q 6 word conflict q w lemma 5 consid execut searchu v df tree state ad pm v line 16 descend v conflict predecessor proof ad pm v line 16 conflict must fals henc lemma 4 entir depthfirst search v must perform conflict predecessor node w successor appear successor w thu conflict predecessor appear descend v descend v conflict predecessor conflict fals descend henc v thu ad pm v line 16 dbgraph r regular express let accept lr intersect graph g algorithm c correct algorithm c add u z qr g dbsimpl path u 0 z f f 2 f simpl path u z g satisfi r proof algorithm c clearli termin sinc line 10 ensur simpl path consid simpl path initi node consid algorithm add u z qr g must travers depthfirst search tree root u 0 simpl path p u 0 z r r 2 f assum p dbsimpl dbnode v appear p let first occurr v p inod v last occurr v thu first state ad cm v order searchu v call line 13 line 11 must ensur henc path p 0 v z q q 2 f sequenc dbnode p 0 ident path v z r p sinc v v first last occurr respect v p path u 0 z q q 2 f dbsimpl respect v simpl induct number repeat dbnode p show dbsimpl path u 0 z f assum dbsimpl path p u 0 z f f 2 f obvious algorithm travers p done assum let v last node p travers w successor v p reason w visit conflict sinc p dbsimpl must case line 10 lemma 4 5 entir depthfirst search v must perform sinc path v z f searchu z f must call case u z would ad qr g line 8 theorem 11 absenc conflict algorithm c run amount time bound polynomi size dbgraph proof essenti point absenc conflict algorithm c perform normal depthfirst search intersect graph polynomi size dbgraph detail analysi time complex algorithm follow let qr queri r length g dbgraph n node e edg although mani o2 state dfa accept lr constant term size g nevertheless assum q state includ q analysi time complex algorithm c sinc intersect graph g oqn node oq 2 e edg line 1 algorithm c done oq 2 time line 2 requir constant time line 3 take time line 4 oq 2 time line 5 execut n time execut node visit conflictfre v stack ad cm v line 10 ensur v restack v unstack ad pm v line 16 remov pm v present execut line 5a termin line 10 ensur v revisit present execut 5a constant time need line 6 12 14 dbnode v cm v implement stack access bottom element function first henc line 7 11 15 perform constant time line 16 sinc fsg pm v disjoint line 10 line 8 implement take oq time pair u v ad qr g final state pm v line 10 also done oq time line 9 10 inspect edg leav node sinc node revisit search call time call take oq time singl execut line 5a take oq 3 e time singl execut line 5b take time total time spent line 5 onq 3 e consequ algorithm c run term size g algorithm c run one time assumpt edg isol node relationship depict figur 11 obtain follow corollari 5 algorithm c evalu qr g time polynomi size g 1 r restrict 2 g acycl 3 g compli cycl constraint compat r even presenc conflict algorithm c run polynomi time size g case exampl r free regular express let q length r r free finit number string lr length longest string q also upper bound length longest dbsimpl path henc q dbsimpl path even algorithm c travers everi dbsimpl path exactli worst case still run polynomi time size g number circumst identifi lead polynomialtim solut exampl certainli queri evalu polynomialtim arbitrari dbgraph whose regular express restrict one class regular express form wa w string fix length unfortun dbgraph algorithm c take exponenti time evalu associ queri clearli much scope investig addit class queriesdb graph polynomialtim evalu possibl identifi appropri gener evalu algorithm develop algorithm c could enhanc react sophist manner detect conflict one possibl flag sourc conflict unmark node algorithm backtrack flag node 6 conclus address problem find node label direct graph connect simpl path satisfi given regular express studi motiv observ mani recurs queri relat databas express form implement queri languag base observ began describ naiv algorithm might evalu queri although algorithm run exponenti time worst case show expect better sinc evalu problem gener nphard use fact associ problem path gener oppos simpl path solvabl polynomi time character class restrict regular express whose associ queri evalu polynomi time consid restrict structur regular express turn attent cyclic structur graph queri introduc notion cycl constraint show graph g compli cycl constraint compat regular express r qr g could evalu polynomi time final present algorithm evalu arbitrari express arbitrari graph algorithm run polynomi time regular express restrict closur free b graph compli cycl constraint compat regular express special case graph acycl c regular express graph conflictfre difficult say often condit encount practic show class restrict regular express close regular oper good start point investig larger class express graph polynomialtim evalu algorithm would attempt identifi class express graph conflictfre algorithm c run polynomi time emphasi paper identifi circumst regular simpl path problem solv polynomi time rather design effici algorithm case believ topic futur research exampl would interest see whether techniqu use spars graph 16 could employ algorithm order improv effici spars graph point analysi paper implement assum graph entir store main memori reason assumpt mani case especi intend applic queri languag g graph often fraction databas present visual natur way relax assumpt provid interest area studi research investig similar algorithm transit closur claim amen effici secondari storag implement 15 final note research done express power graphbas queri languag restrict simpl path semant drop one languag captur exactli queri comput nondeterminist logarithm space present 8 onlin algorithm regular path find given 5 survey mani result found 24 r alpha extens relat algebra express class recurs queri design analysi comput algorithm univers data retriev languag complet queri languag relat databas data structur arc insert regular path find relat complet data base sublanguag graphlog visual formal real life recurs graphic queri languag support recurs direct subgraph homeomorph problem effici evalu subset recurs queri introduct automata theori equival effici transit closur algorithm effici algorithm transit closur linear worstcas complex result class spars graph evenpath problem graph digraph find regular simpl path graph databas practic approach support recurs applic polynomi solut undirect two path problem word problem requir exponenti time fast algorithm solv path problem implement logic queri languag databas tr ctr kemafor anyanwu amit sheth oper discov rank associ semant web acm sigmod record v31 n4 decemb 2002 kemafor anyanwu amit sheth oper discov rank associ semant web acm sigmod record v31 n4 decemb 2002 dan c stefanescu alex thomo lida thomo distribut evalu gener path queri proceed 2005 acm symposium appli comput march 1317 2005 santa fe new mexico weight path queri semistructur databas inform comput v204 n5 p679696 may 2006 gsta grahn alex thomo regular path queri approxim semant annal mathemat artifici intellig v46 n12 p165190 februari 2006 phillip g bradford languag constrain graph problem microcosm engin research develop proceed 2nd wsea intern confer comput engin applic p7176 januari 2527 2008 acapulco mexico makoto murata extend path express xml proceed twentieth acm sigmodsigactsigart symposium principl databas system p126137 may 2001 santa barbara california unit state frank neven thoma schwentick express effici pattern languag treestructur data extend abstract proceed nineteenth acm sigmodsigactsigart symposium principl databas system p145156 may 1518 2000 dalla texa unit state taesun chung hyoungjoo kim xml queri process use document type definit journal system softwar v64 n3 p195205 15 decemb 2002 serg abiteboul victor vianu regular path queri constraint proceed sixteenth acm sigactsigmodsigart symposium principl databas system p122133 may 1115 1997 tucson arizona unit state gsta grahn alex thomo queri contain rewrit use view regular path queri constraint proceed twentysecond acm sigmodsigactsigart symposium principl databas system p111122 june 0911 2003 san diego california partial order regular languag graph queri journal comput system scienc v70 n1 p125 februari 2005 sergio flesca filippo furfaro sergio greco graph grammar base framework queri graphlik data data knowledg engin v59 n3 p652680 decemb 2006 yaron kanza yehoshua sagiv flexibl queri semistructur data proceed twentieth acm sigmodsigactsigart symposium principl databas system p4051 may 2001 santa barbara california unit state sangwon park hyoungjoo kim sigdaq enhanc xml queri optim techniqu journal system softwar v61 n2 p91103 march 2002 gsta grahn alex thomo algebra rewrit optim regular path queri theoret comput scienc v296 n3 p453471 14 march ravi kumar prabhakar raghavan sridhar rajagopalan andrew tomkin extract largescal knowledg base web proceed 25th intern confer larg data base p639650 septemb 0710 1999 georg mihaila louiqa raschid anthoni tomas locat access data repositori websemant vldb journal intern journal larg data base v11 n1 p4757 august 2002 ravi kumar prabhakar raghavan sridhar rajagopalan sivakumar andrew tompkin eli upfal web graph proceed nineteenth acm sigmodsigactsigart symposium principl databas system p110 may 1518 2000 dalla texa unit state yanni papakonstantin victor vianu dtd infer view xml data proceed nineteenth acm sigmodsigactsigart symposium principl databas system p3546 may 1518 2000 dalla texa unit state elisa bertino mohandsad hacid farouk toumani retriev semistructur web data intellig explor web physicaverlag gmbh heidelberg germani stephen dill ravi kumar kevin mccurley sridhar rajagopalan sivakumar andrew tomkin selfsimilar web acm transact internet technolog toit v2 n3 p205223 august 2002 stephen dill ravi kumar kevin mccurley sridhar rajagopalan sivakumar andrew tomkin selfsimilar web proceed 27th intern confer larg data base p6978 septemb 1114 2001 finegrain access control system xml document acm transact inform system secur tissec v5 n2 p169202 may 2002 mohandsad hacid farouk toumani ahm k elmagarmid constraintbas approach semistructur data fundamenta informatica v47 n12 p5373 januari 2001 kemafor anyanwu amit sheth queri enabl queri semant associ semant web proceed 12th intern confer world wide web may 2024 2003 budapest hungari elisa bertino ahm k elmagarmid mohandsad hacid order path constraint semistructur data journal intellig inform system v20 n2 p181206 march serg abiteboul pari c kanellaki object ident queri languag primit journal acm jacm v45 n5 p798842 sept 1998 denni shasha jason l wang rosalba giugno algorithm applic tree graph search proceed twentyfirst acm sigmodsigactsigart symposium principl databas system june 0305 2002 madison wisconsin