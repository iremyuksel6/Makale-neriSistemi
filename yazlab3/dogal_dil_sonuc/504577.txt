loop check logic program function two complet loop check mechan present literatur logic program function oscheck evacheck oscheck comput effici quit unreli often misidentifi infinit loop wherea evacheck reliabl major case quit expens paper develop seri new complet loop check mechan call vafcheck key techniqu introduc notion expand variant captur key structur characterist finit loop show approach superior oscheck evacheck effici oscheck reliabl evacheck copyright 2001 elsevi scienc bv b introduct recurs natur logic program lead possibl run innit loop topdown queri evalu innit loop refer innit sldderiv illustr exampl evalu goal pa logic program lead innit loop anoth repres logic program current leav depart comput scienc univers alberta edmonton alberta canada t6g 2h1 email ydshencsualbertaca fax 780 4921071 evalu queri pga gener innit loop loop check long recogn problem logic program 1 although mani loop check mechan propos last decad eg 1 2 6 7 9 12 14 17 19 20 22 23 major eg 1 2 6 7 9 12 19 20 22 23 suitabl functionfre logic program determin innit loop check variant goalssubgo sldderiv variant goalssubgo goalssubgo variabl renam henc innit loop like l 2 detect variant goalssubgo occur deriv import fact functionfre logic program innit loop complet avoid appeal tabl techniqu 4 5 18 21 23 24 howev innit loop function remain unresolv even tabl system 13 best knowledg among exist loop check mechan two deal innit loop like l 2 one call oscheck overs loop check 14 evacheck extend variant atom loop check 17 oscheck rst introduc sahlin 14 15 formal bol 3 determin innit loop base two paramet depth bound size function size inform os check say sldderiv may go innit loop gener overs subgoal subgoal said overs ancestor subgoal sldderiv predic symbol whose size smaller equal exampl choos innit loop prove oscheck complet sens cut innit loop howev mere take number repeat predic symbol size subgoal decis paramet without refer inform intern structur subgoal underli decis fairli unreli ie mani nonloop deriv may prune unless depth bound set sucient larg evacheck propos shen 17 determin innit loop base depth bound gener variant inform evacheck say sldderiv may go innit loop gener subgoal 0 gener variant ancestor subgoal subgoal 0 said gener variant subgoal variabl renam except argument whose size increas via set recurs claus recurs claus form like c 21 p 2 one distinct properti repeatedli appli may lead recurs increas size subgoal 1 two dierent topic termin logic program one termin analysi see 8 detail survey loop check see 1 23 paper studi loop check recurs increas term size key featur innit loop function innit loop innit larg subgoal gener repeatedli appli set recurs claus due fact evacheck complet much reliabl oscheck sens less like misidentifi innit loop 17 oscheck obviou advantag simplic unreli contrast evacheck reliabl major case comput expens main cost evacheck come comput recurs claus one hand given logic program need determin claus recurs claus hand subgoal 0 sldderiv order determin 0 gener variant need check 0 deriv appli set recurs claus observ show process timeconsum paper continu explor complet loop check mechan prove quit use stop criteria partial deduct logic program 11 see 3 relat stop criteria partial deduct loop check one hand unlik oscheck fulli employ structur characterist innit loop design reliabl loop check mechan hand instead reli expens recurs claus extract structur inform innit loop directli individu subgoal introduc new concept expand variant captur key structur characterist certain subgoal innit loop inform subgoal 0 expand variant subgoal variant except term ie variabl constant function grow 0 function contain term notion expand variant provid use tool seri complet loop check mechan dene paper develop four vafcheck variant atom loop check logic program function v af 1 4 depth bound loop base expand variant v af 2 enhanc v af 1 take account one innit repeat claus v af 3 enhanc v af 2 constraint set innit repeat claus v af 4 enhanc v af 3 constraint recurs claus reliabl increas v af 1 v af 4 comput overhead increas balanc two key factor choos v af 2 best practic applic v af 2 complex oscheck far reliabl oscheck 2 v af 2 reliabl vast major logic program moreov less reliabl evacheck v af 2 much ecient evacheck like oscheck comput recurs claus plan paper follow section 2 review basic concept concern loop check section 3 introduc expand variant examin properti section 4 dene four vafcheck prove complet section 5 make comparison vafcheck oscheck evacheck preliminari section review basic concept concern loop check assum familiar basic concept logic program present 10 throughout logic program alway mean posit logic program variabl begin capit letter predic symbol function symbol constant lower case letter let atomfunct size denot jaj count function symbol variabl constant use rela refer predicatefunct symbol use ai refer ith argument aij refer jth argument ith argument aik refer kth argument ith argument exampl let denit 21 variant sldderiv resp goal subgoal atom function mean deriv resp goal subgoal atom function 0 variabl renam denit 22 1 3 let p logic program g 0 top goal comput rule 1 let l set sldderiv p fg 0 g dene proper subderiv dg l subderiv free 2 simpl loop check comput set l nite sldderiv l close variant subderiv free observ loop check l formal dene certain type innit loop gener ie sldderiv g 0 said step innit loop g k g 0 l therefor whenev innit loop detect cut immedi g k lead follow denit denit 23 let sldtree p fg 0 g l loop check let sldderiv top goal g 0 g 0 lg appli l obtain new sldtree consist node goal cut prune prune node sldtree mean remov descend order justifi loop check bol et al introduc follow criteria denit 24 1 let comput rule loop check l weakli sound follow condit hold everi logic program p top goal g 0 sldtree p fg 0 g contain success branch contain success branch loop check l complet everi innit sldderiv prune l put anoth way loop check l complet logic program p top goal g 0 ideal loop check would weakli sound complet unfortun sinc logic program full power recurs theori loop check weakli sound complet even functionfre logic program 1 mention introduct paper explor complet loop check mechan order compar dierent complet loop check introduc follow concept denit 25 complet loop check l 1 said reliabl 2 complet loop check logic program p top goal g 0 success sldderiv tl1 less tl2 vice versa prove evacheck reliabl oscheck 17 introduct mention notion ancestor subgoal denit 26 17 subgoal sldtree ancestor list ala dene recurs follow 1 root fg 2 let node sldtree 1 select resolv claus 0 1 child node let ancestor list ala ancestor list alb b n ala1 fa 1 g ancestor list ala j j ala j obvious subgoal b ancestor list b ie 2 alb proof requir proof b denit 27 let g g k two node sldderiv b select subgoal g g k respect say ancestor subgoal b denot anc b follow result show ancestor relat anc transit theorem 21 1 anc 2 2 anc 3 1 anc 3 proof denit ancestor list subgoal 2 ala 0 ala ala 0 ala 3 thu 1 2 ala 2 ala3 impli 1 2 ala 3 1 anc 3 2 17 phrase sound loss gener sequel assum leftmost comput rule select subgoal node leftmost subgoal conveni node goal g unless otherwis speci use refer leftmost subgoal g 3 expand variant design complet reliabl loop check rst need determin princip characterist innit loop possess consid innit loop l 2 see introduct notic 0 subgoal pfffga 1th node g i1 variant subgoal pffga ith node g except function ga g grow function fga g i1 howev replac ga constant l 2 pfffa g i1 variant pffa g except constant g grow function fa g i1 furthermor replac ga variabl x l 2 pfffx g i1 variant pffx g except variabl x g grow function fx g i1 anoth exampl consid program let top goal g z get innit loop l 3 depict fig1 observ 0 subgoal g 2i1 variant g 2i except variabl g 2i grow fa g 2i1 fig1 innit loop l 3 observ reveal key structur characterist subgoal innit loop function formal follow denit 31 let 0 two atomsfunct 0 said expand variant denot 0 wev 0 variant except may term certain posit aik grow 0 function 0 term like aik call grow term wrt 0 follow result immedi theorem 31 variant b wev b exampl 31 follow line 0 expand variant variant except grow term gt howev follow line 0 expand variant c c b uniabl fx case px x variant py x exampl px fx expand variant px x might doubt would happen innit loop exampl exampl 32 let p logic program g top goal follow innit loop clearli 0 subgoal i1 g i1 subgoal g second x grow fx i1 variant except i1 expand variant follow properti 3 exampl suggest anonym refere theorem 32 let 0 wev 1 jaj ja 0 j 2 k jaikj ja 0 ikj 3 variant jaj 6 ja 0 j exist jaij ja 0 ij proof 1 2 immedi denit 31 2 grow term denit 31 0 variant prove 3 final 4 immedi 2 2 properti use comput expand variant ja 0 j jaj conclud 0 expand variant otherwis determin variant otherwis proceed argument recurs nd grow term check variant except grow term relat variant dene denit 21 yield equival relat exiv ie variant symmetr ie variant b impli b variant transit ie variant b b variant c variant c howev relat wev equival relat theorem 33 1 wev 2 wev b impli b wev 3 wev b b wev c impli wev c impli b wev c proof 1 straightforward theorem 31 2 counterexampl pfx wev px px 6w ev pfx 3 immedi let immedi let although wev transit size set expand variant transit decrea ing follow result immedi theorem 32 corollari 34 wev b b wev c jaj jcj concept expand variant provid basi design loop check mechan logic program function claim support follow theorem theorem 35 let innit sldderiv innit larg subgoal innit mani goal g j 1 proof sinc innit justic given bol 3 page 40 innit subderiv 0 form j 1 0 sinc logic program nite number claus must set claus program invok innit number time 0 set dierent claus use innit number time must innit subderiv 00 form j 1 00 logic program nite number predicatefunctionconst symbol contain innit larg subgoal must innit sequenc 00 j 1 j anc j1 j variant j1 except term j1 whose size increas note innit increas term size 00 must result claus caus term grow function form fi cycl appli mean j variant j1 except term grow j1 fi ie j1 wev j vafcheck base expand variant dene seri loop check mechan logic program function section present four repres vafcheck prove complet denit 41 let p logic program g 0 top goal 1 depth bound dene goal satisfi follow condit 1 j j anc j1 j1 wev j 2 j ja j ja theorem 41 1 v af 1 simpl loop check 2 v af 1 complet wrt leftmost comput rule proof 1 straightforward denit 22 2 let innit sldderiv sinc p nite number claus must set claus p invok innit 4 note 1 order claus fc j 1 necessarili say fc may contain duplic claus say fc c1g number time deriv let set distinct claus appli innit number time proof theorem 35 innit subderiv form j 1 fc distinguish two case subgoal whose size innit larg logic program nite number predic symbol function symbol constant must innit mani atom variant let fb 1 rst variant theorem 31 1 j b j1 wev b j jb j1 condit v af 1 satis lead deriv prune node leftmost subgoal b d1 ii subgoal innit larg size theorem 35 must innit mani atom expand variant grow term let fb 1 rst 1 j b j1 wev b j jb j1 j jb j j condit v af 1 satis deriv prune 2 complet 1 take 1 lead follow immedi corollari theorem 41 corollari 42 innit sldderiv innit subderiv form j satisfi two condit v af 1 1 observ v af 1 identi innit loop base expand variant select subgoal reliabl loop check built take account claus select gener expand variant denit 42 let p logic program g 0 top goal 1 depth bound dene goal satisfi follow condit 1 j j anc j1 j1 wev j 2 j ja j ja 3 j claus select resolv j g theorem 43 1 v af 2 simpl loop check 2 v af 2 complet wrt leftmost comput rule proof 1 straightforward 2 corollari 42 innit sldderiv innit subderiv form 0 satisfi rst two condit v af 2 sinc logic program nite number claus must claus c k resolv innit mani 0 subderiv let rst 0 resolv c k third condit satis conclud proof 2 take 1 lead follow immedi corollari theorem 43 corollari 44 innit sldderiv innit subderiv form j satisfi two condit v af 1 1 special case v af 1 sldderiv prune v af 2 must prune v af 1 convers true exampl consid sldderiv cut v af 1 2 v af 2 2 condit 3 satis lead follow theorem 45 v af 2 reliabl v af 1 consid repetit one claus innit sldderiv constrain loop check develop consid repetit set claus denit 43 let p logic program g 0 top goal 1 depth bound dene goal satisfi follow condit 1 j j anc j1 j1 wev j 2 j ja j ja 3 j claus select resolv j 4 j set claus use deriv j1 j g theorem 46 1 v af 3 simpl loop check 2 v af 3 complet wrt leftmost comput rule proof 1 straightforward 2 corollari 44 innit sldderiv innit subderiv form 0 satisfi rst two condit v af 3 obvious third condit satis well sinc logic program nite number claus must innit sequenc 0 l 1 l j 0 subderiv set claus use deriv 0 l j1 0 l j let rst fourth condit v af 3 satis 2 take 1 lead follow immedi corollari theorem 46 corollari 47 innit sldderiv innit subderiv form j satisfi three condit v af 2 1 j 1 g obvious sldderiv prune v af 3 must prune v af 2 convers true consid sldderiv cut v af 2 2 v af 3 2 condit 4 satis lead follow theorem 48 v af 3 reliabl v af 2 introduc anoth constrain loop check recal concept recurs claus introduc 16 denit 44 16 set claus fr call recurs claus form similar form 0 q x 1 r 1 uniabl q x r mgu contain rm uniabl q 0 x 0 r 0 mgu contain fx x 0 put anoth way fr set recurs claus start head r 0 replac x 0 x appli success lead infer chain form last atom q 0 f x uniabl head r 0 mgu contain exampl 41 set claus fc 11 g p 1 fc 21 g p 2 fc p 3 fc 41 g p 4 recurs claus recurs claus caus subgoal increas size recurs ie cycl fr appli size q 0 increas constant fr repeatedli appli innit number time subgoal q 0 gener innit larg size note recurs claus repeatedli appli sinc logic program nite number claus exist recurs claus program innit sldderiv innit larg subgoal subgoal increas size recurs mean innit sldderiv innit larg subgoal gener repeatedli appli certain set recurs claus lead follow denit 45 let p logic program g 0 top goal 1 depth bound dene goal satisfi follow condit 1 j j anc j1 j1 wev j 2 j ja j ja 3 j claus select resolv j 4 j set claus use deriv j1 j 5 j ja contain recurs claus lead size increas g theorem 49 1 v af 4 simpl loop check 2 v af 4 complet wrt leftmost comput rule proof 1 straightforward 2 corollari 47 innit sldderiv innit subderiv e form 0 satisfi rst four condit v af 4 1 assum j e contain 0 innit larg size innit increas term size e must gener repeat applic recurs claus mean must innit sequenc 0 l 1 l j 0 e claus use deriv 0 l j1 0 l j contain recurs claus lead size increas 0 l j l j1 let rst j satisfi condit 1 obtain follow corollari theorem 49 corollari 410 innit sldderiv innit subderiv form j 1 g size increas result applic set recurs claus fc k c n j g enhanc v af 3 sldderiv prune v af 4 must prune v af 3 convers true consid program consist claus pfa sldderiv pa c1 pfa c2 2 cut v af 3 1 v af 4 1 recurs claus program follow result theorem 411 v af 4 reliabl v af 3 exampl 42 let us choos depth bound 1 appli one four vaf check four illustr innit loop introduc earlier cut node l 1 l 2 l 4 prune g 1 second node root prune g 4 exampl 43 consid follow listrevers program borrow 3 top goal g z note c 53 recurs claus let us choos 1 success appli claus c 52 c 53 c 53 get follow sldderiv easi check expand variant continu expand g 3 rst appli c 51 g 3 gener success node 2 appli c 52 g 3 gener node 3 anc 5 5 wev 3 ja 5 satis stop expand g 5 appli c 53 g 3 gener node obvious 3 anc 6 6 wev 3 ja 6 j ja 3 j size increas 6 via recurs claus c 53 v af 1 4 1 satis stop expand g 6 sinc v af 1 4 1 cut innit branch retain shortest success sldderiv weakli sound g observ condit vafcheck captur one characterist innit loop obvious except 1 5 condit 2 4 make sens 1 expand variant captur key structur characterist subgoal innit loop vafcheck weakli sound major repres logic program see exampl howev consid undecid natur loop check problem choos 1 would safer 5 follow exampl although quit artici illustr point exampl 44 consid follow logic program pfa c 62 follow success sldderiv top goal g 5 mention bol 3 question depth bound optim remain open howev experi show v af22 weakli sound vast major logic program obvious pa anc pfa pfa wev pa c 61 recurs claus choos deriv prune g 1 four vafcheck v af 1 4 1 weakli sound program appar v af 1 4 2 weakli sound observ v af 1 v af 4 reliabl increas comput overhead increas well therefor need consid tradeo choos among vaf check practic applic 1 suggest choos vafcheck follow basic reason prefer experi show v af 2 2 weakli sound vast major logic program ii check condit 3 v af 2 take littl time wherea check recurs claus condit 5 v af 4 rather costli 5 comparison oscheck evacheck oscheck evacheck v af 1 4 complet loop check make comparison base two key factor reliabl comput overhead 51 comparison oscheck begin recal formal denit oscheck denit 51 3 14 let p logic program g 0 top goal 1 depth bound let size sizefunct atom dene goal 1 j three version oscheck depend sizefunct size dene 14 3 rst version atom b condit 2 alway hold thu ignor second version atom third version atom b ariti n jaij jbij obvious third version reliabl rst two version focu third version comparison oscheck complet 3 weak identi innit loop mainli base sizefunct regardless intern structur atom therefor order increas reliabl choos depth bound larg possibl exampl 14 howev intern structur atom function may vari drastic dierent applic program use larg depth bound togeth sizefunct loop check criterion could gener ineectiveineci exampl appli osc10 size program would gener lot redund node follow exampl illustr fact exampl 51 consid follow logic program top goal 100 c 7100 success sldderiv follow z easi see oscd size weakli sound program unless choos 100 contrast approach common structur featur repeat subgoal nite loop character expand variant base expand variant vafcheck weakli sound small depth bound eg 2 major logic program instanc v af 1 4 1 weakli sound p 7 exampl show dramat dierenc discuss summar follow result theorem 51 let size sizefunct third version oscheck atom b wev b impli sizeb sizea proof immedi theorem 32 2 theorem 52 1 4 v af reliabl oscd size proof theorem 51 corollari 34 oscd size satis whenev condit 1 v af hold sldderiv prune v af prune oscd size well revers true counterexampl 100 sldderiv exampl 51 prune oscd size v af 2 discuss comput overhead first note oscheck vaf check ancestor check j anc j1 requir moreov ancestor subgoal j k oscd size comput although comput expand variant littl expens sizefunct process two string ie atom sinc string process far faster ancestor check need scan goalstack assum two kind string comput take constant time wrt scan goalstack assumpt complex oscd size v af 1 2 note check condit 2 3 vafcheck take littl time sinc check condit 4 vafcheck requir scan goalstack v af 3 expens oscd size furthermor condit 5 vafcheck ie comput recurs claus quit expens one hand given logic program need determin claus recurs claus hand two subgoal j j1 ja sldderiv need nd size increas j j1 result recurs claus mean v af 4 could much expens oscd size discuss suggest v af 2 best choic balanc reliabl overhead among oscd size v af 1 4 52 comparison evacheck begin reproduc denit evacheck denit 52 17 let p logic program g 0 top goal 1 depth bound dene goal 1 j 2 k gener variant j g subgoal 0 said gener variant subgoal variant except may argument whose size increas via set recurs claus follow character gener variant immedi denit denit 31 theorem 53 subgoal 0 sldderiv 0 gener variant 0 wev ja 0 j jaj size increas via set recurs claus ev ad reli heavili recurs claus complex similar v af 4 sinc comput recurs claus expens choos ev ad practic applic unless reliabl v af howev follow exampl show ev ad reliabl four vafcheck exampl 52 consid follow logic program top goal pfa c 83 success sldderiv follow easili seen fc 81 c 82 g fc 82 g two set recurs claus let us choos 2 2 gener variant 0 1 ev a2 cut deriv howev sldderiv never cut v af 2 condit 2 vafcheck satis ie ja 6 conclus develop four vafcheck logic program function base notion expand variant observ key structur featur innit loop repetit select subgoal claus recurs increas term size repetit lead variant logic program nite number claus predicatefunctionconst recurs increas introduc grow term notion expand variant exactli catch structur characterist certain subgoal innit loop due vafcheck much reliabl oscheck less reliabl evacheck even small depth bound see exampl 51 52 hand sinc structur inform extract directli individu subgoal without appeal recurs claus vafcheck except v af 4 much ecient evacheck balanc reliabl comput overhead choos v af 2 best one practic applic although v af 2 2 reliabl vast major logic program due undecid loop check problem like complet loop check v af 2 gener weakli sound xed way deal problem heurist tune depth bound practic applic method carri heurist tune present interest open problem studi acknowledg thank anonym refere construct comment greatli improv present rst author support part chines nation natur scienc foundat transcenturi train programm foundat talent chines ministri educ r analysi loop check mechan logic program toward ecient loop check loop check partial deduct tabul resolut wellfound semant tabl evalu delay gener logic program elimin unwant loop prolog note loop prolog termin logic program neverend stori redund elimin loop check logic pro gram foundat logic program partial evalu logic program elimin loop prolog xsb programm manual version 18 mixtu approach automat partial evalu full prolog mixtu automat partial evalu full prolog verifi local strati extend variant atom loop check posit logic program linear tabul resolut well found semant abstract approach loop detect problem old resolut tabul power logic memo logic program tr control recurs infer old resolut tabul effici loop detect prolog use tortoiseandhar techniqu foundat logic program 2nd extend ed recurs queri process power logic analysi loop check mechan logic program partial evalu logic program mixtu approach automat partial evalu full prolog toward effici loop check memo logic program mixtu sound complet partial deduct unfold base wellfound measur redund elimin loop check logic program tabl evalu delay gener logic program extend variant atom loop check posit logic program abstract approach loop detect problem linear tabul resolut wellfound semant ctr yidong shen jiahuai liyan yuan samuel p shen qiang yang dynam approach character termin gener logic program acm transact comput logic tocl v4 n4 p417430 octob etienn payet fred mesnard nontermin infer logic program acm transact program languag system topla v28 n2 p256289 march 2006 alexand serebrenik danni de schrey infer termin condit numer loop prolog theori practic logic program v4 n56 p719751 septemb 2004