controlflow normal algorithm complex singl method normal controlflow program facilit program transform program analysi automat parallel present previou method result program whose control flowgraph reduc program normal techniqu satisfi stronger condit reduc therefor simpler syntax structur previou method particular controlflow cycl normal singleentri singleexit loop goto elimin furthermor method avoid problem code replic characterist nodesplit techniqu restructur obviat control depend graph sinc afterward control depend relat manifest syntax tree program transform effect normal present complex method studi b introduct problem consid normal controlflow program goal facilit program transform program work support part nation scienc foundat grant nsf mip8410110 us depart energi grant defg02 85er25001 offic naval research grant onr n0001488k0686 us air forc offic scientif research grant afosrf4962086c 0136 donat ibm corpor analysi automat parallel sever way techniqu make process easier first reduc number syntact construct must treat system analysi transform lessen complex mani compil algorithm often driven structur program program structur highli regular number case condit must consid analyz parallel program simpli decreas second convert controlflow cycl singleentri singleexit loop elimin branch instruct may dramat consequ compil exampl loop contain exit branch difficult parallel sinc number iter perform unknown prior execut likewis goto may use creat cycl controlflow hidden loop may caus loss parallel loop describ miss techniqu parallel appli loop also controlflow loop sometim entir subroutin may disturb cycl similarli use goto make program transform analys difficult ineffici gener reason simpl composition controlflow lost term semant may say absenc goto direct semant may given wherea presenc continu semant need increas complex continu semant translat increas complex program analysi model semant eg abstract interpret dataflow analysi third techniqu obviat control depend graph much effort spent tradit parallel compil treatment control depend 3 argu controlflow program properli normal control depend relat manifest syntax tree normal program need separ represent depend similarli method make unnecessari perform interv analysi part dataflow analysi normal intern structur program obviou trivial may therefor use simplifi implement dataflow analysi sinc patholog flowgraph 38 exist unnorm program may aris sever way first unstructur program written languag common lisp fortran pascal c second compil may produc unstructur code appli classic program transform tail recurs elimin 14 exampl see figur 1 2 transform recurs split 22 result even complex output tail recurs elimin wish compil work alway normal program may appli normal follow transform lot work done normal controlflow program 10 47 12 5 techniqu result program reduc defun f lambda begin cond null x f car x figur 1 sampl recurs lisp program defun f lambda begin 1 cond null x set r go 2 2 return r figur 2 tail recurs elimin control flowgraph howev method normal present result program highli regular produc method word condit much stronger reduc satisfi control flowgraph result method furthermor previou method controlflow normal result excess code replic show code replic necessari method elimin irreduc condit rare even unstructur program 2 present normal method normal work transform program system simultan equat whose unknown repres continu associ program label solut system equat normal form program effect detect loop elimin patholog syntact construct program contain william ossher 47 prove elimin necessari suffici obtain structur form program theorem bohm jacopini 13 say may transform program anoth one follow three control structur use assign condit ffl iter howev theorem construct give method deriv program techniqu present exactli simpl effici way normal controlflow program consist transform program anoth equival one three forego control structur use input languag treat lisplik syntax includ branch instruct goto label toplevel procedur appli method fortran 77 lelisp 16 6 appli common lisp c 25 output languag contain singleentri singleexit loop neither goto label repres normal form program 21 denot semant semant program languag precis mathemat specif mean program languag 42 45 40 idea approach defin function map syntact construct algebra one method base scott strachey work use defin languag like algol 60 31 pascal 45 clu 39 input languag contain branch instruct simpl jump make semant program complex lose composition semant command must switch direct semant semant continu theori continu develop c wadsworth l morri independ notion origin tail function mazurkiewicz 30 211 continu continu power tool allow us give straightforward mean branch except error allow us regain degre composition lose branch continu instruct function appli store give final result program execut begin instruct result new store state memori usual continu associ point program approach point repres program label author provid interest reader denot semant continu primit express languag 7 8 languag describ follow section 22 abstract cste 2 cste constant command express lambda 2 proc lambda express cmd unop unari oper gamma biop binari oper purpos simplic grammar includ scalar variabl normal method present appli fortran lisp program 6 24 mean restrict treatment scalar data requir restrict upon side effect alias 23 continu equat procedur p may give syntact represent continu associ program label call x figur 3 illustr sampl lisp program obtain program system continu equat figur 4 x 0 sourc continu contain solut system resolut x 1 x 2 x 3 x 4 continu associ label 1 2 3 4 respect unknown system control structur use system three propos bohm jacopini 13 solut system repres normal form procedur next section present method choos solv system 24 gaussian eliminationlik resolut straightforward gaussian eliminationlik resolut method may use solv system continu equat method yield solut defun h lambda j begin 2 10 go 3 1 set j 1 4 set j k 3 figur 3 sampl lisp program figur 4 continu equat program figur 3 number equat unknown solut present refin method see later paper refin improv complex consider gaussian elimin method consist substitut elimin unknown appear system want satisfi two criteria first minim code size accomplish factor second convert everi controlflow cycl loop accomplish derecursiv solv system style gaussian elimin perform transform along way give normal form program 25 transform look continu equat built may remark contain branch regular structur gener equat follow form true fals part statement may contain state ment statement may absent altogeth let us present transform use solv system 251 precalcul effect subtransform use transform present rest paper put boolean express condit statement new temporari variabl temporari defin program exampl follow statement becom precalcul pred 1 exp pred 1 begin cmd 1 252 distribut like precalcul subtransform use transform present rest paper rewrit statement contain continu variabl sequenc two statement first contain condit captur temporari variabl precalcul second one contain continu variabl control temporari variabl condit save temporari variabl avoid multipl comput also guarante correct result sinc argument may affect cmd exampl let us consid equat x distribut equat pred 1 exp pred 1 begin cmd 1 pred 1 x 253 factor one unknown may appear sever time singl equat avoid increas code size elimin process factor equat two differ factor may use factor unknown factor boolean express factor selector variabl factor boolean express consist assembl condit boolean express govern one unknown use distribut replac equat one unknown appear consid continu equat whose form x j guard boolean express exp true rewrit equat pred 1 exp pred 1 cmd 1 cmd 2 pred 1 pred 1 equival pred 1 exp pred 1 cmd 1 cmd 2 add anoth nest level anoth unknown x k begin exp 2 begin cmd 3 x j x j guard exp 1 exp 1 exp 2 x k guard rewrit equat pred 1 pred 1 begin set pred 2 exp 2 pred 2 begin cmd 3 pred 1 build select tree pred 1 order unknown appear insid x increas order number appear case x k appear insid x x j appear twice thu x k treat first select tree case number appear unknown taken order appear insid equat heurist order allow us creat boolean express manag size case sever nest level factor selector express consist replac unknown assign selector variabl singl integ valu associ unknown case statement ad send control appropri continu consid continu equat add variabl selector assign valu unknown equat x j replac set selector 1 rewrit equat begin cmd 2 set selector 1 selector 1 x j add anoth nest level anoth unknown x k begin exp 2 begin cmd 3 x j rewrit equat use selector variabl follow begin exp 2 begin cmd 2 set selector 2 begin cmd 3 set selector 1 selector1 x j selector 2x k cours order place unknown select tree irrelev sinc guard case simpli test valu selector compar two method measur respect cost run experi normal scientif comput perfect club 34 see figur 24 25 section 5 254 derecursiv derecursiv like 1 hecht transform 20 consist make loop explicit selfrecurs equat form intuit equat loop whose entri instruct label x whose condit iter condit lead x case iter loop exp becom fals case perform begin form associ fals part fix point equat begin cmd set pred 1 exp pred 1 cmd 1 cmd 2 pred 1 semant statement iter begin form contain insid form pred 1 fals semant repeat therefor suppos loop bodi perform least consid equat anoth level nest begin exp 2 begin cmd 3 x k must studi boolean express guard continu insid equat x j guard exp 1 x k guard final x guard exp 1 exp 2 latter condit repres exit condit loop induc continu pred 1 pred 1 cmd 2 begin set pred 2 pred 2 cmd 3 cmd 4 pred 1 pred 2 pred 1 x j begin pred 2 x k 255 substitut elimin 0 consist substitut unknown continu system elimin equat system howev hecht 20 perform 2 unknown singl use system 0 transform constrain condit sinc replac unknown anywher appear system ie unknown may replac sever differ 2 perform check unknown elimin nonrecurs case derecursiv first equat appear factor avoid sever substitut unknown singl equat system figur 5 elimin x 2 system figur 4 substitut x j x elimin system obtain follow equival system begin cmd 3 x k applic 0 transform reduc number n unknown system n gamma 1 26 exampl resolut system continu equat result program figur 3 present figur 4 solv system use transform present may begin resolut elimin x 2 appear equat x 0 x 4 equival system elimin figur 5 next step may elimin x 1 result system equival system figur 6 sinc x 4 recurs want appli derecursiv transform creat correspond loop elimin transform replac elimin unknown system result system figur 7 figur 8 respect point x 3 appear twice x 0 need factor x 0 result system shown figur 9 final substitut elimin x 3 obtain normal form figur 10 27 structur origin program build continu equat attempt preserv much possibl origin structur program say input procedur contain control construct alreadi normal normal mean neither branch instruct leav construct branch instruct enter construct preserv normal figur 11 loop alreadi normal associ figur elimin x 1 system figur 5 pred 1 10 pred 1 pred 1 figur 7 derecursiv x 4 system figur 6 begin begin set j k set pred 1 10 pred 1 pred 1 x 3 figur 8 elimin x 4 system figur 7 pred 2 10 pred 2 begin set j k set pred 1 10 pred 1 pred 1 figur 9 factor x 0 system figur 8 defun h lambda j begin pred 2 10 pred 2 begin begin pred 1 10 pred 1 pred 1 figur 10 normal form program figur 3 continu equat system figur 12 treat assign statement look program figur 13 loop exit insid case loop first rewritten term goto if shown figur 14 convert normal form 3 order resolut system figur 4 elimin unknown arbitrari order easi see qualiti normal form program term code size depend upon order unknown elimin system give idea import order let us take previou system equat figur 4 tri elimin unknown differ order let us choos follow order resolut system elimin x 1 figur 15 variabl x 3 x 4 occur equat x 2 elimin x 4 lead equival system figur 16 x 2 recurs derecursiv substitut obtain system figur 17 final elimin x 3 obtain normal program figur 18 cours program figur 10 semant equival second one contain replic code bodi loop restrain strictli code depend upon ie code insid loop bodi need defun f lambda j b n begin 1 set 1 begin set b j figur 11 program contain normal control structur figur 12 continu equat system program figur 11 defun g lambda j b n begin 1 set 1 begin set b j 2 set b j 1 figur 13 program contain nonnorm control structur defun g lambda j b n begin 1 set 1 g n go g 1 2 set b j 1 figur 14 equival form program figur 13 figur 15 elimin x 1 system figur 4 figur elimin x 4 system figur 15 begin set pred 1 10 pred 1 pred 1 x 3 figur 17 elimin x 2 system figur defun h lambda j begin begin pred 1 10 pred 1 pred 1 figur normal form program figur 3 observ order resolut import impact run time resolut process code replic order resolut propos follow first sort extend topolog order node graph associ equat second move loop header order appear unknown repres bodi note algorithm slightli differ classic method interv analysi normal method make use strongli connect compon topolog sort acycl continu flowgraph solv system continu next section describ elimin order unknown 31 graph topolog sort graph e associ system equat repres control flowgraph program defin take node unknown system creat edg unknown x j appear insid equat x jn number node edg exampl graph associ system equat figur 4 figur 19 topolog order node graph label node integ cours graph must acycl order meaning sinc gener input graph contain cycl order node first elimin back cross edg graph sort result graph topolog order call extend topolog sort graph visit graph node depthfirst order complex combin algorithm kept figur 19 x 2 singl loop header bodi consist unknown x 1 x 4 extend topolog order next step figur 19 graph associ system figur 4 reorder loop header x 2 must appear x 1 x 4 two unknown bodi order resolut use previou exampl follow order 32 algorithm find order resolut input list h loop header list b h label bodi loop header h list l unknown order extend topolog order output order list unknown unknown x l ffl delet x l insert immedi unknown constitut bodi loop design x unknown given b x 33 algorithm resolut system input order list unknown l output sourc label whose equat repres normal form program 1 select first unknown x l 2 x selfrecurs ffl derecursiv x appli x j x element unknown set ffl factor occurr x x j ffl substitut x x j appli 0 3 l nonempti goto 1 34 exampl let us consid irreduc program figur 20 give detail transform perform continu equat system present system figur 21 associ continu graph figur two nest loop graph whose header order resolut normal form rel order figur 23 defun g lambda j x begin 1 2 set x 3 set 1 x begin x go 5 4 set j 1 5 set j 2 figur 20 irreduc program figur 21 continu equat program figur 20 figur 22 continu graph system figur 21 defun g lambda j x begin begin pred 1 0 pred 1 begin pred 2 x pred 2 begin set pred 3 x j pred 2 pred 3 pred 1 pred 2 pred 3 pred 2 pred 1 pred 3 figur 23 normal form irreduc program figur 20 4 complex section analyz complex normal method count number transform necessari solv system continu equat complet time space complex studi would involv us detail data structur beyond scope paper howev analysi reveal import aspect complex normal algorithm extend complet one consid cost appli individu transform chosen represent program let system continu equat e graph associ 2 n let jn repres set node enter node altern set unknown whose equat appear dj degre multipl edg j ie number time appear equat j n total number substitut perform resolut pro cess n f repres number factor n number derecur sivat 41 number substitut show number substitut perform resolut exceed number unknown n system case g reduc theorem 1 g reduc equat substitut system proof let mean appear least equat k want substitut unknown system seen algorithm substitut equat k k factor occur equat k sever case may appear substitut system case appear sever equat system may insid loop whose header h may repres header loop 1 final may neither two case let sourc node graph case 1 simplest case sever predecessor neither loop header insid loop accord resolut order chosen predecessor treat come substitut appear equat nearest domin h 2 factor h appear h substitut case 2 loop whose header h h distinct case order chosen fact g reduc predecessor loop except treat come substitut appear equat h fact h domin factor h appear system therefor replac substitut case 3 loop header accord resolut order describ earlier treat everi node insid loop header let h header innermost loop contain loop loop treat therefor selfrecurs variabl appear reduc everi controlflow cycl g uniqu loop header domin everi node bodi loop also equat h derecursiv factor h substitut system sinc n equat system nin irreduc graph method may replic code worst case without preliminari factor number substitut unknown bound number predecessor theorem 2 g irreduc unknown substitut n time proof first step elimin first unknown substitut worst case time second time substitut ngamma2 time sinc first substitut one unknown definit elimin system elimin unknown number substitut note bound conserv assum control flowgraph program cliqu 42 number factor look algorithm resolut section 33 see factor appli predecessor x j x substitut x factor cours unnecessari x occur equat must note appli one singl step factor x j effect reduc instanc occurr x j one degre edg x j everi occurr x j 1 number instanc variabl insid equat bound n singl factor step abl reduc instanc one worst case factor necessari everi substitut therefor n f n 43 number derecursiv derecursiv perform everi time node occurr number derecursiv depend upon number loop header entir graph worst case everi node graph loop header conserv bound summari number transform perform case reduc flowgraph order number continu equat system cours studi complex take account size continu equat time necessari substitu tion find within equat unknown substitut factor cost collect simplifi boolean condit 5 applic normal process normal method present put sever use project author involv paf 44 miprac 24 paf experiment fortran parallel develop univers pari 6 franc paf normal method two applic first convert everi cycl explicit implicit loop transform loop whenev possibl 9 final doall loop depend permit word even programm write loop use goto write unstructur loop made elig parallel normal second purpos vector order vector statement condit execut loop one must attach boolean variabl mode vector statement 29 48 17 32 controlflow normal may accomplish easili program miprac multilingu compil share memori machin implement univers illinoi applic normal method much ambiti first allow us write genuin multilingu compil miprac accept program common lisp c scheme fortran togeth four languag contain mani control structur dolist dotim loop cond block return break case switch exit goto continu paus normal three controlstructur remain begin moreov intermedi form properli structur word multilingu miprac mean program variou languag simpl structur represent miprac intermedi form accomplish normal second applic simplifi program analysi effect normal allow program requir continu semant goto convert program may given direct semant ex ampl program goto might mean function type normal program would mean function type store store simplif show write analysi program well wherea abstract interpret unnorm program might function type store abstract memori abstract interpret normal program could function store make analysi simpler implement effici reader may contrast interprocedur analysi continu use 22 direct semant appli program whose procedur bodi normal 23 third applic simplifi program transform restructur express need concern branch middl middl express control flow express orderli way reader may look harrison work 21 see difficulti may encount program transform exitloop parallel recurs split 22 perform code structur controlflow normal effect make loop transform applic iter structur replac arbitrari controlflow cycl singleentri singleexit loop reduc number differ syntact structur program point normal quit differ program point program text known user problem fairli easili solv observ express normal program come exactli one express sourc map transform program origin sourc welldefin maintain state section 253 compar run experi perfect code factor use boolean express selector expr sion measur number boolean express selector express gener code replic result without factor see figur 24 25 column ebn give number express present program normal column eanf give number express program normal factor column bexp give number boolean express ad factor column sexp give number selector express selector express assign selector variabl ad factor column bexpeanf give ratio count likewis ratio sexpeanf column ean give number express program normal without repres growth code factor perform ebn growth code normal factor note factor use neither boolean selector express ad program normal izat factor boolean express requir everi predic guard condit statement store temporari variabl see transform distribut temporari variabl necessari factor selector express perform reason ebn code differ valu factor perform use selector express versu use boolean express averag ratio boolean express bexp creat total number express program eanf 001 averag ratio selector express sexp creat total number express program eanf 0004 compar gf g may see gf alway smaller g except factor trfd selector express boolean express creat reason size code gf neg due fact normal process simplifi sourc code produc compact form code exampl label goto sourc code elimin nb miprac fortran c cl frontend translat everi loop use goto label 2 therefor column ebn includ label goto ad frontend account much neg code growth clear look measur factor selector express result less code growth factor boolean expr sion although case growth seem manag main reason small number boolean express use heurist order allow us creat boolean express manag size case sever nest level miprac use phase boolean express simplif rather factor selector express use excess boolean express creat appear howev boolean express gener normal small enough simplif would major expens 6 posit work sever techniqu exist structur flowgraph 13 28 33 11 12 5 techniqu consist modif elimin goto statement ad controlflow variabl copi code creat call procedur ad level iter may appropri case howev program produc often less regular produc method often contain replic code 27 none present simpl comprehens algorithm normal control flowgraph present limit overview method howev emphas kennedi method 5 sinc recent closest method bohm jacopini 13 present two normal method flow diagram decompos flow diagram base diagram three type two type method like add boolean variabl replic code 2 motiv first singl represent sourc code written three differ languag second uniform represent loop goto break code ebn eanf bexp ean bexpean gf g mdg 13870 13648 43 19342 0003 222 5472 migrat 43369 42716 154 43899 0003 653 530 total 426648 416968 4915 605491 001 10774 178843 figur 24 factor boolean express code ebn eanf sexp ean bexpean gf g migrat 42349 41912 178 42632 0004 437 283 total 414088 401772 1868 587513 0004 12316 173425 figur 25 factor selector express even normal reduc flowgraph furthermor author present simpl algorithm rather describ method patternmatch flowgraph could complex costli implement knuth floyd 28 studi program transform elimin goto statement without introduc new variabl modifi sequenc program comput first possibl elimin goto introduc procedur sometim quit clean solut except procedurecal overhead may import program involv mani loop iter second possibl write flowchart accord bnf defin method replic code normal reduc flowgraph author declar method suffic elimin goto program peterson kasami tokura 33 defin wellform program program loop condit statement properli nest singl entri obtain program use node split transform may replic code procedur call case code replic big method replic code normal reduc flowgraph bound given size result program result program multipleexit loop branch exit sever nest control structur ashcroft manna 11 introduc two transform translat program goto program without first one add temporari variabl second add logic variabl program first method replic code normal reduc flowgraph method result loop multipl exit baker 12 concentr make program understand rather elimin goto statement entir goto statement gener give clearer descript controlflow syntact restrict impos upon input program well algorithm divid two step locat loop flowgraph ad branch statement first step use classic notion domin 2 build depthfirst span tree flowgraph second step algorithm add branch statement basic form program gener first step algorithm extend handl irreduc graph shortcom baker method first goto remain second loop may left multipl exit third number control form greater method result syntax still fairli complex allen kennedi method convert control depend data depend call convers 5 primari goal transform transform program purpos vector take everi loop program transform statement guard one beyond goal transform may use applic code structur goto elimin convers perform three step first step analyz branch code classifi goto 300 200 figur 26 program cycl either exit branch backward branch forward branch second step branch reloc last step branch remov exit branch defin one termin loop forward branch defin one whose target loop nest level preced target lexic backward branch defin one whose target loop nest level follow target lexic branch reloc move branch loop branch target loop nest level branch remov elimin forward branch attach guard express target convers goal similar normal method shortcom present along differ work exampl use taken allen kennedi paper 5 written fortranlik syntax normal form also written syntax order make differ appar first problem convers backward branch improperli identifi whose target preced lexic thu program figur 26 treat refer paper 5 cycl convers algorithm detect goto 100 backward branch follow care controlflow code loop program program obtain convers figur 27 method factor perform sinc two differ path could taken arriv label 300 final normal form shown figur 28 written fortranlik syntax facilit comparison second problem convers adhoc treatment irreduc program let us take exampl program figur 29 transform convers program figur 30 boolean variabl use record branch taken reach statement loop bodi result program contain goto cycl controlflow replac structur loop subsequ transform describ refer paper 5 must use replac backward branch loop contrast method produc program figur 31 use uniform treatment reduc irreduc flowgraph sinc flowgraph irreduc code replic notic convers introduc addit loopcarri depend variabl bb1 goto 300 elimin 200 bb1 br1 s2 bb1 br1 goto 100 figur 27 program figur 26 convers pred162 pred162 andpred164 s1 figur 28 normal form program figur 26 present program figur 31 depend may inhibit parallel loop third problem convers extra gener boolean express guard statement program program figur equival convers one figur 33 look normal form figur 34 correspond program figur 32 see latter form straightforward dataflow analysi would accur two reason first statement 5 guard condit therefor may easili conclud definit array b reach program wherea program figur 33 necessit deeper analysi account boolean guard arriv conclus second easi see control structur program figur 34 definit variabl x statement 2 reach last definit statement 1 200 figur 29 exampl irreduc code 200 goto 100 figur 30 convers program figur 29 pred50 pred50 andnot pred52 repeat pred52 figur normal form program figur 29 figur reachabl use br1 br1 br1 br1 andnot br2 ornot br1 andnot br2 figur 33 convers program figur previou definit x convert code deeper analysi necessari perhap conserv decis would taken 7 relat applic gaussian elimin like method sever problem close relat controlflow normal make use gaussian elimin resolut includ global flow analysi 19 20 shortest path problem 15 18 26 convers finit automata regular express 41 fundament framework problem build system equat base region flowgraph solv system use gaussian resolut follow give overview method allen cock interv analysi hecht ullman analysi tar jan interv analysi final graham wegman analysi latter three improv first one literatur algorithm pred20 pred22 notnot pred20 pred22 figur 34 normal form program figur call elimin algorithm ryder paull present comparison four algorithm 38 gener describ specif implementa tion therefor difficult see common point differ goal give present algorithm describ complex perform want emphas follow four algorithm method program normal rather present show reader gaussian eliminationlik solut system wide use similar problem sever improv complex studi algorithm use global dataflow analysi e repres number edg flowgraph assum order n number node flowgraph 71 allen cock method method known interv analysi introduc allen cock 35 treat irreduc graph adjust handl equat use quit differ repres dataflow equat program describ reach definit variabl program 4 38 allen cock algorithm consist iter three phase partit algorithm find singl entri region depend graph elimin dataflow equat final propag elimin process turn applic success substitut loopbreak transform latter transform equival derecursiv transform describ earlier paper unknown system elimin natur order node graph ad interv propag backsubstitut perform propag global dataflow side effect region appli consist find variabl correspond substitut interv head variabl solut reduc equat process reduc system smaller one produc 2 solut 72 hecht ullman method algorithm also applic reduc graph take input system equat analog one describ allen cock algorithm depend graph ie control flowgraph elimin process direct region graph much allen cock algorithm consist appli transform 1 2 describ paper earlier region search common factor reduc equat allow save calcul 1 37 46 improv provid complex log n rather 2 allen cock complex 73 tarjan method tarjan method use differ notion interv method sens repres loop control flowgraph calcul interv implicit order aris allen cock method order use calcul reduc equat clear order follow one depthfirst order graph resolut like hecht method base upon 1 2 transform shown 3 transform composit two previou one method appli reduc flowgraph graph algorithm requir time onffn ff invers ackerman function simpler algorithm run log n exist 43 74 graham wegman method algorithm close tarjan interv analysi handl irreduc graph without need elimin irreduc notion interv call sset 19 repres loop flowgraph sset defin number node depend graph associ equat number perform use depthfirst order elimin process perform use three transform similar hecht ullman algorithm name 1 2 3 applic transform restrict node one predecessor 1 1 consist loopbreak derecursiv frame work 2 consist substitut node sever successor transform necessari elimin node k successor substitut perform way hecht ullman algo rithm term substitut success rather substitut entir right hand side equat allen cock algorithm final 3 elimin node successor algorithm run time log n 75 conclus algorithm present refin gaussian elimin like algorithm two relationship work describ first method use gaussian elimin method similar respect second solv dataflow analysi problem much difficulti come irregular structur underli control flowgraph use method like structur made regular result analysi algorithm made simpler normal program anticip much comput dataflow solut program solv dataflow problem much effici normal process perform program simplif affect forward backward dataflow problem solv program backward flowgraph normal program also normal wherea flowgraph mere structur may unstructur edg revers final even though closur may still requir loop especi nonfast problem 19 43 simpler nonnorm program 8 conclus paper present algebra framework normal controlflow framework made easi us prove transform preserv semant program applic varieti languag power exist method sever respect first method base upon nodesplit 12 convers 5 branch instruct remain transform code replic may occur even normal program whose flowgraph reduc method elimin branch instruct replic code elimin irreduc rare condit even unstructur program second previou method result program reduc flow graph method yield program whose control flowgraph highli structur yet particular controlflow cycl normal singl entri singleexit loop loop may transform convent loop induct variabl recognit 6 9 make method particularli help automat parallel highli regular loop structur essenti 32 22 simplifi forward backward dataflow analys transform program one obviou trivial intern structur third method make separ represent control depend unnecessari program normal method control depend effect repres directli syntax tree sinc condit structur contain express control sinc analysi control depend central work parallel program 3 signific simplif work implement paf 44 parallel fortran program written univers pari 6 miprac multilingu parallel program univers illinoi miprac measur hand exampl ratio total normal time total compil time approxim 002 total compil time includ pars normal interprocedur analysi intraprocedur dataflow analysi restructur averag compil time exampl 185 second expect ratio decreas time measur take account addit pass miprac current implement acknowledg wish thank luddi harrison help idea suggest improv paper also thank anonym refere comment earlier draft paper r design analysi comput algorithm theori pars overview ptran analysi system multiprocess program data flow analysi procedur convers control depend data depend restructur de programm fortran en vue de leur parallelis normal program control flow controlflow normal algorithm complex iti translat goto program program translat program schema whileschema algorithm structur flowgraph flow diagram algebra network rout problem kaps1 advanc sourcetosourc vector s1 mark iia supercomput shortest path fast usual linear algorithm global flow analysi flow analysi comput program effici algorithm shortest path spars network structur program goto statement note avoid go statement structur advanc vector pipelin processor prove algorithm tail function mathemat semant algol 60 advanc compil optim super comput capabl perfect club report combinatori algorithm theori practic increment data flow analysi base unifi model elimin algorithm elimin algorithm data flow analysi denot semant clu denot semant represent event nerv net finit automata denot semant schottstrachey approach program languag theori fast algorithm solv path problem paf un paralleliseur automatiqu pour fortran denot semant program languag fast algorithm elimin common subexpr sion convers unstructur flow diagram structur optim supercompil supercomput tr advanc compil optim supercomput elimin algorithm data flow analysi automat recognit induct variabl recurr relat abstract interpret fast usual linear algorithm global flow analysi effici algorithm shortest path spars network algorithm structur flowgraph fast algorithm solv path problem structur program italicgo toital statement program data flow analysi procedur denot semant program languag capabl repeat exit statement flow diagram ture machin languag two format rule algorithm 97 shortest path denot semant flow analysi comput program increment data flow analysi convers control depend data depend theori pars translat compil design automat parallel symbol numer program optim compil lexic scope lisp denot semant clu optim supercompil supercomput ctr j bergstra b dinesh j field j heer toward complet transform toolkit compil acm transact program languag system topla v19 n5 p639684 sept 1997 fubo zhang erik h dholland use hammock graph structur program ieee transact softwar engin v30 n4 p231245 april 2004 g j van den brand p klint c verhoef revers engin system renovationan annot bibliographi acm sigsoft softwar engin note v22 n1 p5768 jan 1997 todd proebst scott watterson krakatoa decompil java dose bytecod reveal sourc proceed 3rd confer usenix confer objectori technolog coot p1414 june 1620 1997 portland oregon johan janssen henk corpora make graph reduc control node split acm transact program languag system topla v19 n6 p10311052 nov 1997 larri carter jeann ferrant clark thomborson folklor confirm reduc flow graph exponenti larger acm sigplan notic v38 n1 p106114 januari baowen xu ju qian xiaofang zhang zhongqiang wu lin chen brief survey program slice acm sigsoft softwar engin note v30 n2 march 2005 peng zhao jo nelson amar ablego function outlin partial inlin framework research articl softwarepractic experi v37 n5 p465491 april 2007 j koehler r hauser sendal wahler declar techniqu modeldriven busi process integr ibm system journal v44 n1 p4765 januari 2005