priorit multiprocessor spin lock abstractin paper present pr lock priorit spin lock mutual exclus algorithm pr lock contentionfre spin lock block process spin local store cach variabl contrast previou work priorit spin lock algorithm maintain pointer lock holder result spin lock support oper lock holder eg abort ceil protocol unlik previou algorithm work maintain prioriti queue done process acquir lock block anyway releas lock constant time oper present simul result demonstr priorit acquisit lock compar perform pr lock best altern priorit spin lock b introduct mutual exclus fundament synchron primit exclus access critic section share resourc multiprocessor 17 spinlock one mechan use provid mutual exclus share memori multiprocessor 2 spinlock usual implement use atom read modifywrit instruct testset compareswap avail sharedmemori multiprocessor 16 busi wait effect critic section small processor resourc need process interim howev spinlock usual fair naiv implement sever limit perform due network memori content 1 11 care design avoid content requir process spin local store cach variabl 19 real time system process time constraint associ prioriti indic urgenc process 26 prioriti use oper system order render servic among compet process normal higher prioriti process faster request servic get honor synchron primit disregard prioriti lower prioriti process may block execut process higher prioriti stricter time constraint 24 23 prioriti may caus higher prioriti process miss deadlin lead failur real time system work done synchron base prioriti thu suitabl real time system furthermor gener purpos parallel process system often process import other kernel process process hold mani lock etc perform system benefit priorit access critic section paper present priorit spinlock algorithm prlock prlock algorithm suitabl use system either use staticprior schedul use dynamicprior schedul rel prioriti exist task chang block earliest deadlin first 26 minimum laxiti 15 prlock contentionfre lock 19 use creat excess network memori content prlock maintain queue record one record process request yet releas lock queue maintain sort order except head record acquir lock oper releas lock oper perform constant time result queue order maintain process block anyway high prioriti task perform work low prioriti task releas lock lock keep pointer record lock holder aid implement prioriti inherit protocol 24 23 task lock request releas perform welldefin point time make lock predict present correct proof simul result demonstr priorit lock access local refer improv previous propos priorit spin lock organ paper follow section 11 describ previou work area section 2 present algorithm section 3 argu correct algorithm section 4 discuss extens algorithm present section 2 section 5 show simul result compar perform prlock similar algorithm section 6 conclud paper suggest applic futur extens prlock algorithm 11 previou work prlock algorithm base mcslock algorithm spinlock mutual exclus algorithm sharedmemori multiprocessor 19 mcslock grant lock request fifo order block process spin local access flag variabl avoid content usual associ busywait multiprocessor 1 11 process record repres place lock queue mcslock algorithm maintain pointer tail lock queue process add queue swap current content tail pointer address record previou tail nil process acquir lock otherwis process insert pointer record record previou tail spin flag record head queue record lock holder lock holder releas lock reset flag successor record successor exist lock holder set tail pointer nil use compareswap instruct moleski shen zlokapa 20 describ priorit spin lock use testandset instruct algorithm base burn fair testandset mutual exclus algorithm 5 howev lock contentionfre markato leblanc 18 present priorit spinlock algorithm base mcslock algorithm acquir lock algorithm almost mc acquir lock algorithm except markato algorithm maintain doubli link list lock holder releas lock search highest prioriti process queue process record move head queue flag reset howev point task request releas lock well defin lock holder might releas lock low prioriti task even though higher prioriti task enter queue addit work maintain prioriti queue perform lock releas choic make time releas lock unpredict significantli increas time acquir releas lock shown section 5 craig 10 propos modif mc lock markato lock substitut atom swap compareswap instruct permit nest lock use one lock record per process goscinski 12 develop two algorithm mutual exclus real time distribut system algorithm base token pass process request critic section broadcast intent process system one algorithm grant token base prioriti process wherea algorithm grant token process base remain time run process holder token enter critic section util priorit lock demonstr rate monoton schedul theori 9 24 suppos n period process uniprocessor let e c repres execut time cycl time period process assum c 1 c 2 cn assumpt block 9 show j process meet deadlin suppos b j worst case block time process j incur 24 show task meet deadlin thu block high prioriti process lower prioriti process signific impact abil task meet deadlin much work done bound block due lower prioriti process exampl prioriti ceil protocol 24 guarante high prioriti process block lower prioriti process durat one critic section prioriti ceil protocol extend handl dynamicprior schedul 7 multiprocessor 23 8 contribut previou work develop priorit contentionfre spin lock 18 10 directli implement desir prioriti queue algorithm maintain pointer head lock queue record lock holder result prlock use implement prioriti inherit 24 23 work maintain prioriti order perform acquir lock oper task block anyway time requir releas lock small predict reduc length varianc time spent critic section prlock welldefin point time task join lock queue releas lock result guarante highest prioriti wait task alway receiv lock final provid proof correct prlock algorithm similar mcslock algorithm maintain queue block process use compareswap instruct howev mcslock markato lock maintain global pointer tail queue prlock algorithm maintain global pointer head queue mcslock markato lock process queu fifo order wherea prlock queue maintain prioriti order process 21 assumpt make follow assumpt comput environ 1 underli multiprocessor architectur support atom compareswap instruct note mani parallel architectur support instruct relat instruct 13 21 3 28 2 multiprocessor share memori coher cach locallystor global access share memori 3 processor record place queue lock numa architectur record alloc local global access memori record use purpos lifetim queue section 4 allow record use among mani lock queue 4 higher actual number assign prioriti higher prioriti process also assum opposit 5 rel prioriti block process chang accept prioriti assign algorithm includ earliest deadlin first minimum laxiti note process p particip synchron associ uniqu processor p expect queu process preempt though requir correct 22 implement prlock algorithm consist two oper acquir lock oper acquir design lock releas lock oper releas lock process use acquir lock releas lock oper synchron access resourc acquir lockl r critic section releas lockl follow subsect present requir version compareswap need data structur acquir lock releas lock procedur 221 compareswap prlock algorithm make use compareswap instruct code shown figur 1 compareswap often use pointer object record record refer physic memori space object refer data within record current pointer record old previous sampl valu current new pointer record would like substitut old record point old comput record new base object old decid perform swap base object old want set current equal new current still point record old howev even current point old might point differ object one origin read occur old remov data structur reinsert current new object sequenc event detect compareswap known aba problem follow work prakash et al 22 turek et al 27 make use doubleword com pareswap instruct 21 avoid problem counter append current treat part current thu current consist two part valu part current counter part current counter increment everi time modif made current variabl procedur casstructur pointer current old new assum ca oper doubl word atomicf current old els f figur 1 ca use prlock algorithm current old new twice origin size approach reduc probabl occurr aba problem accept level practic applic doubleword compareswap avail address counter pack 32 bit restrict possibl address rang lock record use version compareswap oper current valu target locat return old compareswap fail semant compareswap use given figur 1 version compareswap instruct return true fals use perform addit read 222 data structur basic data structur use prlock algorithm prioriti queue lock l contain pointer first record queue first record queue belong process current use lock process l contain nil process locallystor globallyaccess record insert lock queue process insert record q queue say q ps record p qs process record contain process prioriti nextrecord pointer boolean flag lock process own element busywait lock free addit field data use store applicationdepend inform lock holder nextrecord pointer doubl size variabl one half actual pointer half counter avoid aba problem counter portion pointer two part one bit counter call dq bit use indic whether queu element queue rest bit use actual counter techniqu similar one use prakash et al 22 turek et al 27 counter refer record referenc pointer algorithm counter refer record contain pointer record point dq bit record q fals record queue lock l dq bit true record probabl queue short period time record might queue dq bit set true dq bit let prlock avoid garbag access process keep address record local variabl self addit process requir two local pointer variabl hold previou next queue element navig queue enqueu oper prev node next node data structur use shown figur 2 dq bit pointer field initi true ctr field initi 0 record first use typic queue form prlock algorithm shown figur 3 l point record q 0 current process hold lock record q 0 pointer record q 1 next process highest prioriti among process wait acquir lock l record q 1 point record q 2 next higher prioriti wait process record q n belong process least prioriti among wait process 223 acquir lock oper acquir lock oper call process use critic section resourc guard lock l paramet acquir lock oper lock pointer l record q process pass local variabl self acquir lock oper search correct posit insert q queue use prev node next node keep track current posit figur 4 prev node next node abbrevi p n record point p n q q i1 belong process p p i1 process posit p rp r function map process prioriti posit found q prepar insert make q point q i1 insert commit make q point q use compareswap instruct variou stage final result shown figur 4 acquir lock algorithm given figur 5 acquir lock procedur call data prioriti field process record initi appropri addit dq bit next pointer implicitli true acquir lock oper begin assum lock current free lock pointer l structur pointer f structur object ptr boolean dq structur record f structur structur data data boolean lock integ prioriti structur pointer next share variabl structur pointer l privat variabl structur pointer self prev node next node boolean success failur constant true fals null max prioriti data prioriti nextctr nextptr lock nextdq record structur figur 2 data structur use prlock algorithm figur 3 queue data structur use prlock algorithm start posit prepar commit figur 4 stage acquir lock oper null attempt chang l point record compareswap instruct compareswap success lock inde free process acquir lock without busywait context composit pointer structur algorithm use null pointer zero swap unsuccess acquir process travers queue posit higher equal prioriti process record lower prioriti process record junction found point record higher prioriti process next node point record lower prioriti process process first set link next node attempt chang previou record link record atom compareswap success process set dq flag record fals indic presenc queue process busywait lock bit set fals indic admit critic section three case unsuccess attempt enter queue problem detect examin return valu fail compareswap mark f algorithm note return valu next node addit process might detect misnavig search queue read next node content record point prev node fix record counter read next node 1 concurr acquir lock oper may overtak acquir lock oper insert procedur acquir lockl self f f els f lock use f next nodeprev nodeptrnext ifnext nodedqtru dequ tri ii prev nodeptrpriorityselfptrprior f iii els f ifnext nodeptrnul next nodeptrnul next nodeptrpriorityselfptrpriorityf use lock els f ifnext nodedqtru dequ tri ii prev nodeptrprior els next nodeprev node gwhilesuccess failur figur 5 acquir lock oper procedur record immedi prev node shown figur 10 case compareswap fail posit mark f figur 5 correct oper posit affect oper continu current posit line mark figur 5 2 concurr releas lock oper may overtak acquir lock oper remov record point prev node shown figur 11 case dq bit link pointer record true algorithm check condit scan queue tri commit modif algorithm detect situat two place mark ii figur 5 everi time new record access prev node link pointer read next node dq bit check addit compareswap fail link pointer save next node dq bit test dq bit true algorithm start begin 3 concurr releas lock oper may overtak acquir lock oper remov record point prev node record put back queue shown figur 12 record return prioriti higher equal self prioriti posit still correct oper continu otherwis oper find correct insert point start begin condit test line mark iii figur 5 spinlock busi wait process broken eventu releas lock process immedi ahead wait process 224 releas lock oper releas lock oper straight forward algorithm given figur 6 process p releas lock set dq bit record link pointer true indic record longer queue set dq bit prevent acquir lock oper modifi link releas process copi address successor record l process releas lock set lock boolean variabl record next process wait fals avoid test special case acquir lock oper prioriti head record set highest possibl prioriti 3 correct prlock algorithm section present inform argument correct properti prlock algorithm prove prlock algorithm correct show maintain prioriti queue head procedur releas lockl selff lselfptrnext releas lock ifselfptrnextnullf figur releas lock oper procedur prioriti queue process hold lock prlock decisiveinstruct serializ 25 oper prlock algorithm singl decis instruct decis instruct acquir lock oper success compareswap decis instruct releas lock oper set dq bit correspond concurr execut c queue oper equival respect return valu final state serial execut oper 1 execut decis instruct oper 2 c 1 2 thu equival prioriti queue prlock singl state instant simplifi correct proof concurr data structur lineariz decisiveinstruct serializ might sever state simultan 14 use follow notat discuss prlock l lock pointer l point first record lock queue record process hold lock let n process p 1 particip lock synchron prioriti lock l use prlock algorithm mention earlier process p alloc record q enqueu dequeu thu process p particip lock access associ queue record q let p rp function map process prioriti number 1 n also defin anoth function p rq map record belong process p prioriti prioriti queue abstract data type consist ffl finit set q element simplic assum everi n uniqu assumpt requir correct fact process prioriti obtain lock fcf order ffl two oper enqueu dequeu instant state queue defin call q 0 head record prioriti queue q head record process current lock holder note nonhead record total order enqueu oper defin enqueu dequeu oper nonempti queue defin return valu q 0 dequeu oper empti queue undefin everi prlock l abstract prioriti queue q initi l q empti process p record q perform decis instruct acquir lock oper q chang state enqueu q q similarli process execut decis instruct releas lock oper q chang state dequeueq show observ l find structur equival q observ l take consist snapshot 6 current state system memori next start lock pointer l observ record follow link list head record dq bit set process exit acquir lock oper discard observ observ record sequenc l q say l q equival write l q theorem 1 repres prioriti queue q equival observ queue prlock l proof prove theorem induct decis instruct use follow two lemma releas lock decis instruct q l releas lock decis instruct proof let releas lock decis instruct releas lock oper equival dequeu oper abstract queue definit q1 qn figur 7 observ queue l releas lock figur 8 observ queue l acquir lock state l shown figur 7 l point record q 0 releas lock decis instruct releas lock decis instruct set dq bit q 0 true remov q 0 observ queue thu q l releas lock oper note l point q 1 next releas lock decis instruct 2 acquir lock decis instruct q l acquir lock decis instruct proof two differ case consid case 1 acquir lock decis instruct equival oper abstract queue q enqueu oper thu lock l empti qs process execut success decis compareswap instruct make l point q acquir lock figur 8 clearli q acquir lock decis instruct case 2 acquir lock decis instruct state queue q acquir lock given correspond l acquir lock shown figur 9 pointer p n prev node next node pointer qs acquir lock oper posit record process observ p rq next pointer q set address q i1 figur 9 observ queue l acquir lock compareswap instruct mark f figur 5 attempt make next pointer q point q compareswap instruct succe decis instruct qs process result queue l illustr figur 9 equival q enqueu oper compareswap succe q queue q i1 successor record p rq concurr oper queue observ p n posit correctli compareswap succe concurr oper interfer execut acquir lock oper three possibl case anoth acquir lock enqueu record q 0 q q i1 q yet dequeu p rq qs process attempt insert q q q i1 process 0 modifi q next pointer qs compareswap fail sinc q dequeu process continu search q happen qs process skip q 0 continu search q i1 happen scenario illustr figur 10 case b releas lock oper r overtak remov q queue ie r set q dq bit q yet return queue dq bit still fals sinc q lock queue lost must start search base observ q q i1 may decid continu search queue commit oper either case see dq bit set fail start begin queue scenario illustr figur 11 case c releas lock oper r overtak remov q queue q put back queue anoth acquir lock tri commit oper pointer q chang compareswap fail note even q point q i1 version number prevent decis instruct succeed continu search two possibl base new valu p rq lost find correct place insert q condit detect prioriti q examin line mark iii figur 5 oper restart head queue p still find correct place insert past q q continu figur 10 concurr acquir lock succe f r r restart figur 11 concurr releas lock r succe continu search scenario illustr figur 12 interfer occur alway take right action therefor q l acquir lock decis instruct 2 prove theorem use induct initi point nil q l trivial true suppos theorem true th decis instruct th decis instruct acquir lock oper lemma th decis instruct th decis instruct releas lock oper lemma 1 th decis instruct therefor induct step hold henc q l 2 extens section discuss coupl simpl extens increas util prlock algorithm 41 multipl lock describ record prlock use one lock queue otherwis process might obtain lock one desir realtim system sever critic section lock like process must lock record lock queue wast space fortun simpl extens prlock algorithm allow lock record use mani differ lock queue replac dq bit dq string l bit dq string evalu 0 interpret ri1 ri1 rm rm restart prq prqi continu prq prqi r r figur 12 releas lock r acquir lock succeed binari number record queue lock dq string evalu 0 record probabl queue acquir lock releas lock algorithm carri modifi test queue appropri note process set nest lock new lock record must use level nest craig 10 present method reus record nest lock 42 back process obain lock certain deadlin might wish stop wait continu process process must first remov record lock queue process follow step 1 find preced record lock queue use method algorithm acquir lock oper process determin record head lock queue return lock obtain valu 2 set dq bit dq string process record dequeu 3 perform compar swap predecessor record next pointer process next pointer compareswap fail go 1 compareswap succe return lock releas valu valu processs successor process remov queue without obtain lock compareswap decis instruct compareswap fail predecessor might releas lock third process enqueu predecessor process cant distinguish possibl must research lock queue 5 simul result simul execut prlock algorithm proteu configur multiprocessor simul 4 also implement mcslock markato lock demonstr differ acquisit releas time characterist simul use multiprocessor model eight processor global share memori processor local cach memori 2048 byte size proteu unit execut time cycl process execut uniformli randomli distribut time rang 1 35 cycl issu acquirelock request acquir lock process stay critic section fix number cycl 150 plu anoth uniformli randomli distribut number 1 400 cycl releas lock procedur repeat fifti time averag number cycl taken acquir lock process comput proteu simul parallel repeatedli execut processor program time quanta q simul 10 prioriti process set equal processprocessor number lower number higher prioriti process figur 13 14 show averag time taken process acquir lock use mcslock algorithm prlock algorithm respect process use mcslock algorithm wait fifo queue process everi round howev process use prlock algorithm wait time proport number higher prioriti process exampl highest second highest prioriti process averag wait one critic section period note two highest prioriti process acquir lock execut time altern acquir lock process complet execut third fourth highest prioriti process obtain lock figur 14 clearli demonstr averag acquisit time lock use prlock proport process prioriti wherea averag acquisit time proport number process case mcslock algorithm featur make prlock algorithm attract use real time system figur 15 show averag time taken process acquir lock use markato algorithm priorit lockacquisit behavior shown averag time acquir lock 50 greater prlock use first result puzzl markato lock perform major work lock releas prlock perform work lock acquir howev time releas lock part time spent critic section time acquir lock depend primarili time spent critic section preced lock holder thu prlock allow much faster access critic section see prlock also allow predict access critic section figur show cach hit ratio instanc time processor time cachehit ratio 95 higher processor found averag cach hit rage 9972 9987 thu prlock gener littl network memori content spite process use busywait final compar time requir releas lock use prlock markato lock result shown figur 17 markato lock figur 18 time releas lock use prlock small consist process releas lock use markato lock requir significantli time furthermor experi high prioriti process requir spend significantli averag timecycl x 100 processorprior figur 13 lock acquisit time mcslock algorithm time releas lock requir low prioriti process behavior result way simul run high prioriti process execut low prioriti process block queue result mani record must search high prioriti process releas lock thu high prioriti process work behalf low prioriti process time requir high prioriti process releas lock depend number block process queue result long unpredict amount time requir releas lock sinc lock must releas next process acquir lock time requir acquir lock also made long unpredict 6 conclus paper present prioriti spinlock synchron algorithm prlock suitabl realtim sharedmemori multiprocessor prlock algorithm character priorit lock ac quisit low releas overhead littl buscontent welldefin semant simul result show prlock algorithm perform well practic prioriti lock algorithm use present mutual exclus access critic section use provid higher level synchron construct priorit semaphor monitor prlock maintain pointer record lock holder prlock use implement prioriti inherit protocol final prlock algorithm adapt use singledequeu multipleenqueu parallel prioriti queue averag timecycl x 100 processorprior 28 3213579 figur 14 lock acquisit time prlock algorithm averag timecycl x 100 processorprior figur 15 lock acquisit time markato algorithm time x 10000 processor figur cach hit ratio prlock algorithm averag timecycl processorprior figur 17 lock releas time prlock algorithm averag processorprior figur 18 lock releas time markato algorithm sever priorit spin lock propos prlock follow advantag ffl algorithm content free ffl higher prioriti process work lower prioriti process releas lock result time requir acquir releas lock fast predict ffl prlock welldefin acquirelock point ffl prlock maintain pointer process use lock facilit implement prioriti inherit protocol futur work interest priorit access oper system structur make appropri use realtim parallel oper system r perform spin lock altern share memori multiprocessor concurr program principl practic mutual exclus linear wait use binari share variabl distribut snapshot determin global state distribut system dynam prioriti ceil concurr control protocol realtim system prioriti ceil protocol multipleinst resourc schedul algorithm multiprogram hard realtim environ ment queu spin lock altern support time predict character memori hotspot share memori mimd machin two algorithm mutual exclus realtim distribut comput system methodolog implement highli concurr data object correct condit concurr object perform analysi minimum laxiti earliest deadlin realtim system effici synchron multiprocessor share memori multiprocessor synchron primit prioriti algorithm scalabl synchron sharedmemori multiprocessor predict synchron mechan realtim system prioriti inherit protocol approach realtim synchron concurr search structur algorithm tutori hard realtim system lock without block make lock base concurr data structur algorithm nonblock tr ctr prasad jayanti farray implement applic proceed twentyfirst annual symposium principl distribut comput juli 2124 2002 monterey california jame h anderson yongjik kim ted herman sharedmemori mutual exclus major research trend sinc 1986 distribut comput v16 n23 p75110 septemb