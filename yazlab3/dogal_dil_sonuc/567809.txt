comput given rotat reliabl effici consid effici accur comput given rotat f g posit real number simpli amount comput valu appar trivial comput merit closer consider follow three reason first definit c r seem obviou case two nonneg argument f g enough freedom choic one f g neg zero complex lapack auxiliari routin slartg clartg slargv clargv comput rather differ valu c r mathemat ident valu f g elimin unnecessari ambigu bla technic forum chose singl consist definit given rotat justifi second comput accur valu c r effici possibl reliabl despit overunderflow surprisingli complic complex given rotat effici formula requir one real squar root one real divid well sever much cheaper addit multipl reliabl implement use work precis number case sun ultra10 new implement slightli faster previou lapack implement common case 27 46 time faster correspond vendor refer atla routin also reliabl previou code occasion suffer larg inaccuraci due overunderflow real given rotat also improv speed accuraci though strike third design process led reliabl implement quit systemat could appli design similarli reliabl subroutin b introduct given rotat wide use numer linear algebra given f g given rotat 2by2 unitari matrix rc c fact rc unitari impli c c comput scienc divis univers california berkeley ca 94720 dbindelcsberkeleyedu materi base upon work support nation scienc foundat graduat research fellowship comput scienc divis mathemat dept univers california berkeley ca 94720 demmelcsberkeleyedu materi base part upon work support advanc research project agenc contract daah049510077 via subcontract ora446602 univers tennesse depart energi grant defg0394er25219 contract w31109eng38 via subcontract no 20552402 941322401 argonn nation laboratori nation scienc foundat grant asc9313958 asc9813361 nsf infrastructur grant no cda8722788 cda9401156 comput scienc divis mathemat dept univers california berkeley ca 94720 wkahancsberkeleyedu nersc lawrenc berkeley nation lab osninerscgov see real 2 f g real posit wide accept convent let howev neg c r also satisfi condit 1 2 satisfi 2 also satisfi 1 c r determin uniqu slight ambigu led surpris divers inconsist definit literatur softwar exampl routin slartg clartg slargv clargv level 1 bla routin srotg crotg 6 well algorithm 515 5 get significantli dierent answer mathemat ident input avoid unnecessari divers bla basic linear algebra subroutin technic forum design new bla standard 3 chose pick singl definit given rotat section 2 present justifi design bla technic forum also provid refer implement new standard case comput given rotat kernel routin intermedi overunderflow straightforward implement make output inaccur stop execut even caus infinit loop attempt scale data desir rang even though true mathemat answer might unexcept comput c r ecient possibl reliabl despit overunderflow surprisingli complic particularli complex f g squar root divis far expens real float point oper current machin easi see one real squar root one real divis perhap singl reciprocalsquar root oper necessari comput c r littl algebra manipul also show singl squar root divis also sucient along sever much cheaper addit multipl comput c r complex case contrast algorithm crotg routin fortran refer bla use least 5 squar root 9 divis perhap 13 divis depend implement complex absolut valu function cab howev formula c r use one squar root one divis suscept overunderflow must store intermedi result precis f g defin systemat identifi valu f g formula reliabl ie guarante underflow way unnecessarili lose rel precis overflow gener set simultan linear inequ log f log g defin polygon region safe log f log g space formula may use common situat call case 1 algorithm case new algorithm run 25 faster lapack clartg routin nearli 4 time faster crotg routin vendor bla sun ultra10 atla bla fortran refer bla log f log g lie outsid two possibl scale f g constant fit insid use dierent formula scale may interpret geometr shift parallel diagon line log log g log f log g space region cover shift imag ss shadow region scale possibl part shadow case 4 algorithm scale f g lie insid use previou formula remain region log f log g space includ space outsid ss shadow consist region log f log g dier much f 2 round either f 2 case 2 algorithm case 3 replac f 2 either f 2 g 2 simplifi algorithm dierent formula use addit 4 case 2 simpler one f andor g zero three dierent way deal multipl case first way test branch depend f g appropri formula use portabl method use work precis precis inputoutput argument one explor detail paper second method use except handl ie assum f g fall common case case 1 use correspond formula float point except rais overflow underflow invalid altern formula use 4 sucient fast except handl avail method may fastest third method assum float point format wider expon rang avail store intermedi result case may use main new formula case 1 without fear overunderflow greatli simplifi algorithm case f andor g zero remain exampl ieee doubl precis 11bit expon use input f g ieee singl precis number 8bit expon sun ultra10 mixedprecis algorithm nearli exactli fast case 1 singl precis algorithm describ usual rather faster case 2 4 intel machin doubl extend float point 15bit expon use singl doubl precis input would algorithm choic howev doubl precis input machin like sun ultra10 without doubleextend arithmet doubl precis much slower singl precis new algorithm 4 case best know addit new algorithm significantli faster previou routin accur earlier routin input exhibit larg rel error wherea alway nearli fulli accur rest paper organ follow section 2 present justifi propos definit given rotat section 3 detail dierenc propos definit exist lapack level 1 bla code section 4 describ assumpt float point arithmet section 5 present algorithm complex case simpl case present algorithm common complex case assum neither overflow underflow occur case 1 section 7 show altern formula complex given rotat f g dier greatli magnitud case 2 3 section 8 describ scale f g compar magnitud larg small case 4 section 9 compar accuraci new complex given routin sever altern accur case section 10 discuss perform complex given routin section 11 12 13 discuss algorithm accuraci time real given rotat rather easier section 14 draw conclus actual softwar includ appendix given rotat use follow function defin complex variabl x follow signx clearli continu function away x 0 x real definit simpli state introduct need extra requir besid 1 2 order determin c henc r uniqu least one f g nonzero deduc first compon rc sf g 1 real fact c must real deduc f 0 state chosen arbitrarili long satisfi 2 extra requir initi chosen bla technic forum help resolv choic sign 3 4 follow definit real complex data consist real data pass complex algorithm result answer modulo roundo real algorithm current lapack subroutin use given rotat continu work correctli new definit current lapack subroutin slartg clartg comput singl real complex given rotat resp satisfi requir 1 furthermor lapack subroutin slargv clargv comput multipl given rotat comput answer slartg clartg resp dierenc describ section 3 chang practic need consist definit inde origin motiv bla technic forum simpli adopt lapack definit unchang howev immedi resolv choic sign 1 proceed add requir r3 map f g c r continu whenev possibl continu c function f g possibl everywher real f g approach 0 along real line sin c must discontinu 0 0 consid c r function f increas 0 2 ie f travers unit circl complex plane consid common convent c increas remain equal 1 sinc c real continu impli c stay fix henc continu desir thu requir r3 impli c must nonneg togeth 3 impli f 0 obvious defin f g r continu away simplifi attract r1 0 ident matrix use multipli arbitrari pair vector requir work light requir r3 sinc c continu signf chang arbitrarili small complex neighborhood 0 hope defin continu argument includ complex f instead ask c r continu function real f 0 complex g 0 ie continu f approach zero right limit easili seen take definit final consid case imposs defin continu sinc f g approach 0 direct instead add requir r4 given choic c choos requir least work rc typic use multipli pair vector r1 requir work set summari algorithm complex real f g follow algorithm 1 comput given rotat includ case must nonzero els f g nonzero endif f g real algorithm slightli simplifi replac g g 21 except case algorithm run ieee float point arithmet 2 possibl input might nan notanumb symbol section discuss valu c r case insist routin must termin return output valu case say complex number nan least one real imaginari part nan say complex number infinit least one real imaginari part infinit neither nan first suppos least one nan occur input semant nan binari unari arithmet oper nan return nan extens routin ought return nan well see definit necessarili sinc implement might reason still return sinc requir arithmet oper comput rather specifi exactli happen input nan insist least r nan perhap c well implementor discret permit discret nan hope rare comput insist test case might slow code much common case illustr challeng correct portabl code nan consid comput maxa b need comput f g max implement hardwar softwar b els b max0 nan return nan maxnan return 0 hand equal reason implement b b els instead return 0 nan respect thu implement might mistakenli decid miss nan g model implement work implement max next suppos least one occur input nan case reason return limit valu definit exist nan otherwis exampl one might return sinc welldefin r g one could simpli return nan even limit exist exampl return avoid overspecifi rare case therebi possibl slow common case leav implementor discret approach take insist least r either infinit nan assidu reader note algorithm 1 leav ambigu sign zero treat includ 0 0 dierent implement free return 0 0 whenev zero deliv seem littl gain insist exampl would actual comput r1 0 multipli vector 3 dierenc current lapack bla code short summari dierenc algorithm 1 algorithm lapack 30 1 earlier version level 1 bla 6 lapack algorithm question slartg clartg slargv clargv level 1 bla routin srotg crotg lapack releas 30 test code pass well new given rotat old one inde one test failur old code disappear new rotat new definit given rotat satisfi requir r2 return comment slartg save work mean lapack bidiagon svd routin g nonzero slartg return neg valu c r return algorithm 1 algorithm 1 mathemat ident clartg numer ident see section 9 return return return return g 0 clargv return r g quantiti z one reconstruct c otherwis besid dierenc r assign sign g long either f g nonzero rather sign f 1 comput quantiti like z crotg set g nonzero match algorithm 1 mathemat numer assumpt float point arithmet lapack routin slamch dlamch avail return variou machin constant need particular assum machin epsilon avail power machin radix machin ieee float point arithmet 2 either 2 24 singl 2 53 doubl also use safmin intend smallest normal power radix whose reciproc comput without overflow ieee machin underflow threshold 2 126 singl 2 1022 doubl howev machin complex divis implement compil fastest riski algorithm expon rang eectiv halv sinc c 2 even though true quotient near 1 machin safmin may set safmin indic result scale algorithm make assumpt proxim safmin actual underflow threshold inde tini valu rather less lead correct code though closer safmin underflow threshold fewer scale step need extrem case algorithm also work correctli accur whether underflow gradual import processor default fast mode replac underflow quantiti zero mean eectiv underflow threshold safmin sinc underflow x caus rel error safminx roundo scale algorithm use quantiti z safmin 14 round nearest power radix thu use z eectiv underflow threshold z overflow threshold note may safe add subtract mani quantiti bound magnitud z 4 without incur overflow repeat algorithm work correctli slowli conserv estim safmin use ie one larg power z use softwar comput first call save reus later call valu z power ieee machin safmin equal underflow threshold follow singl precis doubl precis z z input includ nan assum semant ieee arithmet 2 use later discuss denot actual overflow threshold ov underflow threshold un smallest posit number 2un machin gradual underflow un otherwis 5 complex algorithm follow use convent capit variabl name c r data comput f g use notat ref imf mean real imaginari part f w maxr w im w complex number w begin elimin easi case least one f g zero variabl f g r complex rest real algorithm 2 comput given rotat includ case els g must nonzero scale g power z 4 z 2 g z 2 unscal r power z 4 els f g nonzero use algorithm describ endif note even though easi case need scale g avoid overunderflow comput reg2img2 51 except case discuss except handl notic speed code implement test g0 f0 precomput use later test whether sg0 sf0 describ section 21 either test might succeed even though real imaginari part f g nan therefor logic algorithm must chang slightli shown algorithm 2e comput given rotat except handl includ case case g nan make sure r els g must nonzero scale g power z 4 z 2 g z 2 limit number scale step case g infinit nan unscal r power z 4 case f nan make sure r els f g nonzero use algorithm describ endif test scaleg0 succeed one part g 0 nan must return instead r f make sure input nan propag output r note output c1 s0 even nan infin input similarli branch taken g nan infin mean loop scale g scaleg rang might termin written without upper bound maximum number step take maximum essenti maxlog z ovlog z time depend strongli implement detail scale use unrol loop structur etc algorithm use could probabl improv tune particular compil architectur c alway zero nan g either infinit nan r infinit precis g infinit 6 complex algorithm f g nonzero assum f g nonzero comput c r follow code fragment employ one divis one squar root last column show algebra exact quantiti comput line code assum realcomplex multipl perform two real multipl fortran implement explicitli rather reli compil variabl f g r complex rest real algorithm 3 fast complex given rotat f g well scale 1 f2 ref2 2 g2 reg2 3 fg2 f2 4 5 c f2d1 f f 2 7 r 8 fd1 f f f 2 g 2 9 conjg f f recal z safmin 14 z 4 eectiv overflow threshold z 4 eectiv underflow threshold region algorithm run reliabl describ follow inequ number correspond line algorithm logarithm base 2 1 assum f z 2 prevent overflow comput f2 2 assum g z 2 prevent overflow comput g2 3 line safe given previou assumpt 4a assum z 2 f prevent underflow f2 consequ divis zero comput d1 4b assum f z prevent overflow f 4 term f2fg2 comput d1 4c assum fg z 2 prevent overflow f 2 g 2 term f2fg2 comput d1 either 4d z 4e z 2 fg prevent underflow f2fg2 consequ divis zero comput d1 5 line safe given previou assumpt c underflow deserv 6 gf z 4 prevent overflow fg2 sinc 1 gf larg 7 line safe given previou assumpt return r roughli z 1 z 2 smaller compon r underflow deserv un log f log z log g log z un 4b 4a 4c 4d 4e figur 1 inequ describ region unnecessari overunderflow un ov overunderflow threshold smallest represent posit number 8 line safe given previou assumpt return roughli z 2 1 smaller compon may underflow error small compar compon 9 line safe given previou assumpt underflow deserv note inequ list describ half plane log f log g space exampl inequ 6 becom log g log f 4 log z region describ inequ shown figur 1 inequ describ thin line mark arrow indic side inequ hold heavi line border safe region satisfi inequ algorithm safe use remain say decid whether point lie boundari complic time test membership nontrivi accordingli use simplest test like succeed first use expens test particular easiest test threshold comparison f g test membership subset label 1 figur 2 follow algorithm f z f z 1 g z f g region 1 endif call case 1 softwar region 1 contain data f g terribl far 1 magnitud z singl z doubl expect argument especi doubl complement region 1 shown bound dash line figur 2 harder test boundari requir threshold test product fg could overflow test membership region explicitli case someth els instead 61 except case consid consequ nan infin easi see either f g infinit test membership region 1 succeed suce consid nan test like ab evalu fals either b nan case 1 occur nan input f g nan occur describ section 21 examin algorithm 3 see nan f g lead fg2 c r nan 7 complex algorithm f g dier greatli magnitud g 2 round f 2 formula c r may greatli simplifi accur approxim f f 2 region close approxim region g 12 f mark 2 figur 2 call case 2 softwar instead f 2 round g 2 formula c r may greatli simplifi accur approxim g f g g f g f g region close approxim region f 12 g mark 3 figur 2 call case 3 softwar import dierenc formula 7 8 versu formula 5 7 8 independ homogen f g word scale f g independ instead scalar order evalu safe thu shadow region formula safe cover f g pair contrast formula 5 f g must scale valu algorithm implement 7 8 without scale note 7 even requir squar root algorithm 4 comput complex given rotat gf use formula 7 without scale gf endif algorithm 5 comput complex given rotat fg use formula 8 without scale fg endif may appli analysi last section formula deduc linear inequ log f log g must satisfi order guarante safe accur execut simpli summar result case get region boundari like set line segment may vertic horizont diagon wish restrict test f g alon rather product might overflow mean identifi smaller safe region like region 1 within figur 2 membership easili test safe region algorithm 4 set satisfi z 2 f z 2 z 2 g z 2 safe region algorithm 5 smaller set satisfi z lead follow algorithm incorpor scale algorithm comput complex given rotat gf use formula 7 scale gf scale f power z 4 z 2 f z 2 scale g power z 4 z 2 g z 2 unscal power z 4 undo scale f g algorithm 7 comput complex given rotat fg use formula 8 scale fg scale f power z 2 z 1 f z scale g power z 2 z 1 g z unscal c r power z 2 undo scale f g endif note algorithm 7 valu uneect independ scale f g 71 except case first consid case 2 ie algorithm 6 possibl either f g nan sinc f g may neither nan f infinit sinc test gf gf care must taken assur termin scale f g even nan infinit case 2 c1 independ whether input infinit nan nan either f g nan infinit simpli get rf r nan infinit precis f nan infinit word r might nan g model implement ensur r nan either f g nan instead comput comput next consid case 3 ie algorithm 7 analog comment possibl valu input appli care must taken assur termin scale case 3 either input nan three output nan g infinit f finit r nan 8 complex algorithm scale region 4a 4b point f g lie region 1 2 3 figur 2 use follow algorithm 1 scale f g point scale f scale g lie 2 appli algorithm 3 scale f scale g yield c r 3 unscal get rscale scale figur 2 correspond shift f g parallel diagon line log scale lie geometr appar set point scalabl region 4a 4bof figur 2 lie set diagon translat ie shadow scale lie inde point region 2 mani point region 3 scale lie region 2 3 cheaper formula discuss last section avail first suppos f g lie region 4a let scale f g z 2 eventu f g lie union two arrowshap region a1 a2 figur 3 still exce z ie f g a1 multipli f g z put a2 thu guarante scale f g a2 safe use algorithm 3 next suppos f g lie region 4b let scale f g z 2 eventu f g like union two parallelogram b1 b2 figur 4 still less z 1 ie f g b1 multipli f g z put b2 thu guarante scale f g b2 safe use algorithm 3 consider lead follow algorithm algorithm 8 comput complex given rotat f g region 4a 4b scale code execut f g region 4a 4b scale f g power z 2 maxfg z 2 maxfg z scale f g z els scale f g power z 2 f z 2 f z 1 scale f g z endif comput given rotat use algorithm 3 undo scale r caus scale f g call overal algorithm new clartg distinguish old clartg part releas entir sourc code includ appendix contain 248 noncom line oppos 20 refer crotg implement 81 except case either input may nan may simultan infinit case three output nan care must taken scale 9 accuraci result complex given rotat algorithm run valu f g real imaginari part f g independ took 46 dierent valu rang 0 overflow threshold intermedi valu chosen threshold valu determin edg corner figur 1 4 thu bare satisfi satisfi possibl branch algorithm correct answer input comput use straightforward implement algorithm 1 use doubl precis arithmet overflow underflow possibl argument test maximum error r c comput follow r comput singl use new algorithm r comput straightforwardli doubl precis subscript c variabl analog mean absenc gradual underflow error metric finit represent r gradual underflow maximum taken nonzero test case true r overflow subset mathemat definit c r use clartg crotg agre note safmin 2 smallest denorm number analog metric comput c routin first test sun ultra10 use f77 fast o5 flag mean gradual underflow use ie result less safmin replac 0 therefor expect measur 11 un log g log z log f log z 1 2 3 4a 4b figur 2 case code f 0 g 0 un log g log z log f log z figur 3 scale f g region 4a un log g log z log f log z figur 4 scale f g region 4b least 1 hope littl bigger 1 mean error r r either machin epsilon time true result small multipl underflow threshold inher uncertainti arithmet routin also test without optim flag mean gradual underflow use expect stringent measur 12 close 1 result follow gradual underflow routin max error r max error max error c old clartg 70588 70588 70292 refer crotg nan nan nan modifi refer crotg 359 341 322 atla crotg nan nan nan limit atla crotg 288 vendor crotg nan nan nan limit vendor crotg 359 gradual underflow routin max error r max error max error c old clartg 460 427 4913930 refer crotg nan nan nan modifi refer crotg old clartg fail accur first consid situat without gradual underflow g z 2 f algorithm decid scale unnecessari result f 2 may nonneglig rel error underflow creat nonneglig rel error r c consid situat gradual underflow error occur dierent one occur 1 g f f denorm algorithm scale result f suer larg loss rel accuraci round nearest denorm number c f g larg loss accuraci refer bla crotg fail even though tri scale avoid overunderflow scale factor f comput intern overflow even consid situat without gradual underflow sine comput f multipl done first three quantiti parenthes quit accur entri ff less one caus multipl underflow 0 true exce 4 repair insert parenthes f divis done first exclud case f insert parenthes get error line modifi refer crotg consid situat gradual underflow round intermedi quantiti nearest denorm number caus larg rel error c equal 1 instead 1 2 atla vendor version crotg run full optim suggest author mean gradual underflow enabl also return nan larg argument even true answer represent modifi routin instead ran limit subset exampl f g less overflow still occasion larg error underflow caus larg rel error even true valu quit larg summari systemat procedur produc provabl reliabl implement wherea error previou implement yield inaccur result without warn fail unnecessarili due overflow latter occur true r close overflow hard complain much former problem deserv correct time result complex given rotat complex given rotat compar new algorithm describ old clartg lapack crotg refer bla time done sun ultra10 use f77 compil optim flag fast o5 routin call time argument throughout f g plane see figur 2 averag time taken argument f g rang time f g typic percent 29 case tri exercis path new clartg code input data shown tabl note time result optim code entir predict sourc code exampl small chang way scale implement make larg dierenc time proper behavior presenc infin nan input issu finit termin propag infin nan ot output scale part code could simplifi probabl acceler time result figur 5 6 six algorithm compar 1 new clartg algorithm present report use test branch select correct case 2 old clartg algorithm lapack 30 3 ref crotg refer bla 4 atla crotg atla bla 5 vendor crotg sun vendor bla 6 simpli new clartg doubl precis see figur 5 show absolut time microsecond figur 6 show time rel new clartg vertic tick mark delimit case code describ tabl common case case 1 left plot see new clartg 25 faster old clartg nearli 4 time faster version crotg get absolut speed limit also ran version algorithm work case 1 ie omit test scale f g simpli appli algorithm appropri case 1 ultim version ran 243 microsecond 68 time new clartg price reliabl altern system fast except handl one could run algorithm check underflow overflow divisionbyzero except occur recomput rare case 4 experi perform doug priest 7 report result sun enterpris 450 server 296 mhz clock except handl use 1 save clear float point except entri clartg 2 run case 1 without argument check 3 check except flag see divisionbyzero overflow underflow invalid oper occur 4 use case except 5 restor except flag exit way argument fall common usual case 1 run 25 faster new clartg priest note essenti use inlin assembl access except flag rather librari routin ieee flag take 150 cycl descript algorithm call simplifi new clartg doubl precis avoid need scale fastest overal architectur ieee singl precis input test case use algorithm 3 ieee doubl precis three extra expon bit elimin overunderflow machin algorithm take 365 microsecond nonzero input f g nearli exactli case 1 entir singl algorithm attract singl precis machin sinc fast much simpler cours would work input data doubl sinc wider format avail architectur input data time complex given rotat case case code f g 22 26 28 case microsecond time comput complex given rotat old clartg atla vendor refer doubl figur 5 time comput complex given rotat comput real given rotat f g nonzero follow algorithm minim amount work algorithm 9 real given rotat f g nonzero without scale endif may appli kind analysi appli algorithm 3 summar result 1535time comput complex given rotat rel new clartg case time time new old clartg atla vendor refer doubl figur rel time comput complex given rotat algorithm 10 real given rotat f g nonzero scale scale z 2 scale f g scale power z 2 scale z 2 elseif scale z 2 scale f g scale power z 2 scale z 2 endif endif unscal r necessari algorithm one divis one squar root contrast srotg routin fortran refer bla 1 squar root 4 divis comput quantiti contain 95 noncom ment line code oppos 22 line refer bla srotg 20 line exclud 2 describ contain appendix 12 accuraci result real given rotat accuraci varieti routin measur way entir analog way describ section 9 result shown tabl first consid result absenc gradual underflow three version srotg use scale factor f g overflow even r elimin extrem valu f g test yield result line label limit gradual underflow let f g equal smallest posit denorm number yield instead 1 2 larg rel error best machin approxim true result 2m divid get c respect slightli larger f g yield slightli smaller still quit larg rel error c gradual underflow routin max error r max error max error c old slartg 145 181 181 refer srotg nan nan nan limit refer srotg 151 195 195 atla srotg nan nan nan limit atla srotg 168 155 155 vendor srotg nan nan nan limit vendor srotg 168 155 155 gradual underflow routin max error r max error max error c old slartg 145 181 181 refer srotg nan nan nan limit refer srotg 151 time result real given rotat six routin comput real given rotat test way entir analog manner describ section 10 test argument time result shown tabl figur three version srotg refer atla sun vendor version origin comput c r comput singl scalar z one reconstruct c defin f g 1c f g c 0 three case distinguish examin valu z c reconstruct permit exampl qr factor matrix overwrit given rotat use comput q case household transform capabl use lapack neither version slartg comput z make time comparison fairer therefor remov two line code comput z refer srotg time test howev modifi atla sun perform librari anyway routin work necessari input data time real given rotat case f g case microsecond time comput real given rotat old slartg atla vendor refer doubl figur 7 time comput real given rotat see figur 7 8 common case case 1 scale need new slartg 18 faster old slartg 135 262 time faster version srotg get absolut speed limit also ran version algorithm work case 1 ie omit test scale f g simpli appli algorithm appropri data larg small ultim version ran 161 microsecond 72 time new slartg price reliabl experi doug priest use except handl avoid branch show 8 improv common case scale need final doubl precis version slartg simpli test case run algorithm 9 doubl precis without scale nearli fast new slartg common case scale need faster scale need 14 conclus justifi specif given rotat put forth recent bla technic forum stan dard shown implement new specif way faster previou implement reliabl use systemat design process kernel could use whenev accuraci reliabl overunderflow ecienc simultan desir side eect approach algorithm much longer must implement precis argument fast arithmet wider rang avail avoid overunderflow algorithm becom simpl reliabl least fast time comput real given rotat rel new slartg case time time new old slartg atla vendor refer doubl figur 8 rel time comput real given rotat r faster numer algorithm via except handl matrix comput basic linear algebra subprogram fortran usag privat commun tr algebra eigenvalu problem implement complex elementari function use except handl matrix comput 3rd ed appli numer linear algebra implement complex arcsin arccosin function use except handl basic linear algebra subprogram fortran usag faster numer algorithm via except handl perform improv lapack cray scientificlibrari ctr luca gemignani unitari hessenberg qrbase algorithm via semisepar matric journal comput appli mathemat v184 n2 p505517 15 decemb 2005 milo ercegovac jeanmichel muller complex squar root operand prescal journal vlsi signal process system v49 n1 p1930 octob 2007 frayss luc giraud serg gratton julien langou algorithm 842 set gmre routin real complex arithmet high perform comput acm transact mathemat softwar tom v31 n2 p228238 june 2005