random timework optim parallel algorithm find minimum span forest present random algorithm find minimum span forest msf undirect graph high probabl algorithm run logarithm time linear work exclus read exclus write erew pram result optim wr work parallel time first provabl optim parallel algorithm problem measur also give simpl gener processor alloc scheme treelik comput b introduct present random parallel algorithm find minimum span forest msf edg weight undirect graph erew pram kr90 algorithm run expect logarithm time linear work size input bound also hold high probabl size input result optim respect work parallel time first provabl optim parallel algorithm problem measur brief summari relat result follow lineartim sequenti msf algorithm karger klein tarjan kkt95 build came linearwork parallel mst algorithm crcw pram ckt94 ckt96 erew pram pr97 best crcw pram algorithm known date ckt96 run logarithm time linear work time bound known optim best erew pram algorithm known prior work result poon ramachandran run olog n log log linear work algorithm random recent chong han lam chl99 present determinist erew pram algorithm msf run logarithm time linear number processor henc work om n log n n number vertic edg input graph observ poon ramachandran pr98 algorithm pr97 could speed run olog n delta 2 log n time linear work use algorithm chl99 subroutin modifi contract subroutin pr97 paper improv run time algorithm pr97 pr98 olog n best possibl improv algorithm ckt96 achiev logarithm time bound less power erew pram part work support texa advanc research program grant 00365800291999 seth petti also support mcd fellowship algorithm simpl 2phase structur make subroutin call chonghan lam algorithm chl99 fairli complex outsid subroutin call made simplest version algorithm chl99 step algorithm quit straightforward addit first timework optim parallel algorithm msf algorithm use simpler altern sever parallel algorithm 1 crcw pram replac call chl algorithm call simpl logarithm time linearprocessor crcw algorithm one as87 result algorithm run logarithm time linear work consider simpler msf algorithm ckt96 2 modifi crcw pram algorithm simpler linearwork logarithmictim crcw algorithm connect compon given gaz91 3 algorithm improv erew connect span tree algorithm hz94 hz96 sinc comput minimum span tree within time work bound algorithm simpler algorithm hz94 hz96 follow use notat denot union set use e denot set form ad element e set say result hold high probabl whp n probabl fail hold less 1n c constant rest paper describ analyz algorithm organ follow section 2 give highlevel descript algorithm work two phase section 3 describ detail phase 1 algorithm main procedur phase 1 findkmin given section 34 section 4 give phase 2 whose main procedur findmsf section 5 give proof algorithm run expect logarithm time linear work section 6 extend result highprob bound section 7 address issu processor alloc variou step algorithm section 8 discuss adapt algorithm realist parallel model like bsp val90 qsm gmr97 paper conclud section 9 2 highlevel algorithm algorithm divid two phase along line crcw pram algorithm ckt96 phase 1 algorithm reduc number vertic graph n nk vertic n number vertic input graph perform reduct algorithm use familiar recurs tree depth log n ckt94 ckt96 pr97 give rise o2 log n recurs call time need per invoc algorithm well olog n2 log n thu total time phase 1 olog n accomplish requir phase 1 find subset msf contract subset msf obtain graph onk vertic phase 2 use algorithm similar one pr97 need recurs due reduc number vertic graph thu phase 2 abl find msf contract graph olog n time linear work assum edg weight uniqu alway uniqu forc order vertic order ident weight edg end point highlevel descript algorithm use log r n denot log function iter r time log n denot minimum r st log r n 1 phase retain lightest k edg edgelistv g 0 contract edg g appear phase sampl edg g 0 prob 1 log 2 n theorem 21 high probabl highlevelg return msf g olog n time use processor follow section describ analyz algorithm phase 1 phase 2 present proof main theorem expect run time obtain high probabl bound run time work analyz perform algorithm phase 1 phase 2 use timework framework assum perfect processor alloc achiev high probabl within constant factor use loadbalanc scheme hz94 requir superlinear space linearspac scheme claim hz96 discuss processor alloc section 7 point simpl scheme similar one hz94 take linear space qrqw pram gmr94 slightli stronger model erew pram use qrqw pram lie fact algorithm design model map generalpurpos model qsm gmr97 bsp val90 well erew pram describ perform msf algorithm qsm bsp phase 1 goal contract input graph g graph onk vertic identifi certain edg minimum span forest g contract connect compon form edg challeng identifi edg logarithm time linear work phase 1 achiev desir reduct number vertic construct kmin forest defin similar algorithm ckt96 howev algorithm consider simpler show kmin forest satisfi certain properti exploit properti design procedur boruvkaa keep size tree contract variou stage phase 1 small total time need contract process edg tree olog n2 log n phase 1 also need filter subroutin remov kmin heavi edg show use msf verif algorithm small tree construct perform step overal algorithm phase 1 findkmin use two subroutin achiev state reduct number vertic within desir time work bound 31 kmin forest phase 1 use familiar sampl contract discard edg framework earlier random algorithm msf problem kkt95 ckt94 ckt96 pr97 howev instead comput minimum span forest construct kmin tree ckt96 vertex log 2 n 2 contract edg kmin tree produc graph onk vertic understand kmin tree consid dijkstrajarnikprim minimum span tree algorithm choos arbitrari start vertex v repeat contain mst g choos minimum weight edg b st 2 b 62 edg set kminv consist first k edg chosen algorithm start vertex v forest f kmin forest g f msfg v 2 g kminv f set edg path x tree let maxweightfag maximum weight set edg forest f g defin edg b g f heavi weighta b maxweightfp f bg f light otherwis b tree f b flight let kmin tree v defin weight v w maxweightfpm v wg w appear maxweightfkminvg defin edg b kminheavi maxfweight b weight b ag kminlight otherwis 31 let measur weight v w defin respect k rang 1n weight v w maxweightfpmsf v wg proof two case w fall insid kmin tree v fall outsid w insid kminv weight v w maxweightfpmsf v wg sinc kminv msf suppos w fall outsid kminv weight v w maxweightfpmsf v wg must path v w msf consist edg lighter maxweightfkminvg howev step dijkstrajarnikprim algorithm least one edg pmsf elig chosen step sinc w 62 kminv edg weight maxweightfkminvg never chosen contradict 2 let k vector n valu rang 1n vertex u associ valu denot k u defin edg u v kminlight weightu v maxfweight u v weight v ug weight u v weight v u defin respect k u k v respect lemma 31 let h graph form sampl edg graph g probabl p expect number edg g kminlight h less np k proof show edg kminlight g also f light f msf h lemma follow sampl lemma kkt95 state expect number f light edg g less np let us look kminlight edg v w 31 weight v w maxweightfpmsf v wg measur use determin f light thu criterion kminlight maxfweight v w weight w vg must also less equal maxweightfpmsf v wg restat v w kminlight must f light well 2 use properti kmin forest develop procedur findkm l take input graph g suitabl posit integ l return kmin forest g run logarithm time linear work next section describ basic step procedur use findkmin present analyz main procedur phase 1 phase 1 concern kmin tree vertex suffic retain lightest k edg incid vertex henc state first step phase 1 algorithm highlevel section 2 discard lightest k edg incid vertex sinc need phase 2 step perform logarithm time linear work simpl random algorithm select sampl size jlj adjac list l sort sampl use sort list narrow search kth smallest element list size ojlj 34 32 boruvkaa step basic boruvka step bor26 vertex choos minimum weight incid edg induc number disjoint tree tree contract singl vertic useless edg discard call edg connect two vertic tree intern other extern intern edg useless multipl extern edg join two tree lightest useless algorithm phase 1 use modifi boruvka step order reduc time bound olog n per step vertic classifi either live dead modifi boruvka step vertex vs parent pointer edg minimum weight incid v addit vertex threshold keep weight lightest discard edg adjac v algorithm discard edg known kmin tree vertex threshold variabl guard vertic choos edg may msf dead vertex v use properti shown edg b kminv weighta b weightv pv thu dead vertic need particip boruvka step wellknown boruvka step gener forest pseudotre pseudotre tree togeth one extra edg form cycl length 2 algorithm assum boruvka step also remov one edg cycl gener collect root tree follow three claim refer tree result modifi boruvka step proof straightforward omit 32 sequenc edg weight encount path v rootv monoton decreas 33 consist edg path v rootv furthermor weight v pv greater edg dminv 34 minimumweight incid edg u u v kminu kminv tree induc boruvka step let 0 subtre e minimum weight incid edg minimum weight incid edg 0 either e edg proof suppos contrari minimum weight incid edg 0 e 0 62 let v v 0 end point e e 0 insid consid path p v 0 root claim 32 edg weight encount p p 0 monoton decreas two case 0 contain p 0 e 0 must lie along p 0 contradict 0 contain p 0 p edg e 00 2 p adjac procedur boruvkaah l f given return contract version h number live vertic reduc factor l edg design parent pointer guarante msf h return f initi repeat log l time log l modifi boruvka step live vertex v choos min weight edg v w 1 weightv w thresholdv v becom dead stop els tree induc edg f 0 one two type root dead 2 everi vertex becom dead claim 34 contain live vertic 3 depthv k v becom dead claim 33 contract subtre made live vertic result vertex live parent pointer keep smallest threshold constitu vertic lemma 32 boruvkaa design vertex dead kmin tree alreadi found proof vertic make transit live dead line indic number assumpt discard edg kmin tree vertex lightest edg adjac vertex discard know kmin tree alreadi found cover line 1 correct line 2 follow claim 34 sinc v pv lightest incid edg v kminv call dead sinc root tree dead vertic depth one dead impli vertic depth two dead valid line 3 follow directli claim 33 vertex find depth k kmin tree lie along path vertex root 2 lemma 33 call boruvkaah k tree vertex subset f proof lemma 32 dead vertic alreadi satisfi lemma singl modifi boruvka step set parent pointer associ live vertic induc number tree let v tree contain v assum induct dlog ie modifi boruvka step tree vertex origin graph found clearli true live vertex v let x minimum weight edg st x 2 v 62 v induct hypothesi gamma 1min tree v subset v respect first extern edg v chosen dijkstrajarnikprim algorithm start v everi edg gamma 1mini lighter x subset chosen dlog ie th modifi boruvka step subset v dlog ie modifi boruvka step thu step kmin tree vertex found 2 lemma 34 b modifi boruvka step length edg list bound k k b proof true assum lemma hold modifi boruvka step length edg list mani step k k sinc contract tree height k length edg list b step 2 shown next section algorithm deal graph result olog modifi boruvka step henc maximum length edg list k k olog costliest step boruvkaa calcul depth vertex minimum weight edg select process root induc tree broadcast depth depth 1 vertic turn broadcast depth 2 vertic etc vertex know depth may stop let descend infer depth k interleav round broadcast processor alloc step account cost separ section 7 lemma 35 let g 1 1 edg call boruvkaag 1 l f execut time ok olog processor proof let g 1 result b modifi boruvka step lemma 34 maximum degre vertex th modifi boruvka step current call boruvkaa k k bi let us look requir time th modifi boruvka step select minimum cost incid edg take time log k k bi time determin depth vertex k delta log k k bi sum log l modifi boruvka step total time bound p log l note algorithm perform olog modifi boruvka step graph henc time k olog work perform modifi boruvka step linear number edg sum log l step divid number processor arriv second term state run time 2 33 filter step filter forest concurr modifi boruvka step maintain filter forest structur record vertic merg togeth time edg weight involv structur appear first king97 v vertex origin graph new vertex result contract set edg correspond vertex oev filter est boruvka step vertex v becom dead new vertex w ad filter forest well direct edg oev w weight v pv live vertic contract live vertex v vertex oev ad filter forest addit direct edg weight edg v shown king97 heaviest weight path u v msf heaviest weight path oeu oev filter forest path henc measur weight v w easili comput follow way let p f x path x filter forest oev oew filter tree weight weight w v w filter tree let weight 36 maximum weight path oev rootoev maximum weight edg rminv r proof rootoev height h result h boruvka step assum claim hold first h boruvka step number contract vertex v origin graph repres current graph v c let vc tree induc th boruvka step contain v c let e minimum weight incid edg vc induct hypothesi maxweightfp f oev oet vc shown proof claim 35 edg path v c edg e weight weighteg edg v c pv c e correspond edg filter forest name oev c poev c oet vc poet vc sinc edg path oev poet vc maxweightfp f oev poet vc thu claim hold filter step call filterh f findkmin examin edg e h weight maxfweight v w weight w vg order carri test use olog n time om work msf verif algorithm kprs97 modifi algorithm case x tree test pair oex rootoex oey rootoey delet e pair identifi delet comput take time olog r r size largest tree form procedur filter discard edg kmin tree vertex discard edg b updat threshold variabl b thresholda weight lightest discard edg adjac minimum weight edg ever heavier thresholda kmina alreadi found becom dead graph form sampl edg h probabl p f kmin forest h 0 call filterh f return graph contain kmin forest h whose expect number edg np proof vertex v claim 36 state maxweightfp f oev minv valu k v build vector k valu one vertex abl check kminlight use filter forest follow lemma 31 expect number kminlight edg h less np need show kminlight edg h remov filter step suppos edg u v kmin tree u h remov filter v k u min tree u wrt h 0 edg u v heaviest edg cycl could msf much less kmin tree v k u min tree u wrt h 0 weightu v maxweightfk u minug mean edg u v could pick first k step dijkstrajarnikprim algorithm 2 34 find kmin forest readi present main procedur phase 1 findkmin recal initi call given section 2 findkm log n g graph obtain g remov k lightest edg adjac list findkminh sampl edg h c prob 1log igamma1 n 2 h graph vertic possibl mark dead paramet indic level recurs determin number boruvka step perform sampl probabl lemma 36 call findkm log n return set edg includ kmin tree vertex g proof proof induct base return f lemma 33 contain kmin tree vertex induct step assum induct findkminh igamma1 return kmin tree h consid call findkminh induct assumpt call findkminh return kmin tree vertex h claim 37 call filterh c f return h f set edg contain kmin tree vertic h c final induct assumpt set edg return call findkminh f contain kmin tree vertic contain log igamma1 nmin tree vertex h findkminh return return edg kmin tree vertex h 2 38 follow invari maintain call findkmin number live vertic h nlog n 4 expect number edg h mlog n 2 n number edg vertic origin graph proof clearli hold initi call log n lemma 33 contract graph h c nlog igamma1 n 4 live vertic sinc h deriv sampl edg probabl 1log igamma1 n 2 expect number edg h mlog igamma1 n 2 maintain invari first recurs call lemma 31 expect number edg h f nlog igamma1 n 2 log igamma1 n 4 number vertic h c invari maintain second recurs call35 perform findkmin lemma 37 findkm log n run expect time olog n work om n proof sinc recurs call findkmin proceed sequenti fashion total run time sum local comput perform invoc asid randomli sampl edg take constant time work linear number edg local comput consist call filter boruvkaa given invoc findkmin number boruvka step perform graph h sum boruvka step perform ancestr invoc findkmin ie p log n olog 3 n bound maximum length edg list lemma 34 infer size tree filter forest k k olog 3 n thu time need modifi boruvka step filter step k olog 3 n sum step total time requir olog n work requir filter procedur boruvka step linear number edg number edg given invoc omlog n 2 olog n boruvka step perform invoc work requir invoc om log n recal paramet indic depth recurs sinc 2 log ngammai invoc depth paramet total work given p log n log ngammai om log n om4 phase 2 recal phase 2 portion overal algorithm highlevel number vertic g nk g sampl edg g 0 prob 1 log 2 n procedur filterg f kprs97 return f light edg g procedur find describ find msf g 1 time om 1 log n log 2 n 1 number edg g 1 graph g g f expect log 2 n edg sinc g deriv sampl edg probabl 1 k sampl lemma kkt95 expect number edg g f mk1 k call findmsf graph expect size om log 2 n call take olog n time 41 findmsf procedur procedur findmsfh similar previou random parallel algorithm except use recurs instead separ base case algorithm use place recurs call also use slightli differ boruvka step order reduc work modif inspir pr97 pr98 respect basecas use simplest version algorithm chong et al chl99 take time olog n use mn log n processor guarante call graph expect size om log 2 n run time remain olog n processor findmsfh h sampl edg h c prob call boruvkab graph h c log 4 n vertic sinc h deriv sampl edg h c probabl 1 log 2 n expect number edg first basecas call om log 2 n sampl lemma kkt95 expect number edg second basecas call log 4 n1 log 2 n thu total time spent subcal olog n assum size h conform expect om log 2 n call filter boruvkab also take olog n time describ boruvkabh l f procedur return contract version h oml vertic use simpl growth control schedul design vertic inact degre exce l determin vertex inact perform list rank edg list log l time step comput stop much time edg list length l boruvkabg repeat log l time vertex let inact edg list l edg activ otherwis activ vertex v choos min weight incid edg e use edgeplug techniqu build singl edg list induc tree o1 time contract tree inact vertic last step take olog n time step take olog l time deal edg list length ol consequ total run time olog l iter main loop work linear number edg assum graph conform expect size om log 2 n total work linear edgeplug techniqu well idea growth control schedul introduc johnson metaxa jm92 5 proof main theorem proof theorem 21 set edg return findkmin subset msf g contract edg produc g 0 msf g given edg togeth msf g 0 call filter produc graph g f remov g 0 edg known msf thu msf g f msf g 0 assum correct findmsf set edg f constitut msf g f thu f msf g earlier shown step highlevel requir olog n time work linear number edg next two section show whp number edg encount graph algorithm linear size origin graph 2 6 high probabl bound consid singl invoc findkminh h 0 edg n 0 vertic want place like bound number edg recurs call findkmin term 0 first recurs call edg h sampl independ probabl 1log igamma1 n 2 call sampl graph h 1 appli chernoff bound probabl size h 1 less twice expect analyz second recurs call recal sampl lemma kkt95 state number f light edg conform neg binomi distribut paramet sampl probabl f msf h 1 saw proof lemma 31 everi kminlight edg must also f light use observ analyz size second recurs call term f light edg conclud bound attain appli equal kminlight edg bound likelihood twice expect number edg f light probabl sequenc 2n 0 p flip coin probabl p head coin come head less n 0 time sinc edg select coin toss head goe msf sampl graph appli chernoff bound expgammaomegagamma n 0 particular instanc findkmin n 0 mlog igamma1 n 4 probabl fewer 2mlog igamma1 n 2 edg f light given singl invoc findkminh bound probabl h 2 log ngammai mlog n 2 edg expgammaomegagamma mlog n 4 follow appli argument use invoc findkmin initi call current call depth log sum recurs call findkmin total number edg thu total work bound p log n probabl phase 2 use om work omit analysi similar analysi phase 1 probabl bound time total work perform algorithm fail hold exponenti small input size howev assum perfect processor alloc next section show probabl work fail distribut evenli among processor less 1m 1 thu overal probabl failur small algorithm run logarithm time linear work whp 7 processor alloc state section 2 processor alloc need algorithm perform fairli simpl algorithm given hz94 take logarithm time linear work use superlinear space involv algorithm claim hz96 run logarithm time linear work space show simpl algorithm similar spirit one hz94 run logarithm time linear work space qrqw pram gmr94 qrqw pram intermedi power erew crcw pram allow concurr memori access time taken access equal largest number processor access singl memori locat assum total size input n processor group q processor qr group size r log n make initi assign log n element group initi assign made element choos group randomli expect number element group r log n chernoff bound whp log n element group vertic assign group collect togeth array group olog n time work space use qrqw pram algorithm multipl compact given gmr96 run logarithm time linear work high probabl need full power algorithm gmr96 sinc know ahead time group c log 2 n element whp suitabl constant c henc suffic use heavi multipl compact algorithm gmr96 achiev bound logarithm time linear work space simpl analysi use chernoff bound show new graph encount comput group receiv either log n element within constant factor expect number element whp henc olog log n erew pram step processor within group assign 1log n element group processor realloc scheme take olog log n time per stage linear space overal high probabl achiev perfect balanc within constant factor total number processor realloc step need algorithm o2 log n delta k log log log n henc time need perform processor alloc step olog n whp note probabl processor alloc optim within constant increas 1 gamma n gamma1 increas group size r sinc perform olog 2 n 3 processor alloc step r set high n 1log 2 n 3 without increas overal olog n run time thu high probabl bound number item group log n becom 1gamman gamma1 shown gmr96 heavi multipl compact algorithm run time olog n log log log time whp 0 choos log log n log n obtain olog n run time initi step probabl also overal probabl bound processor alloc 8 adapt practic parallel model result impli good msf algorithm qsm gmr97 bsp val90 model realist model parallel comput pram model theorem 81 given follow directli result map erew qrqw comput qsm given gmr97 theorem 82 follow qsm bsp emul given gmr97 conjunct observ slowdown emul due hash occur algorithm sinc assign vertic edg processor made processor alloc scheme achiev effect theorem 81 msf edgeweight graph n node edg found og log n time ogm use om n space qsm simpl processor alloc scheme g gap paramet qsm theorem 82 msf edgeweight graph n node edg found bsp ol g log n time whp use processor om n space simpl processor alloc scheme g l gap period paramet bsp 9 conclus present random algorithm msf erewpram provabl optim time work algorithm work within state bound high probabl input size good perform popular parallel model import open question remain obtain determinist parallel msf algorithm provabl optim time work recent optim determinist sequenti algorithm msf present pr00 intrigu aspect algorithm function describ run time known present although proven pr00 algorithm run within small constant factor best possibl parallel optim sequenti algorithm topic worth investig r new connect msf algorithm shuffleexchang network pram jistem problemu minimaaln im moravsk p parallel time complex undirect connect minimum span tree linearwork parallel algorithm find minimum span tree find minimum span tree logarithm time linear work use random sampl note two problem connexion graph qrqw pram account content parallel algorithm effici lowcontent parallel algorithm sharedmemori model serv bridg model parallel comput theori comput system optim random logarithm time connect algorithm erew pram optim random erew pram algorithm find span forest basic graph connect problem connect compon olog 3 simpler minimum span tree verif algorithm random lineartim algorithm find minimum span tree optim erew pram algorithm minimum span tree verif parallel algorithm sharedmemori machin random linear work erew pram algorithm find minimum span forest privat commun optim minimum span tree algorithm bridg model parallel comput shortest connect network gener tr ctr aaron windsor nc algorithm find maxim acycl set graph proceed sixteenth annual acm symposium parallel algorithm architectur june 2730 2004 barcelona spain vladimir trifonov olog n log log n space algorithm undirect stconnect proceed thirtyseventh annual acm symposium theori comput may 2224 2005 baltimor md usa david bader guoj cong fast sharedmemori algorithm comput minimum span forest spars graph journal parallel distribut comput v66 n11 p13661378 novemb 2006 guoj cong david bader design irregular parallel algorithm mutual exclus lockfre protocol journal parallel distribut comput v66 n6 p854866 june 2006