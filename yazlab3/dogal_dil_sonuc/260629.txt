measur softwar depend robust benchmark abstractin identifi weak quantifi advanc softwar system robust frequent hinder develop robust softwar system effort made develop benchmark softwar robust address problem suffer signific shortcom paper present variou featur desir benchmark system robust evalu exist benchmark accord featur new hierarch structur approach build robust benchmark overcom mani defici past effort also present approach appli build hierarch structur benchmark test part unix file virtual memori system result benchmark success use identifi new respons class structur detect similar situat less organ techniqu b introduct given current scarciti tool measur robust softwar system oper system develop lack mean focu attent issu affect system robust system develop long use suit perform test aid develop high perform machin applic program believ suit robust test would similarli use gaug develop robust system provid mean compar robust among variou system throughout paper mani exampl present context evalu robust oper system howev issu examin aris evalu robust complex softwar system robust benchmark suit robust test stimuli benchmark address issu gener enough appli wide rang system yet specif enough provid basi differenti accord system robust essenti robust benchmark aim stimul system way like trigger intern error therebi expos design error error detect recoveri mechan differenti amongst system reflect number error uncov attempt design use benchmark gener applic sever issu must consid exampl benchmark simul memori fault via fault inject supervisor code oper system kanawati92 kao93 like easili portabl oper system perhap even oper system similar applic point view similar oper system interfac often back differ bodi code make difficult inject fault supervisor code way result meaning compar across system paper document sever goal benchmark robust strive achiev goal consid light constraint present unixlik oper system present choic made initi effort develop suit robust test machin run unixlik oper system section 2 describ motiv robust benchmark section 3 present sever characterist benchmark robust attempt achiev comput system section 4 subsequ examin constraint opportunit aris design benchmark use sole evalu robust unixlik system later document initi effort develop robust benchmark evalu exampl design philosophi present herein 2 background motiv develop comput system tradit motiv desir achiev higher perform need measur progress toward goal prompt develop perform benchmark grown complex sophist sinc incept origin perform measur comput system reflect attempt comput averag instruct execut time system later focu shift attempt measur overal system perform scenario design reflect common use system latter approach led first synthet benchmark whetstonecurnow76 dhrystoneweicker84 applic orient benchmark specspec90 suit measur perform prototyp workload built collect real applic similarli advent reliabl comput system spur develop robust benchmark quantifi improv system reliabl robust benchmark grow focu also shift simpl measur hardwar characterist measur reflect overal reliabl comput environ ie hardwar togeth support softwar date much effort build robust system devot build robust hard ware effort evalu robust softwar system becom common recent exemplifi studi miller90 suh93 studi concentr like robust benchmark studi behavior produc system subject unusu rather commoncas stimuli studi perform evalu via collect isol test draw conclus collect result unfortun often difficult evalu rel signific individu result collect test suit exampl miller90 examin behavior unix util suppli randomli gener input data crash singl util must taken serious crash util even though weight may reflect realiti benchmark lack knowledg underli system structur know two util relat way thu sever util crash due bug underli share system librari robust system measur might perceiv unduli low robust benchmark affect lack knowledg system structur miller90 studi similar synthet benchmark perform arena valid benchmark depend accuraci construct emul normal workload system case robust test emul normal workload refer maintain frequenc distribut except condit occur system normal use distribut must maintain obtain accur assess system robust normal use order allow accur evalu overal system robust robust benchmark must evolv toward structur embodi depend hierarchi system benchmark allow test multipl level abstract order facilit isol sourc failur help evalu sever failur encount robust benchmark also easi adapt new facil ad exist system exampl modul ad softwar system conceptu similar older modul test procedur develop older modul easili adapt new modul ensur expertis lost present suit robust test address issu paper consid goal may achiev without preclud desir properti found exist benchmark robust 3 gener design issu sever issu must address design suit robust benchmark section present mani desir properti mention tradeoff may necessari attain first foremost must possibl use robust benchmark compar differ oper environ comput system thu benchmark portabl across platform goal often restrict rang test perform notabl requir knowledg specif one environ often case faultinject base test coverag ideal benchmark test possibl use everi system modul test often howev space stimuli larg permit exhaust test complet determinist benchmark may choos test frequent use modul experi show common case use often properli debug benchmark function sole verif suit altern determinist benchmark may focu sole unusu use modul therebi provid better assess robust modul howev problem usual occur intersect rare occur event taken togeth produc unexpect state set possibl event intersect often larg explor systemat thu benchmark remain limit coverag like use mainli aid debug uncommon case realist estim robust obtain use random stimul random random stimul attempt uniformli cover space possibl use modul random test usual higher serendip ie abil uncov previous unknown error determinist counterpart note howev nondetermin introduc random stimul may lead loss repeat sometim random stimul requir order adequ emul system comput model explain next section degre random without loss repeat one motiv extens set benchmark extens extens benchmark provid mean extend set stimuli consist manner ie stimuli ad benchmark way produc result directli compar result gener prior addit extens necessari allow addit stimuli differ natur use test exist system modul also allow exist benchmark extend appli new system modul extens ensur benchmark consist measur progress rather simpli verif suit isol modul simpl form extens achiev use parameter stimuli exampl benchmark suit might consist group stimuli whose behavior complet determin input string random number new set test gener therebi increas coverag vari input string wherea everi test set gener maintain peatabl extens benchmark rather restrict howev limit variat achiev test vari input paramet greater extens requir abil add complet new test code maintain consist result process gener extensibilti benchmark determin degre test control structur benchmark extend without affect result process hierarch structur benchmark provid gener mean achiev extens hierarchi complex test within set benchmark organ order increas complex complex invers proport number modul exercis test simplest test often applic across multipl system modul eg test proper resourc alloc dealloc applic system modul manag resourc wherea complic test usual highli specif particular modul combin modul organ may reflect test complic test assum simpler test pass design benchmark suit test sever system modul may desir develop hierarch interfac system modul organ reflect hierarchi function simpl test written objectori fashion without requir code duplic possibl lead diverg permodul basi exampl approach benchmark document section 54 note arrang test hierarchi complex may lead higher initi implement cost effort requir defin structur benchmark unlik construct benchmark compos collect ad hoc test howev initi invest usual worthwhil due desir properti hierarch structur result eas code reus benchmark extend report result sever characterist desir result report test robust mention test result repeat result also amen comparison differ machin inde rather simpli indic whether test robust pass desir report fail test use scale reflect sever failur close relat issu amount local trigger event sullivan91 reflect report result ie extent result pinpoint error detect possibl caus good local especi valuabl system design tri focu improv depen oper system note detect failur ie fail test rais number difficulti mani stimuli exercis system way may anticip creator golden standard correct often absent develop robust benchmark might choos overcom problem defin standard correct even measur incorrect exampl scale rank error term sever rang unanticip error code return complet system crash could serv yardstick incorrect altern benchmark could augment abil learn record correct result exampl develop benchmark may defin correct result result commonli produc particular abnorm scenario 1 benchmark use determin common result third possibl approach involv defin possibl incorrect result assum anyth els correct exampl effect system call invok garbag paramet could defin correct long oper system crash file system left intact execut process unaffect benchmark suit may also elect comput index robust individu test result result serv provid high level mean compar two machin gener weight averag individu test result set weight use gener 1 approach measur behavior consist modul across domain test reflect perceiv sever error detect may depend upon number system modul affect error likelihood occurr daili oper rang applic affect specif type error involv whether system abl detect error whether detect correct error 4 benchmark unixlik system unixlik oper system avail wide spectrum hardwar platform rang person comput supercomput oper system attempt provid similar interfac function benchmark written purpos compar robust section describ opportun limit constrain develop benchmark suit design specif test unixlik oper system issu rais addit present previou section note mani multius multitask timeshar oper system present similar constraint attempt point featur unix relev robust benchmark effort although restrict applic work nonunix oper system 41 goal unix benchmark unixlik oper system primarili use support applic requir support multipl process multipl user even singl user setup process own least two differ user usual present system process own system administr own one user function oper system manag access hardwar resourc ensur run process affect advers suggest robust oper system reflect system abil success contain fault condit gener one process ie reflect abil oper system prevent fault affect process thu system crash consid extrem case failur local fault mean process affect unix benchmark suit thu attempt measur abil modul contain error modul modul basi sever testabl modul interfac exist system 42 benchmark structur 421 gross structur unix system provid least follow modul togeth interfac file system virtual memori process manag signal handl also provid network support window manag simpl benchmark suit might consist seri independ test program exercis one modul howev test accur reflect fact normal use system modul must support simultan interact sever program thu multithread support run monitor sever simpl program simultan requir repres test fault handl scenario may aris regular use note multithread benchmark also abl test system abil handl propag multipl fault simultan occur distinct modul thu robust benchmark unixlik system multipl thread featur also prove conveni measur extent fault propag describ later anoth disadvantag design benchmark suit made one test program per system modul system may sever modul increment cost ad new wide applic test test suit high new test must implement everi modul involv howev new test simpli manipul modul manner abstract beyond standard modul interfac test need code modulespecif code interfac handl interact system modul unchang motiv hierarch structur benchmark unix system support enough modul justifi implement hierarch structur system interfac allow test code objectori manner without code duplic exampl implement approach see section 54 note also hierarch approach enforc consist result report simpli elimin multipl copi function similar test report code test implement exactli abstract level therebi guarante compat test report across modul final note portabl consider often requir code benchmark suit limit userlevel implement unixlik kernel often differ substanti implement case would presum littl differ robust among variou flavor unix thu benchmark requir kernellevel support like easili portabl across wide rang unix platform 422 measur fault follow criteria might use evalu serious fault condit increas order sever 1 fault affect process caus 2 2 fault affect execut process 3 fault crash oper system 4 fault crash oper system microkernel 3 uncontain fault may affect anoth execut process one sever way may caus process crash without crash entir oper system produc incorrect output simpli execut slowli otherwis would note process caus fault may affect similar manner howev caus process benchmark benchmark abl detect fault without aid extern monitor agent watchdog start begin test practic measur limit benchmark abil detect chang made state 3 cours appli system built top microkernel barton cristian suh respons late time earlyl timeout late respons invalid output respons valuest failur incorrect answer crash crash partialtot amnesia paus halt crash task stop process crash abort crash w error messag tabl 1 comparison failur classif possibl effect fault may classifi accord sever taxonomi barton90 cristian91 suh93 summar tabl 1 taxonomi necessit mean measur effect process own benchmark may done observ sacrifici program execut concurr benchmark suit check see affect fault gener benchmark suit note almost possibl result state sacrifici program enumer tabl 1 detect mechan watchdog program previous calibr expect behavior sacrifici program fault produc complet system crash howev watchdog may unabl observ unless execut separ processor isol one use execut test separ processor avail human intervent may requir event system crash sacrifici program cours make widespread use system increas probabl reflect effect uncontain fault robust benchmark suit might elect provid synthet program serv sacrifici program may choos make use sever perform benchmark suit specmark advantag widespread avail system evalu abil run one particular applic without failur applic might well serv sacrifici program point use sacrifici program mark effect properti benchmark particular robust benchmark employ sacrifici workload multithread benchmark suffer disadvantag multithread eg result benchmark like lose determin repeat howev mention earlier multithread also repres applic comput model support oper system use multithread discuss later section 423 record result unixlik system provid stabl data repositori robust benchmark must implement mean record result face advers condit produc test possibl effect test often unknown rather difficult implement buffer output channel suscept data loss oper system crash output channel avail userlevel process fall categori simpl nonautom way overcom problem involv print result unbuff crt printer port monitor human similar effect might also achiev use unbuff serial line output commun result second watchdog processor serial line avail arrang greater chanc lose small amount data approxim commun result second comput local area network last case log variabl granular ie test caus crash test repeat synchron write log disk frequent may help reduc amount data loss although complet overcom effect data buffer kernel 424 random extens order provid good coverag test space robust benchmark may opt use test whose behavior depend upon output random number gener howev test may execut exactli action differ system output random number gener chang unix system provid random number gener interfac random ident across implement guarante produc exactli stream random number machin machin 4 bring question valu compar random run made two differ machin problem resolv control random wherebi stream random number pregener store file advanc pregener number fed benchmark run time therebi ensur benchmark run two differ machin behav manner determin ident set random number note unix random number gener produc stream random number run run given machin given seed thu affect repeat result singl machin nevertheless repeat often difficult achiev realist robust benchmark unix system unix system usual provid determinist process schedul thu test present system multithread workload order evalu system abil handl multipl simultan request introduc random result robust test consequ result test may alway repeat schedul order like vari run run problem usual resolv portabl manner robust suit want test multitask environ unfortun unix schedul normal provid hook allow repeat determinist process schedul multithread benchmark schedul thread may reduc sever problem provid complet solut benchmark whole remain subject schedul action systemwid schedul 43 summari unix environ provid level program support adequ benchmark rang simpl test base perturb input string complex hierarch test extens abstract modulespecif level requir robust benchmark better understood unix may well provid testb develop practic implement produc ident stream system vendor might choos chang portabl coverag extens consist result initi menta tion cost local trigger event repeat random theta theta theta theta theta multithread theta theta theta theta theta hierarch structur theta theta theta theta log theta theta theta theta theta kernel theta theta tabl 2 effect implement choic benchmark characterist postiv correl invers correl independ indic thetarespect one relationship indic actual relationship depend specif implement crashm cmu crashm modular hierarch portabl unix unix similar modul implement similar modul coverag high system call variableloc modul variabl serendip high highlimit syscal variableloc modul variabl extens none none difficult easi local none possibl via sentri high high repeat low low variabl variabl tabl 3 properti variou exampl benchmark properti mark variabl unconstrain design benchmark vari individu test benchmark languag robust test express minim effort present unix environ provid modular interfac organ hierarchi permit hierarch organ benchmark new benchmark deriv small amount effort via inherit initi approach implement describ section 54 tabl 2 summar relationship properti benchmark implement choic made construct seen tabl implement choic affect import characterist robust benchmark next section provid sever exampl benchmark exhibit tabul relationship 5 exampl robust benchmark section present initi effort produc benchmark system robust exampl evalu respect design issu present section 3 properti hardwar oper system time crash approx ibmrt mach 25 3 sec ibmrt mach 26 i486 mach 25 5 sec i486 mach 30 mk76 4 sec i486 mach 30 mk82 50 sec tabl 4 time taken crashm crash machin benchmark summar tabl 3 describ detail 51 crashm crashm simpl publicli avail test robust unix system program alloc array fill array random data subsequ spawn sever child process tri execut array data code parent crashm process observ children spawn replac children take except die crashm run unix system subject larg number vari except condit short period time result error detect handl capabl oper system sever test crashm succe crash larg number unix system albeit small sampl machin observ amount time oper system stay crashm appear correl degre observ reliabl oper system day day use refer tabl 4 crashm good test system abil handl high error rate mani way good gener purpos benchmark robust although portabl good coverag stimulu space correspondingli high serendip result crashm limit either system crash crash system crash difficult determin caus crash determin could result error log extern crashm error log provid oper system crashm also lack repeat high degre random introduc due schedul larg number child process creat program test run twice system crash time determin whether crash share common caus due difficulti interpret result crashm limit use measur progress build robust system 52 cmu crashm observ aforement problem crashm attempt remedi restrict coverag test hope gain repeat better local trigger event spawn child process constrain exercis singl well hardwar oper system time crash approx ibmrt mach 25 ibmrt mach 26 crash i486 mach 25 crash i486 mach 30 i486 mach 30 mk82 crash becam unus sluggish tabl 5 time taken cmu crashm crash machin defin system interfac name unix system call anticip error check paramet pass system call would suffici guarante system call made randomli gener paramet would abl crash oper system much surpris mani system test vulner limit test refer tabl 5 although modifi version crashm still exhibit high degre nondetermin offer better local trigger event origin version local improv restrict test subset unix system call restrict togeth monitor system call via sentri mechan describ russinovich92 use success identifi error mach 30 unix server 53 modular benchmark anoth approach modular benchmark modular benchmark separ test individu system modul benchmark construct regard system collect isol modul write one test exercis modul independ one exampl modular benchmark document suh93 anoth exampl set robust benchmark recent construct cmu test robust advanc spaceborn comput modul ascmdingman93 although embed system run realtim oper system relat unix regard collect system modul much way oper system ascm test suit consist distinct test exercis variou system modul file system memori system extern commun lock support multiprogram oper togeth watchdog program similar parent crashm process monitor collect result test exampl modular benchmark file modul benchmark ascm test suit serv good exampl modular test benchmark stress seven call file modul creat file open file close file delet file read file write file move file pointer systemat construct test file handl buffer address number word close start 16 byte buffer 1 open readonli start 256 byte buffer open readwrit middl 256 byte buffer 256 delet end 16 byte buffer 1024 alter beyond end 16 byte buffer 4090 alloc memori null pointer 4100 address delet buffer 6 file handl theta 7 data buffer theta 6 tabl variou possibl input paramet read file write file test oper number test test correct unexpect error bad success termin warm restart cold restart read file 252 175 77 tabl 7 result run read file write file test ascm system dingman93 test case class produc correct result correct return unexpect error code unexpect error indic success spite given invalid input paramet bad success caus oper system termin benchmark termin caus warm restart system warm restart necessit cold restart system cold restart call interfac definit call exampl read file call take 3 paramet file handl start address buffer data read number word read file benchmark choos valu paramet set valu base paramet type exampl file handl might point valid file close valid file open readonli mode delet file among possibl choos possibl test input combin paramet read file call benchmark gener 252 test case shown tabl 6 result 252 test divid six group increas order sever produc expect result correct return error code one would expect given input paramet unexpect error return indic success spite given invalid input paramet bad success caus oper system termin benchmark termin caus warm restart system warm restart caus cold restart system cold restart result 252 test read file write file call take ident set input thu gener test paramet combin shown tabl 7 advantag modular benchmark approach includ rel low complex individu test intermodul interact usual consid abil guarante determin unfortun modular benchmark also sever disadvantag although modular benchmark approach appli well hardwar system compon manufactur separ often design independ testabl approach scale well larg bodi oper system softwar whose modul often close intertwin make independ test difficult test paradigm match well system evalu differ problem may occur modularli written system seemingli well suit modular test evalu case modular decomposit benchmark suit restrict coverag individu test elimin possibl stimul interact system modul addit modular benchmark also unabl take advantag similar system modul quit like similar exist mani modul system modular benchmark requir similar test applic multipl modul code applic modul appropri test thu similar modul hidden within individu test signific loss similar key extens explain next section modular benchmark offer guarante result similar test even two differ revis test compar effect comparison extern benchmark ie done human autom postprocessor collect result individu test inform determin compar abstract natur test complet hidden evalu problem limit use measur progress develop system modular benchmark goe beyond simpl interfac verif exampl improv system modul may render modular benchmark incompat test simpli implement detail chang origin test may still appli abstract level modular benchmark enforc separ abstract test appli interfac test modul test consequ modular test often need adapt respons signific chang modul adapt made great care must taken result adapt test remain directli compar result origin version order illustr last point consid chang benchmark might necessit incompat upgrad system modul eg chang version 10 version 11 x window system old new version modul provid function aliti thu test old system applic new modul howev part benchmark code must rewritten accomod interfac chang rewrit involv modul interfac code interfac system modul test benchmark test routin result updat benchmark remain compar origin benchmark care must taken modifi code modul interfac code eg code purpos result gather process chang modular benchmark requir separ modul interfac code test code necessari modif may complex must perform great care 54 hierarch approach given shortcom modular benchmark would seem decomposit system multipl unrel modul best approach organ suit robust test consid follow set ident test taken ascm benchmark suit test appear benchmark file system memori buffer system object use denot either file memori buffer list ffl refer object creat refer object delet ffl delet activ object ffl write past end object ffl read begin object ffl alloc object resourc exhaust test repres exampl stimuli applic multipl modul hidden within individu modular benchmark result similar test perform result potenti compar one anoth may appar result one way remedi problem abstract test associ result process separ implement detail variou modul clearli defin interfac layer howev onestep decomposit suffici delin rang applic given test test may applic modul other might appli subset etc believ correct way decompos softwar system order test use class hierarchi system featur organ hierarchi class test specifi appli one particular class one possibl class hierarchi might use organ test unix system shown figur 1 note modular ascm benchmark describ earlier actual repres exampl simpl hierarchi one level abstract ascm benchmark gener test modul look interfac modul set test input paramet select correct data type chosen call implement modul input paramet given type predetermin list input may use instanti paramet thu one think interfac call modul class inherit set base class base class correspond one input paramet type class correspond particular call inherit input paramet type describ argument test applic class composit test applic base class 541 propos hierarchi manag variou resourc primari function oper system figur 1 one possibl start point construct benchmark robust note resourc sharedresourc namespac sharednamespac file descriptor virtual memori commun namespac file namespac storag object virt mem imag file share segment process log writeonc socket sharedlog xwindow figur 1 part one possibl hierarchi abstract class repres abstract boldfac ordinari nonabstract class repres system modul data type hierarchi contain mani abstract class eg storag object correspond singl system modul rather serv fundament mean group modul similar explicit group basi organ hierarch structur benchmark suit also provid mechan orderli extens benchmark suit order construct hierarch benchmark hierarch structur interfac oper system must first implement unix provid interfac hierarch interfac librari must develop support subsequ construct robust test construct interfac proce follow decid upon hierarchi im plement design must choos appropri set method defin interfac class exampl method alloc dealloc might defin toplevel class resourc share resourc inherit resourc might add method lock unlock alreadi defin resourc great care must taken defin method suffici gener appli modul descend instanc particular class eg file requir implement method abstract class ancestor whenev method implement complet modul independ way defin gener abstract class appli subclass instanc class may chose redefin default implement specif one note oper system futur like provid objectori hierarch interfac facil therebi elimin need construct interfac librari note also hierarch interfac benchmark easili written languag support objectori program c also written tradit languag c extra effort part programm experiment hierarchi written c 542 use hierarchi build benchmark hierarch interfac oper system built oper system test requir modulespecif knowledg written abstract manner test implement abstract possibl level class hierarchi appli exampl test resourc exhaust repeat alloc mention section 54 requir alloc method modul test code take paramet class resourc use alloc method provid resourc test code particular class automat appli descend class case resourc overalloc test test appli system modul base hierarchi includ file memori buffer contrast consid test check correct system behavior upon write past end object test requir notion object abl store inform begin end case test appli class storag object subclass test encod appropri level abstract result process associ test encod level thu result process allow knowledg specif test eg might want use knowledg scale result test accord weight assign sever failur class importantli howev test result process test code exactli abstract way guarante compar result obtain appli test multipl modul exactli one copi test use multipl applic way inconsist aris might occur multipl copi present eg modular benchmark hierarch benchmark also easili extens consist manner due organi zation benchmark suit extend includ new modul interfac modul encod subclass appropri class within hierarch interfac oper system new modul relat way exist modul placement reflect relationship test develop exist modul appli new modul immedi possibl duplic test code new modul posit correctli hierarchi consist test result process guarante maintain across extens final note hierarch structur offer superior extens reduct code cost code reus potenti better organ result report antagonist achiev goal desir benchmark portabl coverag local trigger event etc thu hierarch benchmark offer special benefit without sacrif desir qualiti offer benchmark style 543 hierarch test use c hierarch structur benchmark easili implement languag provid support inherit section present trivial test demonstr use c build hierarchi construct test use hierarchi test present intend sole illustr program paradigm reader familiar c may wish skip next section present complic exampl hierarch test actual implement given hierarchi figur 1 signific part declar class resourc might look follow class resourc public virtual int alloc int n 0 virtual int dealloc int id int n 0 resourc abstract class ie correspond singl system modul implement method alloc dealloc provid henc mark 0 storag object abstract class inherit resourc suppli addit method class storageobject public resourc public virtual void setmod objectmod mode virtual objectmod getmod virtual int readdata char buf int len 0 virtual int writedata char buf int len 0 protect enum objectmod modespec mode object storag object class provid two method read data write data implement class inherit default implement also provid two method manag mode storag object class inherit storag object may overrid definit set mode get mode desir method declar virtual final file object class declar follow class fileobject public storageobject public resourc method int alloc int n int dealloc int id int n storageobject method void setmod objectmod mode int readdata char buf int length int writedata char buf int length file object class must implement unimpl method inherit ancestor also choos overrid default implement set mode replac enhanc version manipul mode bit underli file disk call origin default implement declar implement method hierarch interfac simpl test applic resourc might implement follow void resourcetestresourc r alloc forev test attempt exhaust suppli resourc hope stimul anomal behavior similarli specif test applic storag object might attempt stimul error condit write unusu larg segment data void storageobjteststorageobject write big data block final two test appli object appropri type fileobject f processobject resourcetest p resourcetest f storageobjtest f resourc test appli file object process object storag object test applic file object process object storag object 544 exampl hierarch test simpl illustr hierarch benchmark hierarch analog part ascm benchmark construct unix system observ read file write file test describ section 53 requir capabl defin class storag object hierarch unix benchmark implement test storag object class make use read data write data method respect file object memori object class defin hierarch interfac librari subclass storag object evalu use benchmark testspecif analysi modulespecif analysi correct unexpect error unexpect termin bad success correct correct correct correct bad success unexpect error correct unexpect error imposs unexpect error unexpect termin correct imposs unexpect termin imposs bad success bad success unexpect error imposs bad success tabl 8 matrix show modulespecif testspecif analys test result combin determin ultim classif result categori correct unexpect error bad success correspond ascm result class similar name unexpect termin class supersed ascm termin class deriv matrix discuss length text implement read data write data benchmark compos two part first part gener object ie file object memori object use test part embodi modulespecif knowledg must know least data type object gener may need know intern detail object gener exampl may need know object encapsul close file requir second part benchmark embodi abstract test routin part test usual written highest possibl level abstract embodi modul specif knowledg exampl read data write data test written appli storag object requir knowledg object test thu code test file object look like storageobject obj routin test storag object appli storag object file piec virtual memori particular case conduct test read write use possibl combin test buffer address io request size hand get test obj moduledepend routin implement modul test make use local modulespecif knowledg gener object test exampl shown return file object pass test storag object treat like storag object process hierarch benchmark implement maintain six result classif defin ascm modular benchmark seemingli slight import chang ascm error class termin replac unexpect termin class termin expect outcom test instead count correct reason chang discuss later structur result process code resembl test code test result also process moduledepend moduleindepend routin modulespecif analysi routin suppli modul test evalu outcom test view characterist particular object test system without systemwid integr error handler modulespecif routin also abl examin modulespecif error return mechan incorpor feedback analysi unlik modul specif routin moduleindepend routin also known testspecif routin detail knowledg object test detail knowledg test appli awar test object level abstract test testspecif routin applic across modul test evalu outcom base systemwid error handl inform observ behavior test object note inform may avail resultprocess routin use analyz outcom test given goal classifi test result one six class describ two analysi routin return correct unexpect error unexpect termin bad success evalu correspond first four possibl result classif respect modulespecif testspecif evalu combin yield final classif outcom fall one four class situat either remain two possibl outcom warm restart cold restart occur occurr detect extern monitor agent human two case outcom indisput modulespecif testspecif analysi need perform consid exampl write data test attempt write 1024 byte data storag object encapsul close file pass buffer point 256 byte data test run job modulespecif routin awar intern detail storag object check whether result indic invalid attempt write close file modulespecif routin awar file object written actual close error code return agre predict outcom modulespecif routin indic correct return otherwis indic bad success unexpect error appropri moduleindepend routin hand awar deal storag object know test attempt write data actual suppli write data call therefor check see much data test claim written success classifi outcom one four aforement categori two evalu combin accord follow principl employ produc matrix tabl 8 ffl call succe ie didnt return error code result analys must agre success expect outcom order result deem correct error stimulu introduc test either modulespecif object gener abstract test code initi without knowledg thu either one analys expect error correct outcom correct outcom must error eg write data call file open write pass null buffer ask write 1024 byte testspecif routin predict error correct outcom decis use null buffer would made testspecif initi code execut test trigger error predict outcom correctli classifi bad success convers call fail error one analys need accept error correct outcom order result deem correct possibl like one two part test code awar stimulu expect caus error condit exampl suppos call fail return code indic invalid data pass data call moduleindepend routin would suffici inform classifi correct outcom moduledepend independ routin know valid storag object written error return would look like unexpect error return ffl call produc termin one result analysi need accept termin correct ie expect order outcom consid correct justif case analog handl failur call ffl occurr unexpect termin preclud possibl unexpect error bad success analysi routin may disagre whether benchmark termin ffl analysi routin may disagre whether call fail may seem counter intuit common occurr howev may occur presenc error return channel 5 avail analys examin exam ple modulespecif errorreturn channel might indic modulespecif routin test fail altern testspecif routin might conclud test fail observ behavior data avail modulespecif routin case disagr one analysi may return bad success return unexpect error correct combin two result yield unexpect error analysi detect error error indic channel avail avail routin indic error note analysi routin implement observ analyz test termin oper system done order classifi termin correct unexpect termin origin ascm classif retain classifi termin group unto benchmark termin would requir analysi termin could simpli monitor handl way cold restart warm restart howev implement hierarch benchmark expos problem ascm result classif render simpler scheme unus hierarch benchmark initi implement run file object modul interfac part mach 30 filesystem minim effort restrict extend hierarch os interfac librari test later run memori object modul interfac virtual memori system result run benchmark shown tabl 9 result serv demonstr one valuabl benefit hierarch test name enforc consist across modul result process especi valuabl benchmark extend hierarch benchmark initi implement use ascm result classif scheme work reason well context file manag process termin expect outcom file oper howev process termin often correct mean signal error interact virtual memori 5 error return channel mean oper system indic error condit applic exampl includ return code global statu flag signal system trap oper number test test correct unexpect error bad success unexpect termin warm restart cold restart read data file object 210 108 0 0 57 data file object 210 92 0 9 91 read data memori object 210 115 data memori object 210 101 tabl 9 evalu file object memori object modul use hierarch bench mark result class use defin ascm benchmark describ section 53 modifi termin class replac class contain unexpect ter minat termin expect outcom test count correct number correct outcom due expect termin includ parenthes tabl repres number result would misclassifi ascm scheme system eg case attempt refer invalid address benchmark extend test memori object addit file object limit ascm scheme becam appar mani otherwis correct outcom simpli classifi termin seen tabl 9 larg number test outcom misclassifi ascm scheme might lead conclus virtual memori system low qualiti due misclassif less 10 test would appear produc correct outcom howev analysi reveal result classif system virtual memori system fault led modifi result classif wherein termin class either correct unexpect termin origin shortcom result analysi made obviou hierarch structur benchmark enforc compar result across two modul ad hoc modular approach problem might easili obscur addit note case studi exemplifi one potenti pitfal robust benchmark design difficult defin error class without know outcom possibl test class may appli ascm benchmark exampl defin termin class absenc enough data evalu suitabl ascm evalu file modul see tabl 7 show occurr termin test occurr report modul similarli test case hierarch test serv enforc consist result process maintain placehold result class well character data vagu classif becom avail hierarch framework serv guid toward correct character new result class 6 conclus futur work paper current robust benchmark effort examin approach fail address certain issu critic longterm success robust test suit sever issu delin propos benchmark organ overcom mani problem outlin propos hierarch benchmark organ advers affect desir properti attain benchmark date particular propos impos hierarch extens structur upon test suit structur may mandat higher initi implement effort promis improv lifespan maintain robust benchmark use long period time remain sever opportun improv explor discuss extens hierarchi exampl hierarch structur test facilit combin individu test result overal index robust also suggest system determin rel import individu result addit possibl extend hierarch structur includ benchmark oper via fault inject explor mainli simpl fault inject violat notion test procedur abstract implement detail whenev possibl possibl reconcil differ via abstract form fault inject explor much work present herein carri context measur robust unixlik oper system kernel oper system regard opaqu monolith entiti howev advent microkernel base oper system present opportun lowest level hierarch benchmark focu robust layer beneath oper system server ie microkernel hierarch structur benchmark easili extend incorpor notion benchmark one level deeper simpli ad one layer bottom benchmark hierarchi final approach measur robust appli easili larg softwar system written modular manner applic promis extens low mainten cost consist obtain similar benchmark oper system robust detail investig applic remain pursu r fault inject experi use fiat understand faulttoler distribut system synthet benchmark measur robust fault toler aerospac system ferrari tool valid system depend properti fine fault inject monitor environ trace unix system behavior fault empir studi reliabl unix util open system fault manag fault toler mach standard perform evalu corpor develop benchmark measur system robust softwar defect impact system avail studi field failur oper system dhryston synthet system program benchmark hartston synthet benchmark requir hard realtim applic tr ctr jean arlat yve crouzet johan karlsson peter folkesson emmerich fuch gnther h leber comparison physic softwareimpl fault inject techniqu ieee transact comput v52 n9 p11151133 septemb