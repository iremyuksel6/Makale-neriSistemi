improv implement binari univers oper present algorithm implement binari oper type unari loadlink storecondit sc oper perform algorithm evalu accord sensit measur distanc oper graph induc conflict guarante influenc step complex sensit implement ologast n n number processor system oper logast n apart graph induc conflict delay constant sensit achiev oper use implement heap arraybas link listsw also prove problem solv o1 step use binari llsc oper requir olog logast n oper unari llsc oper use indic nonconst gap unari binari llsc oper b introduct algorithm nonblock processor delay processor make progress nonblock algorithm avoid perform bottleneck due processor failur delay asynchron share memori system nonblock algorithm requir use univers oper loadlink storecondit sc 14 eas program conveni write nonblock algorithm use univers oper access sever memori word atom 4 13 18 22 howev exist commerci architectur provid unari oper access singl memori word 23 26 multiword oper implement use unari univers oper eg 14 15 implement effici effici implement evalu isol ie interfer oper contend memori word 19 howev provid indic implement behavior presenc content ie oper compet access memori word clearli hot spot ie memori word content high implement oper tri access word delay long time one even argu case oper delay even support hardwar 5 24 howev hot spot delay far away oper paper propos evalu implement sensit measur distanc hot spot influenc perform oper roughli state sensit longest distanc one oper anoth oper influenc perform eg chang number step need order complet oper concentr implement binari oper unari llsc binari oper induc conflict graph node repres memori word edg two memori word belong data set oper ie pair memori word access oper hot spot correspond node high degre requir two oper whose distanc conflict graph larger sensit interfer step complex whether execut parallel present algorithm implement arbitrari binari oper unari sc oper sensit olog n algorithm use llsc conveni sinc support sever contemporari architectur eg 23 26 algorithm extend reli unari univers oper particular o1 implement llsc compareswap 3 employ core algorithm implement binari oper manner similar known algorithm 3 7 19 25 27 processor lock word data set binari oper appli oper unlock data set oper help complet thu ensur algorithm block new featur algorithm processor may lock data set two directionseith start lowaddress word start highaddress word sensit core algorithm depend orient conflict graph accord lock direct two common data structuresan arraybas link list heapw priori determin lock direct induc constant sensit gener howev processor dynam decid lock direct achiev encapsul core algorithm decis algorithm coordin order processor lock data set lowaddress word first highaddress word first first present decis algorithm base determinist coin toss techniqu cole vishkin 9 simplifi case conflict graph path show synchron method break conflict graph arbitrari topolog path adapt determinist coin toss techniqu appli combin previou algorithm implement arbitrari binari oper unari llsc olog n sensit also show problem solv o1 step use binari llsc oper requir olog log n step unari oper type use proof adapt lower bound linial 20 show messag pass model maxim independ set nring found less omegagammaan n round lower bound indic implement binari llsc unari oper incur nonconst overhead follow origin public work 6 10 afek merritt taubenfeld touitou 1 present algorithm implement kword object unari oper ation algorithm waitfre guarante everi oper eventu termin algorithm use algorithm idea implement addit employ base case recurs construct herlihi moss 16 introduc transact memori hardwarebas scheme implement arbitrari multiword oper three scheme 3 19 25 present softwar implement transact memori singleword atom oper isra rappoport 19 shavit touitou 25 present nonblock implement arbitrari multiword oper use unari llsc anderson moir 3 give waitfre implement kcompareswap ksc shavit touitou 25 present simul result indic algorithm perform well practic isra rappoport 19 analyz step complex oper anderson moir 3 measur step complex kcompareswap ksc oper analysi three implement show sensit content distant oper exampl two oper execut two end link list increas other step complex turek shasha prakash 27 show gener method transform concurr implement data structur nonblock one method employ compareswap process block due lock held anoth process help block process releas lock help continu recurs block process also block anoth process barn 7 present gener method construct nonblock implement concurr data structur method word need oper cach privat memori thu oper access data structur concurr contend method similar softwar transact memori 3 19 25 sensit high algorithm use help 3 7 19 25 27 decreas sensit increas parallel minim distanc oper help herlihi 15 introduc gener method convert sequenti data structur share waitfre one herlihi method extens suggest alemani felten 2 allow parallel concurr oper inher sequenti anderson moir 3 present univers construct allow oper access multipl object atom implement use multiword oper employ effici implement certain larg share object save copi allow parallel nonblock implement multiword oper induc solut wellknown resourcealloc problem solut short wait chain small failur local 8 addit discuss relat two problem appear 1 preliminari 21 asynchron sharedmemori model sharedmemori model processor commun appli memori access oper short oper set memori word processor p model possibl infinit state machin state set q contain distinguish initi state q 0i configur vector local state processor valu memori word j initi configur processor local initi state memori word contain default valu oper type defin number input output argument allow valu function depend input sharedmemori state processor state one hand output argument new state processor memori hand oper instanc oper type data set oper set memori word access exampl unari sc defin follow return valu scm new write success sc sinc previou llm new return success els return failur event comput step singl processor denot index processor event processor determin memori oper perform accord local state determin next local state accord valu return oper oper atom oper seem occur certain point two oper occur point therefor comput system captur sequenc configur configur obtain previou one event singl processor detail execut segment ff finit infinit sequenc everi configur oe k event applic oe k result c k1 oe result appli p transit function p state c k appli p memori access oper memori c k execut execut segment c c 0 initi configur constraint interleav event differ processor manifest assumpt processor asynchron bound rel speed implement highlevel oper type h lowlevel oper type l procedur use oper l intuit processor distinguish h implement l assum processor p invok procedur implement oper op termin let oe f oe l first last event respect execut processor p procedur op interv op execut segment oper termin interv infinit execut segment two oper overlap interv overlap invoc oper may result differ interv depend context execut exampl two interv oper may differ even return differ valu first execut isol second overlap oper let ff interv p step complex ff denot stepff number event p ff op op 3 figur 1 simpl conflict graph execut fi lineariz 17 total order implement oper fi preserv order nonoverlap oper respons satisfi semant h given respons previou oper total order implement nonblock point processor pend oper complet within bound number step 22 sensit conflict graph execut segment ff repres depend data set oper ff undirect graph denot g ff node g ff repres memori word edg two node j correspond oper data set fm whose interv overlap ff g ff may contain parallel edg ff contain sever oper data set 1 exampl 1 let ff finit interv oper opm overlap show g ff next consid conflict graph interv oper op measur distanc edg repres op oper delay execut op maximum distanc measur interv implement determin sensit detail assum ff interv oper op let op oper op connect compon g ff distanc op op ff number edg shortest path g ff whose endpoint edg repres op op intuit sensit measur minimum distanc guarante two oper interfer say oper op 2 interfer oper op 1 step complex op 1 whether op 2 execut parallel definit modifi sensit depend complex measur eg set memori word access earlier version work 6 10 defin content graph execut node repres oper edg repres memori word data set dual conflict graph content graph captur depend oper somewhat accur conflict graph easier work interv ff oper op sensit distanc interv ff 0 op exactli one oper ie edg g ff distanc edg repres op step complex op increas singl oper ad ff distanc op sensit interv ff maximum ff sensit distanc mean step complex op increas singl oper ad ff distanc 1 maximum exist sensit 1 sensit implement maximum sensit interv sensit captur noninterfer oper follow sens sensit implement distanc two oper conflict graph step complex measur consid oper whether execut parallel 23 relat complex measur disjointaccess parallel 19 requir oper complet constant number step oper contend memori word sensit strengthen notion allow evalu behavior implement also presenc content afek et al 1 suggest two complex measur 1 algorithm dlocal step complex number step perform interv ff bound function number oper within distanc g ff 2 algorithm dlocal content two oper access memori word distanc conflict graph joint interv clearli sensit 1 impli dlocal step complex howev convers true exampl suppos data set oper op contain hot spot access oper suppos also path oper length sensit 1 allow oper path influenc op perform 1local step complex op may still help distant oper path local content orthogon sensit local step complex evalu addit either howev oper access memori word associ oper help dlocal content follow sensit 1 content local algorithm discuss end section 4 dwork herlihi waart 12 suggest measur step complex algorithm take content account assum concurr access memori word penal delay respons good complex measur evalu solut specif problem howev implement multiword oper inevit result concurr access word creat hot spot complex measur propos sensit appropri evalu multiword implement measur influenc hot spot 3 leftright algorithm gener scheme implement multiword oper 3 7 19 25 27 oper lock pair memori word execut oper help stuck oper avoid block section introduc variant scheme leftright algorithm oper lock memori word differ order show sensit live leftright algorithm depend orient conflict graph induc lock order overlap oper end section discuss data structur oper inher asymmetri data structur leftright algorithm directli appli achiev constant sensit next section show break symmetri gener situat govern lock direct reduc sensit 31 overview known scheme implement multiword oper unari oper 7 19 25 27 requir processor go follow stage lock lock memori word execut appli oper memori word unlock unlock memori word oper assign uniqu identifi memori word lock oper oper id written word word unlock contain memori word lock oper oper modifi memori word unlock oper block find word need lock anoth block oper case processor execut block oper help block oper figur 2 scenario high sensit order help oper detail publish invok state maintain execut help impli one processor may execut oper initi processor processor invok oper execut processor processor help complet although one processor perform oper advanc processor point execut perform oper execut processor effect block oper help either lock stage alreadi execut stage unlock stage oper execut unlock stage alreadi lock word oper lock data set never block therefor oper help block oper pass lock stage guarante block contrast oper still lock stage block third oper turn block fourth oper therefor help block oper lock stage may continu transit nonblock implement guarante oper eventu termin transit help stop yet sensit high illustr next exampl exampl 2 consid scenario n overlap oper op data set op fm assum everi oper op lock lowaddress word tri lock highaddress word 2 op delay lock op 2 op 1 help op 2 sinc highaddress word op 2 lock recurs help op 3 etc thu sensit simpl implement least n gamma 1 exampl 2 oper symmetr tri lock memori word order lowaddress word first main idea leftright algorithm implement oper binari asymmetri introduc oper lock memori word two direct either left rightlowaddress word first right lefthighaddress word first exampl 3 consid exampl 2 assum oddnumb oper op lock lowaddress word first evennumb oper op address word first op odd lock lowaddress word find highaddress lock anoth oper must op i1 op i1 alreadi lock data set therefor op help op i1 execut unlock stage oper oper decid lock direct lock stage oper termin unlock stage reset sharedmemori area use decis algorithm thu two new stage decis postdecis encapsul algorithm section focu lock unlock stage leav decis postdecis stage algorithm next section 32 pseudocod simplifi code descript separ sharedmemori area use lock unlock stage size area size data area memori word lock area correspond memori word data area algorithm use share array opdetail initi processor publish oper descript oper start initi processor also set oper id opid use later stage opid compos id initi processor timestamp gener timestamp function return uniqu id time invok algorithm follow gener scheme discuss earlier except lock done either left right right left oper discov word lock anoth oper help block oper execut stage unlock word oper tri pseudocod appear algorithm 1 lock unlock stage execut sever processor behalf oper therefor synchron need ensur error caus concurr processor execut oper algorithm 2 present detail share procedur use lock unlock user respons avoid synchron error execut stage local variabl tmp use procedur hold last valu read share memori main synchron mechanismguarante advanc execut processor actual make progressi timestamp part oper id field written initi processor begin oper clear begin unlock stage oper valid timestamp set invalid timestamp set execut processor find oper invalid timestamp set skip directli unlock stage ensur memori word unlock oper lock oper similar consider appli unlock word memori word initi lock oper contain id procedur lock lock two memori word order given paramet singl memori word lock celllock attempt lock word oper algorithm 1 leftright algorithm code processor p record lowword highword data set ts timestamp direct lock direct share state opdetailsn procedur atom write opdetailsi publish ts decidem decid lock direct helpopid help procedur helpopid lock stage opdetailsopidpiddirect left locklow high opid left right els lockhigh left opid right left executionlow high opid execut stage unlocklow high opid unlock stage postdecisionlow high opid clean memori still valid word lock anoth oper procedur reread word word lock oper procedur return true word lock anoth oper execut processor help block oper tri oper becom invalid procedur return fals help anoth oper block oper invok help block opera tion id argument block oper becom execut processor block oper goe stage procedur unlock invalid oper reset ts field prevent execut processor lock word unlock two memori word cellunlock unlock singl word still lock oper success sc check fail word alreadi unlock anoth execut processor procedur valid compar timestamp pass oper id timestamp ts field oper entri opdetail oper valid equal algorithm 2 leftright algorithm share procedur processor p procedur lockx opid celllockx opid celllocki opid procedur celllockaddr opid tri lock lock tmp opid return true els helptmp validateopid return fals check oper end procedur validateop opdetailsoppidt opt return true els return fals procedur unlockx opid invalid oper cellunlockx opid unlock word cellunlocki opid procedur cellunlockaddr opid procedur decidem function decid make sure first execut processor return decis left unspecifi write decis oper detail 2 mention respons user avoid synchron error execut stage user use timestamp oper may add state inform necessari exampl implement oper sc2 need check write oper still valid manner similar celllock function need point decis stage execut initi processor 33 proof correct proof algorithm lineariz follow gener scheme eg 7 19 25 27 lock unlock shown behav correctli thu show data set oper lock execut stage unlock oper termin execut processor return celllock either memori word lock oper oper invalid oper becom invalid execut processor reach unlock stage previous complet lock stage therefor first execut processor return celllock word lock oper prove next lemma lemma 31 data set oper op lock first execut processor op complet lock stage procedur cellunlock check word first thu word unlock execut processor oper lock impli follow lemma lemma 32 data set oper op remain lock first execut processor op reach unlock stage next lemma prove execut processor unlock memori word execut processor lock lemma 33 data set oper op remain unlock first execut processor op reach unlock stage proof execut processor op start unlock stage initi timestamp field opdetail thu invalid op perform llm scm anoth execut processor op tri lock afterward valid op perform llm find oper valid valu read execut processor tri lock thu lock field lock word written order unlock impli two thing first sc cellunlock fail anoth execut processor unlock second execut processor lock 34 progress sensit live properti algorithm sensit depend orient conflict graph accord lock direct figur 3 reduc sensit help direct let ff interv oper op help graph ff h ff mix graph repres help among oper overlap ff node h ff memori word access oper overlap ff edg e node 1 2 constitut data set oper ff direct e oper ff data set fm direct e oper ff data set fm otherwis e undirect h ff partial orient version g ff conflict graph ff lemma 34 let fi execut leftright algorithm oper complet help graph interv fi contain either undirect edg direct cycl proof must point fi oper complet let ff interv block oper op fi leftright algorithm op block lock data set sinc op termin block oper block anoth block oper sinc number processor finit processor one pend oper number block oper fi also finit therefor cycl block oper op 2 algorithm block oper help block oper two oper block help impli data set lock differ direct undirect edg h ff l 2 three oper block help direct cycl h ff next analyz sensit algorithm consid two oper op 1 data set fm op 2 data set fm g assum help graph edg 1 2 direct 2 edg 2 3 also direct 2 see figur 3 op 1 help op 2 code celllock 2 lock op 2 howev op 2 lock 3 lock 2 pass lock stage thu op 1 help op 2 execut unlock stage argument gener next lemma lemma 35 let ff interv oper op let op j overlap oper direct path memori word op memori word op j h ff exist anoth interv op ff 0 overlap oper except op j proof let op set oper op help direct path op oper op impli direct path memori word oper op memori word op j h ff sinc direct path memori word op memori word op j h ff thu oper op help op j argu lemma construct execut ff 0 without op j ff 0 op perform sequenc step ff moreov oper op lock word order ff ff 0 execut leftright algorithm let op k first oper op lock word ff ff 0 algorithm happen anoth oper hold lock word howev add new oper ff 0 omit op j sequenc lock op k lock ff 0 ff thu word unlock ff also unlock ff 0 op k succe lock word perform sequenc step ff ff 0 length direct path h ff bound oper distanc 1 increas number step taken oper lemma 35 lemma 36 let ff interv leftright algorithm length direct path h ff sensit ff 1 35 data structur constant sensit discuss two data structur memori access pattern oper structur therefor lock direct determin priori obtain constant sensit link list link list implement insid array data set oper i1 let lock direct oper determin pariti lowaddress word lock direct oper access left even right odd clearli neighbor oper conflict graph lock opposit direct therefor maximum length direct path one lemma 34 implement nonblock lemma 36 sensit two v v b figur 4 binari oper heap v g even depth heap isra rappoport 18 present implement heap support bubbl bubbl use unari binari sc2 oper implement data set binari oper alway parent node one children order implement binari oper use leftright algorithm let lock direct oper pariti depth higher node lock clearli oper data set lock direct see length direct path two let v g v f v v b four node heap v g parent node v f v f parent node v v b see figur 4 two kind path form contend oper first kind depth monoton eg case neighbor oper lock opposit direct henc direct path v v g v b v g form second kind depth monoton eg case neighbor oper lock direct determin depth v f direct path form v v b therefor longest direct path length one lemma 34 algorithm nonblock lemma 36 sensit two 4 decis algorithm access pattern known advanc processor dynam decid lock direct section present algorithm choos lock direct gather inform memori access pattern minim sensit simplic separ sharedmemori area use decis stage size area size lock area data area memori word decis area correspond word lock data area op op figur 5 lock direct highaddress word equal lowaddress word op op figur lock direct lowaddress word equal consid simpl exampl data set op fm data set op 0 assum data set intersect highaddress word op lowaddress word op 0 lock direct op op 0 differ order avoid direct path see figur 5 lowaddress word op lowaddress word op 0 lock direct op 1 op 2 equal order avoid direct path see figur 6 similarli highaddress word op highaddress word op 0 exampl lead us concentr monoton path highaddress word one oper lowaddress word anoth oper figur 5 situat want neighbor oper lock differ direct much possibl first describ algorithm restrict case singl monoton path handl gener case decompos arbitrari conflict graph monoton path 41 monoton path oper op initi processor id pid data set op oper lower indic op call downstream neighbor oper higher indic op call upstream neighbor situat similar one depict figur 2 assum oper choos lock direct accord follow rule smaller pid upstream neighbor pid i1 op decid left otherwis op decid right edg oper upstream neighbor decid left rule direct path correspond ascend descend chain pid exampl oper decid left pid appear ascend order key insight length longest chain ascend descend pid depend rang pid rang pid reduc ensur adjac oper differ pid rule guarante short direct path reduc rang pid use determinist coin toss techniqu cole vishkin 9 symmetri break algorithm synchron ring adapt monoton path asynchron system colevishkin algorithm work phase phase rang reduc logarithm factor rang small rang reduc rule appli although new pid uniqu fact pid adjac oper differ ensur oper decid lock direct see order perform k rang reduct phase oper know pid k oper oper without k neighbor decid left call edg oper 3 algorithm guarante altern propertyadjac pid equal assum pid phase k rang lg altern properti length ascend descend sequenc pid l howev sinc may chain l oper lock direct monoton path simplifi descript assum oper start togeth b oper wait lock stage oper finish lock stage later remov assumpt first describ singl phase algorithm reduc rang pid olog n memori oper appli idea repeatedli reduc rang olog n use olog n memori oper 411 singl phase oper begin phase write pid lowaddress word sinc oper start togeth memori word written togeth sinc oper wait oper finish lock stage memori word overwritten oper choos direct pid induc pointer consecut word path pid lowaddress word lead oper detail record highaddress word oper found 3 edg oper may also decid accord pariti distanc end path figur 7 reduct pid singl phase assum op read three pid pid i1 i2 denot respect binari represent processor pid string length dlog ne bit number 0 dlog ne gamma 1 go least signific bit signific bit let j index least signific rightmost bit binari represent pid 0 pid 0 repres binari string length dlog log ne concaten binari represent j b j valu jth bit pid 0 note length pid 1 dlog log ne similar manner op comput pid exampl 4 consid figur 7 exampl pid 0 01010101 85 pid 11111101 254 pid 0 i2 01111101 126 index rightmost bit differ 3 valu pid 0 0 thu pid 1 0110 6 index rightmost bit pid 0 differ 7 valu pid sinc memori word modifi decis stage op op i1 use pid 0 1 impli singl phase consistentth new pid comput oper op equal new pid comput op downstream neighbora state next lemma lemma 41 op op i1 neighbor oper path calcul valu pid 1 1 thu refer pid 1 without mention processor calcul describ pid 1 compos bit part denot pid 1 ibit index part denot pid 1 iindex pid 1 thu pid 0 pid 0 bit posit pid 1 contradict fact pid 1 iindex rightmost bit pid 0 pid 0 differ prove follow lemma lemma 42 op op i1 neighbor oper path pid 0 6 pid sinc initi pid distinct lemma impli consecut valu pid 1 equal prove altern properti 412 multiphas algorithm describ idea appli repeatedli reduc pid three bit long guarante longest monoton sequenc pid contain eight oper denot 0 n dlog ne let j fn smallest integ j j n 3 note oper start write pid lowaddress word read upstream memori word edg oper without neighbor choos left without calcul let pid read op pid 0 pid 0 1 iter oper comput pid k j pid kgamma1 j pid 1 everi j singlephas algorithm section 411 lemma 41 immedi impli algorithm consist lemma 43 op op i1 neighbor oper path calcul valu pid k 1 everi k altern properti prove induct appli lemma 42 everi iter lemma 44 op op i1 neighbor oper path pid 0 6 pid proof proof induct phase local comput denot k 0 fn base case 1 assumpt induct step assum lemma hold phase k everi consecut pair pid k differ valu sinc iter onephas algorithm lemma 42 impli pid k1 6 pid repres less three bit thu repres three bit howev x 3 show iter pid length strictli reduc fn iter length three show everi valu pid fngamma1 three bit long thu eight consecut oper ascend descend pid fn valu rang pid reduc oper choos lock direct compar pid pid upstream neighbor follow rule edg oper without neighbor decid left 8 consecut oper decid left eight consecut oper decid right prove follow theorem theorem 45 length direct path 8 42 gener topolog order appli rang reduct techniqu previou section gener topolog disentangl arbitrari combin overlap contend oper collect monoton path achiev oper first check whether data set may creat nonmonoton path oper stall help oper otherwis appli algorithm monoton path explain idea need defin monoton path precis assum memori word l form undirect path conflict graph memori word local minimum local maximum local minimum creat two oper lowaddress word figur 6 local maximum creat two oper highaddress word path monoton contain local minima maxima decis stage oper preced separ mark stage mark stage oper check memori access pattern tri lock memori word detect local minima maxima avoid nonmonoton path one oper form local minimum local maximum continu other stall mark stage maintain variant conflict graph share memori node mark memori word word either mark low lowaddress word oper mark high highaddress word oper word mark low high lowaddress word one oper high address word anoth oper mark memori word data set oper stall oper start tri mark lowaddress highaddress word mark succe oper data set monoton path oper decid lock direct manner similar section 41 mark fail oper data set creat nonmonoton path oper stall help oper word two special fieldsfor low mark high mark oper mark word write id instead lowhigh field mark fail relev field oper succe mark low field lowaddress word tri mark high field highaddress word oper unmark data set unlock word mark high twice low twice impli two overlap oper highaddress word lowaddress address word one succe mark word stall consequ local minima maxima avoid nonmonoton path oper mark memori word low even word alreadi mark high anoth oper respect mark differ lock sinc word lock two differ oper mark two differ oper two problem aris due dynam natur conflict 1 new oper join end mark path lock stage start edg oper may help upstream oper find end path increas sensit lock stage 2 oper may unmark data set anoth oper data set may take place yield inconsist downstream oper use first oper pid local comput downstream oper use second oper pid problem handl mechan oper find end path prune path place special end symbol low field last word path oper later mark last word low henc new oper append end path oper unmark data set replac id end low field lowaddress word word mark high ie downstream neighbor way path cut word data set unmark new oper abl mark word confus downstream oper high field unmark low field mark end field clear set 421 pseudocod memori word contain two field mark low high may contain oper id end initi binari intersect field ad record contain oper detail field set oper intersect ie highaddress word alreadi mark high anoth oper part anoth monoton path intersect field clear begin mark stage set oper clear oper termin oper hold local array idarray pid upstream oper collect local comput monoton path algorithm section 41 tmp variabl contain last valu read low highlevel function function local variabl clear code highlevel procedur decis postdecis stage appear algorithm 3 algorithm 4 5 detail code synchron access share data structur oper start initi local variabl see code clear intersect field oper tri mark lowaddress word use first mark fail first oper help oper whose id mark word low word unmark tri mark succe oper continu advanc next memori word oper extract initi processor id oper id current word read highaddress word record opdetail array next word monoton path oper also store initi processor id idarray local comput oper mark highaddress word use next high low field empti oper tri mark high field word put end mark low field success oper mark end path return left high field empti low field tri mark high field word success continu upstream word otherwis intersect anoth path oper set intersect flag unmark lowaddress word help oper written high field word start intersect oper first unmark lowaddress word oper help continu help upstream oper oper op use next access upstream word paramet pass next address last word access op current address op j id oper whose highaddress word henc op help op j mark highaddress word note op find op j intersect op act discov end path sinc op j go unmark lowaddress word oper unmark lowaddress word unmarklow highaddress word unmarkhigh procedur unmarklow replac id end low field low address word high field lowaddress address word ie downstream neighbor otherwis clear low field algorithm 3 gener algorithm decis postdecis stage local id myopid id oper execut local id lastopid id last oper read local id idarrayfn2 local comput reduc id local addr current prev current previou address local int index index idarray local addr tmp persist use advanc procedur decisionm opdetailsopidpidintersect lowaddress word advanc next word tmplow tmp set first insid current nextprev current opid return left edg oper return accord local comput idarray monoton path algorithm procedur firstaddr opid repeatedli tri mark lowaddress word marklowaddr opid return els helpaddrlow procedur nextprev addr opid repeatedli tri mark upstream word markendaddr opid return true edg oper markhighaddr opid return fals continu next word path setintersectionaddr opid intersect oper initi processor unmarkwordprev unmark lowaddress word get opid intersect oper restart oper get new timestamp clear intersect flag els return true initi processor validateopid return true edg oper procedur postdecisionm algorithm 4 gener algorithm lowlevel procedur decis stage procedur marklowaddr opid tmplow opid return true mark success els tmplow 6 return fals mark anoth oper procedur markendaddr opid checkintersectionopid intersect scaddropid end mark end tmphigh opid return true mark success els tmphigh 6 return fals mark anoth oper procedur markhighaddr opid checkintersectionopid intersect tmphigh opid return true mark success els tmphigh 6 return fals mark anoth oper procedur checkintersectionopid scopdetailsopidpidintersect tmp touch intersect flag els return fals procedur setintersectionaddr opid scopdetailsopidpidintersect true return opdetailsopidpidintersect algorithm 5 gener algorithm lowlevel procedur postdecis stage procedur unmarklowaddr opid tmplow opid downstream oper end mark low els scaddr els return procedur unmarkhighaddr opid tmphigh opid tmplow end edg oper end mark els scaddr tmplow unmark high field els return 422 proof correct proof correct concentr properti mark stage prove data set oper mark first execut oper enter lock stage unmark first execut processor complet oper oper mark lowaddress word first tri mark highaddress word first call next nonintersect oper return next mark word pass paramet intersect oper restart return next therefor highaddress word mark first call next return impli next lemma lemma 46 data set oper op mark first execut processor op enter lock stage word unmark postdecis stage reach initi processor find oper intersect next restart oper impli next lemma lemma 47 data set oper remain mark oper complet next prove data set oper remain unmark oper complet problem may occur execut processor set intersect flag execut processor mark highaddress word setintersect write high markhigh readintersect figur 8 illustr proof lemma 48 case 1 lemma 48 intersect flag oper set highaddress word mark proof three procedur access high fieldmarkend markhigh unmarkhigh procedur unmarkhigh mark unmark word therefor markend markhigh mark previous unmark oper consid markhigh proof appli markend synchron structur let highaddress word oper op consid memori access setintersect markhigh call checkintersect expand setintersect markhigh h5 scmhigh case 1 suppos mark high mintersect set s3 preced h5 scmhigh markhigh h5 reach readmintersect markhigh h4 return henc h4 preced scmintersect setintersect s3 sinc llmhigh markhigh h1 return preced readmhigh setintersect s2 return non valu see figur 8 therefor interven write mhigh llmhigh match scmhigh markhigh sc fail case 2 suppos mintersect set mark high h5 preced s3 scmintersect setintersect s3 succe scmintersect markhigh preced llmintersect setintersect s1 see figur 9 sinc llmhigh markhigh return readmhigh setintersect s2 return non valu interven write mhigh llmhigh match scmhigh markhigh sc fail setintersect write high markhigh figur 9 illustr proof lemma 48 case 2 lemma 49 data set oper op remain unmark op termin proof lowaddress word op mark initi processor op processor start execut op thu execut processor op mark unmark prove lemma lowaddress word op assum highaddress word op op termin postdecis stage op invalid ts field reset data set unmark unmarkword op termin sinc intersect next intersect flag set oper invalid initi processor lemma 48 memori word mark intersect flag set therefor prove unmark highaddress word mark op invalid markend markhigh mark highaddress word proof lemma 48 consid markhigh assum way contradict markhigh mark unmark op invalid sinc markhigh valid oper mark op invalid valid scmhigh oper markhigh moreov oper markhigh read mlow mhigh lemma 46 mark first execut processor op reach lock stage unmark oper invalid thu mark write mhigh llmhigh match scmhigh markhigh sc fail 423 analysi algorithm lemma 410 monoton path exist lock stage proof data set oper mark first execut process enter lock stage lemma 46 remain mark first execut process complet postdecis stage lemma 47 memori word mark low twice mark high twice differ oper code marklow markhigh markend thu two oper low address highaddress word lock stage togeth local minima maxima monoton path exist lock stage lemma 411 let op downstream neighbor op i1 assum op op i1 decid local comput last fn entri idarray first fn entri idarray i1 proof lemma 410 data set op op i1 monoton path op i1 read differ valu memori word j oper unmark j read j without loss gener let op oper read j unmark argu op j exit edg oper induct distanc conflict graph contradict assumpt op op i1 decid local comput prove lemma base case distanc 1 data set op op mark j end word op edg oper claim prove anoth oper op 0 mark j end word sinc lowaddress word mark highaddress word also mark op 0 thu op j mark data set therefor stall claim follow induct step assum lemma hold distanc j assum distanc l op read end j op edg oper claim follow sinc j unmark op read oper op write mark end op claim follow induct hypothesi otherwis op find op invalid therefor next return true op exist edg oper decis algorithm monoton path gener decis algorithm differ mark phase lemma 411 impli new pid comput oper op equal new pid comput op downstream neighbor sinc algorithm local comput theorem 45 impli lemma 412 length direct path nonedg oper eight end path fn1 oper edg oper new oper join end path mark low field last word sinc contain end therefor edg oper help oper distanc smaller equal fn 1 lemma 413 edg oper help upstream oper distanc larger theorem 414 sensit decis stage lock stage olog n proof sensit decis stage fn sinc oper advanc fn word path conflict graph contain highaddress word direct path length nine lock stage oper lock right left decid local comput contradict lemma 412 direct path length 9 lock stage oper lock left right edg oper path distanc larger fn1 end path lemma 412 contradict lemma 413 lemma 36 sensit lock stage fn algorithm guarante local content defin 1 two oper may access entri opdetail differ oper processor although far away conflict graph happen sinc opdetail array index processor id easili fix index opdetail oper id done 1 5 step complex implement binari llsc section prove omegagamma22 log n lower bound number step requir implement binari sc oper use unari oper lower bound prove show problem solv o1 oper use binari llsc requir omegagammaequ log n oper unari oper type use separ problem variant maxim independ set mi problem defin follow set n processor organ virtual ring processor assign initi memori word get input address memori word clockwis neighbor next everi processor termin either member nonmemb requir two consecut processor member b nonmemb processor least one neighbor halt member problem trivial solv binari synchron oper sc2 processor loadlink loadlink next tri sc2 pid atom next p succe exist member otherwis exist nonmemb next show maxim independ set algorithm use unari oper execut processor perform least omegagammaast log n oper linial prove omegagammaat n round requir solv mi problem messagepass model 20 modifi proof sharedmemori model get smaller bound linial use fact messagepass model round processor know address pid processor distanc true sharedmemori model assum comput proce round round processor perform singl memori oper processor know address neighbor round round processor access memori word processor distanc k know address k neighbor 1 howev next lemma prove best may happen lemma 51 round processor ring know pid address processor distanc 2 proof lemma prove induct round number base case round processor know receiv input address two word know address clockwis neighbor induct step assum lemma hold round prove lemma 1 induct assumpt round processor p know pid address processor distanc 2 thu round 1 processor p access singl processor distanc 2 learn pid address processor know therefor know pid address processor distanc rest proof close follow linial 20 first argu algorithm find maxim independ set ring convert 3color algorithm one oper processor decid membership check decis right neighbor decid nonmemb pick color decid member neighbor decid nonmemb pick color 2 otherwis pick color 3 let v set vector v v mutual distinct processor id 3color algorithm map c v f123g construct graph b xn whose set node v edg b xn form v node regular graph degre map 3color b xn see suppos c map v color 3color algorithm ring fail label happen contain segment u v result linial 20 chromat number b xn n therefor color xn three color must x omegagamma323 n log n impli omegagammaat log n step need order solv mi problem togeth o1 algorithm solv mi problem use binari llsc prove follow theorem theorem 52 implement binari llsc oper unari oper must omegagammae1 log n step complex 6 discuss paper defin sensit implement binari oper unari oper sensit distanc term intersect data set two concurr oper guarante interfer clearli sensit implement low oper execut concurr less interfer context say one oper interfer oper one delay howev notion interfer modifi exampl one add requir set memori word access oper chang execut concurr anoth oper present algorithm implement binari oper type unari sc oper sensit olog n algorithm employ symmetri break algorithm base determinist coin toss 9 practic purpos simpl nondeterminist symmetri break techniqu could employ howev care taken avoid deadlock scheme interestingli core algorithmlock memori word two directionsi similar leftright dine philosoph algorithm cf 21 pp 344349 problem n philosoph sit around tabl fork pair philosoph time time philosoph get hungri pick two fork side order eat leftright dine philosoph algorithm philosoph sit oddnumb place first pick left fork philosoph sit evennumb place first pick right fork implement link list guarante short wait chain mani philosoph hungri also prove implement binari llsc unari oper incur nonconst overhead step complex lower bound tight sinc step complex waitfre extens algorithm 1 least olog n acknowledg author thank shlomo moran lihu rappoport gadi tauben feld help comment previou version paper r disentangl multiobject opera tion perform issu nonblock synchron sharedmemori multiprocessor univers construct multiobject oper primit asynchron list compress perform spin lock altern sharedmemori multipro cessor univers oper unari versu binari method implement lockfre data structur local failur distribut synchron determinist coin toss applic optim parallel list rank univers oper unari versu binari alpha architectur handbook content share memori system synergi nonblock synchron oper system structur methodolog implement highli concurr data object transact memori architectur support lockfre data structur correct condit concurr object effici waitfre implement concurr prioriti queue local distribut graph algorithm distribut algorithm powerpc architectur specif new famili risc processor hot spot softwar transact memori alpha axp architectur lock without block make lock base concurr data structur algorithm nonblock tr determinist coin toss applic optim parallel list rank lineariz correct condit concurr object waitfre synchron local distribut graph algorithm perform issu nonblock synchron sharedmemori multiprocessor lock without block alpha axp architectur methodolog implement highli concurr data object transact memori method implement lockfre shareddata structur powerpc architectur primit asynchron list compress disjointaccessparallel implement strong share memori primit synergi nonblock synchron oper system structur local failur distribut synchron univers oper disentangl multiobject oper extend abstract content share memori algorithm univers construct larg object distribut algorithm perform spin lock altern sharedmoney multiprocessor effici waitfre implement concurr prioriti queue