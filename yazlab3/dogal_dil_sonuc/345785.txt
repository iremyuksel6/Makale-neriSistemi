applicationcontrol page share cach propos provabl effici applicationcontrol global strategi organ cach size k share among p applic process applic access inform futur page request use local inform along random context global cach algorithm abl break convent hk sim ln k lower bound competit ratio cach problem p applic process alway make good cach replac decis onlin applicationcontrol cach algorithm attain competit ratio 2hp12 sim 2 ln p typic p much smaller k perhap sever order magnitud competit ratio improv upon 2p2 competit ratio achiev determinist applicationcontrol strategi cao felten li show onlin applicationcontrol algorithm competit ratio better minhp1hk even applic process perfect knowledg individu page request sequenc result respect worstcas interleav individu page request sequenc p applic processesw introduc notion fair realist situat applic process alway make good cach replac decis show algorithm ensur applic process need evict one cach page servic page fault caus mistak applic algorithm fair remain effici global page perform bound term number mistak applic process make b introduct cach use techniqu obtain high perform day latenc disk access rel high today comput typic sever applic process run concurr mean time share multipl processor process special knowledg futur access pattern cao et al cfl94a cfl94b exploit special knowledg develop effect file cach strategi applic provid specif inform futur need equival applic cach strategi manag page cach consid multiappl cach problem formal defin section 3 p concurr execut applic process share common cach size k section 4 propos onlin applicationcontrol cach scheme decis need taken two level page need evict cach global strategi choos victim process process decid page evict cach applic process may use avail inform futur page request decid page evict howev assum global inform interleav individu page request sequenc bound respect worstcas interleav individu request sequenc competit ratio smaller h k lower bound classic cach fkl possibl multiappl cach applic may employ futur inform individu page request sequenc 1 applicationcontrol algorithm propos cao felten li cfl94a achiev competit ratio prove appendix show section 57 new onlin applicationcontrol cach algorithm improv competit ratio optim factor 2 realist scenario k use algorithm fkl 91 case p k result bound optim factor 2 p result signific sinc p often much smaller k perhap sever order magnitud scenario applic process occasion make bad page replac decis mistak show section 8 onlin algorithm incur page fault global function number mistak algorithm also fair sens mistak made one processor page replac decis worsen page fault rate processor classic cach competit analysi wellknown classic cach page problem deal twolevel memori hierarchi consist fast cach size k slow memori arbitrari size hn repres nth harmon number sequenc request page satisfi order occurr order satisfi page request page must fast memori request page fast memori page fault occur page must evict fast memori slow memori order make room new page put fast memori cach page problem decid page must evict cach cost minim number page fault incur cours servic page request beladi bel66 give simpl optimum offlin algorithm cach problem page chosen evict one cach whose next request furthest futur order quantifi perform onlin algorithm sleator tarjan st85 introduc notion competit context cach defin follow cach algorithm let fa oe number page fault gener process page request sequenc oe random algorithm let fa oe expect number page fault gener process oe expect respect random choic made algorithm onlin algorithm call ccompetit everi page request sequenc oe fa oe c delta fopt oe fix constant constant c call competit ratio measur onlin algorithm perform need rel good worstcas page request sequenc order algorithm consid good sleator tarjan st85 show lower bound k competit ratio determinist cach algorithm fiat et al fkl prove lower bound h k random algorithm allow also give simpl eleg random algorithm problem achiev competit ratio 2h k sleator mcgeoch ms91 give rather involv random algorithm attain theoret optim competit ratio h k 3 multiappl cach problem paper take theoret issu best use applic pro cess knowledg individu futur page request optim cach perform analysi purpos use onlin framework similar mention cach algorithm fkl use absolut inform futur page request intuit knowledg futur page request exploit decid page evict cach time page fault practic applic often advanc knowledg individu futur page request cao felten li cfl94a cfl94b introduc strategi tri combin advanc knowledg processor order make intellig page replac decis multiappl cach problem consid cach capabl store k page share p differ applic process denot page cach memori belong onlin algorithm multiappl cach 3 exactli one process individu request sequenc process may interleav arbitrari worstcas manner worstcas measur often critic use evalu cach algorithm individu applic request sequenc birs91 kpr92 feel worstcas measur appropri consid global page strategi cach share concurr applic process knowledg individu page request sequenc local refer within applic individu request sequenc account model applic processs knowledg futur request worstcas natur model assum noth order durat time applic process activ model worstcas measur competit perform amount consid worstcas interleav individu sequenc approach cao et al cfl94a kernel determinist choos process own least recent use page time page fault ask process evict page choic may differ least recent use page appendix show assumpt process alway make good page replac decis cao et al algorithm competit 2 algorithm present next section analyz thereaft improv competit ratio 2h p onlin algorithm multiappl cach algorithm onlin applicationcontrol cach strategi oper system kernel manag share cach effici fair manner show subsequ section competit ratio algorithm 2h optim within factor 2 among onlin algorithm use algorithm fkl page fault first choos victim process ask evict suitabl page algorithm detect mistak made applic process enabl us reprimand applic process pay mistak scheme mark page well process systemat way process request constitut phase 1 global sequenc page request partit consecut sequenc phase phase sequenc page request begin phase page process unmark page get mark phase request process mark page cach mark new phase begin page request cach page cach mark page access phase call clean respect phase onlin algorithm cach begin phase request clean page call clean page request phase alway begin clean page request onlin algorithm multiappl cach 4 mark scheme similar one fkl 91 classic cach problem howev unlik algorithm fkl 91 algorithm develop nonmark algorithm sens algorithm may evict mark page addit notion phase definint 1 differ notion phase fkl 91 look upon special case gener notion put differ perspect section 41 algorithm work follow page p belong process p r request 1 p cach p mark mark b process p r unmark page cach mark p r 2 p cach process p r unmark page p clean page respect ongo phase ie p r made mistak earlier phase evict p ask process p r make page replac decis evict one page cach order bring page p cach mark page p also mark process p r unmark page cach b els process p r mark page p clean page page cach mark remov mark page process start new phase begin current request p ii let denot set unmark process page cach randomli choos process p e process chosen uniform probabl 1jsj iii ask process p e make page replac decis evict one page cach order bring page p cach mark page p also mark process p e unmark page cach note step 2ai 2biii algorithm seek page decis applic process unmark consid unmark process p ask evict page phase consid p page cach time let u denot farthest unmark page process p u unmark page process p whose next request occur furthest futur among p unmark cach page note process p may mark page cach whose next request occur request u 2 good set unmark process p current point phase set consist farthest unmark page u cach everi mark page p cach whose next request occur next request page u page replac decis made unmark process p either step 2ai step 2biii evict page good set regard good decis respect ongo phase page good set p good page evict purpos time decis decis made unmark process p good decis regard mistak process p process p make mistak evict certain page cach detect mistak made p page request p phase p still unmark section 6 7 specif assum applic process alway abl make good decis page replac section 8 consid fair properti algorithm realist scenario process make mistak 41 relat previou work classic cach mark scheme approach inspir similar approach classic cach problem fkl 91 howev phase defin algorithm significantli differ natur fkl 91 phase end k distinct mark page cach k distinct page may request phase phase depend random choic made algorithm probabilist natur hand phase defin fkl exactli k distinct page access given input request sequenc phase determin independ cach algorithm use definit fkl 91 suit facilit analysi onlin cach algorithm never evict mark page call mark algorithm case mark algorithm sinc mark page never evict soon k distinct page request k distinct mark page cach mean phase determin definit special case mark algorithm exactli phase determin definit fkl 91 note algorithm gener mark algorithm sinc may evict mark page mark algorithm alway evict unmark page algorithm alway call unmark process evict page actual page evict may mark 5 lower bound opt competit ratio section prove competit ratio onlin cach algorithm better minfh g let us denot opt optim offlin algorithm cach work follow page fault occur opt evict page whose next request furthest futur request sequenc among page cach fkl 91 compar number page fault gener onlin algorithm phase number page fault gener opt phase express number page front function number clean page request phase state prove lower bound amort number page fault gener opt singl phase proof simpl gener analog proof fkl 91 deal determinist phase mark algorithm lemma 1 consid phase oe onlin algorithm clean page request opt incur amort cost least 2 request made phase 2 number clean page opt cach begin phase number page request oe opt cach algorithm cach begin oe let i1 repres quantiti next phase oe i1 let dm i1 clean page opt cach begin oe i1 mark oe u mark oe note clean page request oe opt cach opt gener least oe hand process request oe opt use u cach locat sinc begin oe i1 u page opt cach mark oe u page would opt cach oe even began k mark page algorithm cach end oe dm page mark oe algorithm cach number distinct page request oe least dm k henc opt serv least dm correspond oe without use u cach locat mean opt gener least k oe therefor number fault opt gener oe least let us consid first j phase jth phase sequenc opt least fault first phase opt gener k fault k thu sum opt fault phase least use fact 2 thu definit amort number fault opt gener phase oe least 2 amort lemma 1 mean j 1 number page fault made opt serv first j phase least number clean page request ith phase next construct lower bound competit ratio random onlin algorithm even applic process perfect knowledg individu request sequenc proof straightforward adapt proof h k lower bound classic cach fkl 91 howev situat hand adversari restrict request sequenc use prove lower bound therebi result lower lower bound theorem 1 competit ratio random algorithm multiappl cach problem least minfh p even applic process perfect knowledg individu request sequenc lower bound classic cach problem fkl directli applic consid case process access one page give lower bound h k competit ratio case p k construct multiappl cach problem base nemesi sequenc use fkl 91 classic cach fkl 91 lower bound h k 0 prove special case cach size k 0 total k page denot c 1 c 2 c k 0 1 one page fit cach time correspond multiappl cach problem consist one process correspond page classic cach lower bound instanc k 0 size cach process total number page among process k cach size one page among process fit memori simultan instanc multiappl cach problem construct request sequenc process p consist repetit doubl roundrobin sequenc 1 length 2r refer doubl roundrobin sequenc 1 touch process p adversari gener request correspond touch process p say touch process p given arbitrari adversari sequenc classic cach problem describ construct adversari sequenc multiappl cach problem replac request page c former problem touch process latter problem transform algorithm instanc multiappl cach one classic cach problem follow correspond multiappl algorithm evict page process p j servic touch process p classic cach algorithm evict page c j order servic request page c lemma 2 show optimum onlin algorithm instanc multiappl cach never evict page belong process p servic fault request page process p thu transform valid page c alway resid cach page request c servic reduct immedi impli competit ratio instanc multiappl cach must least h k 0 lemma 2 instanc multiappl cach onlin algorithm convert onlin algorithm 0 least good amort sens properti page process p cach immedi touch p process intuit doubl roundrobin sequenc forc optim onlin algorithm servic touch process evict page belong anoth pro cess construct onlin algorithm 0 onlin manner suppos 0 fault touch process p algorithm evict page p j j 6 0 algorithm evict page p first roundrobin servic touch p page fault second roundrobin evict page anoth process second roundrobin 0 evict page first roundrobin incur fault second roundrobin first page fault wast page could evict instead first roundrobin instead evict anoth page p second roundrobin 0 evict arbitrari page anoth process first roundrobin 0 incur page fault second roundrobin thu evict page p incur least one page fault 0 fault touch p 0 doesnt page decis 0 make fault touch p 0 fault 0 evict page cach page fault 0 charg extra page fault incur earlier 0 evict one p page thu number page fault 0 incur number page fault incur construct page process p algorithm 0 cach immedi touch process p doubl roundrobin sequenc reduct replac singl roundrobin sequenc redo explicit lower bound argument fkl 6 hole section introduc notion hole play key role analysi onlin cach algorithm section 62 mention crucial properti hole algorithm assumpt applic alway make good page replac decis properti also use bound page fault occur phase applic make mistak page replac decis definit 3 evict cach page time page fault clean page request said creat hole evict page intuit hole lack space page page place cach contain hole page page p 1 evict servic clean page request page p 1 said associ hole page p 1 subsequ request anoth page p 2 evict servic request hole said move p 2 p 2 said associ hole end phase say hole h move process p mean hole h move page p belong process p 61 gener observ hole request clean page phase page fault creat hole number hole creat particular phase equal number clean page request phase apart clean page request request hole also caus page fault occur request hole mean request page associ hole proceed request sequenc phase page associ particular hole vari time consid hole h creat page p 1 evict serv request clean page p c request made page p 1 page p 2 evict h move p 2 similarli page p 2 request h move p 3 let tempor sequenc page associ hole h particular phase page p 1 evict clean page p c request page evict p igamma1 request request p fall next phase number fault incur particular phase consid due request h gamma 1 62 use properti hole section make follow observ hole assumpt applic process make good decis lemma 3 let u farthest unmark page cach process p point phase process p mark process time request page u serv follow definit farthest unmark page natur mark scheme employ algorithm lemma 4 suppos request page p associ hole h suppos process p own page p process p alreadi mark time present request page p associ hole h process p evict page p ask make page replac decis order serv either clean request page fault previou page associ h either case page p good page time process p made particular page decis sinc process p unmark time decis made p either farthest unmark page process p mark page process p whose next request request p farthest unmark page lemma 3 process p mark process time request page p lemma 5 suppos page p associ hole h let p denot process own page p suppos page p request time phase hole h move process p subsequ current phase proof hole h belong process p lemma 4 request made h mark remain mark end phase sinc unmark process chosen evict page request h thereaft result evict page belong p hole never move process let r unmark process time request hole h unmark process denot farthest unmark page process p j time request hole h without loss gener let us relabel process tempor order first subsequ appear page u j global page request sequenc lemma 6 situat describ 2 suppos page request hole h hole move good page p unmark process p serv current request h h never move process current phase proof first subsequ request good page p p evict definit must must first subsequ request farthest unmark page u process p mark next time hole h request lemma 4 hand first subsequ request respect farthest unmark page u 1 u appear page u thu lemma 3 alreadi mark next time hole h page get request remain mark remaind phase henc fact unmark process get chosen hole h never move 7 competit analysi onlin algorithm main result theorem 2 state onlin algorithm multiappl cach problem roughli 2 ln pcompetit assum applic process alway make good decis eg process know futur page request lower bound theorem 1 follow algorithm optim term competit ratio factor 2 competit analysi onlin algorithm 11 theorem 2 competit ratio onlin algorithm section 4 multiappl cach problem assum good evict alway made 2 competit ratio within factor 2 best possibl competit ratio problem rest section devot prove theorem 2 count number fault gener algorithm phase make use properti hole previou section request made clean page phase hole move phase count number fault gener algorithm phase n number time hole h request phase assum good decis alway made prove phase hole h expect valu n bound h p gamma1 consid first request hole h phase let r h number unmark process point time let cr h random variabl associ number page fault due request hole h phase lemma 7 expect number ecr h page fault due request hole h hr h prove induct r h ec suppos use terminolog notat lemma 6 let farthest unmark page r h unmark process time request h appear tempor order global request sequenc renumb r h unmark process conveni page u farthest unmark page unmark process p hole h request algorithm randomli choos one r h unmark process say process p ask process p evict suitabl page assumpt hole h move good page p process p lemma 5 6 algorithm choos unmark process p good page p evict r h gamma process remain unmark next time h request sinc r h unmark process chosen probabl 1r h ecr h r h ecr h gammai r h applicationcontrol cach fair 12 last equal follow easili induct algebra manipul let us complet proof theorem 2 lemma 4 maximum possibl number unmark process time hole h first request impli averag number time hole request phase bound h p gamma1 3 total number page fault phase 1 alreadi shown lemma 1 opt algorithm incur amort cost least 2 request made phase therefor competit ratio algorithm bound 1 h p 2 appli lower bound theorem 1 complet proof applicationcontrol cach fair section analyz algorithm perform realist scenario applic process make mistak defin definit 2 bound number page fault incur phase term page fault caus mistak made applic process phase main idea applic process p commit mistak evict certain page p phase request page p process p still unmark algorithm make process pay mistak step 2ai hand page ps evict process p mistak process mark page p later request phase say time process p mistak worth detect follow reason sinc evict page p mistak must mean time 1 ps evict exist set u one unmark page process p cach whose subsequ request appear next request page p process p mark time next request p impli page u evict p time 2 3 ju j1 mistak evict p instead time 1 2 ju j1 process p make specif good page decis evict farthest unmark page set fpg u page cach time notion fair choos ignor mistak consid worth detect definit 4 ongo phase page fault correspond request page p unmark process p call unfair fault request page p clean page request fault phase unfair call fault unfair fault precis page fault caus mistak consid worth detect state follow two lemma follow trivial definit mistak good decis unfair fault fair fault applicationcontrol cach fair 13 lemma 8 phase page request get process step 2ai algorithm precis unfair fault phase unfair fault correspond mistak get caught step 2ai algorithm lemma 9 fair fault precis request get process step 2biii consid behavior hole current mistakepron scenario number hole phase equal number clean page request phase lemma 11 consid hole h associ page p process p request h unfair fault process p still unmark hole h move page belong process p request hole h fair fault process p alreadi mark hole h never move process p subsequ phase request hole h unfair fault definit process p unmark lemma 8 h move page p 0 process p request h fair fault definit fact request h clean page request process p mark sinc algorithm never choos mark process evict follow h never visit process p subsequ phase phase hole h creat process say p 1 clean page request move around zero time within process p 1 account mistak request hole h fair fault upon move process p 2 never come back process p 1 phase behav similarli process p 2 end phase let h denot total number fault attribut request hole h phase f h fault fair fault u h fault unfair fault lemma 11 proof techniqu proof lemma 7 theorem 2 prove follow key lemma lemma 12 expect number ef h page request hole h phase result fair fault h p gamma1 lemma 10 algorithm incur page fault phase clean page request expect valu quantiti h p lemma 12 express number unfair fault number mistak consid worth detect algorithm effici number unfair fault addit term phase oe clean request denot oe 9 conclus 14 theorem 3 number fault phase oe clean page request oe unfair fault bound 1 time oe unfair fault applic process make mistak caus fault must evict page cach applic process ever ask evict page servic unfair fault caus applic process 9 conclus cach manag strategi prime import high perform comput ing consid case p independ process run comput system share common cach size k applic often advanc knowledg page request sequenc paper address issu exploit advanc knowledg devis intellig strategi manag share cach theoret set present simpl eleg applicationcontrol cach algorithm multiappl cach problem achiev competit ratio 2h 2 result signific improv competit ratio 2p multiappl cach thetah k classic cach sinc cach size k often order magnitud greater p proven onlin algorithm problem competit ratio smaller minfh even applic process perfect knowledg individu request sequenc conjectur upper bound h p gamma1 proven second order term perhap use techniqu ms91 although result algorithm like practic use notion mistak abl consid realist set applic process make bad page decis show algorithm fair effici algorithm situat applic need pay applic processs mistak bound global cach perform algorithm term number mistak notion good page replac decis mistak fair context new one relat area possibl futur work consid altern model model worstcas interleav anoth interest area would consid cach situat applic good knowledg futur page request applic knowledg futur request could also consid page share among applic process r studi replac algorithm virtual storag com puter competit pag cao implement perform applicationcontol file cach competit algorithm page problem markov page strongli competit random page algorithm amort effici list updat page rule tr ctr guy e blelloch phillip b gibbon effect share cach among thread proceed sixteenth annual acm symposium parallel algorithm architectur june 2730 2004 barcelona spain