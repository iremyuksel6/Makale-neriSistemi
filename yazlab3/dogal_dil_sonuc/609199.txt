continuationbas multiprocess multiprocess facil must includ three featur elementari exclus data protect process save elementari exclus must rest hardwar facil eg testandset instruct two requir fulfil featur alreadi present applic languag data protect may obtain use procedur closur funarg process save may obtain use catch oper use catch particular allow eleg treatment process savingw demonstr techniqu write kernel modul multiprocess system kernel small mani function one would normal expect find insid kernel complet decentr consid implement schedul interrupt implic idea languag design b introduct past year research made progress understand mechan need wellstructur multiprocess facil seem univers agreement follow three featur need 1 elementari exclus 2 process save 3 data protect elementari exclus mean devic prevent processor interf other access share resourc typic elementari exclus may program use test set instruct creat critic region critic region howev adequ describ kind share one want control complex resourc disk region highli structur data base case one use elementari exclus control access resourc manag eg monitor 11 serial 1 turn regul access resourc unfortun access manag may becom system bottleneck standard way allevi manag save state process wish delay manag act take request consid state resourc either allow request program continu research report herein support part nation scienc foundat grant number mcs7506678a01 mcs7904183 paper origin appear j allen editor confer record 1980 lisp confer page 1928 palo alto ca 1980 compani republish acm current address colleg comput scienc northeastern univers 360 huntington av enu 161cn boston 02115 usa delay queue pictur manag littl comput becom less bottleneck implement kind manag one need kind mechan save state process make request basic observ paper mechan alreadi exist literatur applic languag catch oper 14 15 21 25 oper allow us write code processsav procedur littl fuss leav third problem protect privat data would good monitor user could bypass manag blith get resourc standard solut introduc class mechan implement protect data applic languag data may protect make local procedur closur idea exploit 19 unjustli neglect reviv show give eleg solut problem demonstr solut write kernel modul multiprocess system kernel small mani function one would normal expect find insid kernel semaphor manag 2 may complet decentr use catch system thu answer one question 3 provid way drastic decreas size kernel implement system present slightli differ form use indiana scheme 31 system 26 remaind paper proce follow section 2 discuss assumpt system code run section 3 4 show implement class processsav respect section 5 bring idea togeth write kernel multiprocess system section 6 7 util kernel write schedul modul system section 8 show treat interrupt last section 9 consid implic work applic languag 2 model comput fundament model multiprocessor multiprocess system use share memori mani segment code call process resid singl share randomaccess memori extent process actual share memori control softwar sever activ unit call processor execut process sever processor may execut process simultan make usual assumpt memori access mark finest grain interleav two processor may access read write sane word memori time elementari memori exclus enforc memori hardwar interfac process processor distinguish process call kernel kernel job assign process readi run processor idl convent system eg 22 entail keep track mani thing shall see kernel need keep track readi process may worthwhil discuss author scheme 31 system provid context work scheme applicativeord lexicallyscop fullfunarg dialect lisp 25 scheme 31 system indiana univers translat input scheme code code suitabl multistack machin machin implement lisp thu constraint could lisp code sinc addit would constitut modif machin system simul multiprocessor system mean interrupt use protocol discuss section 8 howev primit oper includ applic lisp function uninterrupt allow us write uninterrupt testandset oper de testandsetcar x prog2 nil car x rplaca x nil return car argument set car nil two featur scheme worth mention first scheme use callbyvalu pass paramet mean actual paramet evalu new conscel alloc new cell pointer evalu actual paramet plant usual associ list implement pointer cdr field ribcag implement 24 car pointer may chang use asetq procedur thu write defin schemedemo1 x asetq x call schemedemo1 alway return 3 sinc second asetq chang differ cell first one featur applic languag alway rather obscur see 17 sec 185 illumin discuss second properti depend stack actual alloc lisp heap use con reclaim use garbag collector allow us quit code techniqu shall say assumpt conclus 3 implement class us primari purpos class construct provid locu retent privat inform simula 6 class instanc activ record surviv caller applic languag record may construct environ associ list closur funarg idea state clearli 23 discuss briefli complet exampl simpl conscel may model defin conscel x lambda msg cond lambda val asetq x val lambda val asetq val defin car x x car defin cdr x x cdr defin rplaca x v x rplaca v defin rplacd x v x rplacd v con cell function expect singl argument depend type argument receiv cell return chang either compon arbitrarili chosen one sever way behavior defin data structur discuss 10 20 23 least one similar object known church 5 cite 24 anoth exampl import purpos defin busywait let x con nil label self lambda msg cond testandsetcar x car rplaca x busywait function argument call creat new locu busywait creat function new privat variabl x x guarante new use callbyvalu return function denot self expect singl argument either p v call p send testandset loop call v reset car x thu releas semaphor way access variabl x except call function note advoc busywait except perhap certain special circumst use busywait rest paper may safe replac hardwaresupport elementari exclus devic reader may prefer concern build complex schedul elementari exclus particular shall consid better way build semaphor section 6 4 process save catch catch old addit applic languag oldest version known author landin call either pp program point 15 jlambda 14 1 reynold 21 call escap somewhat restrict form catch exist lisp 15 errset 16 anoth version found maclisp pair catch throw form adopt steel sussman 25 similar reynold scheme catch bind oper evalu express catch id caus identifi id bound use callbyvalu continu object describ shortli express expr evalu extend environ continu object function one argument invok return control caller catch express control proce catch express return suppli argument valu correspond notion express continu denot semant understand use catch may consid exampl catch con return 3 3 evalu entir catch express return 3 form usual use catch similar defin foo evalu junk caus function foo return caller valu junk power catch aris store valu invok point program case caller foo restart ms argu ment portion program call lost unless preserv strateg place catch small instanc phenomenon happen even first examplether ms caller con abandon call continu function thu much like jump hyperspaceon lose track entir one current context reemerg context set continu actual occurr catch code write remaind section next shall consid thing continu alreadi creat catch get section 6 shall start use catch code shall use continu repres process process selfcontain comput may repres process pair consist continu argument sent continu correspond notion command continu denot semant defin consprocess cont arg lambda msg cond defin process class instanc two compon continu argument singl oper runit caus continu appli argument thu start process cont contin uation appli caus control revert place refer caller x runit lost terribl sinc caller x runit may save continu someplac els 5 kernel enough machineri write kernel oper system kernel job keep track process readi run assign process processor ask one kernel therefor class instanc keep queue process two oper one add process readi queue one assign process processor therebi delet readi queue shall need queue manipul therefor assum function createqueu creat empti queue function addq q x side effect ad valu x queue q function deleteq q return top element queue q sideeffect delet q may write code kernel defin genkernel let readyqueu createqueu mutex busywait lambda msg cond lambda cont arg block mutex p addq readyqueu consprocess cont arg mutex mutex p let nextprocess deleteq readyqueu block mutex v nextprocess runit asetq kernel genkernel defin madereadi cont arg kernel makereadi cont arg defin dispatch kernel dispatch defin two basic function makereadi dispatch call makereadi cont arg put process built cont arg readi queue must get past short busywait busywait alway short kernel never tie long construct also keep idea build complex exclus mechan simpl one put process queue releas kernel exclus exit given code busywait alway return valu return must pointer privat data dispatch subtler processor execut dispatch whenev decid noth better normal call dispatch would preced call makereadi need case pass semaphor next wait process delet readi queue assign nextprocess mutex v execut nextprocess start send runit signal subtleti order last two oper revers sinc nextprocess start would way reset semaphor given order safe howev use callbyvalu everi call dispatch use differ memori word nextprocess therefor call nextprocess runit use share data may execut outsid critic region explanatori word code order first note kernel makereadi return function take two argument perform requir action kernel dispatch howev perform action directli could made kernel dispatch return function argument judg confus asymmetri second block scheme sequenc construct analog progn also cond use socal gener cond implicit block progn righthandsid altern 6 two better semaphor function busywait would adequ implement binari semaphor one sure semaphor never close long section shall write code two better implement semaphor first implement use kernel provid altern testandset loop testandset fail throw remaind current process readi queue execut dispatch sometim call spin lock defin spinlocksemaphor let x con nil label self lambda msg cond cond testandsetcar car rplaca x defin giveupandtrylat catch caller block makereadi caller key function giveupandtrylat put readyqueu process consist caller argument call dispatch switch processor execut readi process enqueu process restart processor execut dispatch appear giveupandtrylat quietli return effect execut delay unknown durat depend state readi queue thu process execut p semaphor knock testandset cell close process go sleep tri later exampl illustr use catch makereadi probabl good implement semaphor better implement closer standard one would maintain queue process wait semaphor process need delay tri p store queue v execut wait process may restart precis place readi queue code follow defin semaphor let q createqueu queue wait process count mutex busywait lambda msg cond mutex p catch caller block cond greaterp count asetq count sub1 count mutex v mutex v mutex p emptyq q asetq count add1 count makereadi deleteq q mutex v execut semaphor creat class instanc queue q use hold process wait semaphor integ count tradit valu semaphor busywait locu mutex mutex use control access schedul code alway reopen process pass semaphor suggest introduct use small busywait control entranc sophist schedul typic p execut call process first must get past mutex critic region critic region count check greater 0 decrement mutex exclus releas semaphor return valu caller count zero continu correspond caller semaphor store queue mutex releas processor execut dispatch find process work v execut call process first get past mutex semaphor critic region queue check see process wait semaphor none count increment least one delet queue deleteq q put kernel readi queue argument restart kernel think complet call p sinc p alway return second argument makereadi must likewis bookkeep accomplish mutex releas call v return typic implement semaphor eg 2 differ semaphor independ object lie outsid kernel way privileg code also written code implement complex schedul complex schedul actual written code brinch hansen process 4 written scheme syntact macro code page long 7 one thing turn import issu process creation although semaphor previou section use catch save state current process provid mean increas number process system may function createprocess createprocess take one argument function argument creat process execut function parallel caller createprocess defin createprocess fn catch caller block catch process block makereadi process caller createprocess call fn first creat continu contain caller call caller enter block creat continu call process start continu execut block fn continu process put kernel readi queue argument ignor process restart caller execut caus createprocess return caller valu thu process call createprocess continu control pro cessor process put onto readi queue kernel decid run process fn execut processor run process dispatch find someth els reader find code tricki may take comfort opinion trickiest piec code paper difficulti lie fact execut sequenc almost exactli revers lexic sequenc 8 use createprocess implement forkjoin function fork take two function argument result con valu execut two function proceed two independ process process call fork delay return defin fork fn1 fn2 catch caller let onedon nil ans1 nil ans2 nil mutex busywait let checkdon lambda dummi block mutex p onedon makereadi caller con ans1 ans2 asetq onedon mutex v block createprocess lambda checkdon asetq ans1 fn1 createprocess lambda checkdon asetq ans2 fn2 fork set four local one two answer flag call onedon semaphor control access flag creat two daughter process dispatch save caller continu caller two process comput answer deposit appropri local variabl call checkdon checkdon use mutex obtain access flag onedon initi nil valu nil set valu signifi current call checkdon second one caller move readi queue argument con ans1 ans2 8 interrupt written far quit adequ nonpreempt schedul system 2 wish use preemptiv schedul system must wish use singl processor must consid handl interrupt shall consid problem preemption process time interrupt nonpreempt interrupt handl method analog 3 27 model time interrupt follow processor detect time interrupt next identifi encount cours comput say x execut replac preempt x preempt name interrupthandl routin believ 23 function applic goto bind model quit close convent model interrupt caus control pass predefin valu program counter similar treatment interrupt develop independ use mitxerox parc scheme chip 12 simplest interrupt handler defin preempt x catch caller block makereadi caller x interrupt handler process processor execut thrown back readi queue processor execut dispatch find someth els complic aris preemptiv schedul interrupt must inhibit insid kernel may accomplish chang busywait kernel kernelexclus defin kernelexclus let sem busywait lambda msg cond sem p sem v note order oper v revers order wrong interrupt might occur enablepreempt sem v caus instant deadlock discov hard way first time introduc oper probabl privileg disablepreempt enablepreempt 2 make privileg without chang architectur machin introduc readloop like defin userreadloop let disablepreempt lambda error protectionerror enablepreempt lambda error protectionerror label lambda dummi loop print eval read loop intend suggest user input evalu environ disablepreempt enablepreempt bound errorcr func tion actual way code written scheme written way avoid deal complic scheme version eval 9 conclus issu paper shown mani troublesom portion back end oper system may written simpli use applic languag catch cours drawn conclus three categori oper system kernel design applic languag languag design gener oper system work answer part brinch hansen call simplifi kernel 3 schedul apparatu except readi queue move kernel kernel becom smaller call less often therefor becom less bottleneck pass messag class instanc function instead pass process avoid need individu process therebi avoid need maintain process tabl etc reduc size kernel meant impli solv problem associ system kernel problem storag alloc perform address area process save protect howev approach discuss seem offer consider advantag area applic languag work seem address issu state modul said state differ call modul ident argument may give differ result differ time comput anoth way describ phenomenon model historydepend confus issu nondetermin object state never matter whether two process deal object two copi process commun howev must talk modul two copi instanc modul must commun kernel two modul produc call genkernel therefor kernel similar modul must statethey must use asetq code seem us import observ mean must come grip concept state deal semant parallel observ could made context imper languag everi modul state applic context distinguish true state bind intern state could make distinct 3 relat issu use callbyvalu detail semant scheme incorpor algol callbyvalu mechan would give unambigu account two modul thu also give account two modul share state account necessari explain use asetq program determin data privat share last line kernel dispatch descript would find restart continu restor environ map identifi lvalu undo chang global state map lvalu rvalu alter asetq nonetheless find account unsatisfi systemat introduct global state everi procedur call seem quit odd usual statefre pictur applic program find unpleas say pass paramet worth ie without copi except need think harder program regard commend applic metaprogramm closer studi denot semant descript denot semant expound chapter 1 17 9 provid tool give accur descript actual happen paramet pass howev measur would help allevi confus exampl could use primit cell oper place unrestrict use asetq valu could pass worth rvalu lvalu would aris denot cell explicit dereferenc would requir approach taken variou degre plasma 10 forth 13 bliss 28 4 also john reynold one student investig semant reli singl global state person commun 5 last essay idea languag design process choic work area applic languag motiv part minski call separ syntax semant program 18 attempt home essenti semant idea multiprogram semant simpli mean idea express denot semant though sure use denot semant expos simplifi basic idea program gener add idea basic oper knowledg one goe semant implement eg 21 addit oper knowledg express formal semant eg treatment interrupt firm grasp inform semant idea begin consid syntax syntax human engineeringreplac parenthes posit structur grammar keyword syntax may introduc restrict class runtim structur need support languag design russel 7 good exampl paradigm one spectacular success may claim approach pascal took wellunderstood semant algol introduc syntact restrict consider simplifi runtim structur case consid syntact restrict allow use sequenti structur avoid spend one time garbagecollect stack clever data structur runtim stack also consid anoth syntact restrict might desir one would prevent continu restart languag languag propos must embodi tradeoff gener sometim call function effici consid complet gener first may readili see tradeoff may occur lost therebi unfortun typic approach languag design start given runtim structur wors yet syntact propos author realiz function lack add introduc patch introduc gener clean first compromis effici one seem like produc clean small understand even effici languag note 1 though catch callcc clearli interdefin j callcc differ importantli detail see hayo thieleck introduct landin gener jump label higherord symbol comput 112 pp 117123 decemb 1998 2 addit primit ad scheme 31 interpret 3 paragraph grew convers carl hewitt natur object ident object hewitt notion object ident distribut system requir notion global state c hewitt h g baker actor continu function e j neuhold ed formal descript program concept page 367390 north holland amsterdam 1978 page 388 issu remain interest gener globallyuniqu identifi use larg distribut system ip dcom worldwid web 4 approach cours adopt ml time chang scheme way least conceiv serious consid indiana scheme 84 implement revis 3 report 1984 radic chang becam imposs sussman steel list among mistak design scheme gj sussman gl steel jr first report scheme revisit higherord symbol comput 112 pp 5 sure refer best guess refer work ole stack semant j c reynold essenc algol j w debakk j c van vliet ed algorithm languag page 345372 north holland amsterdam 1981 r synchron actor system oper system principl architectur concurr program distribut process concurr program concept calculi lambdaconvers hierarch program structur data type go statement consid harm denot descript program languag view control structur pattern pass messag monitor oper system structur concept scheme79 chip forth microcomput correspond algol 60 church lambdanot part next 700 program languag theori program languag semant form content comput scienc protect program languag definit interpret higherord program languag logic design oper system lambda ultim declar art interpret revis report scheme scheme version 31 refer manual modula languag modular multiprogram bliss languag system program ming tr ctr edoardo biagioni robert harper peter lee network protocol stack standard ml higherord symbol comput v14 n4 p309356 decemb 2001 manuel serrano frdric boussinot bernard serpett scheme fair thread proceed 6th acm sigplan intern confer principl practic declar program p203214 august 2426 2004 verona itali zena ariola hugo herbelin amr sabri typetheoret foundat continu prompt acm sigplan notic v39 n9 septemb 2004