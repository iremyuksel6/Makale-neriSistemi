crash resili commun dynam network abstractan endtoend data deliveri protocol dynam commun network present protocol use bound sequenc number toler link failur intermedi processor crash previou bound endtoend protocol could toler crashesw present selfstabil version algorithm recov crash sender receiv well intermedi processor start network arbitrari state selfstabil version guarante proper transmiss messag follow finit converg period b introduct basic commun task network endtoend commun deliveri finit time data item gener design sender processor design receiv processor without duplic omiss reorder data item endtoend commun easi achiev reliabl net work link never fail processor crash howev exist commun network link failur processor crash possibl network subject failur call dynam network one approach construct endtoend protocol dynam network use unbound sequenc number uniqu identifi data item sent sender approach use protocol ae86 use unbound sequenc number impli messag size amount memori need grow number data item transmit therefor much effort spent design endtoend protocol use bound sequenc number import aspect endtoend commun protocol type fault toler clearli endtoend task unsolv perman senderreceiv link cut network work support nsf presidenti young investig award ccr91 58478 fund texa univers colleg engin contact author jennif l welch email welchcstamuedu phone 4098455076 fax link forev thu assumpt behavior faulti link necessari three common assumpt literatur infinit frequent stabil infinit often network topolog stabil period time senderreceiv link cut stabil topolog eg aag87 as88 infinit frequent path stabil infinit often period time link form least one path sender receiv oper eg agh90 h92 eventu connect assumpt perman senderreceiv link cut eg ag88 ams89 ag91 agr92 almost exist endtoend protocol depend physic link made wellbehav sequenc messag deliv alway prefix sequenc sent ie messag lost middl processor crash behavior ensur run altern bit protocol bsw69 processor crash good behavior achiev without keep inform includ messag current transmit stabl storag 2 even weaker behavior physic link requir name crash end point sequenc deliv prefix sequenc sent either stabl storag requir flms91 bound capac link must known adw93 unfortun exist dynam network processor may repeatedli crash recov corrupt memori even problem one endtoend protocol caus crash messag current transmit lost probabl data item deliv could exponenti small length path data item travel assum probabl processor crash deliveri data item bound constant would like protocol resili crash intermedi processor ie processor network design sender receiv reli stabl storag exclud possibl sender receiv fail sinc stabl storag would requir argument allud physic link obvious actual system sender receiv could crash recoveri techniqu use case applic depend beyond scope paper presenc processor crash previou definit eventu connect suffici exist protocol sinc perman cut combin crash processor crash link could elimin connect sender receiv thu make weakest assumpt possibl name exist least one viabl path sender receiv path contain perman faulti link 2 known endtoend protocol withstand processor crash without stabl storag random protocol present h92 howev protocol bound probabl failur use header strictli bound processor perman crash path ie least one path along commun possibl eleg approach design commun protocol view network run black box provid messag transfer servic messag lost reorder duplic corrupt 3 howev approach limit wz89 show bound sequenc number protocol toler reorder duplic aa92 show although bound sequenc number protocol toler reorder loss protocol must properti number messag need transmit data item increas without bound imposs result hing assumpt black box network reorder messag arbitrarili assumpt model situat user network know network layer protocol implement black box rout messag even network topolog altern approach avoid arbitrari reorder use knowledg network topolog explicitli control retransmiss rout packet inde lost travel physic link howev duplic caus protocol retransmit packet certain circumst packet retransmit protocol duplic exist reorder also protocol properti protocol use singl path sender receiv singl path receiv sender fifo properti direct preserv network thu protocol design work top bare network consist node connect fifo nondupl link lose messag although protocol retransmit use multipl path thu messag duplic reorder lost activ care coordin paper present endtoend protocol dynam network toler crash node failur link commun network without requir stabl storag knowledg link capac best knowledg protocol first crash resili endtoend protocol use bound sequenc number space complex protocol ie maximum amount space use processor program op 2 log p p number simpl path network messag size op log p bit time complex ol l length viabl path messag complex onp1lt n number processor system retransmiss paramet roughli speak time messag complex measur run time messag travel viabl link 1 compar complex measur agr92 assum reliabl data link layer number possibl path p two processor system theoret exponenti jej number link system could drawback protocol howev practic commun scheme 3 practic nonzero probabl messag corrupt howev due error detect scheme assum messag identifi discard base send messag along singl rout sourc destin see h92 nice discuss practic protocol thu protocol theoret interest could use improv exist protocol use constant number path sourc destin long least one viabl data item deliv moreov deliveri time time interv due fastest reliabl path period anoth applic protocol case parallel physic link two processor applic would provid implement reliabl nonparallel link situat number path would obvious extrem small 2 bare network model commun network graph gv e jv node processor edg undirect commun link undirect link consist two direct link deliv messag opposit direct commun link connect two processor two processor connect link call neighbor commun link obey fifo disciplin bound transmiss delay known processor system view state machin execut pro gram execut program consist sequenc step step consist 1 one receiv oper zero one messag ceiv 2 intern comput 3 zero send oper intern comput sender includ input data item intern comput receiv includ output data item assum sender receiv subject crash processor call intermedi processor intermedi processor subject crash follow crash processor reenter initi state may continu execut crash intermedi processor could occur middl step model partial step subset messag sent actual sent model link processor p q two fifo queue one hold messag transit p q hold messag transit q p link subject failur link failur caus one messag elimin compon queue configur system set state processor content messag link run sequenc configur initi configur processor initi state link empti go c c i1 one follow hold processor p take next step possibl partial step accord program messag receiv head relev queue c dequeu c i1 p chang state accordingli enter initi state partial step messag sent enqueu c i1 noth els chang link fail chang one messag queue particular link c longer c i1 go concern run satisfi certain basic con dition given run admiss sender take infinit number step receiv take infinit number step exist least one viabl path sender receiv remain defin viabl path assum infinit run satisfi first two admiss condit intermedi processor p viabl provid whenev p receiv messag infinit often succe send infinit often 4 link viabl provid whenev infinit number messag sent link infinit number messag receiv receiv processor assum true direct link note definit viabl link impli receiv processor must take infinit number step partial step path viabl everi intermedi processor everi link path viabl definit viabil weaker agr92 sinc latter consid processor crash viabl path network sender receiv everi path either nonviabl processor nonviabl link thu senderreceiv cut note restrict concern rel order processor step number step send messag receipt thu asynchron system assum whatev entiti suppli data item sender provid one sender request one 3 problem statement algorithm solv endtoend commun problem everi admiss run follow properti satisfi safeti prefix run sequenc data item output receiv prefix sequenc data item input sender 4 definit restrict behavior intermedi processor way compat system suppos strip part header send one link gener definit viabl processor would upon receiv messag infinit often p execut infinit often complet step start receiv howev protocol weaker condit infinit execut partial step succe forward suffici live receiv infinit number output interest complex measur space maximum amount space requir node program messag size maximum number bit messag messag number maximum number messag sent transfer data item ideal run 5 two success input time maximum length time two success input ideal run time messag complex discuss ideal run defin processor send messag either respons receiv messag base timeout paramet order guard messag loss say messag retransmit sent base timeout expir otherwis new time retransmiss due speed processor natur frequenc retransmiss influenc total time number messag need deliv data item processor procedur respons send messag send procedur keep track number step k processor taken order estim real time elaps systemdepend valu depend say probabl loss distribut messag delay link want estim base k good one rational condit 1 definit ideal goal retransmit everi unit time ensur messag deliv within one time unit assum link viabl rational condit 2 definit ideal admiss run ideal 1 whenev processor taken k step least real time elaps 2 processor p receiv messag time address travel viabl path path neighbor q path receiv time 4 protocol main problem protocol keep track set sequenc number label messag transit network key observ fifo properti link use ensur fifo deliveri everi path sender receiv vice versa messag sent descript path take messag sent path obey fifo order note two differ path might share link thu set messag transit link could relat one path order two messag within one link necessarili impli anyth rel order send receipt unless two messag path 5 defin sender receiv use set 2p sequenc number shortli explain number suffici sender receiv rememb sequenc number recent messag sent receiv path sender use array sent sr recvr entri possibl path whenev sender send messag sequenc number seqnum path path sender assign sent sr pathseqnum similarli whenev sender receiv messag sequenc number seqnum sender assign recvr pathseqnum receiv use array sent rs recv sr bookkeep sender use clean path send new data item new sequenc number path path sender receiv consid clean sent sr pathrecv sr path say sequenc number current repeatedli sent path arriv destin use clean path ensur set sequenc number messag particular senderreceiv path path contain sent sr path path moreov case two sequenc number path path messag order path one sequenc sent sr path closer sender messag sequenc number recv sr path unfortun array recv sr updat receiv thu valu recv sr path known sender consequ receiv send array recv sr sender howev sender abl distinguish old valu recv sr current valu done implement independ altern bit protocol bsw69 one entir path r individu physic link given path protocol keep track number altern bit token ie number time sender receiv acknowledg bit current tri send arriv sender path sinc sender input last data item sender use inform concern recv sr arriv path come second token arriv path sinc last data item input rule ensur inform receiv reflect current state path whenev inform concern recv sr arriv sender updat view recv sr array call vrecv sr sender use inform sent sr vrecv sr determin whether senderreceiv path clean similarli receiv use sent rs vrecvr determin whether receiversend path clean view run protocol sequenc altern sting begin sender use sequenc number 1 sting receiv first data item sender repeatedli send messag sequenc number 1 possibl path eventu messag arriv receiv use sequenc number 1 sting sender acknowledg time receiv send next sequenc number call stingtag use sender sting receiv second data item receiv choos sequenc number minim sequenc number appear either recv sr vsent sr thu sequenc number set size 2p1 big enough case recv sr vsent sr includ sequenc number 1 thu receiv choos 2 next sequenc number use sender sting receiv sender eventu stung acknowledg receiv first messag sequenc number 1 arriv sender sender calcul next stingtag use sting acknowledg similar argument sequenc number 2 sender readi send ith data item get acknowledg 1st data item sequenc number entri sent sr could distinct roughli speak entri contain last sequenc number sent yet clean path ie arriv side howev sinc least one viabl path path path eventu clean sequenc number sent sr path sender eventu get two token path updat vrecv sr vrecv sr pathsent sr path sender use path send ith data item ith data item sent seqnum sr chosen receiv 1st acknowledg ith acknowledg arriv sender continu updat cleandirti statu senderreceiv path use inform concern recv sr arriv messag receiv senderreceiv path chang statu clean ith acknowledg arriv sender use path also send ith data item seqnum sr receiv use similar scheme deliv ith acknowledg unlik endtoend protocol base flood stead messag sent entir path specifi formal descript protocol appear figur 2 3 4 variabl use sender initi valu appear figur 1 variabl receiv similar except order subscript r revers confus possibl use name array eg sent sr repres set sequenc number yield entri 41 correct proof throughout section assum admiss run step caus transit c igamma1 c step denot vari valu variabl var configur c correct proof induct number sting r sender stung whenev sender execut line 02 execut line 02 occur either first atom step end line 10 atom step start messag receiv line 11 end messag send line 10 receiv stung whenev sender execut line line 24 execut line 02 occur first atom step end line 12 execut line 24 occur atom step start line 13 end line 12 variabl name type initi valu set path empti arbitrari fig 1 variabl sender forev repeat 06 8 path 07 path 2 cleanpathssr 13 recvrsmsgpath msgseqnum 14 19 vrecvsrpath msgrecvsrpath 22 vsentr msgsentr od fig 2 program sender forev msg 6 nil 04 pendingmsgpathmsg 07 od fig 3 program intermedi processor recvsrmsgpath msgseqnum 04 forev 07 repeat els sendpathnilsentr pathbitr pathnil sentr recvsr 14 msg 6 nil 22 26 seqnumr msgstingtag 28 od fig 4 program receiv copi altern bit protocol implement distinct undirect path consid singl copi altern bit protocol undirect path path token altern bit protocol arriv sender sender receiv messag bit sender current send token arriv receiv receiv receiv messag opposit bit last bit receiv sent given configur denot path path sequenc messag sender receiv 0 messag sequenc messag receiv sender j 0 messag togeth current valu bit sr p ath bit rs p ath follow rs well known eg bsw69 messag lost duplic configur altern bit protocol bitseq contain singl valu either 0 1 exist singl border bitseq valu furthermor border sender eventu chang valu bit sr border produc border look sequenc bitseq success configur run border travel toward end bitseq import properti altern bit use protocol two success token arriv sender one token arriv receiv ensur properti follow lemma lemma 1 suppos j messag msg arriv sender path p step j token p first token p sender receiv sinc step exist k k analog properti true receiv well next lemma state consecut sting sender resp receiv set valu fseqnum srg sent sr resp fseqnumrsg sent rs either remain decreas seen true inspect code sinc sender chang entri sent sr send messag sequenc number equal seqnum sr lemma 2 step sting sender fseqnum sr ig 1 analog properti true receiv well prove correct protocol theorem 3 protocol crash resili endtoend protocol proof safeti live properti prove induct number sting r prove follow 1 sting 2 even ith sting occur receiv caus i2th data item output data output equal data previou input b everi configur gamma 1st ith sting messag msg transit sender receiv sting sr msgsent sr sent sr 3 odd ith sting occur sender caus 1st data item input b 1 everi configur gamma 1st ith sting messag msg transit receiv sender sting rs msgsentr sent rs 4 configur ith sting everi senderreceiv path p sequenc sequenc number messag transit along p order start closest sender form x j k 5 configur ith sting everi receiversend path p sequenc sequenc number messag transit along p order start closest receiv form x j k prove statement basi 1 obviou code initi els vacuous true induct assum j show 1 well show odd case even similar left reader even index step ith sting r occur exist show 4 consid step sender step assum statement true preced configur well show true configur pick path p messag sent p step sequenc number sent sr p gamma 1 clearli 4 true suppos messag sent p differ sequenc number p cleanpath sr sent sr p 1 let equal valu sent sr p sinc p cleanpath sr sent sr p code first time sender chang sent sr p sinc step look step step vrecv sr p updat caus p put cleanpath sr second token p receiv sinc lemma 1 inform reflect valu recv sr p receiv configur induct hypothesi hold messag path p sequenc number name long sequenc number p recv sr p continu thu configur p sequenc number assert 4 hold configur show 5 similar 4 show 2a must show sender never stung step long receiv stung ie must show everi messag receiv sender step sequenc number equal sting rs note sting rs chang sender stung chosen vsentr recvr note ith sting arriv sender set vsentr accord inform sting messag induct hypothesi 3b sinc transit sting msentr superset sent rs sent rs induct hypothesi 5 messag transit configur sequenc number either sent rs though recvr chang path sting messag path follow sequenc number alreadi includ sent rs sequenc number thu includ recvr messag transit configur sting sender must show messag sent receiv step sting sender follow lemma 2 assert 5 prove 1st sting occur occur receiv induct hypothesi 2a would output straightforward check data correct show 2b immedi ith sting messag transit sender receiv sting receiv chose next stingtag back sting gamma 1 messag seqnum transit sender receiv messag sent sting seqnum current valu sent sr attach lemma 2 current set element sent sr shrink rel sent messag show 3 vacuou sinc show 1 must show eventu receiv stung ie receiv receiv messag sequenc number equal sting sr suppos true first note sting sr chang receiv stung sender get least two token viabl path p put p cleanpath sr send current messag p lemma 1 current messag sting sr eventu copi messag get receiv contradict messag length op log p sinc messag consist constant number compon largest sent recv array consist p entri size log p assum data item bigger space complex due intermedi processor store messag path op 2 log p recal time messag complex defin ideal run first explain detail messag retransmit send proce dure send procedur keep track pend recent messag sent path whenev send procedur execut follow first consid messag input procedur messag fresh last messag sent path store pend array differ one compon sent recv array messag store pend actual alreadi done intermedi node need done sender receiv messag fresh immedi sent onward path otherwis sent least k step elaps sinc last sent determin count step modulo k consid viabl path p length lp happen input two success data item worst case path need clean cost olp new messag olp time sender receiv two altern bit token cost olp new messag olp time final new stingtag must sting receiv cost olp new messag olp time similar analysi hold acknowledg come back sender thu time complex ol l length shortest viabl path discuss messag complex number retransmit messag sent two success data item input onplt recal retransmiss paramet reason ol time input n processor retransmit p path olt time consid new messag path p length lp discuss show olp new messag use sinc lp n p path number new messag onp thu messag complex onp note cost due retransmiss implicitli explicitli protocol assum reliabl data link layer conclud remark present crash resili endtoend protocol protocol ensur reliabl data transfer even present processor crash long least one viabl path sender receiv although bypass datalink layer protocol still work link run datalink protocol even presenc crash crash affect correct function datalink protocol one two way either messag lost link could even without datalink protocol messag duplic howev duplic toler protocol could happen point intermedi node protocol well duplic immedi follow duplic insert later malici way protocol easili modifi work case viabil one direct impli viabil direct let p sr number path sender receiv pr number path receiv sender one possibl virtual implement p sr theta pr altern bit protocol one possibl combin senderreceiv path receiversend path sinc least one combin viabl direct current inform recv sr array reach sender current inform recvr array reach receiv sever optim possibl one updat vrecv sting arriv addit one token arriv chang caus path place cleanpath earlier anoth possibl optim concern reduc messag size send array element chang sinc last time third optim would everi node period send one larg messag neighbor contain individu messag path go neighbor instead send messag separ immedi chang would decreas total number messag would increas messag length time howev simplic present incorpor optim protocol could also made selfstabil detail selfstabil version appear dw93 acknowledg thank reuven cohen amir herzberg help discuss amir also gave us use comment written draft r reliabl commun unreli channel appli static network protocol dynam network memori requir connect manag reliabl broadcast protocol unreli net work bootstrap network resynchron effici techniqu endtoend commun quantit approach dynam network slide mechan applic dynam network polynomi end end com munic dynam network fast static network note reliabl fullduplex transmiss halfduplex link crash resili commun dynam network resynch procedur failsaf network protocol imposs implement reliabl commun face crash tight bound sequenc transmiss problem tr ctr micah adler faith fich complex endtoend commun memoryless network proceed eighteenth annual acm symposium principl distribut comput p239248 may 0406 1999 atlanta georgia unit state pierr fraigniaud cyril gavoil headers lower bound endtoend commun memoryless network comput network intern journal comput telecommun network v50 n10 p16301638 14 juli 2006 faith fich eric ruppert hundr imposs result distribut comput distribut comput v16 n23 p121163 septemb