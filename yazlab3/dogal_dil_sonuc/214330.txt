buffer manag sharedmemori time warp system mechan manag messag buffer time warp parallel simul execut cachecoher sharedmemori multiprocessor studi two simpl buffer manag strategi call sender pool receiv pool mechan examin respect effici particular interact multiprocessor cachecoher protocol measur implement kendal squar research ksr2 machin use synthet workload benchmark applic demonstr sender pool offer signific perform advantag receiv pool howev also observ scheme especi sender pool mechan prone sever perform degrad due poor local refer larg simul use substanti amount messag buffer memori third strategi call partit buffer pool approach propos exploit advantag sender pool exhibit much better local measur approach indic partit pool mechan yield substanti better perform sender receiv pool scheme largescal smallgranular parallel simul applicationsth central conclus studi 1 buffer manag strategi play import role determin overal effici multiprocessorbas parallel simul 2 partit buffer pool organ offer significantli better perform sender receiv pool scheme studi demonstr poor perform may result proper attent paid realiz effici buffer manag mechan b introduct largescal sharedmemori multiprocessor kendal squar research ksr2 recent convex spp import class parallel comput high perform comput applic recent sharedmemori machin becom popular comput server multiprocessor workstat sgi challeng sun sparcserv becom common engin scientif comput laboratori technolog advanc enabl multipl cpu place within singl chip substrat multichip modul simpler program model offer sharedmemori machin enabl remain import class parallel comput forese futur well known mani largescal discret event simul comput excess time consum natur candid parallel comput time warp well known synchron protocol detect outoford execut event occur recov use rollback mechan 8 time warp demonstr success speed simul combat model 14 commun network 12 queu network 4 digit logic circuit 1 among other assum reader familiar time warp mechan describ 8 concern effici implement time warp sharedmemori multiprocessor comput prior work area focus data structur 4 synchron 9 implement share state 6 11 concern effici buffer manag strategi messag pass sharedmemori machin assum hardwar platform cachecoher sharedmemori multiprocessor commerci machin mention earlier type assum multiprocessor contain set processor local cach automat fetch instruct data need assum mechan place ensur duplic copi memori locat differ cach remain consist typic accomplish either invalid copi cach one processor modifi block updat duplic copi 13 particularli concern largescal small granular discreteev simul applic specifi calli envis applic contain thousand tensor hundr thousand simul object modest amount comput per simul event event may requir execut littl hundr machin struction small granular aris mani discreteev simul applic eg celllevel simul asynchron transfer mode atm network simul wireless person commun servic network gatelevel simul digit logic circuit applic even modest amount overhead central event process mechan lead substanti perform degrad thu import overhead incur messag pass event process loop parallel simul execut kept minimum messagepass fundament time warp mecha nism messagepass util frequent crucial effici implement particularli small granular simul becom appar later effici buffer manag essenti achiev effici messag pass mechan issu examin remaind paper organ follow section 2 describ underli messag pass mechan assum throughout studi contrast messag pass mechan messagebas parallel comput section 3 describ simpl approach buffer alloc call receiv pool altern approach call sender pool propos perform rel receiv pool compar evalu experiment use implement execut ksr2 multiprocessor section 4 observ sender pool approach gener superior receiv pool approach suffer sever perform degrad simul util larg amount memori section 5 describ third mechan call partit pool approach address flaw sender pool scheme section 6 present perform result use mechan section 7 extend result consid synthet workload compar perform three mechan two benchmark applic studi demonstr partit pool approach yield superior perform compar two mechan 2 messag pass mechan let us first consid implement messag pass sharedmemori multiprocessor assum time warp execut maintain certain number memori buffer contain inform associ singl event messag use term synonym transmit messag one processor anoth involv follow step 1 sender alloc buffer hold messag 2 sender write data transmit messag 3 sender enqueu pointer messag queue access receiv 4 receiv detect messag queue remov read possibl modifi content messag buffer mani time warp system messag buffer includ variou field pointer enqueu buffer local data structur field eg flag requir time warp execut case receiv modifi content buffer implement applic program may allow modifi receiv messag buffer although time warp execut would maintain separ copi case rollback occur altern pointer flag field may kept separ data structur extern messag buffer case content messag may modifi receiv essenti question concern organ pool free unalloc messag buffer central global pool clearli becom bottleneck nat ural distribut approach associ buffer pool processor consid altern organ assum processor maintain separ buffer pool instruct contrast messag pass mechan describ messagebas parallel comput messagebas machin pool unalloc memori buffer maintain processor new buffer must alloc prior send messag messag written buffer transmit destin processor buffer reclaim return send contrast sharedmemori multiprocessor messag need explicitli transmit copi receiv requir messagepass machin instead suffici pass pointer messag buffer destin processor memori cach mechan transpar transfer content messag referenc receiv second differ messagepass sharedmemori architectur latter provid global address space present much richer set possibl buffer organ compar messagepass machin 3 sender vs receiv buffer pool assum princip atom unit memori buffer buffer contain fix amount storag hold singl event processor maintain pool free unallo cate buffer singl buffer alloc prior messag send buffer reclaim messag cancel fossil collect either case processor last receiv buffer via messag send respons ad free pool key issu discuss follow interact cach coher protocol messag send mechan number lock oper requir oper requir access nonloc memori typic expens exist machin instanc ksr2 ten hundr machin instruct may execut time singl cach miss hundr thousand instruct may execut time singl lock oper 31 receiv pool one simpl approach manag free buffer associ pool processor receiv messag mean buffer alloc routin obtain unus buffer buffer pool processor receiv messag prior messag send call receiv pool strategi althoughsimpl implement receiv pool suffer two drawback first lock requir synchron access free pool even sender receiv lp map processor 1 processor list share among processor send messag processor second drawback concern cach effect discuss next multiprocessor system use invalidatebas cachecoher protocol receiv pool make effect use cach buffer free pool processor usual resid cach processor assum buffer delet cach replac polici case buffer last access event process procedur execut processor assum sender receiv messag resid differ processor send processor alloc buffer receiv write messag buffer seri cach miss invalid occur buffer move sender cach later receiv dequeu messag buffer place local queue second set miss occur buffer content transfer back receiv cach invalid also occur messag buffer modifi receiv process thu two round cach miss one two round invalid occur messag transmiss 32 sender pool altern approach use sender pool scheme send processor alloc buffer local pool ie buffer pool processor send messag write messag enqueu receiv scheme free pool local processor lock requir control access also sender alloc buffer write content messag memori refer hit cach scenario describ receiv processor access messag buffer cach miss possibl invalid occur case receiv pool mechan thu round cach miss avoid use sender pool compar receiv pool approach sender pool creat new problem howev messag send effect transfer buffer send receiv processor buffer pool messag buffer alway reclaim receiv fossil collect cellat buffer effect migrat processor processor less random fashion reus messag send differ processor contrast receiv pool scheme buffer alway return processor pool pool buffer initi alloc problem buffer migrat memori buffer accumul processor receiv messag send lead unbalanc distribut buffer buffer pool processor becom deplet processor bloat excess buffer lock could circumv local messag send howev separ buffer pool local messag address problem mechan requir redistribut buffer processor receiv messag send processor opposit behavior buffer redistributioncan accomplish use addit global buffer pool serv conduit transmit unus buffer exampl processor accumul mani buffer place extra globalpool diminish buffer pool extract addit buffer need pool 7 thu princip advantag sender pool elimin lock free pool better cach behavior multiprocessor use cach invalid protocol central disadvantag overhead buffer redistribut 33 cach updat protocol previous describ cach behavior invalidatebas coher protocol let us consid updatebas protocol updatebas cach coher protocol sender receiv pool exhibit similar cach behavior though receiv pool offer slight edg sender pool result ad dition unnecessari updat traffic among cach see consid follow receiv pool scheme buffer resid cach receiv processor assum suffici space cach sender write messag buffer miss occur unless buffer recent referenc send processor anoth messag send updat protocol automat transfer messag via cach updat receiv copi buffer result cach hit receiv read messag sender pool scheme cach hit occur sender write messag buffer receiv access result cach miss unless buffer alreadi receiv cach thu scheme experi one round hit one round miss messag transmiss howev updat protocol processor access buffer maintain copi local cach even use buffer longer exampl receiv pool scheme five differ processor reus buffer send messag processor p buffer appear cach five processor well p sixth processor use buffer send messag p write messag buffer updat copi resid five processor well p updat sent five sender processor clearli unnecessari sender pool exhibit even wors behavior messag buffer may migrat arbitrari number processor thu resid mani cach receiv pool scheme receiv pool approach buffer migrat limit processor send messag p number processor cach must updat cours reduc processor replac cach block make room other cach miss howev system larg cach replac may occur time busbas multiprocessor main disadvantag updat sever processor content cach directori updat inher broadcast request thu see neither sender receiv pool scheme provid total satisfactori solut multiprocessor use updatebas cach coher protocol howev later propos third scheme call partit buffer pool provid satisfactori solut avoid unnecessari updat describ 34 hardwar platform compar perform sender receiv pool scheme implement multiprocessorbas time warp system implement use direct cancel minim cost messag cancel 4 buffer contain variou pointer flag describ earlier modifi receiv messag hardwar platform use experi kendal squar research ksr2 multiprocessor ksr processor contain 32 mbyte local cach memori faster 256 kbyte subcach ksr somewhat differ cachecoher multiprocessor main memori hold data store processor cach effect secondari storag act main memori ksr processor organ ring ring contain processor cach invalid protocol use maintain coher data neither subcach local cach fetch anoth processor cach resid anoth cach secondari storag via virtual memori system detail machin architectur perform describ 10 3 machin contain 40 mhz twoway superscalar pro cessor access subcach requir 2 clock cycl access local cach requir 20 cycl time access anoth processor cach depend ring traffic cach miss servic processor ring take approxim cycl 10 cach miss servic processor anoth ring requir approxim 600 cycl discuss follow cach miss refer miss megabyt cach subcach estim singl ksr 2 processor approxim 20 faster sun sparc2 workstat base measur sequenti simul lock unlock oper requir 3 sec absenc content 14 sec pair processor ring 32 sec pair processor differ ring 3 p 10 experi describ use singl ring except processor run use processor two differ ring experi perform ksr2 run ksr os r122 manufactur provid c compil use experi except explicitli state otherwis special compil optim use gener object file sens perform report conserv perform measur receiv pool implement memori evenli distribut across processor sender pool scheme 30 total memori place global pool rest evenli distribut among processor free pool fraction select empir maxim perform number buffer processor buffer pool exce initi alloc excess buffer move free pool buffer pool contain five fewer buffer addit buffer reclaim global pool avail restor processor initi alloc initi experi use synthet workload model call phold 5 model use fixeds messag popu lation event gener one new messag timestamp increment select exponenti distribut destin logic process lp select uniform distribut first measur send time messag transmit differ processor time includ alloc free buffer write messag buffer enqueu buffer queue destin processor phold 64 lp messag popul 128 execut 8 processor 76 megabyt memori alloc state event buffer scheme time perform messag send measur use ksr x user timer primit sender receiv pool implement use prefetch mechan gain exclus copi buffer prior receiv messag prefetch also invalid copi messag resid send processor cach figur 1 show averag time messag send use receiv pool uppermost line sender pool third line top strategi differ messag size ex pect sender pool outperform receiv pool scheme line two second line top separ perform improv result elimin free pool lock distanc upper two line improv result better cach behavior distanc second third line lock time measur approxim 20 sec consist time report 3 one consid content lock increas access time degre addit cach overhead receiv pool implement increas size messag miss occur write data messag buffer measur approxim 34 sec per cach miss consist vendor report cach miss time lower line repres messag copi time ie time write data messag sender pool scheme ie cach miss use hardwar monitor provid ksr machin measur number cach miss occur sender receiv pool implement figur 2 show number cach miss differ messag size phold 64 lp 256 messag 8 processor run length approxim one million commit event approxim megabyt alloc simul data confirm receiv pool approach encount cach miss sender pool approach100300500700900 time msg size kb recv pool sender pool msg copi figur 1 messag send time sender receiv pool four curv repres top bottom 1 messag send time use receiv pool 2 messag send time sender pool plu addit cach overhead encount receiv pool 3 messag send time sender pool 4 time copi messag messag buffer sender pool 1 larger slope 3 addit cach overhead receiv pool mention earlier central drawback send pool scheme need redistribut buffer buffer redistribut use global pool perform fossil collect turn occur time processor determin fewer five free buffer remain free pool perform metric use studi number event commit per second real time execut calcul total number event commit simul divid total execut time refer metric commit event rate simpli event rate note event rate declin number rollback increas raw perform eg speed messag send decreases2468100 1 cach page million messag size kb receiv pool sender pool figur 2 cach miss sender receiv pool figur 3 show commit event rate parallel simul use receiv pool sender pool mechan experi use eight ksr2 processor benchmark program phold use 256 lp messag popul 1024 seen sender pool significantli outperform receiv pool strategi indic reduc time perform messag send far outweigh time requir buffer redistribut third curv shown figur 3 show perform altern buffer manag scheme discuss later final note sinc hardwar provid mechan prefetch data may possibl lessen cach effect receiv pool scheme prefetch buffer prior messag send assum cours sender determin destin processor suffici far advanc send perform prefetch current examin perform improv result techniqu howev even prefetch messag send still faster sender pool lock free pool need 4 perform larg simul although sender receiv pool good perform small amount memori observ dramat perform degrad larg simul util substanti amount messag buffer memori perform phold simul assum 8 proce sor 256 lp messag popul 1024 total amount memori alloc messag buffer chang shown figur 4 run includ execut approxim one million commit event point repres median valu least 5 run typic 9 run use seen perform declin dramat total amount buffer memori across processor exceed 20 25 megabyt observ behavior independ number processor use simul declin perform surpris run util 8 processor total 256 megabyt cach memori avail yet signific perform degrad occur amount buffer memori increas compar modest level eg perform eventssec processor partit pool sender pool receiv pool figur 3 number event commit per second real time phold sender receiv partit pool mechan reason declin perform intern fragment virtual memori system result poor spatial local lead excess larg number page processor work set page thrash behavior among cach page size ksr kbyte discuss page thrash lead disk access ksr would result much sever perform degrad nevertheless caus signific reduct performance2500035000450005500065000 perform eventssec memori alloc mb partit pool sender pool receiv pool figur 4 perform amount memori chang consid execut sender pool simul ini tialli buffer alloc processor pack contigu block memori howev sender pool scheme buffer migrat one processor anoth messag send global pool via buffer redistribut mechan thu short period time set buffer contain sender pool processor includ buffer origin alloc mani differ processor thu scatter across address space thu instant time processor buffer pool includ portion mani differ page entir possibl mani case like buffer particular proce sor buffer pool includ portion everi page buffer memori avail system500001500002500003500000 20 40 page memori alloc mb receiv pool sender pool partit pool figur 5 page miss count amount memori chang well known perform virtual memori system declin number page processor work set increas memori manag overhead becom larg uniprocessor multiprocessor minim miss translat lookasid buffer tlb occur eventu page fault occur perform poor ksr space must alloc entir page portion resid cach cach miss occur referenc page alreadi map processor cach space must alloc page cach miss servic referenc block load cach page miss subsequ block load cach demand referenc ie result cach miss page miss page miss usual result access secondari storag assum total amount memori well amount physic cach memori page usual resid one cach nevertheless tabl manag virtual memori system must updat miss page miss due poor local reason perform poor total amount buffer memori exceed 25 megabyt amount buffer memori less 25 megabyt page entir buffer memori across processor maintain cach processor howev amount exce size processor work set page longer fit local 32 megabyt cach page must map processor result thrash behavior excess overhead incur map unmap page valid effect reason poor per formanc number page miss measur experi depict figur 4 data shown figur 5 seen aforement declin perform beyond 25 megabyt memori accompani dramat increas number page miss page miss problem also sever receiv pool scheme caus signific perform degrad larg simul receiv pool approach avoid page miss overhead processor hold page correspond buffer pool plu receiv pool processor send messag thu processor send messag small subset processor system like page fit cach page miss occur worst case howev processor send messag processor system case page miss overhead may sever sender pool scheme phold applic repres worst case processor send messag everi processor system sender pool outperform receiv pool low amount memori cach local verifi better page miss figur bigger amount memori sender pool hold page tlb subsequ show wors perform page miss receiv pool verifi evalu effect page miss local iti set experi conduct use receiv pool strategi modifi version phold workload origin phold workload select destin process processor messag uniform distribut modifi workload processor select among k processor number processor destin use uniform distribut valu k refer size processor neighborhood workload processor receiv messag k processor number page miss measur amount memori vari k set 1 impli unidirect ring topolog 2 4 use receiv pool result experi shown figur 6 seen amount memori necessari yield aforement increas page miss becom progress smaller k increas agreement analysi assum processor effect util 25 megabyt memori knee observ earlier experi messag buffer pool k equal 1 page miss avoid long two buffer pool local pool one remot pool processor messag sent util less 25 megabyt data impli buffer pool larg 125 megabyt per processor 100 megabyt entir system recal 8 processor toler ate similarli one would anticip knee occur neighborhood size 67 megabyt k equal 2 40 megabyt k equal 4 data figur 6 consist approxim analysis500001500002500003500000 20 40 page memori alloc mb local 4 figur page miss receiv pool differ neighborhood size vs amount memori alloc line top bottom neighborhood size local 4 2 1 partit buffer pool third strategi develop design capit advantag sender pool scheme time avoid page miss problem minim number page miss buffer manag scheme minim number page contain messag buffer util processor anoth way state set buffer use processor pack contigu memori locat much possibl achiev necessari prevent arbitrari migrat buffer one processor anoth partit buffer pool scheme use sender buffer pool pool processor subdivid set sub pool one processor send messag let refer buffer pool ie subpool processor use send messag processor j processor must alloc buffer b ij whenev wish send messag j processor j reclaim messag buffer via fossil collect messag cancel must return buffer b ji buffer subsequ return processor either j send messag util buffer buffer return via buffer redistribut mechan strict rule concern buffer return pool global pool need buffer redistribut elabor upon later partit pool scheme memori buffer initi alloc b ij may resid b ij b ji lifetim simul size work set processor page hold b ij k page miss problem avoid long page resid processor cach second advantag partit pool scheme provid type flow control must provid use separ mechan origin sender receiv pool scheme time warp prone buffer hog phenomena certain processor may alloc disproportion share buffer classic exampl behavior sourc process serv purpos provid stream messag simul sourc process use simul open queu network instanc model new job arriv system sourc process never receiv messag never roll back fact gener true event event eventu commit howev process throttl flow control mechan easili execut far ahead simul time process fill avail memori new event leav buffer messag phenomenon sever degrad perform processor memori fill messag gener sourc origin sender receiv pool scheme noth prevent sourc fill buffer certain processor messag problem compound sender pool scheme sourc immedi scoop addit free buffer appear global pool via buffer redistribut mechan therebi hog even larger portion system buffer partit buffer pool scheme buffer hog limit buffer pool util processor execut sourc process commun processor affect separ pool reserv buffer use thu partit pool scheme provid protect buffer hog problem third advantag partit buffer pool scheme updatebas cach protocol oper effici either origin sender receiv pool scheme recal problem origin scheme buffer may simultan resid sever cach ie cach processor use buffer result unnecessari cach updat traffic partit pool scheme buffer may util two processor buffer use processor resid processor cach processor alloc buffer write content messag cach hit occur assum buffer delet replac memori refer updat protocol immedi write messag destin processor cach also hold copi messag buffer receiv access buffer experi cach hit fewer unnecessari updat request gener buffer manag scheme central disadvantag partit pool scheme buffer pool processor subdivid sever smaller pool buffer result somewhat less effici util memori thu scheme may requir memori either origin sender receiv pool scheme processor send messag processor j b ij empti messag send perform even though mani buffer may resid pool local processor send messag one could cours alloc buffer anoth pool satisfi request howev would quickli degener origin sender pool scheme result perform problem cite earlier gener desir use differ size buffer pool within processor size pool proport amount traffic flow processor gener size pool chang dynam ever purpos studi consid fixeds buffer pool size pool manual set begin simul 6 implement detail perform partit buffer pool scheme implement sharedmemori time warp system messag send perform buffer avail design pool event abort return unprocess event list typic result busi wait behavior event continu abort retri buffer redistribut pair processor necessari perform fossil collect perform period user defin interv net increas number buffer resid particular pool exce certain threshold 25 origin size pool experi processor attempt return number buffer equal net gain restor initi distribut buffer among pool note earlier partit buffer pool scheme requir buffer reclaim fossil collect return appropri buffer pool specif buffer correspond messag sent processor j must return processor js buffer pool rather labori scan fossil collect buffer return appropri pool mechan call onthefli fossil collect use soon messag process immedi return even though buffer may still requir handl futur rollback buffer alloc allow alloc buffer timestamp larger gvt ensur buffer reclaim gvt guarante messag contain buffer longer need buffer reclaim messag cancel assign zero timestamp return buffer pool ensur immedi reus onthefli fossil collect amort overhead fossil collect entir simul commit event rate receiv sender partit pool strategi differ amount memori compar figur 4 workload phold 256 lp messag popul 1024 seen partit buffer pool approach consist outperform two scheme unlik origin receiv pool sender pool scheme declin perform detect beyond 25 megabyt figur 5 verifi page miss problem elimin partit buffer pool scheme number remain rel low partit pool scheme memori size test applic perform data present thu far result measur synthet workload appropri ask behavior also preval actual parallel simul applic one would encount practic impact buffer manag cach effect overal per formanc answer question addit experi perform use three buffer manag polici certain small granular simul name hypercub topolog commun network person commun servic pc network simul benchmark amount memori use sender receiv pool scheme optim experiment maxim perform use less 20 megabyt partit pool implement use 8 megabyt per processor messag buffer experi 71 hypercub rout first applic messag rout simul 7 dimension binari hypercub 128 node messag rout randomli select destin node use wellknown e cube rout algorithm messag length select uniform distribut addit transmiss delay may delay due congest node queu messag messag serv node use firstcomefirstserv disciplin messag reach destin immedi reinsert network new destin select uniform distribut experi 2048 messag continuouslyrout throughth network fashion figur 7 show commit event rate simul three buffer manag scheme differ number processor partit pool strategi outperform two scheme case perform differenti increas number processor increased2000060000100000140000 perform eventssec processor partit pool sender pool receiv pool figur 7 perform hypercub rout simul 72 person commun servic network pc 2 simul wireless commun network set radio port structur squar grid one port per grid sector grid sector cell assign fix number channel portabl mobil phone resid cell period time move anoth cell phone call arriv portabl move new cell new radio channel must alloc connect maintain phone call correspond portabl channel busi call block drop princip output measur interest block probabl simul pc network contain 1024 cell grid 25000 portabl cell contain 10 radio channel portabl remain cell averag 75 minut time select exponenti distribut portabl move one four neighbor cell equal probabl call length time period call also exponenti distribut mean 3 minut 6 minut respect averag comput time event exclud time schedul new event approxim microsecond lp pc simul selfiniti ie send messag advanc simul time commun highli local typic 90 messag transmit lp map processor mani messag sent lp figur 8 show commit event rate simul use three buffer manag scheme seen partit buffer pool scheme outperform strategi though differenti larg experi due high amount local commun pc simulation50000150000250000 perform eventssec processor partit pool sender pool receiv pool figur 8 perform pc three buffer manag scheme 8 conclus futur work implement effici parallel simul system sharedmemori multiprocessor requir care consider interact simul execut hardwar cach virtual memori system work focus one aspect name buffer manag messag pass mechan experi ksr2 multiprocessor demonstr sever perform degrad may result interact care consid simul execut design studi three buffer manag strategi term sender pool receiv pool partit pool scheme sender pool scheme gener perform better receiv pool scheme flaw sever perform degrad occur simul requir larg amount memori much less physic memori provid machin partit pool scheme outperform two approach much factor two benchmark applic futur avenu research refin partit buffer scheme automat alloc appropri amount memori individu pool automat adjust size pool maxim perform anoth open question quantit evalu effect examin context machin architectur although experi perform context time warp execut ksr2 believ result also applic context first method improv perform involv restructur simul execut maxim local memori refer pattern local fundament effici util cach virtual memori system sens believ measur suggest approach fruit appli sharedmemori multiprocessor though perform gain realiz depend heavili specif architectur fur ther messag pass common wide use construct nearli parallel simul mechan propos date thu believ result ramif synchron protocol conserv opti mistic also applic nonsimul applic requir high perform messag pass acknowledg work support nation scienc foundat grant number mip94085550 thank samir da comment r distribut simul largescal pc network ring perform kendal squar multiprocessor time warp share memori multiprocessor perform time warp synthet workload parallel discret event simul use spacetim memori virtual time synchron parallel discret event simul sharedmemori multi processor share variabl distribut simul benchmark time warp oper system comput network simul distribut combat simul time warp model perform benchmark smtw ss7 perform model simul tr virtual time time warp share memori multiprocessor highperform comput architectur 2nd ed share variabl distribut simul distribut simul largescal pc network ctr girindra sharma radharamanan radhakrishnan umesh kumar v rajasekaran nael abughazaleh philip wilsey time warp simul clump proceed thirteenth workshop parallel distribut simul p174181 may 0104 1999 atlanta georgia unit state chri j booth david bruce peter r hoar michael j kirton k roy milner ian j relf dynam memori usag parallel simul case studi largescal militari logist applic proceed 28th confer winter simul p975982 decemb 0811 1996 coronado california unit state christoph caroth kalyan perumalla richard fujimoto effect statesav optimist simul cachecoher nonuniform memori access architectur proceed 31st confer winter simul simulationa bridg futur p16241633 decemb 0508 1999 phoenix arizona unit state z xiao b unger r simmond j schedul critic channel conserv parallel discret event simul proceed thirteenth workshop parallel distribut simul p2028 may 0104 1999 atlanta georgia unit state kiran panesar richard fujimoto adapt flow control time warp acm sigsim simul digest v27 n1 p108115 juli 1997 christoph caroth david bauer shawn pearc ross highperform low memori modular time warp system proceed fourteenth workshop parallel distribut simul p5360 may 2831 2000 bologna itali marcelctlin rou karsten schwan richard fujimoto support parallel applic cluster workstat virtual commun machinebas architectur cluster comput v1 n1 p5167 1998 samir r da richard fujimoto empir evalu performancememori tradeoff time warp ieee transact parallel distribut system v8 n2 p210224 februari 1997 samir r da richard fujimoto adapt memori manag optim control time warp acm transact model comput simul tomac v7 n2 p239271 april 1997