solv variou weight match problem constraint paper studi resolut augment weight match problem within constraint program cp framework first contribut paper set techniqu improv substanti perform branchandbound algorithm base constraint propag second contribut introduct weight match global constraint weightedmatch propag use special increment algorithm oper research first compar program techniqu use constraint propag special algorithm oper research busak gowen flow algorithm hungarian method although cp shown competit special polynomi algorithm pure match problem situat differ soon problem modifi addit constraint use previous mention set techniqu simpler branchandbound algorithm base constraint propag outperform complex special algorithm techniqu appli success travel salesman problem 5 seen augment match problem also show increment version hungarian method use propag weightedmatch constraint extens weight case work rgin 19 show bring signific improv timet exampl b introduct constraint logic program clp gener constraintbas program cp becom interest approach solv combinatori optim problem vh 89 instanc problem jobshop schedul shown effici tradit approach base oper research cl 94 deliv flexibl ie easi adapt algorithm slightli custom problem addit constraint goal investig advantag drawback constraint program compar classic combinatori optim maximum weight match problem bipartit graph see techniqu may combin bipartit match interest import three reason first wellunderstood problem mani polynomi algorithm rang simpl realli elabor eg gt 89 avail therefor perform constraint satisfact algorithm assess rigor gaug second mani reallif problem either match extend match one addit constraint therefor perfect domain see boundari flexibl effici lay moreov mani match problem optim problem weight may indic use weight match algorithm use gener optim method nonweight techniqu third match often part complex problem effici propag match constraint basic build block modern constraint satisfact system look care match algorithm deriv idea use design constraint solver paper organ follow section 2 describ naiv approach match improv implement easili move complex heurist cut rule show use handl larger problem section 3 compar previou result two wellknown algorithm hungarian weight method busak gowen flow algorithm show constraint satisfact approach realli compar special algorithm problem find optim match hand plausibl approach find set good solut lead section 4 look two extend match problem first case allow substitut new cost matrix k edg machinetask alloc problem renew k machin second case studi resolut two simultan match problem eg machinetask alloc problem maxim product within bound energi consumpt two variat problem origin algorithm adapt compar last appli section 5 variou techniqu present paper timet problem show use weight match global constraint captur hard soft constraint time enabl effici resolut 2 constraint base program formal match problem describ follow let gve bipartit graph vertex set v part two shore edg link v 1 v 2 match set edg e two adjac perfect match match cover vertic consid case perfect match correspond assign match frequent aris product plan assign job machin task technician moreov consid case weight graph defin weight match sum weight edg purpos find exist perfect match maxim weight minim weight weight w ij replac w ij larg constant 21 naiv clp natur way see problem constraint program think vertic v 1 variabl v 2 valu vertex v 1 link set valu v 2 form domain match correspond assign variabl differ variabl alway assign differ valu problem consist find assign maxim weight constraint alldiffer r94 offer builtin clp languag propag often perform arcconsist ma77 mm 88 valu assign variabl taken domain variabl contradict occur domain becom empti system backtrack previou variabl assign tri next possibl assign optim algorithm classic branch bound scheme variabl select possibl valu recurs tri solut weight w found constraint weight w ad system help prune subtre search space use simpl upper bound weight time search two upper approxim maxim match maintain sum variabl best possibl assign variabl v defin valu bestv maxim valu weightvx possibl valu x reciproc sum valu best possibl invert assign instead comput sum explicitli node search tree maintain increment time valu x remov domain variablev weightxvbestx bestx recomput differ old new valu subtract similar updat perform bestv weightxvbestv whenev one bound becom strictli smaller goal one predict upcom solut smaller weight best one found far branch tree cut propag algorithm widespread among implement alldiffer constraint clp system select node branch usual done firstfail principl one select variabl smallest domain assign usual tri decreas order weight drive search toward match heavi weight best first principl greedi heurist shown tabl 1 naiv algorithm solv problem 2x20 node within second requir unreason amount time larger problem although may case implement alldiffer constraint take upper bound import program consid upper bound 10 time slower 10x10 instanc solv 20x20 problem within reason time fact give us hint progress symmetr view problem bring constraint approach next two section 22 23 describ improv made propag scheme heurist first fail best first order improv perform 1 experi report paper done clair program languag 2 1 programm use blackbox constraint system access propag search engin mani clp system chang could encod within solver allow state problem singl command alldiffer chang written expert constraint system programm use open constraint system access solver propag engin program littl longer user program chang 2 avail httpwwwdmiensfrlaburtheclairehtml 22 ad symmetri regret mani improv made algorithm make scale larger problem first idea suggest import symmetr upper bound fulli symmetr descript problem model consid vertic v 1 variabl vertic v 2 valu arbitrari breech symmetri problem although perfectli valid way around add redund model v 2 seen set variabl v 1 set valu branch vertic v 1 v 2 impli overhead invers domain relat must maintain avoid miss evid decis instanc valu one domain need assign variabl henc match done side time similar use symmetr redund model nqueen problem jo 95 would expect sinc nqueen custom match problem without weight moreov firstfail heurist select vertex branch panacea notion regret give acut descript crucial vertic regret usual defin differ optim choic second best case v vertex v 1 x valu bestvweightvx defin regretx differ bestv maximum weightvx valu xx focus regret justifi fact problem solut chang constant ad edg incid one vertex thu rel valu matter oppos absolut one regret actual chang made upper bound best assign vertex discard select vertex largest regret branch point entrop choic sens tri maxim impact decis describ cl 94 entrop heurist power tool proof optim sinc limit size tree forc much propag happen node avoid real slow algorithm node regret best assign node memor updat increment anoth idea would somehow rebreak symmetri time two upper bound match avail soon one becom less goal branch cut select vertic v 1 larg regret decreas convers case one bound clearli better could seem worthwhil encourag dissymmetri choic branch node implement give bonu penalti depend situat select branch vertex proport vertic v 1 heurist denot balanc tabl 1 tabl illustr effect techniqu randomli gener instanc 2 20 2 vertex typic connect 5 8 edg weight random number 1 100 entri tabl show number backtrack b search process 1kb1000b run time pentium pro 200 find optim solut give proof optim naiv approach arc consist first fail behav poorli addit regret symmetri bring gain factor 10 idea balanc realli pay naiv propag 12 52 kb 500 5 kb 9 kb 198 kb b 800 b 35 kb 800 b 12 95 27 mb basic 900 b 35 kb 900 b 43 kb 25 11 mb tabl program 23 finer tune algorithm one aspect algorithm sharpen propag addit upper bound evalu domain reduct due edg select also domain reduct upper bound matter fact dynam remov illeg edg edg uv illeg soon bestu weightuv greater avail slack goal goal object weight goal subsequ decreas time admiss solut found call techniqu dynam cut report behavior tabl 2 interest dynam cut two fold one hand detect failur littl earlier rather small benefit hand maintain smaller relev domain may improv effici firstfail principl remov meaningless valu produc rapidli domain small cardin 1 3 firstfail tell us examin want reintroduc firstfail behavior choic heurist base regret use simpl trick use cgl93 select vertex minim lexicograph pair par fix paramet effect select vertic largest regret still domain cardin par select first fail domain smaller par strategi yield improv small valu par 3 search tree describ mani branch per node actual may wast time wonder edg select vertex know best one sinc edg may well look alik numer search tree construct differ singl altern node either best edg select one tree becom narrow binari mayb deeper practic prevent algorithm wast time irrelev choic new branch scheme report tabl 2 binari branch tune done concern upper bound use cut branch search tree formula sum best choic estim best assign inde v v 1 favorit choic p vertic v 2 know take account regret atleast p1 match common favorit vertex therefor possibl tighten bound subtract conserv estim regret occur applic lookahead principl tri forecast evolut bound vertex v v 1 consid previou set vertic x v 2 bestx set p vertic associ sum regret highest one call lookv replac strategi estim differ simpl bound actual choic call lookahead tabl 2 note estim correspond relax match problem could suggest use lagrangean relax affect weight node fact lookahead strategi use similar idea affect weight node relat sever other one prefer graph node prevent solut relax problem match moreov hungarian method associ weight node also seen relat lagrangean relax basic 12 95 27 mb dynam cut 24 kb 15 mb 22 mb new branch 12 95 kb 65 lookahead 45 kb 12 6 tabl remark made result first lookahead heurist work well although benefit obviou number backtrack pay size problem larg enough hand dynam cut binari branch scheme produc unstabl result difficult measur signific improv techniqu propag branch boud heurist succes appli travel salesman problem tsp repres weight match problem tri match node direct successor cycl coupl subtour elimin constraint describ cl97 improv enabl constraint program solv 30citi tour instead 15citi tour complex techniqu also given larger problem 3 tradit algorithm approach match wide studi oper research commun year col 86 ge 94 two method present pretend best one avail today made compromis limit algorithm simpl enough understood implement reason amount time proport implement time constraintbas program algorithm busak gowen describ gm 79 vl 90 emb match problem flow problem ad sourc link vertic v 1 sink link vertic v 2 case capac edg set 1 adapt wellknown fordfulkerson maximum flow algorithm case network weight edg start null flow augment satur along augment path augment path found mean flow maxim polynomi algorithm run number edg n number node howev unlik fordfulkerson increment sens complet partial flow minim cost maxim flow requir partial flow maxim stream cost hungarian method algorithm class primaldu algorithm often associ problem state linear program ps 82 primal program consist find maxim match minim weight dual program consist find posit weight p u associ vertic u edg uv sum p u maxim algorithm construct increment weight p u start p u equal 0 construct graph g p form edg uv verifi p u algorithm altern work dual model updat p u order add new edg graph g p primal model find augment path g p end match g p minim weight maxim match g polynomi algorithm run 3 major interest compar flow algorithm increment one want remov edg uv graph recomput optim solut one set weight uv larg posit constant remov uv g p take one iter complet optim match 31 comparison clp find optim solut pure match program cp competit techniqu cp solv reason well problem 2 40 node wherea hungarian method scale problem well 2 100 node exampl solv 70 80 000 backtrack approxim 200 best constraint program flow algorithm take 1 hungarian method take 03 howev one longer consid problem find one optim solut optim solut rather solut within given distanc optimum clp becom plausibl competitor tabl 3 report experi four program compar first one straightforward adapt previou constraint program basic instead stop first solut explor whole tree second similar branch bound explor flow algorithm use evalu optim match node instead use upper bound estim flow algorithm actual trigger one edg current optim match remov dynam graph third program similar differ branch scheme edg origin optim solut explor two branch either edg part match remov dynam graph fourth program branch bound algorithm similar third one except hungarian method use instead flow algorithm take advantag increment hungarian method abil recomput optim match singl iter edg discard node search tree explor bottleneck amount comput perform node search tree increment hungarian method best algorithm sinc explor small search tree explor branch lead admiss solut howev constraint algorithm fair competitor perform much less work per node 1 4 sol 2 9 sol 5sol 05 3 sol 1 8 sol 25 sol basic 1249 b b 8000 b 14 kb 11 38 kb 2s 140kb flow algorithm 137 b 9 224 b 2000 b 100 100 b 26 172 b 215 b 48 15kb 200 flow algorithm new branch 57 b 136 b b 34 b b 22 195 b hungarian match b 58 b b b b b b tabl find solut henc problem find nearoptim perfect match constraint program behav better basic oper research program adapt flow algorithm well smarter program increment hungarian method big advantag constraint program simplic inde much easier implement algorithm naiv smart seem therefor good candid reallif match problem involv addit constraint thu requir explor space solut pure problem 4 complex match section address case two reallif variat match problem adhoc algorithm could also probabl special design variat problem howev methodolog point view decid consid adapt origin solut could implement reason amount time sinc constraint program adapt matter minut 41 replac k machin suppos plant manag fund replac k machin among n newer one want find optim assign maximum bring maxim product task machin given newer machin effici older one mean match problem extend addit choic k vertic v 1 prefer use differ weight matrix say weight instead weight sake comparison implement three solut problem one use constraint propag two solut basic adapt flow algorithm smart adapt hungarian method first one straightforward adapt constraintbas program basic principl postpon choic k new vertic much possibl take account modifi upper bound estim instead take sum best choic node add sum sum k heaviest edg differ graph defin gain product function new old machin ie consid weightuv weightuv weight edg uv like bound maintain increment second program base flow algorithm goe search tree node depth correspond choic th machin replac branch explor whenev decis replac made product function updat ie second weight function use th machin node upper bound comput prune sum optim solut match origin graph k decis made optim solut match cardin ki differ graph third program base hungarian method algorithm goe search tree program look near optim solut cf section 33 node vertex v v 1 select branch match one vertic x remov edg vx x x first branch explor correspond current assign v solut given hungarian method upper bound sum best possibl match given hungarian method estim submatch size k differ graph estim constraint algorithm constraint 266b 01 433b 01 735b 01 19kb 21 26kb 99 44mb 700 flow 5 hungarian match 20b 22b 31b 30b 30b 34b 40b 71b 107b tabl replac k machin figur 4 show three strategi problem constraintbas approach perform better approach base flow algorithm well algorithm use hungarian method constraint approach much faster smart algorithm n10 littl faster n20 somewhat slower n30 much slower n40 anyway upper limit constraintbas approach pure match problem main advantag simplic took simpl line code modifi upper bound origin constraint algorithm compar algorithm make constraint approach good solut small midsiz problem even valu k 10 solut base increment hungarian method well adapt larg problem 42 bimatch second problem address case combin two match problem two distinct weight matric one problem use satisfi one optim tasktomachin assign amount maxim product keep energi consumpt certain level difficulti vari accord role play passiv match problem valu chosen maxim energi consumpt low high energi match domin problem margin hand intermedi valu make problem much harder shape solut space equal affect match problem impli distribut feasibl solut search tree longer concentr one area dispers linear program perspect bi match problem made three compon match constraint share two match problem energi consumpt constraint cost function repres optim product classic approach situat use lagrangean relax push energi constraint cost function implement sever solut find maxim product match consumpt less given constant first one also straightforward adapt basic constraint program search guid optim product consumpt constraint use prune two lower bound consumpt estim sum edg least consumpt vertex set moreov instead consid regret product function consid sum regret product energi function therefor program obtain simpl replic line origin basic program energi substitut product second algorithm branch bound algorithm use twice increment hungarian method two hungarian match construct one maxim product one minim consumpt branch base hungarian match maxim solut match use prune branch cut minim consumpt strictli greater e maxim product less best one found far third one fourth base lagrangean relax busak flow algorithm hungarian method gener principl method put constraint object function certain coeffici vari valu coeffici 93 assum relax problem ie without constraint push cost function simpler solv push energi constraint cost function obtain simpl match problem solv flow algorithm object function becom total weight match follow weight function edg weight l u let us call fl valu maximum match weight l construct fl l 0 upper bound origin problem sinc energi consumpt smaller e comput valu f minim valu fl l vari l 0 f also upper bound found dichotom search provid us upper bound high qualiti also vari valu l possibl lower bound one l yield admiss energi bound comput node search tree branch made edg match optim flow indic third approach previou section third program straightforward implement lagrangean relax flow algorithm fourth one implement lagrangean relax hungarian method tri increment possibl tri keep part dual solut similar valu l inc hung match 24kb 26kb 71 32 kb 140kb 500 900 14kb lagragean relax flow algorithm 20b 31b 102b 22b 107b 31b 72 197b 87b lagragean relax hung match 14b 51 64b 80b 28b 86b 50 28b 180b 296b constraint basic 1kb 28kb 12 30kb 13 2kb 900kb 43 tabl bimatch tabl 5 compar four algorithm two problem cost weight function randomli gener valu rang 1 100 balanc optim cost feasibl energi cut search tree e small close valu minim energi consumpt match energi respons prune program behav like simpl match one symmetr e larg problem almost unconstrain look like simpl maxim product match program hardest situat energi cost respons prune search tree situat correspond e 550 e 900 exampl lagrangean relax pay larg problem criterion domin howev seem real life problem criterion often domin point view constraint approach much effici constraint program perform better simpl algorithm two increment hungarian match also perform better except balanc situat n30 complex lr program fact hungarian method mildli increment lagrangean relax scheme dual solut easili repair chang weight function 5 applic previou section shown strenght constraintpropag approach compar special algorithm shall see techniqu combin oppos consid timet problem consist fill weekli schedul set lesson durat 1 4 hour lesson given set possibl start time set prefer start time schedul made 10 halfday 4 hour lesson interrupt section illustr weight match techniqu appli problem provid signific improv notic lesson durat 1 problem would inde match problem suggest straightforward relax consid lesson interrupt second prefer encod use weight minimum weight match correspond assign use mani prefer start time possibl rest paper consid lesson l 1 l schedul n time slot length 1 hour 4 lesson given two list time slot integ 1 n repres respect set possibl preferr start time goal find start time lesson two lesson overlap usus disjunct schedul constraint pair lesson either startl startl lesson fit half day within half day say th halfday cover time unit 4i1 4i2 4i3 4i4 lesson durat 4 start first unit 4i1 lesson size 3 start unit 4i1 4i2 etc number default defin number lesson assign start time outsid set prefer time minim problem depend rang input data problem seen combin satisfiablil problem fill schedul optim problem assign problem lesson larg enough problem may look like binpack prefer optim almost irrelev hand smaller lesson pack much easier optimis problem domin similarli difficulti prefer ie tight prefer set augment import optim compon problem pick three problem repres differ situat problem 1 use rather short lesson highschool schedul complex prefer optimum 6 default problem 2 similar lesson size point view simpler prefer optimum 1 last problem use larger lesson explor algorithm would react problem satisfi issu order exploit match relax decompos lesson durat k k unit 1 hour total number u unit therefor sum durat lesson match need build associ start time time slot unit unit u associ lesson l time slot give weight edg ui follow happen would impli illeg start time lesson l u happen impli start time outsid prefer set happen lesson l start one prefer time defin minweightalldifferentstartu 1 startu u w minimum weight match graph recal valu comput effici hungarian match also maintain increment throughout search procedur section 3 describ recomput valu edg remov graph sinc lesson l k unit straightforward check optim solut timet problem correspond minimum weight match schedul default valu match 1000 u 12 thu search solut less defautlt use redund constraint solv three problem use branchandbound algorithm minim number default branch done start time lesson tri peref valu first lesson branch pick use firstfail heurist start time decis propag follow discard valu lesson could caus overlap lesson assign start time unit compos lesson set accordingli number default reach upper bound edg prefer remov use redund constraint detect becom imposs place larg lesson valu durat strictli larger halfday exampl 3 hour comput set lesson lessonsd durat union possibl half day lesson possibl check possibl lessonsd final check possible432 2 problem 1 24 lesson 39h problem 2 26 lesson 40h problem 3 14 lesson 39h 1 simpl propag 189 kb 1541 286 kb 1040 43 kb 246 2 match cut 31 kb 177 269 kb 1008 27 kb 160 3 regin filter 31 kb 197 269 kb 1243 27 kb 160 4 weight match cut 3511 b 29 234 b 26 17 kb 120 5 global consist 1206 b shave 382 b 96 183 b 11 5888 b 314 tabl appli variou weight match techniqu timet problem tabl 6 give result obtain follow approach 1 first method perform constraint propag 2 second method check underli match problem unit still feasibl ie exist perfect match 3 third method remov edg belong least one perfect match use regin algorithm r94 4 fourth method use new global constraint minweightalldiffer 1 propag explain earlier use increment hungarian method 5 fifth method use lookahead consist check tri unassign lesson l discard prefer respect nonpref edg tri mean detect remov valu would creat contradict propag constraint contradict detect deduc lesson l must start prefer resp nonpref time 6 sixth method appli global consist techniqu consist tri possibl start time remov produc contradict similar shave techniqu use jobshop schedul cl96 conclus drawn experi first global constraint minweightalldiffer bring seriou improv standard propag local consist problem 2 number backtrack divid factor 1000 moreov overhead keep valu minim weight match date increment hungarian method reason compar cost simpl match propag bound default inde addit minweightalldiffer averag time per backtrack three instanc goe 41 ms 73 ms therefor gain search tree size turn real speedup second propag unweight match constraint differ constraint done effici filter algorithm propos r 94 margin impact resolut problem compar propag weight match constraint third seem good idea check global consist perform limit breadthfirst explor search tree limit depth one seem work better branch decis base satisfact lesson method 5 rather actual assign time slot lesson method 6 due fact complex method 5 smaller method 6 moreov global consist techniqu work best timet larg block lesson durat 3 4 rather problem small lesson match relax accur 6 conclus first conclus might constraint propag competit techniqu pure weight match problem special algorithm simpl enough use appropri hand constraint propag plausibl approach augment match problem depend complex addit constraint size problem perform obtain easili cp approach rang reason excel compar special approach case good enough best approach incorpor weight match techniqu constraint base branch bound search first contribut paper set gener techniqu improv perform constraintbas branchandbound algorithm problem name binari branch scheme base regret use implicit symmetri lookahead bound function techniqu may appli augment match problem actual appli success travel salesman problem cl97 second contribut show inde weight match consid global constraint minweightalldiffer sinc know propag effici use increment version hungarian algorithm use global constraint shown timet exampl constraint solver offer featur abl solv problem hard soft constraint time take advantag weight wherea system reli simpl match implement soft constraint second layer much less effici way must also notic featur allow us combin best world two augment problem studi part 4 keep simplic flexibl constraintbas approach ensur robust underli match algorithm acknowledg would like thank anonym refere help comment suggest earlier version paper r deduct objectori approach complex schedul problem improv clp schedul task interv cumul schedul task interv solv small tsp constraint introduct algorithm match handbook oper research manag scienc network faster scale algorithm network problem concurr et cooprat de modl multipl consist network relat run effici arc consist combinatori optim filter algorithm constraint differ csp modern heurist techniqu combinatori problem constraint satisfact logic program graph algorithm tr