effici implement softwar architectur via partial evalu notion flexibl abil adapt chang requir execut context recogn key concern structur softwar mani architectur design effect howev correspond implement often come perform code size overhead sourc ineffici identifi loos integr compon flexibl often present design level also implement solv flexibl vs effici dilemma advoc use partial evalu autom techniqu produc effici special instanc gener program support case studi consid sever flexibl mechan commonli found softwar architectur select broadcast pattern match interpret softwar layer gener librari use tempo special c show partial evalu safe optim implement mechan optim automat preserv origin gener extens implement b introduct partial evalu partial evalu techniqu partial execut program input data avail consid program p requir two input x 1 x 2 specif valu 1 2 given two input run program produc result one input valu 1 given run p partial evalu produc version p d1 p special case x partial evalu instanc program special special version p d1 p call residu program exampl consid follow c function powern x comput x rais nth power int nx f int p n n 2 els given valu 7 comput power57 obtain result exploit x even integ n suppos need comput powern x great mani differ valu x partial evalu function obtain follow residu function int x f int p comput power 57 obtain result 7 fact input x comput power 5x produc result comput depart comput scienc univers copenhagen universitetsparken 2 depart mathemat physic royal veterinari agricultur univers thorvaldsensvej 40 dk1871 frederiksberg c denmark power5x sinc valu variabl n avail partial evalu say n static convers variabl x dynam valu unavail exampl show strength partial evalu residu program power 5 test arithmet oper involv n elimin flow control condit statement origin program complet determin static variabl n suppos need comput powern7 mani differ valu n opposit problem n dynam unknown x static known littl case sinc flow control determin dynam variabl n one could imagin creat tabl precomput valu 7 n valu n know valu relev mani case control flow determin static variabl case substanti speedup achiev partial evalu 11 notat consid program two way function transform input output also data object input output program need distinguish function comput program program text write p program text write function comput want make explicit languag l p written consequ denot result run program p input lmachin assert power 5 correct residu program c power given input 5 12 interpret compil interpret sint languag written languag l satisfi program input data run input smachin give result use interpret sint run lmachin includ possibl nontermin side compil stcomp sourc languag gener code target languag written languag l satisfi p compil target program p 0 run p 0 tmachin input give result run p input smachin though equat doesnt specifi normal assum compil alway produc target program partial evalu 21 partial evalu partial evalu program perform partial evalu produc residu program special given program respect part input let p lprogram requir two input x 1 x 2 residu program p respect x program p d1 valu 2 remain input partial evalu program peval given program p part 1 input produc residu program p d1 word partial evalu peval must satisfi peval socal partial evalu equat read follow partial evalu p respect 1 produc residu program p d1 run d1 input 2 give result run program p input 1 compil equat guarante termin lefthand side implic contrast compil howev alway assum partial evalu succeed desir partial evalu alway termin guarante larg number exist partial evalu see section 22 55 termin issu specifi languag l partial evalu written languag sourc program accept languag residu program produc languag may differ notat simplic assum note open possibl appli partial evalu see instanc partial evalu equat consid 5 must follow power57 22 achiev partial evalu definit partial evalu stipul special program must better origin program inde easi write program peval satisfi partial evalu equat trivial way prepend new special function power 5 origin program new function simpli call origin one given argument int nx f int p n n 2 els int x f returnpower5 x g program correct residu program faster origin program quit possibl slower even construct use prove exist partial evalu proof similar kleen 1952 proof smn theorem 63 theorem essenti stipul exist partial evalu recurs function theori exampl introduct demonstr sometim possibl obtain residu program arguabl faster origin pro gram amount improv depend partial evalu program special program lend spe cializ comput done input known sometim choos differ algorithm may help case problem illsuit special exampl special power function known valu x discuss introduct look definit power one would think special respect valu x would give good result assign involv n execut special loop howev control n sinc termin condit known fulli elimin loop x p differ valu differ iter loop replac constant henc find perform comput x p anyway could forc unfold loop keep valu x p known sinc bound number differ valu x p obtain finit amount unfold elimin x p program conflict termin special qualiti residu program common partial evalu must tri find balanc ensur termin often enough interest prefer alway yield suffici speedup worthwhil due undecid halt problem perfect strategi exist suitabl compromis must found see section 55 subject 3 anoth approach program special gener extens twoinput program p program p gen given valu 1 first input p produc residu program p d1 p respect 1 word gener extens take given valu 1 first input paramet x 1 construct version p special x exampl show gener extens power program introduct int n f printfint xn printff int pn n n 2 els f printf printf returnpn note powergen close resembl power part power depend static input n copi directli powergen part also depend x made string print part residu program run powergen input yield follow residu program int x f int p almost one shown introduct differ made priori distinct static variabl n dynam variabl x p sinc p dynam assign made part residu program even execut special time exampl shown introduct later shall see gener extens construct appli suffici power partial evalu one even construct gener gener extens way 4 partial evalu interpret compila tion 41 compil use partial evalu section 12 defin interpret program take two input program interpret input program often expect run program repeatedli differ input henc natur partial evalu interpret respect fix known program unknown input program use partial evalu equat get use definit interpret get residu program thu equival sourc program differ languag residu program written input output languag partial evalu ident residu program written languag l interpret sint henc compil languag interpret interpret l languag written 42 compil gener use selfapplic partial eval uator seen compil program partial evalu terpret typic want compil mani differ program amount partial evalu interpret repeatedli respect differ program situat call optim yet anoth applic partial evalu henc use partial evalu special partial evalu peval respect program sint without argument sint use partial evalu equat get peval peval peval sint use result get peval sint recal definit compil section 12 see peval sint fulfil requir compil case input output languag partial evalu ident languag compil written target languag compil languag l interpret written note guarante partial evalu termin neither produc compil use experi shown may problem often case compil termin gener program termin note compil peval sint gener extens interpret sint accord definit shown section 3 gener program interpret partial evalu partial evalu peval respect program p yield gener extens p program 43 compil gener gener seen interest partial evalu partial evalu may want repeatedli partial evalu partial evalu respect rang differ program eg interpret may exploit partial evalu peval peval sinc gener extens p see peval peval gener gener extens program peval peval gener extens partial evalu peval peval peval case p interpret gener extens p gen compil henc peval gen compil gener capabl produc compil interpret 44 summari futamura project instanc partial evalu equat appli interpret directli selfappl partial evalu collect call futamura project three futamura project first futamura project compil peval second futamura project compil gener peval peval third futamura project compil gener gener first second equat devis futamura 1971 40 latter independ beckman et al 12 turchin et al 94 around 1975 5 techniqu partial evalu 51 polyvari special polyvari special techniqu partial evalu work rang languag program thought collect program point connect controlflow edg flowchart languag program point controlflow edg respect label basic block jump function languag defin function function call logic languag predic predic applic atom polyvari special construct residu program creat zero special variant program point connect residu controlflow edg 511 exponenti exampl revisit illustr polyvari special consid power function section 1 flowchart form explicitli label basic block lab1 n n 2 goto lab1 goto lab1 lab3 returnp program form special given valu static variabl special basic block basic block set static variabl valu may execut one creat special basic block residu program polyvari special 24 57 instanc basic block label lab1 may execut static henc one creat special basic block whose label lab1 fn5p1g consist origin label bind static variabl bodi special basic block consist special residu command origin basic block natur special version jump goto lab jump goto lab fg special decor version lab see work let us special program known valu unknown valu x first get lab1 use inform special basic block perform condit if static find n 0 fals n 2 0 true must jump lab2 still creat residu goto command new special label lab2 fn5p1g goto lab2 fn5p1g correspond special basic block block lab2 special respect 1 assign special residu sinc x dynam mean p longer static assign execut n static new static environ 4 henc goto lab1 special goto lab1 fn4g get goto lab1 fn4g note gener constant express 1 repres static valu 1 p residu program say static valu p lift appear residu program next must special basic block lab1 respect 4 process continu special basic block creat special label occur residu program total follow residu program obtain goto lab2 fn5p1g goto lab1 fn4g goto lab1 fn2g goto lab1 fn1g goto lab2 fn1g goto lab1 fn0g goto lab3 fn0g returnp simplifi replac jump goto code jump call transit compress unfold result almost section 1 returnp techniqu polyvari special turn work languag demonstr later section function languag logic languag special process build graph whose node special program point label whose edg residu controlflow edg jump may done maintain set pend special program point still creat map special program point special program code fragment basic block one repeatedli choos remov program point pp pend construct correspond special program code fragment code pp extend map pp 7 code pp moreov one extend set pend new special label reachabl code pp precis pend extend set set program point pp 0 jump goto pp 0 code pp begin pend contain program entri point togeth initi valu static variabl empti procedur termin pend becom empti case contain residu program process may fail termin discuss section 55 52 onlin versu offlin partial evalu two type partial evalu onlin partial evalu kind gener interpret need priori divis variabl static dynam partial evalu environ map static variabl concret valu dynam variabl symbol express process express e partial evalu make onlin decis whether evalu give concret valu residu give residu express base current bind variabl appear e offlin partial evalu constrast work two phase first phase bindingtim analysi classifi program variabl definit static possibl dynam similarli classifi oper second phase special proper phase simpli use staticdynam classif variabl oper process ex pression evaluateresidu decis made offlin never use actual valu variabl express unless bindingtim analysi guarante static henc inde concret valu sinc offlin partial evalu reli program analysi usual conserv onlin partial evalu miss opportun special hand offlin special simpler structur may exploit global knowledg program gain bindingtim analysi experi show harder construct selfapplic onlin special offlin one hybrid onlin offlin special construct instanc one may use threevalu bindingtim analysi classifi variabl express definit static definit dynam undecid 92 special phase obey static dynam annot use actual special time valu variabl decid whether evalu residu gener gener extens similar offlin partial evalu sinc gener extens embodi priori distinct earli static input late dynam input gener gener extens usual includ bindingtim analysi onlin partial evalu studi scheme ruf weis 82 100 mani research logic program commun 53 bindingtim analysi classif variabl static dynam call divis divis must congruent valu dynam express e may assign variabl must made dynam express e static contain dynam variabl consid flowchart version power function section 51 see n static x dynam outset p must classifi dynam p x assign p wherea n remain static n never assign dynam valu simpl bind time analysi may perform mean abstract interpret variabl express take one abstract valu static dynam one build initi divis variabl except dynam input paramet assign program abstractli execut possibl reclassifi variabl dynam satisfi congruenc requir variabl need reclassifi dynam altern bindingtim analysi may done type infer sub type consid subtyp mean may coerc correspond lift static valu kind bindingtim analysi may implement effici constraint solv 53 composit data structur tupl record list consid data structur may partial static instanc valu variabl may whose first compon static whose second compon dynam may describ bindingtim theta similarli list pair may describ bindingtim theta list type infer approach bindingtim analysi especi use handl partial static data structur strongli type languag standard ml pascal c latent type languag scheme handl essenti consid dynam express untyp divis comput bindingtim analysi one must decid oper program whether must evalu sidual produc residu code partial evalu arithmet oper must residu unless operand static statement must residu unless condit static shall assum assign residu unless assign variabl static also assum goto residu excess goto may remov subsequ transit compress visual classif oper annot dynam oper underlin power function annot would lab1 n n 2 goto lab1 goto lab1 lab3 returnp polyvari special program blindli follow annot obtain transit compress returnp result obtain gener extens section 3 gener gener extens presuppos priori distinct static n dynam x p variabl 54 residu program contain loop residu program gener contain loop condit static decid transit could compress howev machineri section 51 suffic creat residu program contain loop consid follow contriv exampl n els written flowchart program lab1 n goto lab3 lab2 goto lab3 lab3 goto lab1 lab4 returnsum let us special respect static dynam sum n special basic block lab1 respect must creat residu version first condit n dynam wherea second condit reduc k static nonzero give residu jump lab2 fk3g n goto lab2 fk3g next special code label lab2 respect goto lab3 fk3g continu manner obtain residu program n goto lab2 fk3g goto lab3 fk3g goto lab1 fk3g returnsum transit compress get n goto lab1 fk3g returnsum decor label lab1 fk3g lab4 fk3g may replac simpl one lab1r lab4r see partial evalu elimin test k insid loop effect found loopinvari loop recreat residu program simpli jump lab3 fk3g goe back special program point lab1 fk3g begin program 55 termin partial evalu transit compress appli care program shown attempt repeatedli unfold remain occurr goto lab1 fk3g would never termin infinit loop due transit compress avoid fairli easili either unfold jump residu label exactli one way reach label 21 ascertain unfold must stop due descend chain condit 87 termin problem caus infinit special harder deal illustr consid power program section 51 static straightforward applic polyvari special attempt produc infinit residu program n n 2 goto lab1 fx49p1g goto lab1 fx7p7g n n 2 goto lab1 fx2401p1g goto lab1 fx49p49g program incomplet complet use finit number program point insist keep x p static onlin partial evaluatior one may recogn configur similar previous encount two program point therefor merg singl gener one eg make x dynam eventu forc p dynam also process call gener offlin partial evalu one may recogn bindingtim analysi test dynam decid static variabl static data construct dynam control sign danger indic x p made dynam make special complet trivial safe holst develop finit analysi use ensur termin polyvari special 54 56 gener partial evalu one lesson may learnt partial construct residu program shown basic block label lab3 fx49p1g superflu reach would requir test n 0 n 2 0 fail test n2 succeed imposs integr n former two impli 2 superflu basic block creat static environ outlin take account valu static variabl x p outcom previous encount dynam test n polyvari special may enhanc give gener partial evalu theorem prover requir decid static condit decid whether two static environ equival 41 certain data domain applic less power method may suffic 46 6 partial evalu languag 61 function languag 611 firstord languag partial evalu firstord function languag may done polyvari special describ section 51 notion label basic block global variabl must replac notion function name function definit function paramet henceforth special program point special function name residu program collect special function definit illustr consid function version power program section 1 use standard ml syntax els n mod els x powern1 x special function power respect static dynam x obtain fun power fn5g power fn4g power fn2g power fn1g power fn0g note special function name power fn5g consist origin function name power togeth bind static paramet n residu program may simplifi unfold trivial function call reduc subexpress x x 1 aris unfold fun power fn5g power fn2g residu program equival gener c version power section 1 bindingtim analysi may proceed flowchart languag applic f e e may dynam reclassifi formal paramet f dynam sinc languag firstord f must known function flowchart languag partial evalu may either offlin onlin offlin partial evalu perform bindingtim analysi program classifi paramet either static dynam embark special phase proper complet descript simpl offlin self applic partial evalu firstord function languag may found 58 chapter 5 appendix 612 higherord function languag polyvari special appli higherord function languag function may pass around valu well main new challeng repres static function valu partial evalu ation lift function valu static dynam special respect function valu bindingtim analysi function valu may repres closur g vs consist function name g togeth valu vs static free variabl gs bodi lift partial static function valu dynam valu complic usual avoid offlin partial evalu requir everi partial static function valu must appli argument function valu occur dynam context reclassifi dynam bindingtim analysi special function f respect fulli static function closur g vs simpl special respect function name g valu vs static free variabl special f respect partial static g vs involv sinc bodi g may dynam free variabl variabl may free also residu express result appli g vs henc dynam must lift gs bodi special time must pass extra paramet residu function f gv higherord function program may contain applic evalu function closur analysi provid approxim set function e 1 may evalu use inform bindingtim analysi may proceed firstord languag 58 chapter 15 altern bindingtim analysi may base type infer 53 prefer one want permit partial static data structur also selfapplic partial evalu exist realist higherord function languag scheme 20 21 28 29 31 standard ml 70 well callbyvalu lambda calculu extens 51 pure lambda calculu 74 75 inform see eg 58 chapter 10 full detail see abovement paper 62 logic program languag prolog distinguish featur prolog logic program languag abil run incomplet input seem similar partial evalu number differ ffl result run prolog program incomplet input po sibli infinit list instanti input output variabl though consid list fact henc restrict form program gener want partial evalu abl produc nontrivi residu program possibl contain loop ffl prolog nonlog featur mean run program incomplet input gener run complet input exampl call predic defin partial instanti input paa return result run complet input paa would fail research partial evalu partial deduct often call logic languag tend avoid second issu work pure logic languag 43 68 system howev deal nonlog featur prolog 76 84 partial evalu logic languag typic done use basic techniqu function languag call unfold polyvari specializ ation program point predic major sourc speedup partial evalu logic program abil detect fail comput special time cut away residu program way static comput also dynam comput fail branch elimin partial evalu make potenti speedup partial evalu greater logic languag function imper languag onlin special prefer techniqu logic languag commun usual combin power techniqu avoid nontermin 23 71 logic languag onlin special present opportun special offlin special unif often instanti otherwis dynam variabl selfappl major goal offlin special use also 52 76 exampl prolog special shown special program regular express match acceptsr nullabl acceptsrc firstrc nextrcr1 acceptsr1 program take regular express string argument string empti regular express test nullabl accept empti string string start charact c test whether among first set regular express case new regular express match rest string produc next predic nullabl first next shown note set cs first succe determin r henc partial evalu first respect known r unknown c yield number instanti c special program respect r regular express ajb aba yield follow residu program accepts3 sinc nullabl depend static valu complet elimin visibl fail true case empti string call first instanti c b instanti made possibl fulli evalu next yield total four differ regular express give rise special version accept accepts0 regular express ajb aba accepts1 ajb abajba accepts2 ajb abaja accepts3 ajb abajbajffl 63 full imper languag c seen polyvari special suffic partial evalu flowchart languag henc simpl imper languag realist imper languag c includ composit data structur record index array pointer dynam data structur function may side effect global variabl etc offlin partial evalu c need sophist bindingtim analysi deal pointer composit data structur instanc pointer variabl p may dynam pointer may static point dynam object pointer pointedto object may static bindingtim analysi may requir program wellbehav assum array program contain assign form e e dynam principl variabl program may becom dynam result assign case address outsid alloc array would conserv make partial evalu trivial instead one requir program wellbehav address inde insid tast difficulti caus combin nonloc side effect recurs function consid function side effect static global variabl side effect control dynam express dyn int global int stmt els call foo valu global may either 1 1 know one partial evalu time dyn dynam simplest solut reclassifi global dynam wast static inform might use partial evalu stmt anoth solut unfold call foo give residu program form int global int f dyn f stmt fglobal1g g els f stmt fglobalgamma1g g stmt fglobal1g special version stmt howev function foo recurs unfold imposs third solut introduc dynam continu variabl cont assign differ valu branch residu version foo foo function main call foo switch cont int global int switch cont f case 1 stmt fglobal1g break case 2 stmt fglobalgamma1g break howev work foo recurs recurs dynam control sinc number path foo static bound case henc recurs procedur feasibl option may reclassifi global dynam mani problem studi lar ole andersen construct two system special c program first one selfapplic partial evalu c subset includ procedur well pointer array 6 8 second one gener gener extens ansi c 9 latter system licens univers copenhagen techniqu c carri eg ada modula pascal littl modif knowledg done 7 partial evalu perspect 71 program special without partial evalu far focus mainli special use partial evalu idea method present inde use without use partial evalu special hand quit common programm handtun code particular case often amount partial evalu hand exampl quot paper 80 program videogam nevryon manag keep speed basic two way write routin one complex multipurpos routin everyth quickli exampl sprite routin handl size flip sprite horizont vertic piec code mani simpl routin one thing use sprite routin exampl routin plot sprite one way anoth plot flip vertic second method mean code requir speed advantag dramat nevryon written way separ sprite routin plot sprite slightli differ way special use doubt gener purpos partial evalu use special instead special perform hand possibl without ever explicitli write gener purpos routin form basi special routin use handwritten gener extens saw section 3 gener extens power function easili produc origin code use knowledg variabl contain valu known special time alway quit simpl exampl often particularli difficult write gener extens small medium size procedur program situat partial evalu avail often viabl way obtain special program use gener extens instead write special version hand use either larg number variant must gener known advanc valu program special respect common use handwritten gener extens runtim code gener piec special code gener execut runtim sprite exampl one often gener special code plot oper larg bitmap involv typic situat gener purpos routin use plot small bitmap special code gener larg bitmap special routin exploit knowledg align sourc bitmap destin area respect word boundari well clip sourc bitmap aspect scale differ colour depth etc also target runtim special bitmapplot code handwritten gener extens use optim parser special respect particular tabl 78 convert interpret compil 77 handwritten gener extens gener recent year becom popular write gener extens gener instead partial evalu 9 16 55 approach quit old 12 gener extens gener use instead tradit partial evalu follow special program p respect data first produc gener extens p gen appli p gen produc special program p convers selfapplic partial evalu produc gener extens gener cf third futamura project two approach seem equal power write gener extens gener instead selfapplic partial evalu reason ffl gener extens gener written anoth higher level languag languag handl wherea selfapplic partial evalu must abl handl text ffl reason among other may easier write gener extens gener selfapplic partial evalu ffl partial evalu must contain interpret may problemat type languag explain neither gener extens gener gener extens need contain interpret write interpret strongli type languag one must use singl type interpret repres unbound number type use program interpret true partial evalu singl univers type must use static input program special henc static input must code mean partial evalu equat must modifi take code account peval overlin mean valu code eg 1 code valu 1 selfappli partial evalu static input program program normal repres special data type repres program text data type must code univers type peval peval doubl encod space timeconsum report make selfappl intract unless special attent paid make encod compact 67 gener extens produc selfappl must also use univers type repres static input even though alway type observ lead idea make gener extens accept uncod static input achiev gener extens gener simpli copi type declar origin program gener extens gener extens gener take singl input program need deal arbitrarili type data gener extens handl valu singl program type known gener extens construct henc neither gener gener extens gener extens need handl arbitrarili type valu equat special use gener extens gener shown note absenc code usual expect gener gener termin normal partial evalu allow construct residu program perform gen loop 72 partial evalu worthwhil section 22 saw alway expect speedup partial eval uation sometim signific comput depend known input virtual work postpon residu program execut even comput appear depend known input evalu special may requir infinit unfold seen section 22 much unfold residu program becom intract larg hand exampl section 1 manag perform signific part comput special time even partial evalu pay residu program execut often enough amort cost special must two condit expect benefit partial evalu comput depend static data execut repeatedli either repeat execut program whole repetit loop recurs within singl execut program static known data obtain sever way may constant appear program text part input quit common librari function call constant para meter format string case partial evalu may speed program even input given case partial evalu work kind optim often achiev speedup optim compil would hand partial evalu may loop creat excess amount code tri optim program henc illsuit default optim special respect partial input common situat often opportun speedup exploit constant paramet case eg special interpret comput done partial evalu sometim yield speedup order magnitud similar speed differ interpret compil program choic run program interpret compil choos former program execut time contain signific repetit wherea want compil run mani time involv much repetit principl carri special partial evalu often get benefit replic loop unrol index variabl exploit constant fold function special respect sever differ static paramet case replic result enorm residu program may undesir even much comput save exampl section 1 amount unrol henc size residu program proport logarithm n static input expans small enough doesnt becom problem expans linear n would accept small valu n special interpret typic yield residu program proport size sourc program reason hand quadrat exponenti expans hardli ever accept may hard predict amount replic caus partial evalu fact seemingli innoc chang program dramat chang expans done partial evalu even make differ termin nontermin special process similarli small chang make larg differ amount comput perform special henc speedup obtain similar way parallel compil sensit way program writ ten henc special offtheshelf program often requir usual minor modif get optim benefit partial evalu ideal programm write program partial evalu mind avoid structur caus problem like program parallel machin best written limit compil mind 73 partial evalu optim compil modern machin mani compil perform transform constant fold inlin small function improv target program transform similar perform partial evalu howev contrast partial evalu compil rare produc one special version given piec code except possibl inlin kind special essenti partial evalu must handl correctli also presenc loop recurs procedur complex memori hierarchi modern comput hardwar hard know program modif actual achiev speedup exploit memori hierarchi well data regist instruct pipelin two level cach main memori virtual memori crucial perform modern machin henc may detriment unrol loop fit cach benefici inlin procedur replac indirect jump linear code sequenc much unrol inlin replic perform machin depend often see optim improv perform one machin degrad other increas degre microparallel modern microprocessor one may even get benefit elimin static comput may part critic path henc may execut parallel dynam comput hand elimin variabl special reduc regist pressur unrol loop inlin function increas basic block size give opportun lowlevel optim mean hard predict amount speedup obtain partial evalu exampl exist residu program twice fast origin program one machin slower origin anoth machin speedup also affect optim perform compil residu program 8 applic partial evalu saw section 4 partial evalu use compil program gener compil one main practic use partial evalu make compil c similar languag rapidli obtain implement accept perform experiment specialpurpos languag sinc output partial evalu typic highlevel languag tradit compil use backend compil gener partial evalu 1 14 25 27 30 33 61 case compil languag case purpos make certain comput strategi explicit eg continu pass style add extra inform eg debug program 20 42 83 93 mani type program eg scanner parser use tabl data structur control program often possibl achiev speedup partial evalu tabledriven program respect particular tabl 7 78 howev may produc larg residu program tabl unless spars often repres inform compactli code exampl convert structur knowledg represent procedur knowledg represent choic two type represent usual determin idea structur inform compact easi modifi slow use procedur inform fast use hard modifi less compact automat convert structur knowledg procedur knowledg overcom disadvantag difficult modifi procedur knowledg retain disadvantag larg space usag section 71 mention applic special comput graph ic one area seen applic partial evalu earli exampl 49 extend form partial evalu use special render use flight simul flight simul landscap view repeatedli differ angl though occlus surfac depend angl view often case knowledg particular surfac occlud anoth decid occlus question pair surfac henc partial evalu simul sort surfac decid two surfac must plot first leav test residu program furthermor use inequ occlus test posit neg constraint branch condit gener constraint use decid later occlus test attempt solv constraint simplex method time test decid inform ad constraint set effect constrain viewangl allow later test decid goad report typic landscap 1135 surfac form triangul landscap typic depth path residu decis tree 27 compar 10000 comparison need full sort 49 rather extrem speedup due natur landscap mani surfac almost parallel henc occlud narrow view angl anoth graphic applic raytrac raytrac scene render trace ray line pixel screen imaginari world behind scene test object ray hit process repeat ray use fix scene sinc may million pixel henc ray typic raytrac applic special respect fix scene unknown ray give speedup even render singl pictur speedup 6 report simpl raytrac 73 realist raytrac speedup rang 15 3 report 10 speedup gain sever sourc rayobject intersect routin special object highli parametr shade colour function special object furthermor represent scene convert procedur form figur 1 exampl raytrac pictur made raytrac 73 pictur show 3d diagram process partial evalu program p one input x fed partial evalu pe yield residu program p x partial evalu also appli numer comput particular simul program program part model constant simul part chang special respect fix part model speedup obtain exampl nbodi problem simul interact move object gravit forc simul mass object constant wherea posit veloc chang special respect mass object speed simul berlin report speedup 30 problem 15 howev residu program written c wherea origin one scheme may account part speedup anoth experi special standard numer algorithm gave speedup rang none 5 47 neural network train usual run sever thousand time number test case train variou paramet fix eg topolog net learn rate momentum special trainer paramet speedup 25 50 report 56 list applic exhaust give impress rang possibl 9 read first sketch histori 1952 1984 give number pointer literatur partial evalu relat topic book jone gomard sestoft 58 includ materi subject mention larg bibliographi updat sourc text bibliographi avail anonym ftp ftpdikudk file pubdikudistsjonesbookpartialevalbibz 91 histori kleen smn theorem 1952 assert feasibl partial evalu 63 construct proof provid design partial evalu design intend provid improv special program improv symbol reduct similar goal subsequ work partial evalu lombardi probabl first one use term partial evalu 69 futamura first research consid partial evalu program well transform thu consid applic partial evalu 40 futamura paper give equat compil compil gener partial evalu compil gener gener figur 1 partial evalu action three equat call futamura project andrei ershov 38 futamura earli idea implement around 1975 beckman haraldsson oskarsson sandewal develop partial evalu call redfun substanti subset lisp 12 describ possibl compil gener gener doubl selfappl turchin group also work partial evalu earli 1970 context function languag refal gave descript selfappl doubl selfappl 94 histori work briefli summar english 95 andrei ershov work imper languag use term mix comput mean roughli partial evalu 34 35 1984 jone sestoft sndergaard construct selfapplic partial evalu simpl firstord function languag 59 60 86 neither singl doubl selfappl carri practic time interest partial evalu logic program area increas background 1987 workshop partial evalu mix comput 19 39 subsequ proceed partial evalu may found 2 3 4 5 32 88 92 partial evalu imper languag earli paper partial evalu imper languag includ 34 36 37 bulyonkov ershov report selfapplic partial evalu flow chart languag 25 gomard jone 50 gluck et al creat nonselfapplic special numer algorithm fortran 11 47 andersen 6 8 9 develop two system special c program see section 63 lisp scheme first major partial evalu lisp redfun report beckman et al 12 weis et al construct fulli automat onlin partial evalu subset scheme 100 jone et al construct self applic partial evalu firstord function languag 59 60 romanenko improv variou respect 81 consel construct selfapplic partial evalu schism scheme subset handl partial static structur polyvari bind time 28 29 31 bondorf danvi construct selfapplic partial evalu similix subset scheme 20 21 standard ml danvi heintz malmkjaer develop partial evalu pellmel 70 birked welind creat gener gener extens 17 18 refal supercompil turchin creat refal languag develop program transform techniqu drive supercompil gener partial evalu 95 96 97 number recent survey drive supercompil exist 48 89 90 91 prolog partial evalu pioneer komorowski 64 65 subsequ work prolog includ 13 44 45 66 93 98 99 sahlin construct practic nonselfapplic partial evalu full prolog 84 85 bondorf mogensen 76 construct selfapplic partial evalu prolog subset gurr one logic languag godel 52 jrgensen leuschel creat gener gener extens prolog 62 93 relat topic mccarthi use program transform rule calcul proof recurs function program 72 boyer moor autom proof kind 22 burstal darlington view manual program transform applic type meaningpreserv program rewrit definit instanti unfold fold abstract law 26 partial evalu special program forward use knowledg avail input convers program slice special program backward use knowledg demand output 79 r compil base partial evalu ation new partial evalu c automat compil gener extend abstract program analysi special c program languag partial evalu appli ray trace partial evalu numer program fortran partial evalu partial evalu procedur logic pro gram compil scientif code use partial evalu partial evalu appli numer comput partial evalu standard ml partial evalu mix comput automat autoproject higher order recurs equat prove theorem lisp function gener criterion avoid infinit unfold polyvari mix comput analyz program adhoc compil construct appear univers mix comput process transform system develop recurs program compil orparallel andparallel new insight partial evalu schism experi bind time analysi higher order untyp function lan guag schism manual dagstuhl seminar partial evalu compil embed languag lisp partial comput principl mix comput class recurs program schemata essenc compil mix comput potenti applic problem studi futamura project special issu select paper workshop partial evalu mix comput partial evalu comput process approach compilercompil gener partial comput transform logic program specialis interpret tutori specialis logic program lowlevel sourc transform logic program specialis prolog fcp program use abstract interpret gener optim special applic metasystem transit function invers transform automat construct special purpos program compil gener partial evalu partial evalu untyp lambda calculu effici type infer higherord bindingtim analysi finit analysi handwrit cogen avoid problem static type speed backpropag algorithm partial evalu automat program special reexamin basic principl partial evalu automat program gener experi partial evalu gener compil gener gener compil lazi languag partial eval uation effici gener effici gener extens prolog introduct metamathemat specif abstract prolog machin applic partial evalu partial evalu mean inferenc data structur applic languag theori implement case prolog prolog partial evalu system stronglytyp selfapplic partial evalu partial evalu logic program ming lisp languag increment comput ml partial evalu use setbas analysi ensur global termin partial deduct allow flexibl polyvari basi mathemat theori comput applic partial evalu raytrac convert interpret compil compar effici gener residu parser program special via program slice realm nevryon compil gener produc selfapplic special surprisingli natur understand structur special onlin program special meta interpret real mixtu approach automat partial evalu full prolog automat partial evalu full prolog structur selfapplic partial evalu automat call unfold partial evalu special issu partial evalu turchin supercompil revisit algorithm gener posit supercompil toward unifi partial eval uation cake eat partial evalu prolog program applic meta program basic refal implement comput supercompil system base languag refal concept supercompil program transform metasystem transit prolog metainterpret partial evalu applic sourc sourc transform queryoptimis partial evalu system prolog practic consider automat onlin partial evalu tr ctr mohan rajagopalan saumya k debray matti hiltunen richard schlicht profiledirect optim eventbas program acm sigplan notic v37 n5 may 2002 arvind krishna aniruddha gokhal dougla c schmidt venkatesh prasad ranganath john hatcliff toward highli optim realtim middlewar softwar productlin architectur acm sigb review v3 n1 p1316 januari 2006 arvind krishna aniruddha gokhal dougla c schmidt contextspecif middlewar special techniqu optim softwar productlin architectur acm sigop oper system review v40 n4 octob 2006 yasushi shinjo calton pu achiev effici portabl system softwar case studi posixcompli multithread program ieee transact softwar engin v31 n9 p785800 septemb 2005 annefranois le meur julia l lawal charl consel toward bridg gap program languag partial evalu acm sigplan notic v37 n3 p918 march 2002 jacqu carett gaussian elimin case studi effici gener metaocaml scienc comput program v62 n1 p324 septemb 2006 annefranois le meur julia l lawal charl consel special scenario pragmat approach declar program special higherord symbol comput v17 n12 p4792 marchjun 2004