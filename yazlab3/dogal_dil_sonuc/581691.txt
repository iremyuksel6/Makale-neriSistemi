templat metaprogram haskel propos new extens pure function program languag haskel support compiletim metaprogram purpos system support algorithm construct program compiletimeth abil gener code compil time allow programm implement featur polytyp program macrolik expans user direct optim inlin gener support data structur function exist data structur functionsour design implement glasgow haskel compil ghc b introduct compiletim program optim similar po etri written actual publish commerci compil hard econom realiti mani interest optim narrow audienc justifi cost altern allow programm defin compiletim op timiz alreadi happen accident c albeit imperfectli obviou function programm committe realiz later c templat function languag evalu compil time 12 haskel workshop oct 2002 pittsburgh robinson provoc paper identifi c templat jor albeit accident success c languag design despit extrem baroqu natur templat metaprogram templat use fascin way extend beyond wildest dream languag design 1 perhap surprisingli view fact templat function program function programm slow capit cs success recent flurri work runtim meta program much less done compiletim meta program scheme commun notabl except discuss section 10 paper therefor present design compiletim metaprogram extens haskel stronglytyp pure function languag purpos extens allow programm comput part program rather write seamlessli conveni extens view templat system haskel la c well typesaf macro system make follow new contribut describ quasiquot mechan languag binder precis describ translat monad comput allow use gensym like oper even pure function languag like haskel section 61 9 stage typecheck algorithm coroutin type check compiletim comput stage use ful support code gener written ordinari program would need given depend type languag therefor express simpl depend still secur runtim comput either handwritten comput alway typecheck execut section 7 reific programmerwritten compon support comput part program analyz structur userwritten part particularli use build boilerpl code deriv data type declar section 5 81 addit origin contribut synthes previou work coher system provid new capabl includ represent code ordinari algebra datatyp make possibl use haskel exist mechan case analysi observ structur code therebi allow programm write code manipul program well code gener program section 62 93 augment quotat monad encapsul metaprogram featur fresh name gener program reific error report monad librari syntax oper built top algebra datatyp quotat monad provid easytous interfac metaprogram part system section 4 6 63 section 8 quasiquot mechan built top monad li brari templat haskel extend metalevel oper static scope static typecheck objectlevel code fragment built use quasiquot mechan sec tion 9 71 static scope typecheck automat extend code fragment built use algebra datatyp represent would program user section 9 93 reific facil quotat monad allow programm compiletim queri compil intern data structur ask question line number sourcefil current posit use error report kind type construc tor section 82 metaprogram produc group declar includ data type class instanc declar well express section 51 2 basic idea begin exampl illustr mean meta program consid write clike printf function haskel would like write someth like printf error line msg line one defin printf haskel printf type de pend complic way valu first argument see 5 ingeni altern templat haskel though defin printf typesaf ie report error compiletim msg line type string int respect effici control string interpret compil time userdefin fix number compil extens ever enough write call templat haskel printf error line msg line say evalu compil time call printf return haskel express splice place call compil origin express proceed often use term splice splice printf return follow code s0 n1 show lambda abstract typecheck appli msg line exampl interact session illustr prompt printf error line bad var 123 error bad var line 123 1 note templat haskel follow open parenthesi alphabet charact special syntact form x mean x appli splice wherea x mean ordinari infix applic function ordinari haskel situat similar ab mean someth differ b function printf execut compil time program produc program result metaprogram templat haskel user defin printf thu printf string expr type printf say transform format string haskel express type expr auxiliari function pars break format string tractabl list format specifi data string pars string format exampl pars return l even though pars execut compil time perfectli ordinari haskel function leav definit exercis function gen much interest first give code gen assum exactli one format specifi gen format expr gen l result gen construct use quasiquot notat templat templat haskel quasiquot user interfac repres haskel program construct place quasiquot bracket around ordinari haskel concret syntax fragment function lift string expr lift string expr type produc expr execut would evalu liftss ar gument say lift section 91 matter becom interest want make gen recur sive deal arbitrari list format specifi give auxiliari paramet name express repres string prefix result adjust call printf accordingli printf string expr gen format expr expr gen insid quotat splice annot still mean evalu quasiquot code construct gen call recurs call gen therefor run compil time result splice enclos quasiquot express argument type expr second argument recurs call gen accumul paramet type expr henc anoth quasiquot ex pression notic argument recurs call gen refer objectvari n bound outer quasiquot occurr within static scope bind occurr static scope extend across templat mechan 3 templat write program highlevel languag make program shorter concis easier maintain easier think mani low level detail data layout memori alloc abstract compil programm longer concern detail time good sinc expert knowledg embed compil compil job manner superior user could manag sometim programm know particular detail compil compil couldnt deal detail econom reason doesnt 12 limit number featur compil writer put one compil solut construct compil manner ordinari user teach new trick rational behind templat haskel make easi programm teach compil certain class trick compil manipul program make easi user manipul program also easi interlac manipul compil manipul creat power new tool envis templat haskel use programm mani thing condit compil extrem use compil singl program differ platform differ debug option differ configur crude approach use preprocessor like cpp inde sever compil haskel support directli mechan part program languag would work much better program reific enabl program inspect structur exampl gener function serialis data structur base data type declar structur algorithm program construct allow programm construct program algorithm describ construct program simpler program gener function like map show prime exampl compiletim special program like printf code compil special compiletim constant abstract transcend abstract mechan access languag exampl includ introduc higherord oper firstord languag use compiletim macro implement integ index function like zip1 zip2 zipn strongli type languag optim may teach compil domainspecif optim algebra law inlin opportun templat haskel function execut compil time written languag function execut run time name haskel choic sharp contrast mani exist system exampl cpp languag defin etc templat metaprogram c written entir type system big advantag approach exist librari program skill use directli arguabl disadvantag explicit annot necessari specifi bit code execut anoth consequ programm may erron write nontermin function execut compil time case compil fail termin regard program error avoid diverg run time rest paper flesh detail design shall see follow section turn simpl quasiquot splice notat introduc far enough 4 flexibl construct one start use templat haskel long one discov quasiquot splice express anyth like full rang metaprogram opportun want haskel builtin function select compon name fst snd want select first compon tripl write hand case x abc templat haskel instead write sel 1 least would like write sel sel int int expr sel case x uh oh cant write ordinari haskel pattern case express depend n quasiquot notat broken instead need way construct haskel syntax tree directli like sel int int expr sel alt match pat patt rh expr base string code use syntaxconstruct function construct express pattern list type concret exampl refer syntax pattern pvar string patt x ptup patt patt xyz pcon string patt patt fork x pwild patt syntax express var string expr x app expr expr expr f x lam patt expr expr x 5 case x simplem patt expr match xx 2 code sel verbos printf use explicit constructor express rather implicit one exchang code construct fundament flexibl sel show templat haskel provid full famili syntax construct function lam pvar document appendix two style mix freeli exampl could also sel like sel int int expr sel illustr idea suppos want nari zip func tion whose call might look like zipn bs cs list zipn int expr gener code nari zip let start write zipn zipn int expr metafunct zipn gener local let bind like let zip3 bodi bind dot gener auxiliari metafunct mkzip defin low function defin let zip3 exampl paragraph recurs name function doesnt realli matter sinc use result let never escap scope let whole let express return name function must pass mkzip mkzip gener bodi let properli scope size zip function n also paramet mkzip use see mkzip gener particular n understand work appli 3 object variabl var ff gener valu expr type prettyprint valu concret syntax get case y1y2y3 note paramet var ff end function one arm case user level function zipn oppos auxiliari function mkzip appli 3 obtain full let note name bound variabl zp0 pass paramet mkzip end recurs call case y1y2y3 zp0 function mkzip oper gener bunch pattern eg y1 y2 y3 x1xs1x2xs2x3xs3 bunch express use variabl bound pattern gener sever pattern patternvari associ express expressionvari common abstract function string int pattexpr map pvar ns map var ns pvar x1pvar x2var x1var x2 mkzip use function construct three list match pattern express assembl piec lambda abstract whose bodi case analysi lambda abstract variabl px py pcon x pcon px pxss b use quasiquot mechan pattern p function app anoth idiom worth abstract function applic function multipl argument app expr expr app app messag section work quasiquot notat simpl conveni secur understand haskel static scope type rule howev quasiquot alon enough usual want gener code sequenc indetermin length templat haskel syntaxconstruct function app lam case etc allow programm drop less conveni express notat necessari 5 declar reific haskel one may add deriv claus data type declar data tip fork deriv eq deriv eq claus instruct compil gener boilerpl code allow valu type compar equal howev mechan work hand builtin type class eq ord ix want instanc class write hand tiresom winstanley wrote drift preprocessor haskel allow programm specifi codegener algorithm use algorithm gener boilerpl code mani data type 17 much work also done polytyp algorithm whose execut specifi base structur type 9 6 templat haskel work like fullyintegr version drift exampl data tip fork splice geneq reifydecl code show two new featur seen reific declar splice reific involv make intern represent avail data structur compiletim comput reific cover detail section 81 51 declar splice construct splice may appear declar group need wherea seen express expect splice instruct compil run enclos code compiletim splice result declar group place splice call 2 splice gener one declar exampl geneq gener singl instanc declar essenti asid syntax use splice rather latter seem rather ters declar context particular applic deriv gener could also gener one class data type valu declar gener declar rather express use purpos deriv code data type consid nari zip function discuss section 4 everi time write zipn bs cs fresh copi 3way zip gener ate may precis programm want say may also want gener singl toplevel zip function like might want gener zip function 10 20 whatev write splice genzip 20 understand zip1 zip2 zip20 brought scope 6 quasiquot scope quotat monad ordinari haskel static scope templat haskel exampl consid metafunct cross2a cross2a expr expr expr execut cross2a var x var expect var x var would inadvert captur local objectvari x insid quasiquot cross2a definit inde case prompt cross2a var x var display toplevel term type expr quasiquot notat renam x get expect result static scope work ordinari haskel quasiquot lift behavior objectlevel well unfortu nate syntax construct function lam var tup etc behav way consid lam ptup pvar x pvar tup app f var xapp g var appli cross2b x result inadvert captur prompt cross2b var x var display toplevel term type expr sinc program gener written use quasiquot notat alon appear syntax construct function inadequ express static scope appear troubl need way gener fresh name turn next 61 secret reveal one correct render cross templat haskel without use quasiquot cross2c expr expr expr x gensym x return lam ptup pvar xpvar tup app ft var x exampl reveal three secret type expr synonym monad type q exp deed true declar code return cross2c repres ordinari haskel algebra datatyp fact two algebra data type exampl exp express constructor lam tup app etc pat pattern constructor pvar ptup etc monad q quotat monad support usual monad oper bind return fail notat well gensym oper gensym string q string gener expr return cross2c use haskel monad donot first gener fresh name x use monad gensym build express return notic tiresom also perform f g monad give ft gt type exp f g type might intern gensym see avoid pain section 63 summar templat haskel three layer represent objectprogram order increas conveni decreas power bottom layer two part first ordinari algebra data type repres haskel program fragment section 62 second quotat monad q encapsul notion gener fresh name well failur inputoutput section 8 librari syntaxconstruct function tup app lift correspond algebra data type constructor tup app quotationmonad level provid conveni way access bottom layer section 63 quasiquot notat introduc section 2 conveni seen import metaprogram express revisit quasiquot notat section 9 show built top previou layer programm freeli mix three layer latter two simpli conveni interfac first discuss detail first two layer code represent leav detail discuss quasiquot section 9 62 datatyp code sinc objectprogram data haskel repres data structur use algebra datatyp natur templat haskel repres haskel objectprogram use algebra datatyp particular data type use templat haskel given appendix b highlight includ algebra datatyp repres express exp declar dec pattern pat type typ addit data type use repres syntact element haskel guard definit bodi express comprehens statement arithmet sequenc dotdot use comment freeli appendix b illustr algebra datatyp concret syntax exampl tri make data type complet yet simpl model haskel concret surfac syntax haskel program abl use algebra constructor function repres advantag algebra approach objectprogram represent ordinari data particular analys use haskel case express pattern match disadvantag approach verbos construct represent program requir consider effort requir construct program littl support semant featur object languag scope type 63 syntaxconstruct function syntaxconstruct function section 4 stand reveal monad variant correspond data type constructor exampl type data type constructor app monad counterpart rememb app exp exp exp app expr expr expr argument app comput wherea argument app data valu howev app conveni function simpli perform argument comput build result app expr expr expr x b return app b conveni worth exampl yet anoth version cross cross2d expr expr expr x gensym x lam ptup pvar x pvar tup app f var x var use monad version constructor build result therebi avoid bind ft gt hand cross2c instead lam app tup us gener use follow nomenclatur fourcharact type name eg expr monad version threecharact algebra data type eg exp lowercas function eg app monad version uppercas data constructor eg app 3 expr decl monad comput version underli concret type correspond type pattern patt type type simpli synonym underli data type 3 constructor whose lowercas name would clash haskel keyword like let case data class instanc use convent suffix lowercas name initi letter type lete case doe datad classd instanc reason need gensym construct pattern type look cross2d would point gensym x insid pattern variabl must scope bodi lambda well nevertheless provid type synonym patt type togeth lowercas constructor pvar ptup etc programm use consist set lowercas work comput set even though format exp dec comput uppercas work algebra datatyp set syntaxconstruct function ordinari haskel librari one readili extend program mer seen one exampl definit app end section 4 mani other possibl exampl consid common pattern wish gener code scope newlygener pattern dont care name variabl pattern dont clash exist name one approach gensym new variabl construct pattern express hand cross2d altern clone whole pattern one fell swoop rather gener new variabl one time vfp genpat ptup pvar xpvar lam p tupapp f vf xapp g vf function genpat patt q stringexpr patt alpharenam whole pattern return new pattern function map name variabl origin pattern expr name variabl alpharenam pattern easi write recurs pattern scheme even mix quasiquot notat vfp genpat p xy use quasiquot notat pattern p mention pass section 4 also suppli quasiquot notat declar type cours renam happen automat quasiquot explain detail section 9 7 type templat haskel templat haskel strongli type milner sens welltyp program go wrong runtim tradit strongli type program first typecheck compil execut situat templat haskel littl complic exampl consid first exampl printf error line urk 341 readili typecheck form type splice express depend complic way valu string argument templat haskel type check take place stage first type check bodi splice case printf error line expr next compil execut splice result place call exampl program becom s0 n1 show urk 341 typecheck result program programm written program first place henc type check intim interleav compiletim execut templat haskel compiletim metasystem metalevel oper bracket splice reific appear code gener exampl f 3 ill gal restrict well exampl definit illeg unless insid quotat say evalu compil time splice valu x known f call common stage error enforc restrict like break staticcheck part compil process three state compil c state normal compil without metaoper compil would alway state compil enter state bracket compil code insid quasiquot compil enter state splice encount express escap insid quasiquot bracket exampl consid definit f static check state c call foo type state b call zipn type state addit state count level start state 0 increment process quasiquot decrement process insid splice level use distinguish toplevel splice splice insid quasiquot exampl call h static check state level 1 x2 check state b level 0 three state legal transit reflect figur 1 transit diagram indic error transit tempt think state merg togeth case transit state c impli compiletim comput thu requir complic static check includ comput transit state rule diagram enforc weav type checker formal type judgment type checker given figur 2 embodi transit diagram suppli case legal state studi rule detail 71 express begin rule express simpler inde simplif wellestablish rule metaml 16 type judgment rule express take convent form g environ map variabl type bind state e express type state describ state type checker n level describ reifi reifi splice figur 1 type state templat haskel rule bracket say one state c express e type q exp regardless type e ever notic e still typecheck new state b increment level reflect legal transit figur 1 emphas use bracket type rule one list state type check term e detect intern type inconsist right away exampl would reject immedi repres interest design compromis metafunct includ code fragment gener static check guarante metafunct produc welltyp code complet splice recheck believ new approach type meta program approach catch mani error earli possibl avoid need use depend type yet still complet typesaf notic rule quasiquot state b quasiquot nest unlik multistag languag metaml rule escb explain type check splice e insid quasi quot state b type e must q exp tell us noth type express e evalu henc use unspecifi problem sound ever express splice sit typecheck later inde precis happen rule esc deal splice state c express e type check evalu give new express e express type check scratch state c programm written first place rule lam var deal stage environ g contain assumpt form record xs type also level bound rule lam think environ finit function variabl x use level n check n later bind level rule var 72 declar figur also give rule type declar whose judgment form state cb reifydecl fun figur 2 type rule templat haskel g environ declar check g minienviron give type variabl bound decl 4 rule quit convent exampl rule fun explain type function definit rule splice interest one follow pattern splice expr sion first typecheck splice express e run typecheck declar return abil gener group declar seem fundament use rais interest complic even resolv lexic scope program let alon type splice done exampl program valid splice genzip 20 well valid splice bring zip3 scope expect doesnt similar remark natur appli instanc declar produc geneq function section 51 modul contain sever splice may obviou order expand tackl complic assum programm intend splice expand toptobottom precis 4 singl haskel declar bind mani variabl typecheck group declar 1 n follow follow procedur group declar follow splice e a2 b splice e b splice e z z2 n splice declar one indic explicitli group 1 etc ordinari haskel declar perform convent depend analysi follow type check first group free variabl scope environ thu establish typecheck expand first splice typecheck result expand first splice augment environ thu establish typecheck next ordinari group algorithm implement judgment declar list use rule splice 73 restrict declar splice notic rule splice assum state c level 0 permit declar splice state exampl permit splice pq h int decl typecheck f run comput h x x known yet run h x know let bind sensibl typecheck bodi let name pq would possibl give typecheck bodi sinc result everi call f typecheck logic conclus line thought would give typecheck bodi quasiquot express would sound would defer mani type error definit site metafunct call site choic pend experi err side earlier error detect want effect f still get drop lower level fact current restrict splice must toplevel declar like haskel data class instanc declara tion reason restrict concern usabl rather technic complex sinc declar splice introduc unspecifi new bind may clear variabl occur origin program bound situat similar haskel exist import statement bring scope unspecifi collect bind restrict splice top level make worthwhil gain given occurr x see lexic enclos bind x inde xs bind top level splice hide anoth toplevel bind import x haskel permit two definit valu top level contrast nest splice could hide enclos bind x inde one think toplevel splice kind programm import statement 8 quotat monad revisit far use quotat monad gener fresh name use purpos discuss section 81 reific reific templat haskel way allow programm queri state compil intern symbol tabl exampl programm may write modul data tip fork rept decl lengthtyp type percentfix q int q string first construct reifydecl return comput type decl ie q dec repres type declar perform comput rept perhap write rept would obtain dec data mt constr mtip tvar constr mfork tapp tcon name mt tvar tapp tcon name mt tvar write mt mean unambigu defin modul say mt origin name origin name part syntax haskel necessari describ inde implement metaprogram cor rectli say origin name section 91 similar way reifydecl f give data structur repres valu declar f similarli class deed reific provid gener way get compiletim format construct reifytyp length return comput type type ie q typ repres compil knowledg type librari function length similarli reifyfix tell fixiti argument use figur print someth final reifylocn return comput type q string repres locat sourc file reifylocn occur reifi alway return comput combin comput compiletim reific languag construct say map reifytyp xs exampl import reific return result quotat monad exampl consid definit assert function assert expr bool b r els error assert fail notic comment give type express gener assert static type system metaml would nicer one might invok assert like find xs assert splice expand get find xs n error assert fail line 22 fooh n 10 xs n vital cours reifylocn captur locat splice site assert rather definit site precis achiev make reifylocn return com putat one take idea make assert behaviour depend commandlin argument analog cpp command mechan defin symbol dfoo cassert expr bool mb reifyopt debug isnoth mb els assert assum anoth reific function reifyopt string mayb string return noth command line option specifi string defin valu one one could go yet clear much reific allow exampl might use restrict use reifydecl type constructor class variabl eg function declar top level current modul perhap type constructor declar data declar import modul may also use support addit kind reific make compil symbol tabl inform avail 82 failur compiletim metaprogram may fail programm made error exampl would expect zipn 1 fail make sens produc nari zip function argument error sort due inappropri use rather bogu implement metaprogram metaprogramm need way cleanli report error anoth place quotat monad use case zipn write zipn int expr arg zipn must 2 fail standard monad fail oper class monad whose type instanc fail string q compil catch error report via fail grace report occur 83 inputoutput metaprogram may requir access inputoutput facil exampl may want write splice genxml fooxml gener haskel data type declar correspond xml schema store file fooxml togeth boilerpl haskel function work data type end easili provid way perform arbitrari inputoutput quotat monad qio io q natur power open abus mere compil malici program might delet entir file store mani compromis posit possibl includ rule io altogth allow limit set benign oper file read polici choic technic one consid 84 print code far produc code order splice modul compil sometim want write program gener haskel program put file rather compil happi parser gener exampl exist program follow paradigm inde pedagog reason extrem conveni display code gener rather compil end librari provid make exp dec etc instanc class show instanc show exp instanc show dec etc display code construct comput framework suppli function runq q io thu compil run program e runq sel 1 output x case x abc pro duce notic absenc splice sel defin section 4 implement q far treat q monad abstractli easi im plement io monad augment environ newtyp q environ contain mutabl locat serv name suppli gensym sourc locat toplevel splice invok evalu reifylocn compil symbol tabl support implement reifydecl reifyfix reifytyp commandlin switch support reifyopt thing could cours readili ad 9 quasiquot lexic scope introduc quasiquot notat inform time pay direct attent quasiquot notat conveni shorthand repres haskel program lexic scope precis everi occurr variabl bound valu lexic scope occurr site origin sourc program templat expans obvioussound properti lisp commun call hygien macro 10 metaprogram set nearli easi implement one might think quasiquot notat implement top quotat monad section 6 saw variabl bound insid quasiquot must renam avoid inadvert captur cross2a exampl variabl bound outsid quasiquot 91 crossstag persist possibl splice expand express contain name scope splice occur need take care happen consid rather contriv exampl modul genswap consid call genswap anoth modul modul foo import genswap splice genswap 45 expand expand swap 45 modul foo plain swap would bind boolean valu defin foo rather swap defin modul splice expand tswap 45 use haskel qualifiednam notat tswap scope foo genswap import foo name space import genswap instead expand splice tswap 45 use origin name tswap origin name first discuss section 81 context represent return reifi solv similar problem part code represent must unambigu refer global toplevel variabl may hidden scope represent may use extens haskel templat haskel use implement static scope across metaprogram extens access ordinari part haskel exampl one write mmap f 123 abil includ gener code valu variabl exist compiletim special name crossstag persist requir care implement correctli seen happen toplevel variabl swap nest variabl requir differ treatment particular consid statu variabl x free quotat swap x unlik swap x toplevel bind modul inde noth xs type known modul com pile way give origin name sinc valu vari everi call genswap crossstag persist kind variabl qualit dif ferent requir turn arbitrari valu code exampl compil execut call genswap 45 pass valu 45 genswap latter must return data structur type exp app var tswap tup lit int 4 lit int 5 somehow code genswap lift valu exp show happen genswap becom quasiquot translat away lift x return app var tswap take advantag haskel exist typeclass mecha nism lift overload function defin type class class lift lift expr instanc lift allow programm explain lift type choic expr exampl one provid part templat haskel instanc lift int instanc lift alift b lift ab take advantag type class way requir slight chang type judgment var figur 2 stage b insid quasiquot variabl x bound outsid quasi quot top level type checker must inject type constraint lift x type omit mention type constraint figur 2 real system cours summar lexic scope mean free variabl swap x toplevel quasiquot right hand side definit genswap static bound clo sure need scope applic site insid modul foo case inde quit differ valu name may scope noth terribl surpris simpli lexic scope action precis behaviour would expect genswap ordinari function 92 dynam scope occasion programm may instead want dynam scope strategi gener code templat haskel express dynam scope like splice site genswapdyn 45 expand swap 45 swap bind whatev swap scope splice site regardless scope definit genswapdyn behaviour sometim use templat haskel clearli flag use stringquot variabl name var swap unquot variabl lexic scope open question whether power desir easili remov make var take gensym return abstract type instead string 93 implement quasiquot quasiquot notat explain term origin name syntax constructor function use gensym return lift oper one think translat process term within quasiquot anoth term figur 3 make translat precis express translat ordinari haskel function skeleton handl enough constructor pat exp illustr process omit mani other interest breviti main function tre translat express insid quasi quot first argument environ type venv ignor coupl paragraph given term exp call cl construct anoth term exp evalu genswap exampl compil translat genswap bodi swap x execut translat function tre argument tre cl app var swap var x result call exp app app var app app var var str tswap app var lift var x print concret syntax app var tswap lift x wed expect quasiquot swap x expand quasiquot translat environ cl tell tre treat swap x differ captur translat process haskel function write tre cl app b tran tran b tre cl cond x z tran x tran tran z tre cl simpl pattern captur tre cl app cl ab tre cl cond x cl xyz tre venv exp exp tre cl es map tre cl es rep string exp exp app f app f return environ cl venv section 91 discov variabl need treat differ depend bound environ record inform use tre decid translat variabl occurr string varclass data modnam lift bound varclass variabl v follow tre cl var case cl bound rep var var lift rep lift var orig mod rep var str mod tre cl elitint tre cl app f cl fx tre cl tup cl es tre cl lam ps ps cl e tre cl esc tre cl br nest bracket allow tre venv exp exp tre cl es map tre cl es copi venv exp exp copi cl var copi cl lit c lit c copi cl app f cl f copi cl x copi cl lam ps ps copi cl e copi cl br cl e trp pat statement pat exp decpat trp p pvar rep pvar var ps ps trp pat statement pat exp decpat figur 3 quasiquot translat function trexp orig mean v bound top level modul v origin name lift mean v bound outsid quasiquot top level translat function gener call lift type checker later ensur type v class lift bound mean v bound insid quasiquot alpharenam three case reflect directli case var tre figur 3 need auxiliari function trp translat pattern trp pat statement pat exp decpat first part pair return trp list statement repres gensym bind gener translat second part pair pat repres alpharenam pattern exampl translat patternvari x get one bind statement x gensym x result pvar x trp hand look lam case tre lambda express f x f x wish gener local bind preserv scope quot lambda f gensym f lam pvar fpvar x app var f var x bind f gensym f x gensym x renam pattern pvar fpvar x bound metavari ss1 xs call trp ps assembl bodi app var f var x gener recurs call tre new express return last interest case esc case consid exampl translat tre translat follow tup f gensym f lam pvar f var f f gensym f lam pvar fptup pvar xpvar app app var f var w notic bodi splice w transcrib liter translat code w copi function look copi interest case reach nest quasiquot resort back tre exampl given code transform f quasiquot term nest quotat within escap x gensym x lam pvar x tup f var xlit int 5 relat work 101 c templat c elabor metaprogram facil known templat 1 basic idea static compiletim comput take place entir type system c templat class consid function whose argument either type integ thu factorial7 return type one extract integ result return struct select conventionallynam member thu factorial7ret type system rich enough one construct manipul arbitrari data structur list tree etc type system use comput control objectlevel code gen erat wide recogn typesystem comput languag simpli extraordinarili baroqu function languag full ad hoc code trick convent fact c templat wide use strong evid need thing barrier use consider believ templat haskel take principl approach task particular static comput languag dynam languag new program idiom requir first think idea cours lisp commun year discuss next 102 scheme macro lisp commun taken templat metaprogram serious twenti year 11 modern scheme system support elabor tower languag extens base entir macro earli design suffer badli namecaptur prob lem problem solv evolut hygien macro 10 4 dybvig hieb bruggeman paper excel lent selfcontain summari state art 7 differ vocabulari worldview combin subtleti materi make quit difficult give clear pictur differ scheme approach immediatelyobvi differ templat haskel static type expans afterward scheme macro expand sort static type system howev report stage error beyond three pervas way scheme system power less tractabl scheme admit new bind form consid macro call suitablydefin macro foo might requir first argument variabl name scope second ar gument exampl call foo might expand much complex scheme macro aris abil defin new bind form way templat haskel much clumsili hand least make clear occurr var k lexic scope sourc program declar splice splice e bind variabl declar splice occur top level outsid quasi quot situat tractabl scheme macro special bind form definesyntax call site syntact baggag instead macro call identifi observ token function posit bound definesyntax templat haskel special syntax definit site templat function ordinari haskel function splice requir call site interest tradeoff templat haskel macro complet higherord first class like function pass argument return result partial appli construct anonym lamb da scheme macro pretti much first order must call name bawden discuss firstclass macro 2 scheme admit side effect complic everyth mutabl valu instanti move compiletim runtim share haskel free complic 103 metaml deriv goal metaml 16 14 13 templat haskel differ sig nificantli mani lesson learn build metaml influenc templat haskel design import featur migrat metaml templat haskel includ use templat quasiquot notat mean construct object program typesafeti program fragment ever execut context typecheck type check construct program fragment happen compiletim static scope objectvari includ alpha renam bound objectvari avoid inadvert captur crossstag persist free objectvari repres runtim function mention objectcod fragment correctli bound scope code creat use 1031 metaml also signific differ templat haskel metaml differ follow differ assumpt metaprogram system use follow assumpt use design templat haskel differ strongli metaml user comput portion program rather write pay runtim overhead henc assumpt exactli two stage compiletim runtim metaml code built execut even runtim templat haskel code meant compil metacomput happen compiletim code repres algebra datatyp henc amen inspect case analysi appear first odd staticscop quasiquot mechan shown accomplish rather interest way use monad everyth static typecheck check delay last possibl moment use strategi justintim type check allow power metaprogram written without resort depend type handwritten code reifiabl ie data repres obtain manipul runtim function data type definit reifi ie data structur represent obtain inspect compiletim function quasiquot metaml indic boundari stage execut bracket run metaml akin quot eval scheme templat haskel bracket indic boundari compiletim execut runtim execut one main breakthrough type system metaml introduct quasiquot respect scope type metaml code gener program typecorrect program gener 16 properti crucial gener step happen runtim late start report type error howev secur come price metaml express mani use program exampl printf exampl section 2 type metaml type call printf depend valu string argument one way address problem use depend type system approach distinct disadvantag start programm would burden write function transform format string type type system becom much complic explain templat haskel second stage may give rise type error still occur compil time situat much less seriou runtim code gener contribut current work develop semant quasiquot monad comput allow quasi quot exist pure languag without side effect process gener fresh name encapsul monad henc quasiquot referenti transpar 1032 metaocaml metaocaml 3 stage ml implement built top ocaml system like metaml runtim code gener sy tem unlik metaml compil rather interpret gener compil bytecod runtim demonstr impress perform gain stage program non stage counterpart translat quasiquot manner preserv scopingstructur quot express first implement metaocaml 1033 macroml macroml 8 propos add compiletim macro ml languag macroml demonstr even macro implement new bind construct given precis semant stage program macro strongli type macroml allow introduct new hygen local binder macroml support gener macro macro limit construct new code combin code fragment analyz code fragment 1034 dynam type approach justintim typecheck root earlier studi 15 dynam type stage typeinfer work well templat haskel type code fragment split stage templat haskel code final typecheck toplevel splice point splice state c work code type check splice point addit code construct splice point typecheck runtim activi tie signific effort place reduc runtim overhead typecheck implement small prototyp read templat haskel perform compiletim execut throe scale prototyp full implement embodi templat haskel extens glasgow haskel compil ghc ghc implement fulli support separ compil deed compil modul function defin modul compili earlier execut compil time rea son execut function defin compil would need compil function function call way execut code even typecheck part compiletim function invok compil find previouslycompil execut dynam link modul packag import run com piler modul consist complet metafunct need link execut built final link step although ghc make yet clever enough figur work design repres work progress hope provid work implement work driven directli experi real user meanwhil mani avenu alreadi know want work import except reifi data type defini tion said littl userdefin code manipul optim one advertis goal well get yet know confus error messag templat haskel given may aris code programm see least possibl display code alreadi found one often want get earlier type secur addit document say expr whose type int like metaml type expect add parameteris code type expr int use expr indic type static known c templat scheme macro lighterweight syntax call macro inde programm may need awar macro involv interest tradeoff discuss briefli section 102 lot said reduc syntact baggag call site specul idea infer splice annot acknowledg would like particularli thank matthew flatt sever long convers explor relationship templat haskel scheme macro error comparison two remain also thank magnu carlsson fergu henderson toni hoar dick kieburtz simon marlow emir pasal haskel workshop refere help comment draft work would also like thank student class cse583 fundament stage comput winter 2002 particip mani live discuss use stage especi bill howe whose final project motiv tim sheard begin work work describ support nsf grant ccr 0098126 mj murdock charit trust depart defens r modern c bytecod compil macro work function unpars technic overview gener haskel syntact abstract scheme macro multistag comput typesaf deriv type class hygien macro expans special form lisp impact econom compil optimiza tion accomplish research challeng meta program introduct multistag program use metaml tr macro work syntact abstract scheme multistag program explicit annot dynam type stage type infer hygien macro expans firstclass macro type impact econom compil optim macro multistag comput accomplish research challeng metaprogram special form lisp ctr andi gill introduc haskel equat reason assist proceed 2006 acm sigplan workshop haskel septemb 1717 2006 portland oregon usa bjrn bringert ander hckersten conni andersson martin andersson mari bergman victor blomqvist torbjrn martin student paper haskelldb improv proceed 2004 acm sigplan workshop haskel p108115 septemb 2222 2004 snowbird utah usa walid taha patricia johann stage notat definit proceed second intern confer gener program compon engin p97116 septemb 2225 2003 erfurt germani sava krsti john matthew semant reflect languag proceed 6th acm sigplan intern confer principl practic declar program p3242 august 2426 2004 verona itali gregori neverov paul roe toward fullyreflect metaprogram languag proceed twentyeighth australasian confer comput scienc p151158 januari 01 2005 newcastl australia sheard languag futur companion 19th annual acm sigplan confer objectori program system languag applic octob 2428 2004 vancouv bc canada martin sulzmann meng wang aspectori program type class proceed 6th workshop foundat aspectori languag p6574 march 1313 2007 vancouv british columbia canada ralf lmmel simon peyton jone scrap boilerpl class extens gener function acm sigplan notic v40 n9 septemb 2005 louisjulien guillemett stefan monnier typesaf code transform haskel electron note theoret comput scienc entc v174 n7 p2339 june 2007 bjrn bringert aarn ranta pattern almost composit function acm sigplan notic v41 n9 septemb 2006 marco viera alberto pardo multistag languag intension analysi proceed 5th intern confer gener program compon engin octob 2226 2006 portland oregon usa ralf lmmel scrap boilerpl xpathlik combin acm sigplan notic v42 n1 januari 2007 lloyd allison program paradigm machin learn case studi bayesian network proceed 29th australasian comput scienc confer p103111 januari 1619 2006 hobart australia tim sheard emir pasal twolevel type parameter modul journal function program v14 n5 p547587 septemb 2004 arthur baar doaits swierstra typesaf self inspect code proceed 2004 acm sigplan workshop haskel septemb 2222 2004 snowbird utah usa syme leverag net metaprogram compon f integr queri interoper heterogen execut proceed 2006 workshop ml septemb 1616 2006 portland oregon usa amr sabri model quantum comput haskel proceed acm sigplan workshop haskel p3949 august 2828 2003 uppsala sweden martin erwig zhe fu softwar reus scientif comput program gener acm transact softwar engin methodolog tosem v14 n2 p168198 april 2005 jerzi karczmarczuk structur interpret quantum mechan function framework proceed acm sigplan workshop haskel p5061 august 2828 2003 uppsala sweden jame cheney scrap namepl function pearl acm sigplan notic v40 n9 septemb 2005 ralf lmmel simon peyton jone scrap boilerpl practic design pattern gener program acm sigplan notic v38 n3 march stephani weirich replib librari deriv type class proceed 2006 acm sigplan workshop haskel septemb 1717 2006 portland oregon usa edwin bradi kevin hammond verifi stage interpret verifi compil proceed 5th intern confer gener program compon engin octob 2226 2006 portland oregon usa murdoch j gabbay new calculu context proceed 7th acm sigplan intern confer principl practic declar program p94105 juli 1113 2005 lisbon portug maribel fernndez fabien fleutot histor function objectori calculu proceed 8th acm sigplan symposium principl practic declar program juli 1012 2006 venic itali chiyan chen hongwei xi metaprogram type code represent journal function program v15 n6 p797835 novemb 2005 sheard languag futur acm sigplan notic v39 n12 decemb 2004 ralf hinz gener mass journal function program v16 n45 p451483 juli 2006 martin erwig dele ren updat calculu express typesaf program updat scienc comput program v67 n23 p199222 juli 2007 jim grundi tom melham john oleari reflect function languag hardwar design theorem prove journal function program v16 n2 p157196 march 2006 judith bayard cush nalini nadkarni michael finch ann fiala emerson murphyhil loi delcambr david maier componentbas endus databas design ecologist journal intellig inform system v29 n1 p724 august 2007 rita loogen yolanda ortegamalln ricardo peamar parallel function program eden journal function program v15 n3 p431475 may 2005 paul hudak john hugh simon peyton jone philip wadler histori haskel lazi class proceed third acm sigplan confer histori program languag p1211255 june 0910 2007 san diego california