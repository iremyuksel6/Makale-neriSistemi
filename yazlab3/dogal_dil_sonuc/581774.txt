complex analysi static analys paper argu mani algorithm static analysi algorithm particular bottomup logic program present clearer simpler analyz correct complex classic pseudocod present main technic contribut consist two theorem allow mani case asymptot run time bottomup logic program determin inspect well known datalog program run onk time k largest number free variabl singl rule theorem given significantli refin varieti algorithm present analyz exampl b introduct paper argu mani algorithm static analysi algorithm particular bottomup logic program present clearer simpler alyz correct complex classic pseudocod presenta tion static analysi algorithm natur represent bottomup logic program ie infer rule forwardchain procedur inter pretat technic content paper consist two metacomplex theorem allow mani case run time bottomup logic logic program determin inspect paper present analyz varieti static analysi algorithm natur present bottomup logic program exampl run time bottomup present determin metacomplex theorem given either best known within polylog factor best known use term infer rule mean first order horn claus ie first order formula form 1 c c first order atom ie predic appli first order term first order horn claus form ture complet model comput use practic gener purpos program languag atom 1 call anteced rule atom c call conclus use infer rule program languag one repres arbitrari data structur first order term exampl one repres term lambda calculu arbitrari formula first order logic first order term underli program languag restrict first order term way rule construct rule defin static analys higher order languag two basic way view set infer rule algorithm backward chain approach taken tradit prolog interpret 13 4 forward chain bottomup approach common deduct databas 23 22 18 metacomplex analysi deriv bottomup approach simpl exampl consid rule p x p state binari predic p transit let set assert form c constant symbol gener use term assert mean ground atom ie atom contain variabl use term databas mean set assert set r infer rule databas let rd denot set assert prove obviou way assert use rule r r consist rule transit consist assert form p c rd simpli transit closur bottomup view rule set r taken algorithm comput output rd input interest method quickli determin run time rule set r ie time requir comput rd exam ple consid follow algorithm comput transit closur predic edg defin bottomup rule edgex pathx z input graph contain e edg algorithm run oen time significantli better 3 spars graph note oen run time deriv simpli count number variabl singl rule section 4 give metacomplex theorem appli arbitrari rule set allow oen run time algorithm determin inspect simpl rule set oen run time may seem obviou exampl given throughout paper metacomplex theorem use case complet rigor treatment run time rule set would otherwis tediou metatheorem prove section 4 state rd comput time proport number prefix fire rule r number deriv ground instanc prefix rule anteced theorem hold arbitrari rule set matter complex anteced mani anteced rule provid everi variabl conclus rule appear anteced rule present first signific metacomplex theorem section 4 section 3 review known metacomplex theorem base count number variabl singl rule use syntact local rule set one everi term conclus rule appear anteced basic properti syntact local rule set also mention briefli section 3 fact syntact local rule set express polynomi time decid term languag section 4 give first signific metacomplex theorem basic exampl includ cki algorithm contextfre pars although paper focus static analysi algorithm varieti pars algorithm eisner satta recent algorithm bilex grammar 6 simpl complex analys base metacomplex theorem given section 4 section 5 give seri exampl program analysi algorithm express bottomup logic program first exampl basic data flow algorithm comput dynam transit closur transit closur oper new edg continu ad underli graph comput proce mani dynam transit closur algorithm shown 2npdacomplet 11 17 2npda class languag recogn twoway nondeterminist pushdown automaton problem 2npdacomplet class 2npda furthermor properti solv subcub time problem 2npda also solv subcub time 2npdacomplet problem known solvabl subcub time section 5 also present linear time subtransit data flow algorithm appli program typabl nonrecurs data type bound size combin control data flow analysi algorithm calculu exampl metacomplex theorem section 4 allow run time algorithm determin inspect rule set section 6 present second main result paper metacomplex theorem extend bottomup program languag incorpor unionfind algorithm three basic applic metacomplex theorem unionfind rule present section 7 unif algorithm congruenc closur algorithm type infer algorithm simpli type calculu section 8 present henglein quadrat time algorithm typabl version abadicardelli object calculu 12 exampl interest two reason first algorithm obviou first publish algorithm problem use 3 dynam transit closur algorithm 19 second henglein present quadrat algorithm use classic pseudocod fairli complex show algorithm present natur small set infer rule whose 2 run time easili deriv unionfind metacomplex theorem assumpt mention introduct use term assert mean ground atom ie atom contain variabl use term databas mean set assert also mention introduct rule set r databas let rd set ground assert deriv use rule r write r phi altern notat phi 2 rd use jdj number assert jjdjj number distinct ground term appear either argument predic assert subterm argument ground substitut map finit set variabl ground term paper consid ground substitut oe ground substitut defin variabl occur term oet defin standard way result replac variabl imag oe also assum express term atom repres intern dag data structur mean term alway repres pointer memori equal test unit time oper furthermor assum hash tabl oper take unit time substitut oe defin x comput pointer repres oefx unit time note intern express support index exampl given binari predic p index assert form p w data structur repres point list term w p w assert convers term w point list term p w assert concern rule written intent defin bottomup algorithm intuit bottomup logic program variabl conclus appear anteced unbound assign valu rule run although unbound variabl conclus well defin semant write rule use bottomup way alway possibl avoid variabl rule variabl conclus appear anteced call bottomup bound paper consid bottomup bound infer rule datalog rule one contain term variabl syntact local rule one everi term conclus appear anteced either argument predic subterm argument everi syntact local rule bottomup bound everi bottomup bound datalog rule syntact local howev rule bottomup bound syntact local note convers syntact local give main result paper appli arbitrari rule set give first naiv metacomplex theorem theorem appli syntact local rule set everi term conclus syntact local rule appear anteced follow syntact local rule never introduc new term impli r syntact local databas rd finit precis follow theorem 1 r syntact local rd comput ojdj largest number variabl occur singl rule prove theorem one simpli note suffic consid set ground horn claus consist assert unit claus plu instanc rule r term appear ojjdjj k instanc comput inferenti closur set ground claus done linear time 5 oen transit closur exampl introduct show theorem 1 provid crude upper bound run time infer rule present second metacomplex theorem howev briefli mention addit properti local rule set use remaind paper includ sake complet first properti syntact local rule set captur complex class p say rule set r accept term inputt r acceptt theorem impli languag accept syntact local rule set polynomi time decid follow less trivial theorem prove 8 state convers polynomi time properti firstord term encod syntact local rule set theorem 2 givan mcallest l polynomi time decid term languag exist syntact local rule set accept exactli term l second subject mention briefli call semant local rule set r call semant local whenev r phi exist deriv phi assert use rule r everi term deriv appear everi syntact local rule set semant local reason use prove theorem 1 r semant local rd comput ojdj largest number variabl singl rule mani case possibl mechan show given rule set semant local even though syntact local 15 2 howev semant local gener undecid properti rule set 8 4 second metacomplex theorem prove second metacomplex theorem say databas e close rule set r would seem determin closed would easier comput closur case yet close metacomplex theorem state essenc closur comput quickli comput time need mere check closed final result consid rule 1 c check databas e close rule one comput ground substitut oe e check oec also e find substitut first match pattern 1 assert databas get substitut oe 1 oe 1 given oe oe e match oe assert databas get extens oe i1 oe i1 e substitut oe determin prefix fire rule defin definit 1 defin prefix fire rule rule set r databas e ground instanc initi sequenc contain let pr e set prefix fire rule r databas e note rule p x might larg number fire first two anteced fire three anteced simpl algorithm outlin check e close r requir least jp r ej step comput outlin closur check algorithm would actual requir time step extend oe oe i1 involv iter entir databas follow theorem state comput rd time proport jdj plu rdj theorem 3 set r bottomup bound infer rule exist algorithm map rd run ojdj jp r rdj time prove theorem 3 consid simpl applic consid transit closur algorithm defin infer rule edgex pathx edgex pathi z pathx z r consist two rule consist e assert form edgec involv n constant immedi jp r rdj oen theorem 3 immedi impli algorithm run oen time parsesu consa j parsesb parsesc j fig 1 cockekasimiyoung cki pars algorithm parsesu mean substr j pars nontermin u second exampl consid algorithm context free pars shown figur 1 grammar given chomski normal form consist set assert form x x z input sting repres lisp list form consa input string specifi assert form input let g number product grammar let n length input string theorem 3 immedi impli algorithm run ogn 3 time note rule six variabl three string index variabl three nontermin variabl give proof theorem 3 proof base sourc sourc transform given program note follow sourc sourc transform infer rule preserv quantiti jdjjpr rdj function multipl constant second transform note must least one element p r rd assert rd henc ad rule singl anteced fresh predic conclus doubl valu jdj jp r rdj second transform done two step first add new rule replac anteced exist rule similar analysi hold third transform free variabl 1 2 least one nonvari x free variabl variabl among x among variabl occur x variabl among among x transform allow us assum without loss gener multipl anteced rule form p x multipl anteced rule creat index enumer valu x p x assert also enumer valu z qy z assert new assert form p x qy z deriv iter possibl valu miss variabl time proport number valu 5 basic exampl figur 2 give simpl firstord data flow analysi algorithm algorithm take input set assign statement form assignx e x program variabl e either constant express form constantn tupl express form hy zi z program variabl project express form pi 1 pi 2 program variabl consid databas contain e assign assert involv n program variabl pair express clearli first rule upper left corner e fire transit rule n 3 fire two rule en fire sinc e 2 theorem 3 impli algorithm given figur 2 run 3 time possibl show determin whether given valu reach given variabl defin rule figur 2 2npda complet 11 17 2npda class languag recogniz twoway nondeterminist pushdown automaton languag l call 2npdahard problem 2npda reduc l n polylog n time say problem solv subcub time solv k 3 2npda hard problem solv subcub time problem 2npda solv subcub time data flow problem 2npdacomplet sens class 2npda 2npdahard cubic time impract mani applic problem chang slightli requir assign statement well type use type bound size problem determin given valu reach given variabl solv linear time done sub transit data flow analysi 10 firstord set rule figur 2 use type defin follow grammar h note grammar allow recurs type linear time analysi extend handl list type recurs type give analysi weaker figur 2 simplic avoid recurs type consid databas contain assign statement describ subject constraint must possibl assign everi variabl type everi assign well type exampl databas contain assignx hy zi x must type h oei oe type z respect similarli databas contain must type form h oei type assumpt use infer rule given figur 3 note rule figur 3 syntact local infer rule lower right contain term conclus name pi j e 2 contain anteced rule introduc new term howev difficult see rule maintain invari everi deriv assert form e 1 e 2 e 1 e 2 fig 2 data flow analysi algorithm rule involv pi j abbrevi two rule one pi 1 one pi 2 fig 3 subtransit data flow analysi rule multipl conclus repres multipl rule one conclus z fig 4 determin exist path given sourc fig 5 flow analysi algorithm calculu pair rule intend appli initi databas contain singl assert form input e close calculu term ffrenam distinct bound variabl distinct name note rule rule syntact local everi term conclus appear anteced henc term deriv assert subterm input term rule comput direct graph subterm input type impli everi newli introduc term must well type exampl rule construct express pi 1 pi 2 x x must type form h hoe jii sinc type express finit finit mani well type term infer process must termin fact variabl type involv b syntax node infer process termin linear time see suffic observ rule maintain invari everi deriv assert involv form pij assert e 1 deriv directli assign use one rule left hand side figur type x b syntax node input assign form assignx e lead b deriv assert n assign input databas bn deriv assert involv easi check infer rule bn fire theorem 3 algorithm run obn time possibl show rule construct direct graph whose transit closur includ graph construct rule figur 2 determin given sourc valu flow given variabl need simpli determin path sourc variabl well known one determin linear time whether path exist given sourc node node direct graph howev also note comput done algorithm shown figur 4 fact algorithm figur 4 run linear time guarante theorem 3 anoth exampl figur 5 give algorithm control data flow calculu extend pair project oper rule implement form set base analysi 1 9 rule also use determin given term typabl recurs type function pair ing union type 16 use argument similar relat control flow analysi partial type 14 20 detail discuss precis relationship rule figur 5 set base analysi recurs type beyond scope paper primarili concern complex analysi algorithm rule transit rule prefix fire transit rule n 3 fire henc theorem 3 impli algorithm run 3 time possibl give subtransit flow algorithm analog rule figur 5 run linear time assumpt input express well type everi type express bound size 10 howev subtransit version figur 5 beyond scope paper 6 algorithm base unionfind varieti program analysi algorithm exploit equal perhap fundament use equal program analysi use unif type infer simpl type exampl includ nearli linear time flow analysi algorithm bondorf jorgensen 3 quadrat type infer algorithm abadicardelli object calculu given henglein 12 dramat improv empir perform due equal report fahndrich et al 7 formul gener approach incorpor unionfind method algorithm defin bottomup infer rule section give gener metacomplex theorem union find rule set let union find merg three distinguish binari predic sym bol predic union appear rule conclus rule teced predic find merg appear rule anteced rule conclus bottomup bound rule set satisfi convent call unionfind rule set intuit assert form unionu w conclus rule mean u w made equival assert form mergeu w mean point union oper appli u w time union oper u w equival assert findu f mean point find u valu f given databas defin merg graph undirect graph contain edg w either merg w mergew databas path w merg graph say w equival say databas unionfind consist everi term whose equival class contain least two member exist uniqu term f everi term w equival class databas contain findw f uniqu term call find note databas contain merg find assert unionfind consist defin result perform union oper term unionfind consist databas alreadi equival union oper effect equival union oper add assert merg plu assert form findw f w equival either f find larger equival class either equival class contain one member otherwis f term fact find valu second argument equival class singleton signific complex analysi unif congruenceclosur algorithm note either class contain one member w larger class assert findw f need ad appropri index union oper run time proport number new assert ad ie size smaller equival class also note whenev find valu term chang size equival class term least doubl impli given term number term f e contain find f log base 2 size equival class cours practic one eras obsolet find assert term one assert form find f howev find assert gener conclus eras erasur process improv bound given theorem 4 fact erasur make theorem difficult state order allow rel simpli metacomplex theorem eras obsolet find assert defin clean databas one contain merg find sertion given unionfind rule set r clean databas say databas e rclosur e deriv repeatedli appli rule r includ rule result union oper applic rule r chang e unlik case tradit infer rule unionfind rule set mani possibl closur set deriv assert depend order rule use exampl deriv three union oper unionu w union w unionu merg graph contain two arc graph depend order union oper done rule use deriv assert merg assert arbitrari relat depend order infer algorithm howev correct analysi run time analysi done independ order rule run present gener metacomplex theorem unionfind rule set theorem 4 unionfind rule set r exist algorithm map rclosur denot rd run time ojdj jp r rdj jf rdj f rd set find assert rd proof essenti ident proof theorem 3 sourc tosourc transform appli r show without loss gener need consid singl anteced rule plu rule form z variabl p q r predic union find merg rule union assert conclus argument rule union oper conclus handl use union oper unit cost prefix fire lead redund union oper cost nonredund oper proport number new find assert ad 7 basic unionfind exampl figur 6 give unif algorithm essenc unif problem pair hs ti unifi hu wi one must recurs unifi u w rule guarante hs ti equival hu wi u equival term pi 1 f f common find two pair similarli w must also equival rule comput appropri equival relat unif howev rule detect clash occurscheck failur done perform appropri lineartim comput final find map analyz run time rule figur 6 first note rule maintain invari find valu term appear input prob lem impli everi union oper either form union w unionpi w w appear input problem let n number distinct term appear input fig 6 unif algorithm algorithm oper simpl term defin either constant variabl pair simpl term input databas assum set assert form equat w w simpl term rule gener appropri equival relat unif gener clash occurscheck failur see text unionx select find valu argument singleton equival class rule maintain invari find valu term origin input fig 7 congruenc closur algorithm input databas assum consist set assert form equat w input w simpl term defin caption figur 6 figur 6 find valu term origin input fig 8 type infer simpl type input databas assum consist singl assert form input e close term pure calculu distinct bound variabl ffrenam distinct name case unif algorithm rule construct appropri equival relat type occurscheck result equival relat must done elsewher term involv equival relat defin merg graph given term number assert form find f log base 2 size equival class log n find assert closur impli log n prefix fire theorem 4 impli closur comput log n time best known unif algorithm run time 21 best onlin unif algorithm run onffn time ff invers ackermann function applic theorem 4 rule figur 6 yield slightli wors run time perhap simpler present consid congruenc closur algorithm given figur 7 first consid correct fundament properti congruenc closur equival 0 equival 0 pair hs ti appear input hs ti equival hs fundament properti guarante lower right hand rule figur 7 rule guarante hs ti hs occur input equival 0 0 hs ti hs equival hf common find 0 f 2 common find 0 algorithm comput congruenc closur equival relat analyz complex rule figur 7 first note case unif rule maintain invari everi find valu input term given one see term involv equival relat either input term pair input term impli 2 term involv equival relat n number distinct term input given term number assert form find f ologn number fire congruenc rule log 2 n impli number term involv equival relat actual log 2 n sinc term appear left hand side olog n find assert log 3 n find assert theorem 4 impli closur comput log 3 n time possibl show eras obsolet find assert algorithm made run log n time best known run time congruenc closur leav reader verifi infer rule figur 8 defin appropri equival relat type program express type construct linear time find relat output procedur clear infer rule gener union oper henc closur comput log n time 8 henglein quadrat algorithm consid henglein quadrat time algorithm determin typabl variant abadicardelli object calculu 12 algorithm interest first algorithm publish problem classic dynam transit closur algorithm requir 3 glein present quadrat algorithm given classic pseudocod fairli complex fig 9 henglein type infer algorithm simpl unionfind rule set henglein algorithm given figur 9 first defin type express grammar oe ff j ff repres type variabl intuit object type provid slot field slot name slot name slot valu type oe algorithm take input set assert type constraint form oe 1 oe 2 oe 1 oe 2 type express take type object slot note given null type base type infinit mani close type express ie type express contain variabl algorithm decid whether exist interpret fl map type variabl close type express constraint oe 1 oe 2 floe 1 subtyp floe 2 subtyp relat taken invari ie close type subtyp close type equal j rule figur 9 assum input preprocess type express appear input either top level subexpress top level type express databas also includ assert form accept note preprocess done linear time invari properti subtyp relat justifi final rule lower right figur 9 system constraint reject equival relat forc type subexpress ie occurscheck type express fail final databas contain oe accept analyz complex algorithm figur 9 note term involv equival relat type express appear process input express either type express origin unprocess input form oe oe origin input slot name appear top level oe let n number assert process input note preprocess guarante least one input assert type express number type express appear input also sinc term involv equival relat rule gener merg assert impli rule gener assert form oe impli number prefix fire 2 sinc term involv equival relat log n find assert closur theorem 4 impli run time 2 n log 9 conclus paper argu mani algorithm natur present bottomup logic program present clearer simpler analyz correct complex classic pseudocod pre sentat varieti exampl given analyz exampl suggest varieti direct work case unif henglein algorithm final check perform postprocess pass possibl extend logic program languag way allow algorithm fulli express rule stratifi negat failur would allow natur way infer notacceptso henglein algorithm preserv truth theorem 3 4 would allow accept check done rule simpl extens unionfind formal would allow detect equival distinct constant henc allow rule unif detect clash might also possibl extend languag improv run time cycl detect strongli connect compon analysi direct graph anoth direct work involv aggreg would nice languag featur metacomplex theorem allow natur effici render dijkstra shortest path algorithm insid algorithm comput probabl given string probabilist context free grammar r type condit type autom complex analysi base order resolut effici analysi realist offlin partial evalu ation logic program scheme implement time algorithm test satisfi proposit horn formula effici pars bilex contextfre grammar head automaton grammar partial onlin cycl elimin inclus constraint graph new result local infer relat base analysi ml program linear time subtransit control flow anal ysi cubic bottleneck subtyp flow analysi break n 3 barrier faster object type infer predic logic program languag effici infer partial type automat recognit tractabl infer relat infer recurs type intercovert set constraint context free languag reachabl effici infer object type type system equival flow analysi linear unif complex relat queri languag tr compil principl techniqu tool old resolut tabul magic set strang way implement logic program extend abstract alexand methoda techniqu process recurs axiom deduct databas bottomup beat topdown datalog finit present theorem approxim logic program type condit type setbas analysi ml program xsb effici deduct databas engin effici infer partial type type system equival flow analysi effici infer object type tabl evalu delay gener logic program modern compil implement java lineartim subtransit control flow analysi interconvertbl set constraint contextfre languag reachabl partial onlin cycl elimin inclus constraint graph break italicnitalicsubscrpt3subscrptbarri effici unif algorithm algorithm reason equal abstract interpret theori object cubic bottleneck subtyp flow analysi complex relat queri languag extend abstract ctr dan melam multitext grammar synchron parser proceed confer north american chapter associ comput linguist human languag technolog p7986 may 27june 01 2003 edmonton canada jen palsberg tian zhao trevor jim automat discoveri covari readonli field acm transact program languag system topla v27 n1 p126162 januari 2005 pablo lpez frank pfen jeff polakow kevin watkin monad concurr linear logic program proceed 7th acm sigplan intern confer principl practic declar program p3546 juli 1113 2005 lisbon portug markjan nederhof giorgio satta languag intersect problem nonrecurs contextfre grammar inform comput v192 n2 p172184 august 1 2004