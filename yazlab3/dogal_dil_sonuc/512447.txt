dynam memori manag programm devic paper present design implement novel dynam memorymanag scheme espa languag programm devic firmwar programm devic fast reliabl support high perform esp provid explicit memorymanag interfac implement effici ensur reliabl esp use model checker verifi memori safetyth vmmc firmwar use case studi evalu effect memorymanag scheme find spin model checker abl exhaust verifi memori safeti firmwar largest process took 676 second use 3445 mbyte memori verifi also find runtim overhead maintain refer count small addit overhead account 735 total messag process cost worst case mallocfre interfac b introduct tradit devic implement simpl function usual implement hardwar complex function implement devic driver run main processor howev devic get faster increasingli harder softwar run main cpu keep devic main cpu permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee ismm02 june 2021 2002 berlin germani go across memori io buse reach devic incur sever hundr cycl access situat better perform achiev implement function devic instead main cpu 2 22 9 21 18 20 25 1 24 programm devic use implement increasingli sophist function support devic devic equip programm processor memori figur 1 sinc processor resid card incur much smaller overhead access control regist devic write firmwar devic dicult two rea son first code run devic fast process power memori devic tend least order magnitud less main cpu main memori migrat code main cpu devic involv tradeo run code faster processor incur higher overhead access devic run slower processor faster access devic slower code run devic smaller benefit migrat code devic second devic firmwar reliabl trust oper system abil write locat physic memori stray memori write result bug corrupt critic data structur oper system crash entir machin firmwar programm devic usual written use eventdriven state machin c concurr eectiv way structur firmwar programm devic multipl thread control provid conveni way keep track progress sever event time eventdriven state machin support lowoverhead concurr howev program eventdriven state machin c suer number problem 17 consequ devic firmwar deliv good perform often dicult write debug esp 17 16 languag write firmwar programm devic use eventdriven state machin design meet three goal eas program eas debug high perform paper focus novel memorymanag scheme support esp earlier paper 17 includ brief descript scheme paper present detail descript design implement esp dynam memori manag scheme paper also provid detail measur vmmc firmwar evalu effect approach challeng firmwar fast well reliabl problem compound fact firmwar implement use concurr tradit memori manag scheme fall two categori automat explicit memori manag one hand automat memori manag use garbag collect techniqu 26 provid safeti usual involv high overhead term amount memori process time hand explicit memori manag involv lower overhead hard program correctli section 6 discuss relat work detail keep dynam memori manag overhead low esp provid explicit memori manag interfac use model checker spin 15 ensur memori safeti key observ alloc bug dicult find memori alloc correct global properti programth properti infer look singl modul program rectifi esp design make memori alloc correct local properti process promot modular program also allow model checker verifi safeti model check involv exponenti search make memori safeti local properti result smaller model amen model check esp runtim maintain refer count object manag dynam alloc ecient make memori alloc correct local properti process object sent channel pass valu esp se mantic mean copi object sent channel deliv receiv process ensur two process share object howev copi object sent channel runtim expens esp runtim avoid copi object maintain refer count object object actual share multipl process cover demonstr eectiv approach use vmmc firmwar case studi vmmc firmwar run myrinet 4 network interfac card program use esp found spin model checker abl exhaust verifi memori safeti esp process vmmc firmwar implement largest process took 676 second 3445 mbyte memori verifi also found refer count use esp runtim incur fairli small overhead measur indic addit bookkeep necessari maintain refer count result 735 increas worst case messag process cost mallocfre interfac support c rest paper organ follow section 2 present brief introduct model check section 3 present overview esp section 4 describ design implement esp dynam memori manag scheme section 5 use vmmc firmwar evalu eectiv scheme section 6 discuss relat work final section 7 present conclus 2 background esp use model checker debug extens test devic firmwar model check techniqu verifi system compos concurr finitest machin given concurr finitest system model checker ex cpucpu bu main memori main cpu network dma dma cpu mem card network dma cpu figur 1 machin programm devic plore possibl interleav execut state machin check properti verifi hold global state system snapshot entir system particular point execut state space system set global state reachabl initi global state sinc state space system finit model checker principl exhaust explor entir state space model check verifi check varieti prop erti properti tradit divid safeti live properti safeti properti properti satisfi specif global state system assert check deadlock safeti properti assert predic hold specifi point one state machin correspond set global state state machin specifi point predic hold deadlock situat correspond set global state valid next state live properti one refer sequenc state absenc livelock live properti correspond sequenc global state use work get done live properti usual specifi use tempor logic advantag use model check auto matic given specif system properti verifi model checker automat explor state space violat properti discov produc execut sequenc caus violat therebi help find bug disadvantag use model check comput expens state space explor exponenti number process amount memori use program result resourc requir cpu well memori resourc model checker explor entir state space quickli grow beyond capac modern machin 3 esp eventdriven statemachin program esp 17 16 languag programm devic design three goal eas program eas debug high perform section begin descript approach esp take meet goal present overview esp languag 31 approach esp meet three goal follow figur 2 eas program support eas program esp allow program express concis modular fashion use process channel addit provid number featur includ pattern match support dispatch channel flexibl extern interfac c novel memori manag scheme e cient safe eas debug support eas debug esp allow use model checker like spin 15 extens test program esp compil figur 2 gener execut also extract spin model esp program 16 minim eort requir use model checker debug program often esp program debug entir use model checker port run devic avoid slow painstak process involv debug program devic high perform support high perform esp languag design fairli static compil aggress optim program languag like c eventdriven state machin specifi use function pointer make dicult c compil optim program forc programm hand optim program get good perform contrast esp design support eventdriven state machin allow esp compil gener ecient code 32 languag overview esp languag adopt sever structur csp 14 cstyle syntax esp support eventdriven statemachin program concurr esp express use process chan nel esp program consist set process commun channel process repres sequenti flow control concurr program implicitli encod state machin process commun channel messag sent channel use oper receiv use oper commun channel synchron 1 unbuereda process attempt perform oper channel concurr anoth process attempt perform oper channel messag success transfer channel consequ block oper alt statement allow process wait oper sever dierent channel till one becom readi complet addit basic type like int bool esp support mutabl immut version complex data type like record union array howev esp support recurs data type two reason first specif languag model checker support recurs data type send recurs data type byvalu channel involv addit runtim overhead esp process channel static firstclass objectsthey neither creat dynam also known rendezv channel store variabl sent channel design allow compil perform optim effect esp support pure messag pass commun channel allow process commun share memori use share mutabl data structur would requir esp provid addit mechan like lock avoid race condit avoid esp allow process share data structur two aspect esp prevent share data structur first esp disallow global variabl variabl local singl process second object sent channel pass valu support ecient esp allow immut object sent channel appli object specifi oper also object recurs point object 4 dynamicmemorymanagementin 41 design design memori manag scheme esp driven two goal first program safe bug stem lack safeti dicult find problem compound fact program concurr run devic minim debug support second memori manag overhead small esp provid novel memori manag scheme provid safeti well low overhead manag dynam alloc memori provid explicit mallocfre style interfac incur low overhead ensur safeti use model checker unsaf aspect esp explicit memori manag scheme memori alloc bug elimin use model checker result safe esp program incur low memorymanag overhead runtim key observ alloc bug dicult find memori alloc correct global properti programth properti infer look singl modul program programm examin entir program make sure alloc object eventu freed access freed rectifi esp make memori alloc correct local properti process section 32 describ design choic ensur two process share data structur note support pure messag passingstyl commun would sucient ensur two process share mutabl data structur howev make memori alloc correct local properti esp disallow share even immut data structur make memori alloc correct local properti allow model checker verifi memori safeti process separ abil check process separ ensur size model check remain small largest model check depend size largest process size entir program number process con sequent abl exhaust check memori safeti esp process vmmc firmwar sec pgmesp esp compil pgmc helpc gener firmwar use c compil pgmnspin verifi properti 1 verifi properti n use spin use spin figur 2 esp approach esp compil gener model pgm1nspin use spin model checker debug esp program pgmesp compil gener three type model detail retain detail program memorysafeti check memori safeti abstract gener compact model drop irrelev detail compil also gener c file pgmc compil execut shade region repres code provid programm test code test1nspin use check dierent properti esp program includ code gener extern event network messag arriv well specifi properti verifi programmersuppli c code helpc implement simpl lowlevel function like access special devic regist deal volatil memori marshal packet sent network tion 52 addit make memori alloc correct local properti promot modular program object sent channel pass valu mean deep copi object deliv receiv process 2 object receiv channel treat like newli alloc object later freed process one possibl complic occur object contain multipl link anoth object pointer share preserv receiv process would need know share check data structur correctli freed howev determin share pointer comparison allow esp exampl figur 3 illustr problem copi semant preserv pointer share avoid deep copi perform data structur sent channel preserv pointer share allow receiv process simpli perform recurs arriv channel esp provid mallocfreestyl interfac manag dynam alloc memori sinc object share process process respons free object two primit free rfree 3 allow process free alloc object addit esp provid two primitivespfre prfree free object evalu current express allow compil perform optim section 43 follow code fragment chan1 prfreev equival chan1 v esp support immut well mutabl data struc ture immut object arriv channel 2 true semant esp runtim never actual copi object sent channel section 43 3 perform free recurs mutat first appli cast oper obtain mutabl version object semant cast oper caus new object alloc correspond valu copi new object howev compil avoid creat new object number case instanc compil determin object cast freed immedi cast reus object avoid alloc esp allow dangl pointer pointer object alreadi freed program execut dangl pointer allow program would delet pointer given object object could freed would requir addit bookkeep would place unnecessari burden programm although esp allow dangl pointer disallow use pointer access memori ensur memori safeti contrast usual approach ensur memori safeti reclaim object pointer point avoid dangl pointer approach awar provid safeti allow dangl pointer regionbas memori manag 19 use type system guarante dangl pointer use run time memori alloc esp nonblock oper concurr program make memori alloc block advantag allow memori alloc request one process find memori avail block till anoth process free memori although would lead better memori util introduc addit synchron process forc programm treat alloc potenti block make sure caus program deadlock 42 extract memorysafeti model current esp use spin model checker 15 spin flexibl power model checker design softwar system spin support highlevel featur like process rendezv channel array record ver record v int channel sharec array entryt process process1 sharec assert lengtha 2 process process2 11 sharec p1 p2 process process3 5 sharec p p figur 3 exampl illustr problem copi semant preserv pointer share process process1 expect array two element channel sharec receiv process free one entri proce use entri process process2 send array channel process1 would execut correctli two entri point dierent object howev process process3 send array channel process1 tri access record freed result error ifier target hardwar system provid fairli dier ent specif languag although esp translat languag addit state would introduc implement featur like rendezv channel use primit provid specif languag would make state explos problem wors addit semant inform lost translat would make harder verifi optim statespac search allow verif safeti well live prop erti live properti spin specifi use linear tempor logic ltl esp compil gener three type model de tail memorysafeti abstract 16 detail model contain detail origin esp program model use develop debug firmwar use simul mode spin memorysafeti model use check memori alloc bug program model essenti detail model addit spin code insert check valid memori access abstract model omit detail irrelev particular properti verifi model significantli smaller state detail model use check larger system paper discuss detail memorysafeti model memorysafeti model gener esp compil use check memori alloc bug program model essenti detail model addit spin code insert check valid memori access therefor contain even state detail model spite model usual use exhaust explor state space alloc bug memori safeti individu process check separ use verifi section 41 variabl esp store pointer data object stanc follow code variabl b1 b2 point array therefor updat b11 visibl variabl b2 b1 array int 5 11 alloc sinc spin support pointer object gener model assign objectid alloc time objectid store addit field object object get copi due assign oper objectid field also get copi ensur object translat spin code share objectid repres singl object origin esp code mutabl object get updat esp code translat spin code includ code check updat object objectid memorysafeti model includ addit code asser tion check valid object access new object alloc unus objectid assign object everi object access code insert model check object live array access includ addit code check array index within bound union refer includ code check field access valid object object model objectid mark invalid chang objectid field 1 memorysafeti model check bug like access object freed doubl free object use invalid array index addit also find memori leak process gener model bound number object compil determin bound array sourc unbound alloc esp process sinc esp support recurs data type howev esp compil impos bound maximum length array model extract 17 therebi bound number object model constrain model pick objectid within bound steadi memori leak detect steadi leak caus model run objectid model check current objectid sourc unnecessari increas state space explor model gener esp compil problem stem fact given object program get assign dierent objectid depend schedul decis made prior alloc result singl state manifest sever dierent state state space problem allevi use separ objectid tabl distinct type process two pointer point object type belong process reduc number dierent objectid given object get assign 43 code gener programm perspect process set object manag separ process section 41 process alloc object explicitli free use free object sent channel deep copi hand receiv process therefor object arriv channel treat like newli alloc object later freed process implement use referencecount scheme manag object although semant process share object implement share object process eciencycopi object comput expens runtim system maintain refer count keep track number process share object recurs increment decrement oper cyclic data structur requir addit bookkeep avoid infinit loop howev esp support recurs data type consequ oper implement ecient normal alloc caus object alloc refer count initi one object sent channel refer count object recurs increment therebi avoid expens deep copi give receiv process process free object refer count decrement one object actual dealloc process freed refer count zero follow simpl optim fairli eectiv reduc number refer count increment decr ment follow code fragment chan1 prfreev refer count recurs increment send object v channel send object refer count recurs decrement prfree case refer count increment decrement optim away compil deep copi perform data structur sent channel preserv pointer share section 41 two benefit first allow copi semant implement ecient simpl recurs increment refer count suce object point multipl time within data structur refer count increment multipl time second allow correct memori alloc local properti process section 41 receiv process worri pointer share object arriv channel cast immut object mutabl object requir copi object program detect object share mutat one locat observ chang anoth locat howev cast oper fairli uncommon esp program addit copi alway necessari copi often avoid cast necessari program written care allow compil optim instanc refer count immut object one process hold object object freed immedi cast compil avoid copi use object record v int channel countc array entryt process processa 3 p1 p2 countc process processb figur 4 exampl show tradit refer count scheme sucient esp sever design choic esp languag allow implement share object provid illus disjoint set object first immut object sent channel therefor program detect object share mutat one process observ chang anoth process sec ond object compar pointer equal prevent program compar pointer two dierent object detect implement use object repres final esp support recurs data type therefor program cyclic data structur mean recurs refer count increment deal infinit loop due cyclic data structur therefor implement ecient tradit refer count scheme maintain count object dierent way done esp tradit scheme refer count increment root decrement recurs refer count object becom zero earlier paper 17 suggest would sucient esp turn sucient consid exampl figur 4 point object sent channel countc scheme would kept refer count object three object point variabl p1 p2 would refer count one howev perform send oper channel countc tradit scheme increment refer count array object esp scheme increment refer count three object schedul choos schedul process processb first free statement execut tradit scheme caus refer count object point p1 go zero therebi free object gener error process processa schedul run tri access variabl p1 esp scheme refer count object point p1 decrement two one object freed allow process processa later access 44 limit one main limit approach problem deal recurs data type problem recurs data type introduc cyclic data structur presenc cyclic data structur deep copi semant esp make sens one possibl approach allow noncycl data structur channel might requir addit check run time howev check would necessari channel allow recurs data type 5 experiment result section present measur demonstr eectiv esp memori manag scheme measur perform vmmc firmwar run myrinet 4 network interfac card measur design investig follow issu programm eort requir verifi memori safeti eectiv use model checker verifi memori safeti extra perform overhead incur runtim maintain refer count alloc pattern exhibit firmwar particular measur object lifetim answer question section present brief overview vmmc firmwar 51 vmmc firmwar virtual memorymap commun vmmc architectur 9 deliv high perform gigabit network use sophist network card allow data directli sent applic memori therebi avoid memori copi without involv oper system therebi avoid system call overhead oper system usual involv connect setup disconnect vmmc implement 9 use myrinet 4 network interfac card myrinet packetswitch gigabit network myrinet network card connect network two unidirect link 160 mbytess peak bandwidth actual nodetonetwork bandwidth usual constrain pci bu 133 mbytess network card sit network card programm memori three dma engin transfer data one transfer data host memori one send data onto network one receiv data network card number control regist includ statu regist check data arriv watchdog timer dma statu vmmc softwar figur 5 three compon librari link applic devic driver use mainli connect setup disconnect firmwar run network card softwar complex concentr firmwar code implement use eventdriven statemachin c signific eort 10 9 3 6 spent impl ment perform tune debug vmmc card interfac processor main network applic network firmwar devic driver librari figur 5 vmmc softwar architectur shade region vmmc compon process esp gener test program model code reliablesend reliablerecv 152 664 41 localreq 172 742 67 remotereq 167 882 85 remoterepli 177 715 104 tabl 1 size line variou file use check memori safeti variou process vmmc firmwar three remain process list tabl involv alloc second column show size portion program relev particular model third column show size model gener esp compil last column show number line spin test code requir firmwar spite continu encount bug firmwar vmmc firmwar reimplement use esp esp version vmmc firmwar requir significantli fewer line code c version esp version 500 line esp code togeth around 3000 line c code complex state machin interact restrict esp code use 8 process 19 channel c code perform simpl oper like packet marshal handl devic regist signific improv c version complex interact scatter throughout 15600 line code 52 verifi memori safeti vmmcfirmwar esp compil extract memorysafeti model use verifi safeti process separ section 42 use model verifi safeti involv two step first programm provid test code test1nspin figur 2 check process model checker use perform statespac explor verifi safeti former involv programm eort latter perform automat constrain avail comput resourc programm eort requir test code check memori safeti provid programm simul extern event network messag arriv unlik model test includ addit code check safetyth code check memori safeti includ gener model form assert tabl 1 present size test code written verifi memori safeti firmwar 4 case size test code fairli small tabl also show size relev portion esp code size model gener esp compil test code written use repeatedli recheck system softwar evolv sinc model extract automat recheck softwar requir littl programm eort eectiv model check everi process vmmc firmwar entir state space could explor exhaust use spin tabl 2 present amount state explor verifi memori safeti process biggest process reliablesend requir 676 second processor time 3445 mbyte memori show eectiv model checker verifi safeti contrast experi check vmmc firmwar global properti like deadlock 16 esp compil use abstract techniqu gener smaller model would requir less resourc explor state space approach allow model checker identifi sever hardtofind bug firmwar caus firmwar deadlock howev state space still big result spin could perform partial search due resourc constraint illustr import make memori safeti local properti process memorysafeti model gener esp compil catch bug due invalid memori access also memori leak section 42 memori safeti bug vmmc firmwar alreadi elimin time esp compil modifi support memorysafeti model spin use check earlier version firmwar alloc bug verifi easili identifi bug check eectiv use memorysafeti model varieti memori alloc bug insert manual program bug either access object freed use invalid array index introduc memori leak spin abl quickli find bug everi case esp model checker use throughout program develop process tradit model check use find hardtofind bug work system sinc develop firmwar network interfac card involv slow painstak process use spin simul implement debug debug firmwar port network interfac card littl eort 53 perform refer count overhead measur perform overhead incur esp runtim manag dynam memori vmmc firmwar put 4 process list tabl involv dynam alloc head perspect estim addit overhead esp scheme would incur mallocfre interfac support c vmmc provid two type oper transfer data two machin remotewrit oper transfer data local machin remot machin remoteread oper fetch data remot machin local machin remoteread oper behav like two remotewrit oper requir two messag sent networka request messag sent local machin repli messag request data sent remot machin therefor section report measur remotewrit oper measur memori manag overhead firmwar pose problem granular clock avail myrinet network card fairli larg 05 fore simpli instrument firmwar measur fraction time spent memori manag rou tine consequ estim memori manag overhead three step first measur overhead memori manag oper second column tabl 3 refer count decrement oper perform object freed depend whether refer count zero therefor overhead case mea sure overhead memori manag oper littl varianc esp use simpl scheme manag free memori keep set list free blocksal block particular list size consequ alloc free object involv remov ad head list second measur number time oper execut remotewrit oper tabl 3 use number two step estim memori manag overhead involv remotewrit oper final instrument vmmc firmwar measur total time spent process remotewrit request third column tabl 4 comput fraction total process time spent manag dynam memori tabl 4 esp perform common optim perform referencecount system refer count newli alloc object set zero instead one free object identifi presenc free list avoid need increment counter alloc decrement free consequ actual cost maintain refer count tabl 4 obtain ad execut time row two three tabl 3 tabl 4 show overhead maintain refer fairli small fraction total memorymanag cost 277 worst case refer count increment decrement necessari firmwar one refer count increment necessari send side three receiv side tabl 3 remain memori manag overhead cost alloc free memori cost would incur even simpl mallocfre interfac provid c one advantag explicit memori manag scheme programm control object freed allow programm get better perform process name state time second memori use mbyte store match stack hash tabl state store total reliablesend 11118 316725 676 240 10 945 3445 localreq remotereq 2315 3510 09 240 10 187 2687 remoterepli 8565 7312 23 240 10 555 3055 tabl 2 check memori safeti vmmc firmwar use spin case entir state space explor exhaust mode spin store column show number uniqu state encount match column show number state encount alreadi visit memori usag broken space use stack hash tabl visit state space use stack hash tabl static alloc spin oper oper sender receiv execut time oper count execut time oper count execut time alloc 059 3 177 3 177 increment ref count 015 1 015 3 045 decrement object freed 026 1 026 3 078 count object freed 048 3 144 3 144 total 362 444 tabl 3 estim memori manag overhead vmmc firmwar tabl comput amount time spent memori manag primit firmwar machin send messag anoth machin show time spent send well receiv machin valu comput use measur column machin total memori manag overhead refer count overhead execut time execut time total execut time total sender small 1950 362 1856 041 210 rest 2847 362 1272 041 150 receiv 1674 444 2652 123 735 tabl 4 comparison memori manag overhead total time spent vmmc firmwar process messag sent network sender receiv machin sinc messag 32 byte treat dierent larger messag sender overhead shown separ two categori small byte messag rest total execut time measur instrument firmwar memori manag overhead obtain tabl 3 refer count overhead overhead maintain refer count object obtain ad execut time row two three tabl 3 applic problem size lucontigu 2048 x 2048 matrix waterspati 15625 molecul barnesspati 8192 particl waternsquar 1000 molecul volrend head tabl 5 splash2 applic move alloc overhead critic path object lifetim measur lifetim alloc object vmmc firmwar use splash2 applic tabl 5 applic run top share virtual memori svm 3 librari turn run top vmmc librari applic measur made use cluster four smp pc pc four 200 mhz pentium processor 1 gb memori myrinet network interfac card lanai 4x 33 mhz processor 1 mb onboard sram memori node connect myrinet crossbar switch pc run tabl 6 show lifetim object alloc firmwar lifetim measur number alloc execut time alloc counter increment seen tabl object freed quicklyov 99 object freed within 128 alloc small number tabl alloc firmwar start object never freed 6 relat work explicit memori manag tradit dynam memori programm devic manag use interfac allow program alloc free memori maintain buer pool requir programm explicitli maintain refer count object interfac provid memori safeti often result memori alloc bug notori dicult find lead memori corrupt manifest faulti behavior locat program dierent site bug number tool 5 use static runtim techniqu find memori alloc bug unsaf languag like c instanc purifi 13 tool insert code execut check number bug like invalid indic array access memori leak allow detect error happen run time howev programm respons run execut differ input exercis everi possibl program path lclint 11 combin static analysi program annot identifi broad class alloc bug differ approach 23 find limit class bug buer overrun formul buer overrun problem integ constraint problem static check constraint satisfact limit static approach flag falseposit well falseneg bug automat memori manag automat memori manag safe program languag implement use garbag collector respons reclaim unus memori 26 garbag collect often involv runtim overhead term processor overhead well addit memori requir make dicult use programm devic copi garbag collector usual use half avail memori problem programm devic rel small amount memori markandsweep collector wast memori incur overhead proport size heap although techniqu 7 use reduc cost sweep phase even cost mark phase signific firmwar maintain larg tabl scan mark phase problem programm devic collector would trigger frequent limit memori avail memori manag use region vault 8 cyclon 12 use region 19 provid safe memori man agement regionbas memori manag techniqu exit dynam context like procedur make unsuit languag like esp dynam context 7 conclus paper present design implement novel memorymanag scheme esp esp provid explicit interfac manag dynam memori interfac implement ecient use referencecount techniqu esp design make memoryalloc correct local properti process allow model checker use ensur safeti pro gram approach result safe program incur low runtim overhead manag memori eectiv esp scheme evalu use vmmc firmwar case studi found spin model checker abl exhaust verifi memori safeti esp process firmwar verifi memori safeti took 01 676 second requir less 35 mbyte memori also found runtim overhead maintain refer count small addit overhead maintain refer count compar simpl mallocfre interfac vari 15 735 total messag process cost acknowledg work support part nation scienc foundat cda9624099eia9975011ani9906704eia 9975011 depart energi defc0299er25387 california institut technolog pc159775 pc228905 sandia nation lab ao5098a06 lawrenc livermor laboratori b347877 intel research council intel technolog 2000 equip grant 8 r use network interfac support avoid asynchron protocol process share virtual memori system gigabitpersecond local area network port userlevel commun architectur nt experi perform reduc sweep time nearli empti heap enforc highlevel protocol lowlevel softwar design implement virtual memorymap commun myrinet static detect dynam memori error fast detect memori leak access error commun sequenti process spin model checker esp languag programm devic esp languag programm devic high perform messag workstat illinoi fast messag fm myrinet implement type callbyvalu lambdacalculu use stack region activ messag mechan integr commun comput evolut virtual interfac architectur first step toward autom detect bu virtual log base file system programm disk uniprocessor garbag collect techniqu splash2 program character methodolog consider tr activ messag implement type callbyvalu myampersand955calculu use stack region splash2 program unet high perform messag workstat static detect dynam memori error model checker spin activ disk virtual log base file system programm disk use network interfac support avoid asynchron protocol process share virtual memori system reduc sweep time nearli empti heap commun sequenti process enforc highlevel protocol lowlevel softwar regionbas memori manag cyclon highspe data path hostbas router userlevel network interfac protocol evolut virtual interfac architectur myrinet design implement virtual memorymap commun myrinet uniprocessor garbag collect techniqu ctr sanjeev kumar kai li use model check debug devic firmwar proceed 5th symposium oper system design implement due copyright restrict abl make pdf confer avail download decemb 0911 2002 boston massachusett sanjeev kumar kai li use model check debug devic firmwar acm sigop oper system review v36 nsi winter 2002