concurr thread optim parallel minimum span tree algorithm paper resolv longstand open problem whether concurr write capabl parallel random access machin pram essenti solv fundament graph problem like connect compon minimum span tree ologn time specif present new algorithm solv problem ologn time use linear number processor exclusiveread exclusivewrit pram logarithm time bound actual optim sinc well known even comput nbit requir ohgrlog n time exclusivewrit pram effici achiev new algorithm base new schedul exploit high degre parallel b introduct given weight undirect graph g n vertic edg minimum span tree mst problem nd span tree span forest g smallest possibl sum edg weight problem rich histori preliminari version paper appear proceed tenth annual acmsiam symposium discret algorithm baltimor maryland acm new york siam philadel phia pp 225234 work support part hong kong rgc grant hku28995 address ka wong chong takwah lam depart comput scienc inform system univers hong kong hong kong email fkwchongtwlamgcsishkuhk yiji han comput scienc telecommun program univers missouri kansa citi 5100 rockhil road kansa mo 64110 usa email hancstpumkcedu permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut prot direct commerci advantag copi show notic rst page initi screen display along full citat copyright compon work own other acm must honor abstract credit permit copi otherwis republish post server redistribut list use compon work work requir prior specic permiss andor fee permiss may request public dept acm inc 1515 broadway new york ny 10036 usa fax 1 212 8690481 permissionsacmorg han tw lam sequenti mst algorithm run om log n time known decad ago see tarjan 1983 survey subsequ number ecient mst algorithm publish particular fredman tarjan 1987 gave algorithm run ommn time n minfi j log n mng time complex improv om log n gabow galil spencer tarjan 1986 chazel 1997 present even faster mst algorithm time complex ommn log n n invers ackerman function recent chazel 1999 improv algorithm run ommn time later petti 1999 independ devis similar algorithm time complex recent petti ramachandran 2000 obtain algorithm run optim time simpl random algorithm run linear expect time also found karger et al 1995 parallel context mst problem close relat connect compon cc problem nd connect compon undirect graph cc problem actual admit faster algorithm sequenti con text yet two problem solv similar techniqu variou model parallel random access machin see survey jaja 1992 karp ramachandran 1990 respect model concurr write capabl ie processor write share memori locat simultan problem solv olog n time use nm processor awerbuch shiloach 1987 cole vishkin 1986 use random gazit algorithm 1986 solv cc problem olog n expect time use n processor work algorithm dene timeprocessor product thu optim later cole et al 1996 obtain result mst problem exclus write model includ concurrentread exclusivewrit exclusiveread exclusivewrit pram olog 2 n time algorithm cc mst problem develop two decad ago chin et al 1982 hirschberg et al 1979 believ exclus write model could overcom olog 2 n time bound rst breakthrough due johnson metaxa 1991 1992 devis olog 15 n time algorithm cc problem mst problem result improv chong lam 1993 chong 1996 olog n loglog n time random allow time work improv particular karger et al 1995 show cc problem solv olog n expect time later halperin zwick 1996 improv work linear mst problem karger 1995 obtain random algorithm use olog n expect time superlinear work poon ramachandran 1997 gave random algorithm use linear expect work olog n log log n 2 log n expect time anoth approach stem fact determinist space bound stconnect problem immedi impli ident time bound erew algorithm cc problem nisan et al 1992 shown stconnect problem solv determinist use olog 15 n space armoni et al 1997 improv bound olog 43 n result impli erew algorithm solv cc problem olog 15 n time olog 43 n time respect optim parallel mst algorithm 3 prior work open whether cc mst problem could solv determinist olog n time exclus write model notic log n optim sinc graph problem least hard comput n bit cook et al 1986 proven latter requir qui n time crew erew pram matter mani processor use exist mst algorithm cc algorithm dicult improv lock among processor processor work dierent part graph dierent densiti progress processor uniform yet processor coordin close order take advantag result comput result mani processor often wait rather use comput paper present new parallel paradigm solv mst problem requir minim coordin among processor fulli util parallel base new insight structur minimum span tree show paradigm implement erew solv mst problem olog n time use n processor algorithm determinist natur requir special oper edg weight comparison find connect compon minimum span tree often key step parallel algorithm graph problem see eg miller ramachandran 1986 maon et al 1986 tarjan vishkin 1985 vishkin 1985 new mst algorithm parallel algorithm immedi improv run optim ie olog n time without use concurr write eg biconnect tarjan vishkin 1985 ear decomposit miller ramachandran 1986 theoret point view result illustr concurr write capabl essenti solv number fundament graph problem ef cientli notic erew algorithm actual practic sens adapt realist parallel model like queu share memori qsm gibbon et al 1997 bulk synchron parallel bsp model valaint 1990 latter distribut memori model parallel comput gibbon et al 1997 show erew pram algorithm simul qsm model slow factor g g bandwidth paramet qsm model simul howev known crcw pram thu result impli mst problem solv ecient qsm model og log n time use linear number processor furthermor gibbon et al 1997 deriv random workpreserv simul qsm algorithm logarithm slow bsp model rest paper organ follow section 2 review sever basic concept introduc notion call concurr thread nding minimum span tree parallel section 3 describ schedul use thread illustr limit form pipelin avor similar pipelin mergesort algorithm cole 1988 section 4 lay detail requir thread section 5 show detail algorithm simplifi discuss rst focu crew pram show solv mst problem olog n time use n log n processor section 6 adapt algorithm run erew pram reduc processor bound linear 4 kw chong han tw lam remark recent petti ramachandran 1999 made use result paper improv exist random mst algorithm precis algorithm rst one run high probabl olog n time linear work erew pram 2 basic parallel mst algorithm past present section review classic approach nding mst base approach easili contrast new mst algorithm exist one assum input graph g given form adjac list consid edg g note e appear adjac list u v call copi e mate need distinguish use notat hu vi hv ui signifi edg origin respect weight e real number denot wu v without loss gener assum edg weight distinct thu g uniqu minimum span tree denot g throughout paper also assum g connect otherwis algorithm nd minimum span forest g let b subset edg g contain cycl b induc set tree natur sensetwo vertic g tree connect edg b b contain edg incid vertex v v form tree denit consid edg g tree 2 f u v belong e call intern edg one u v belong e call extern edg note edg also intern edg convers may true denit b said forest tree 2 f least vertic exampl b empti set b 1forest g span tree g nforest consid set b edg chosen g assum b forest augment b give 2forest use greedi arbitrari subset f f 0 includ tree 2 f fewer vertic may contain tree 2 vertic everi tree f 0 pick minimum extern edg denot b 0 set edg lemma 1 jaja 1992 lemma 54 b 0 consist edg g lemma 2 2forest proof everi tree f f 0 alreadi contain least 2 vertic consid tree f 0 let hu vi minimum extern edg v belong anoth tree 0 2 f respect vertic 0 connect togeth among tree induc one includ 0 contain least 2 vertic therefor 2forest g base lemma 1 2 nd g blog nc stage follow notat let bp q denot q empti set otherwis optim parallel mst algorithm 5 procedur 1 blog nc stage let f set tree induc b1 1 g let f 0 arbitrari subset f f 0 includ tree 2 f fewer 2 vertic e minimum extern edg 2 f 0 g 2 return b1 blog nc stage dierent strategi choos set f 0 step 1a may lead dierent b nevertheless b1 alway subset g induc 2 forest particular b1 blog nc induc 2 blog nc forest tree denit contain least 2 blog nc n2 vertic word b1 blog nc induc exactli one tree equal g use standard parallel algorithm techniqu stage implement olog n time erew pram use linear number processor see eg jaja 1992 therefor g found olog 2 n time fact parallel algorithm nding mst includ crcw pram algorithm base similar approach see eg awerbuch shiloach 1987 chin et al 1982 citencv86 johnson metaxa 1991 1992 chong lam 1993 chong 1996 karger et al 1995 parallel algorithm sequenti sens comput b start b 1 avail see figur 1a innov idea exploit mst algorithm use concurr thread comput b thread group processor work dierent task comput thread independ algorithm blog nc concurr thread nding particular b thread character fact thread comput b start long thread comput b 1 complet actual output b o1 time figur 1b result g found olog n time algorithm take advantag interest properti set properti actual hold respect determinist algorithm nding mst though mention explicitli literatur lemma 3 let one tree induc b1 k 0 k blog nc e minimum extern edg subtre ie connect sub minimum extern edg either e edg proof see appendix 3 overview schedul algorithm consist blog nc thread run concurr 1 blog nc thread aim nd set b one possibl set comput stage procedur iterativemst precis let f set tree induc arbitrari subset f includ tree fewer contain minimum extern edg tree f 0 thread 6 kw chong han tw lam phase 2 phase 1 phase 1 phase 1 phase 2 phase 1 phase 2 phase 1 b thread phase blog ic phase blogi 1c fig 1 iter approach b concurrentthread approach receiv output thread 1 1 ie increment never look comput o1 time 31 exampl show detail schedul thread give two exampl illustr thread speed comput b exampl 1 2 thread comput b time ci 1 respect thread c xed constant simplifi discuss exampl assum adjac list set vertic merg singl list time end section explain infeas implement highlight novel observ techniqu evad problem thread start set q 0 adjac list list contain smallest edg incid vertex g edg kept q 0 alreadi sucient comput b reason follow consid tree induc assum minimum extern edg e incid vertex v contain fewer 2 vertic 2 2 edg incid v intern edg thu 2 1 smallest edg incid v must includ e exampl 1 straightforward implement lemma 2 thread start avail let f set tree induc b1 1 suppos merg adjac list vertic tree form singl combin adjac list notic hat tree f fewer vertic combin adjac list contain 2 edg optim parallel mst algorithm 7 combin list 2 edg determin minimum extern edg time ci c suitabl constant collect minimum extern edg report b observ combin adjac list edg repres tree contain least 2 vertic denit b necessari report minimum extern edg tree exampl 2 exampl slightli complex illustr thread work increment manner thread start soon b i2 comput point avail thread readi comput b nevertheless perform preprocess call phase b becom avail comput b speed run time 1 2 ci phase ii phase let f 0 set tree induc b1 i2 suppos merg adjac list q 0 everi tree f 0 form anoth set q 0 adjac list denit b1 i2 tree f 0 contain least 2 i2 vertic tree f 0 fewer 2 vertic combin adjac list contain 2 1 2 edg extract list 2 i2 1 smallest edg connect distinct tree f 0 edg sucient nding b argument extens argument exampl 1 comput take time ci phase ii b avail comput b base q 0 follow edg bi2 connect tree f 0 form set f bigger tree suppos merg list q 0 everi tree f notic tree f contain fewer 2 vertic compos 2 i2 1 tree f 0 combin adjac list contain 2 i2 1 2 edg case nd minimum extern edg 1 time b set minimum extern edg found conclus comput b found time 1 remark set b found exampl 1 2 may dierent yet either case subset g 2 forest 32 schedul mst algorithm base gener idea comput thread divid blog ic phase thread 1 comput enter last phase take o1 report b see figur 1b global speak mst algorithm run blog nc superstep last o1 time particular thread deliv b end ith superstep let us rst consid power two phase 1 thread start avail comput take i4 superstep end i2 start i2 avail use i8 superstep subsequ phase use half mani superstep preced phase last phase phase log start end within ith superstep see figur 2 gener thread run blog ic phase mark start time 8 kw chong han tw lam1 2 1 ii iphas log phase 1 phase 2 thread fig 2 schedul thread power 2 phase dene sequenc phase j thread 1 j blog ic start 1th superstep use j1 superstep phase j handl edg set b j 1 made avail thread execut phase j 1 33 merg exampl assum everi tree f merg adjac list vertic subtre phase ii exampl 2 singl list ecient time depend total length done via techniqu introduc tarjan vishkin 1985 let us look exampl suppos tree contain edg e two vertic u v assum adjac list u v contain e mate respect two list combin e mate exchang successor see figur 3 everi edg mate exchang successor adjac list get combin adjac list o1 time howev merg fail edg mate includ correspond adjac list algorithm keep track edg vertex subtre ecienc exampl adjac list q 0 involv edg incid vertex respect tree edg mate may present correspond adjac list therefor appli o1tim merg techniqu may abl megr adjac list one singl list repres fail form singl combin adjac list also complic extract essenti edg particular minimum extern edg comput set b particular easili determin vertic belong identifi redund edg ie intern extra multipl extern edg adjac list e e e e fig 3 merg pair adjac list lu lv respect common edg e optim parallel mst algorithm 9 actual mst algorithm insist merg adjac list singl list key idea algorithm maintain essenti edg includ one particular combin adjac list base structur properti minimum span tree lter redund adjac list obtain uniqu adjac list see lemma 5 9 section 5 adjac list repres intern edg remov use techniqu base threshold chong 1996 intrigu part concern extra multipl extern edg nd necessari remov specic show extra multipl extern edg remov easili must bigger weight presenc aect correct comput next section elabor idea formul requir phase achiev schedul 4 requir phase section specifi formal thread expect achiev phase initi phase 0 thread construct set q 0 adjac list vertex v g q 0 contain circular link list l includ 2 1 smallest edg incid v addit l assign threshold denot hl l contain edg v smallest edg truncat l blog ic phase adjac list merg base newli arriv edg set truncat accord length requir combin adjac list new threshold comput intuit threshold record smallest edg truncat far consid phase j 1 j blog ic inherit set q j 1 adjac list phase j 1 receiv edg set ba recal denot set tree induc b1 j phase j aim produc set q j adjac list captur extern edg tree f j essenti comput b basic tri merg adjac list q j 1 respect ba mention merg process may produc one combin adjac list tree nevertheless strive ensur one combin list retain rest ltere view time constraint impos schedul thread also need tight bound length remain adjac list let l list q j r1 uniqu correspond tree 2 f j store extern edg case said repres l q j tree f j may repres list q fewer 2 vertic repres r2 length l contain 2 bi2 j c 1 edg dene edg tree 2 f j essenti must includ l consid extern edg e connect anoth tree 0 2 f j han tw lam say e primari among edg connect 0 e smallest weight otherwis e said secondari note minimum span tree g contain edg extern edg 0 must primari one ideal primari extern edg retain list yet infeas sinc thread start truncat adjac list identifi remov secondari extern edg phase remov intern edg though nontrivi feasibl import observ necessari remov secondari extern edg base structur classic light heavi edg dene nd light secondari extern edg remov easili af terward list contain light primari extern edg possibl heavi secondari extern edg set light primari extern edg may cover primari extern edg size much smaller 2 bi2 j c 1 yet show set light primari extern edg suce comput presenc heavi secondari extern edg aect correct give denit light heavi edg base notion base denit let tree f j let real number tree 0 2 f j said access anoth tree 00 2 f j 00 access connect 0 edg weight smaller let e extern intern edg dene set weaccess tg size basef total number vertic tree involv let e extern intern edg say e light kbasef follow denit light edg tree smaller weight heavi edg also heavi edg remain heavi edg subsequ phase specic phase k k j subtre tree x 2 f k extern intern edg e therefor e heavi respect also heavi respect x follow lemma give upper bound number light primari extern edg tree f j compli length requir list q j lemma 4 tree 2 f j 2 bi2 j c 1 light primari extern edg proof let x number light primari extern edg among light primari extern edg let e one biggest weight set includ least x 1 tree adjac b1 j 2 j forest everi tree f j contain least 2 j vertic denit light edg thu x 2 j 2 x 2 optim parallel mst algorithm 11 follow requir speci essenti edg kept list character secondari extern edg list r3 base let tree f j repres list l 2 q j light primari extern edg includ l secondari extern edg includ l must heavi retain light primari extern edg list q j alreadi sufcient comput b particular let us consid scenario end phase blog ic tree 2 f blog ic fewer 2 vertic minimum extern edg e ts must report b note basef blog ic contain ts light primari extern edg previou phase k f k contain subtre denot w e ts extern edg note e ts also light primari extern edg w heavi edg remain heavi edg subsequ hand end phase blog ic tree x 2 f blog ic contain 2 vertic extern edg heavi r3 enforc minimum extern edg e tx x kept list x fortun necessari thread report minimum extern edg tree follow requir threshold help us detect whether minimum extern edg x remov report anyth x essenti requir e tx primari extern edg e x remov list l x repres x threshold kept l x bigger respect smallest edg l x e tx weight fewer threshold let tree f j repres list l 2 q j threshold l satis follow properti r4 lower bound threshold hl 6 1 hl equal weight heavi intern extern edg r5 upper bound threshold let e extern edg includ l e primari hl algorithm actual satis stronger requir hl e primari e secondari mate e still includ anoth list l 0 q j summari r1 r5 guarante end phase blog ic tree fewer 2 vertic minimum extern edg e edg kept uniqu adjac list repres otherwis may may repres list repres list e alreadi remov threshold kept everi extern edg current kept list must weight greater equal threshold thu simpli ignor list easi check q 0 satis requir phase 0 next section give algorithm satisfi requir everi phase consequ thread report b base edg list 12 kw chong han tw lam 5 algorithm section present algorithm detail thread show merg extract adjac list phase discuss induct naturefor j 1 assum phase j 1 produc set adjac list satisfi requir r1r5 show phase j comput new set adjac list satisfi requir oi2 j use linear number processor phase j inherit set adjac list q j 1 phase j 1 receiv edg ba eas discuss refer ba input notic list q repres one tree f j 1 recal denot set tree induc b1 phase j merg adjac list q accord tree f j 1 connect edg input consid edg input denot w 1 w 2 tree f j 1 contain u v respect ideal e mate appear adjac list w 1 w 2 respect adjac list w 1 w 2 merg easili o1 time howev w 1 w 2 might alreadi larg represent q j 1 even repres length requir adjac list may allow e includ result e may appear two separ list q one even none call e full half lost edg respect accordingli partit input three set name fullinput halfinput lostinput phase j start merg list q respect edg fullinput let tree f j let w 1 tree f j 1 togeth edg input constitut note w may repres list q j 1 sinc merg done respect fullinput adjac list w 1 present may merg sever list instead singl one let merg list l repres bigger subtre z call cluster see figur 4 cluster may contain one w distinguish one cluster call core cluster minimum extern edg e extern edg cluster note minimum extern edg core cluster may may e noncor cluster z minimum extern edg e z z must tree edg lemma 3 thu e z input moreov e z full edg otherwis merg oper e z becom intern edg bigger cluster merg list obvious need satisfi requir q j follow section present addit process use fulll requir ment summari process given section 54 discuss process merg list divid accord size tree sketch follow tree 2 f j contain fewer 2 vertic simpl way ensur exactli one merg list retain q j edg list optim parallel mst algorithm 13 fig 4 wx repres tree f j 1 dot solid line repres half full edg input respect tree form connect tree f j 1 edg input zy call cluster subtre form connect wx full edg adjac list wx within zy merg singl list easili ltere contain light primari extern edg secondari extern edg includ must heavi tree 0 2 f j contain least 2 vertic process may retain one merg list put extra step ensur except possibl one merg list 0 remov threshold remain list updat retain 2 bi2 j c 1 smallest edg show requir threshold satis matter whether tree concern contain fewer 2 vertic 51 tree f j fewer 2 vertic section focu tree 2 f j contain fewer 2 vertic denot merg list repres cluster observ list contain 2 bi2 edg deriv ecient way nd uniqu adjac list repres contain light primari extern edg first realiz everi light primari extern edg also light primari extern edg tree w f j 1 must present adjac list repres w q j 1 r3 thu light primari extern edg includ minimum extern edg present merg list uniqu represent let l cc list fl l cc contain minimum extern edg e l cc repres core cluster z 0 concern remov list fl repres uniqu l cc ecient distinguish l cc list make use properti 14 kw chong han tw lam state follow lemma let l nc list fl g let z denot cluster repres l nc lemma 5 l cc contain edg halfinput ii l nc contain least one edg halfinput particular minimum extern edg z halfinput proof lemma 5i assum contrari l cc includ edg halfinput precis ha bi l cc hb ai includ list tree f j 1 connect e 2 w edg e primari extern edg w well w 0 w w 0 subtre w also subtre z 0 show contain least 2 vertic latter contradict assumpt thu lemma 5i follow w 0 subtre contain less 2 vertic r1 q contain list lw 0 repres w 0 r3 lw 0 contain light primari extern edg w 0 edg hb ai includ lw 0 must heavi therefor next want show tree basef subtre dene b subtre construct remov e see figur 5 assum contain vertex b vertex b w well z 0 fig 5 partit two subtre ta b connect e subtre w 0 subtre b lemma 3 minimum extern edg b either e e former case imposs e includ l cc must extern edg z 0 thu e minimum extern edg b denit base basef includ tree f j 1 outsid b word b includ subtre basef must least 2 vertic must contradict occur proof lemma 5ii let e z minimum extern edg z e z tree edg input full edg case show e z actual half edg includ l nc thu complet proof let w tree f j 1 w compon z e z extern edg w note e z primari extern edg w let lw denot adjac list q repres w sinc e z minimum extern edg optim parallel mst algorithm 15 includ tree f j 1 outsid z thu size less 2 r3 light primari extern edg w includ e z present lw therefor e z halfinput l nc must inherit e z lw use lemma 5 easili retain l cc remov merg list l nc one might worri l nc might inde contain light primari extern edg remov l nc incorrect actual imposs view follow fact lemma 6 extern edg e includ l nc proof let e z minimum extern edg z extern edg e includ l nc e also extern edg z z let w w 0 tree f j 1 connect e z w 0 compon z shown previou lemma e z halfinput moreov e z tree edg present adjac list w w 0 compon adjac list w 0 q contain e z note e z primari extern edg w 0 r1 r3 conclud e z heavi extern edg w 0 henc kbasef therefor lemma 6 l nc contain light primari extern edg word light primari extern edg must l cc list retain exclud light intern secondari extern edg l cc contain light primari extern edg also edg length requir ie r2 retain 2 bi2 j c 1 edg l cc note light primari extern edg may smallest edg l cc base follow two lemma remov light edg l cc includ light intern secondari extern edg light primari extern edg smallest edg left list retain 2 bi2 j c 1 smallest edg alway includ light primari extern edg lemma 7 suppos l cc contain light intern edg hu vi mate hv ui also appear l cc proof recal l cc form merg adjac list tree f j 1 r1 list contain intern edg tree repres l cc contain light intern edg hu vi edg u v must two tree w w 0 f j 1 compon z 0 assum light extern edg w w 0 respect let lw lw 0 adjac list q j 1 hu vi appear appear lw r3 light edg found lw includ hu vi must primari extern edg w symmetri hv ui primari extern edg w 0 r3 hv ui appear lw 0 sinc l cc inherit edg lw lw 0 conclud hu vi hv ui appear l cc han tw lam lemma 8 suppos l cc contain light secondari extern edg e let e 0 correspond primari extern edg e e 0 appear l cc mate also appear anoth merg list l 0 cc l 0 cc repres core cluster anoth tree 0 2 f j proof suppos l cc contain light secondari extern edg e assum e connect anoth tree 0 2 f j e 0 primari extern edg 0 0 e fig 6 e light secondari extern edg e 0 correspond primari extern edg thu e also light primari extern edg must includ l cc hand sinc e secondari equal basef thu contain less 2 vertic merg list q obtain merg list l 0 cc includ light primari extern edg 0 show l 0 cc contain mate e 0 e observ kbasef e 0 e light extern edg 0 e 0 also primari extern edg 0 e 0 precis mate must includ l 0 cc let w w 0 two tree f j 1 connect e w subtre w 0 0 e light extern edg 0 also light extern edg w w 0 note l cc inherit e adjac list repres w r3 lw includ light secondari extern edg w e primari extern edg w symmetri e also primari extern edg w 0 thu r3 e adjac list lw repres w 0 note l 0 cc must includ edg lw 0 well list q j 1 contain light extern edg see lemma 6 l 0 cc contain e lemma 7 remov light intern edg simpli remov edg whose mate list lemma 8 impli l cc contain light secondari extern edg correspond primari extern edg also appear optim parallel mst algorithm 17 l cc mate exist anoth list l 0 cc suggest simpl way identifi remov light secondari extern edg follow without loss gener assum everi edg l cc determin ident l cc distinct label given l cc edg e 2 l cc mate anoth list say cc e announc ident l cc mate vice versa sort edg l cc respect ident receiv mate multipl light extern edg connect tree come togeth easili remov light secondari extern edg know l cc contain light primari extern edg edg contain must heavi let us summar step requir build uniqu adjac list repres procedur mc mc mean merg clean 1 edg input full respect q j 1 activ merg list q j 1 let q set merg adjac list 2 merg adjac list l 2 q l contain edg halfinput remov l q b detect remov intern secondari extern edg l accord lemma 7 8 52 tree least 2 vertic consid tree 0 2 f j contain 2 vertic let l 1 l merg list repres cluster 0 list may contain 2 edg unlik case section 51 minimum extern edg e 0 0 heavi guarante merg list contain e 0 repres core cluster 0 nevertheless thread ignor tree 0 may remov merg list lemma 9 show list fl 1 l g repres noncor cluster 0 remov easili inde merg list l cc repres core cluster thread may remov l cc sinc 0 contain least 2 vertic light primari extern edg noth enforc l cc regard light primari extern edg concern l cc requir threshold handl section 53 0 contain least 2 vertic merg list l nc repres noncor cluster 0 may satisfi properti state lemma 5ii need way detect l nc first detect length l nc l nc contain 2 edg remov l nc immedi next l nc contain less 2 edg make use follow lemma identifi denot hl threshold associ list l 2 merg l nc g lemma 9 list l repres noncor cluster 0 satis least one follow condit 1 l nc contain edg halfinput 2 everi edg hu vi l nc either hv ui also l nc wu v han tw lam proof assum l nc contain edg halfinput l nc contain edg hu vi contain hv ui show wu v tmphl nc edg u v intern extern edg z case 1 u v intern edg z l nc inherit hu vi list l 2 tree repres l r1 hu vi extern edg w thu z includ anoth tree w 0 2 f j 1 hv ui extern edg l nc also inherit edg list lw repres w 0 note hv ui appear lw 0 r5 hlw 0 case 2 u v extern edg z obviou wu v z e z minimum extern edg z show z tmphl tree z e z extern edg let lw 2 adjac list repres w mention e z input full edg e z lost edg l nc contain e z e z half edg l nc contain e z l nc contain edg halfinput conclus e z appear l nc henc appear lw sinc e z primari extern edg w know r5 hlw z denit use lemma 9 extend procedur mc remov everi merg list l nc repres noncor cluster tree f j see procedur ext mc precis fewer 2 vertic l nc remov step 2a otherwis l nc remov step 1b step 2ac procedur ext mc 1 edg input full respect q j 1 activ merg list q j 1 let q set merg adjac list b list l 2 q l contain 2 remov l q 2 merg adjac list l 2 q l contain edg halfinput remov l q b detect remov intern secondari extern edg l c edg hu vi l wu v tmphl remov l q procedur ext mc execut remain merg list repres core cluster tree f j moreov tree 2 f j fewer 2 vertic procedur ext mc like procedur mc alway retain merg list l cc repres core cluster l cc remov step 1b l cc contain 2 edg addit l cc contain light primari extern edg lemma 10 show tmphl cc weight heavi intern extern edg thu l cc contain edg weight less tmphl cc remov step 2c lemma 10 tmphl cc equal weight heavi intern extern edg proof among list q j 1 merg l cc let l one optim parallel mst algorithm 19 smallest threshold tmphl cc denot tree f j 1 repres l r4 hl equal weight heavi intern extern edg e w thu e also heavi intern extern edg 53 updat threshold retain extern edg procedur ext mc execut everi remain merg list repres coreclust tree f j let l cc list repres tree 2 f j contain less 2 vertic light primari extern edg appear among smallest edg l cc edg l cc heavi edg least 2 vertic extern intern edg light edg l cc must heavi denit ext mc number edg l cc 2 bi2 may exceed length requir phase j ie 1 ensur l cc satis r3 retain 2 bi2 j c 1 smallest edg l cc threshold l cc denot hl cc updat minimum tmphl cc weight smallest edg truncat contain fewer 2 vertic everi edg truncat l cc heavi togeth lemma 10 conclud hl cc equal weight heavi intern extern edg satisfi r4 next give observ l cc lemma 12 show r5 satis denot z 0 coreclust repres l cc lemma 11 let e extern edg z 0 e tree edg e includ l cc hl cc proof suppos e includ l cc note e full edg respect q full edg mate remov step 2b procedur ext mc e halfinput procedur ext mc remov l cc step 2a contradict l cc one remain list procedur ext mc execut therefor e includ l cc next show hl cc let w subtre z 0 e extern edg w sinc e tree edg e primari extern edg w e includ l cc l cc inherit adjac list lw 2 repres w e also includ lw r5 hlw recal lemma 12 let e extern edg current found l cc e primari ii e secondari mate e still includ list l 0 q j hl cc proof let vi extern edg current found l cc satisfi condit state lemma 12 let w tree f j 1 w subtre e extern edg w respect w either e primari e secondari mate e includ anoth list q consid whether w includ core cluster z 0 case 1 w subtre z 0 denit z 0 w must repres list end phase j 1 e may may appear lw e 20 kw chong han tw lam z fig 7 z 0 z connect path p p contain edg b extern edg z 0 w 0 appear lw r5 hlw hl cc suppos e lw e pass l cc procedur ext mc start yet e current l cc e remov l cc within procedur ext mc take place step 2b e either intern edg secondari extern edg remov togeth mate contradict assumpt e thu e remov procedur ext mc ie due truncat case way hl cc updat guarante case 2 w subtre noncor cluster z show z 0 extern observ contain path connect z 0 z path must involv extern edg ha bi z 0 lemma 11 hl cc wa b next show wa b let w 0 tree f j 1 w 0 subtre z 0 ha bi extern edg w 0 see figur 7 suppos remov edg b partit two subtre b contain vertic b respect note b contain w e extern edg b hand z 0 includ e extern edg b lemma 3 minimum extern edg b hb ai therefor wa b result hl cc wa b lemma follow remov remain intern edg note l cc may still contain intern edg procedur ext mc remov intern edg whose mate also appear l cc follow lemma show everi remain intern edg l cc weight greater hl cc thu discard edg l cc weight greater hl cc ensur extern edg retain cours light primari extern edg remov step lemma 13 intern edg e current includ l cc proof consid whether intern extern edg z 0 optim parallel mst algorithm 21 fig 8 pair vertic u v e connect path p everi edg p weight smaller case 1 e intern edg z 0 suppos l cc inherit e list repres tree w 2 f j 1 w subtre z 0 r1 hu vi extern edg w z 0 includ anoth tree w 0 2 f j 1 contain vertex v denot lw 0 list q j 1 repres w 0 edg hv ui extern edg w 0 hv ui appear lw 0 otherwis would also inherit hv ui lw 0 procedur ext mc remov hu vi hv ui l cc step 2b r5 hlw 0 wu v case 2 e extern edg z 0 lemma 11 e tree edg let p path connect u v see figur 8 sinc subtre g everi edg p weight smaller wu v p nd extern edg ha bi z 0 lemma 11 hl cc wa b henc hl cc wu v 54 complet algorithm discuss thread previou three section summar follow procedur time processor requir analyz next section thread input g b k 1 k 1 avail end kth superstep construct q 0 g 0 0 3 blog ic phase j denot input ba 1 edg input full respect q list set merg adjac list b list l 2 q l contain 2 bi2 part lg otherwis remov l q 2 list l 2 q remov unwant edg list 22 kw chong han tw lam l contain edg halfinput remov l q b detect remov intern secondari extern edg l c edg hu vi l wu v tmphl remov l q 3 truncat list necessari remov remain intern edg list l 2 q l contain 2 bi2 j c 1 edg retain smallest one updat hl minimum tmphl smallest edg remov l b edg hu vi 2 l wu v hl remov hu vi l appear list l q blog ic wu v hl g 6 time processor complex first show new mst algorithm run olog n time use nm log n crew pram processor illustr modifi algorithm run erew pram reduc processor bound linear thread start run concurr need initi step first adjac list g sort ascend order respect edg weight set sort adjac list replic blog nc time copi move local memori thread part global share memori dedic processor perform local comput thread replic take olog n time use linear number processor thread construct q 0 o1 time afterward thread run concurr mention section 3 comput thread schedul run number phase phase start end predetermin superstep need show comput phase complet within alloc time interv particular phase j thread schedul start j 1th superstep end j1 th superstep use superstep follow lemma show phase j thread implement ci2 j 1 time c constant set length superstep constant c 0 ci2 j 1 c 0 1 phase j complet comput 1 superstep verifi lemma 14 phase j thread implement oi2 use processor proof consid comput phase j thread merg adjac list start thread read ba may also read mani thread local memori thread merg adjac list step 2a take o1 time step 2b test length list 2 bi2 done perform pointer jump time adjac list left length 2 bi2 subsequ step make use standard parallel algorithm techniqu includ list rank sort pointer jump optim parallel mst algorithm 23 process remain list time use techniqu logarithm order length list see eg jaja 1992 therefor step phase j implement ci2 use linear number processor corollari 1 minimum span tree weight undirect graph found olog n time use n log n crew pram processor proof lemma 14 comput phase j thread satis predetermin schedul therefor b found end ith superstep b1 blog nc readi end blog ncth superstep mean whole algorithm run olog n time thread use nm processor n log n processor suce whole algorithm 61 adapt erew pram illustr modifi algorithm run erew pram model consid phase j thread discuss proof lemma 1 concurr read use access edg ba may also read mani thread time ba alreadi resid local memori thread step implement erew pram avoid use concurr read requir thread copi output subsequ thread modifi schedul thread perform copi process sequenti manner detail follow shown proof lemma 1 phase j thread implement ci2 c constant length superstep set c 0 phase j thread complet within superstep length superstep doubl ie superstep take 2c 0 time instead c 0 comput phase j defer last half superstep ie last 1 superstep rst half superstep phase j ie 1th j1 th superstep comput perform thread wait thread store output b j 1 local memori complet schedul need show thread k k perform copi time recal thread k complet comput kth superstep k four thread name thread replic take use linear number processor lemma 15 consid thread end th super step copi ba resid local memori thread proof k thread receiv b k k phase j thread b j last set edg receiv arriv th superstep start second half phase j han tw lam 62 linear processor section adapt mst algorithm run linear number processor rst show reduc processor requir n log n dens graph least n log n edg processor requir domin final give simpl extra step handl spars graph reduc processor requir log n would like introduc preprocess thread thread work n instead edg comput requir output use n processor yet preprocess thread still need handl edg requir processor sidestep diculti attempt share preprocess among thread precis comput divid dlog log ne stage stage k 1 ne perform one singl preprocess allow 2 k 1 thread comput concurr edg set use processor preprocess run o2 k superstep use processor thu stage make use total number superstep stage still olog n lemma 16 minimum span tree weight undirect graph found olog n time use n log n processor erew pram proof linearprocessor algorithm run dloglog ne1 stage stage 0 found thread 1 1 k dloglog ne stage k given comput b2 specic let thread 2x preprocess thread 1 2 x actual comput part requir ox superstep preprocess prepar initi adjac list thread let f set tree induc b1 x denit 2 x forest g invok thread 2x execut phase 1 comput set q 1 adjac list denit list q 1 length 2 2x2 repres tree f contain primari extern edg base less 2 2x contain sucient edg nding b 2x also f contain n2 x tree q 1 contain total n edg list q 1 sort respect edg weight use ox superstep n processor q 1 copi local memori thread 1 x one one x superstep use n processor 1 x thread replac initi set adjac list q 0 new set q 0 construct truncat list q 1 includ smallest 2 1 edg thread 1 x readi run concurr comput b respect 1 x thread use q 0 initi set adjac list follow origin phasebyphas schedul execut algorithm state section 54 note algorithm thread versatil state everi thread start q 0 input thread comput edg set b xi instead found thread 1 x x superstep note q 0 n edg processor requir thread n short stage k take ox superstep use mx n mn log n processor optim parallel mst algorithm 25 recal dlog log ne stage altogeth run olog n time use processor input graph spars ie n log n rst construct contract graph g c g follow execut thread 1 loglog n concurr nd log n induc log nforest b g contract tree forest obtain contract graph g c n log n vertic contract take olog n time use processor lemma 16 minimum span tree g c denot gc comput olog n time use n log n log processor note gc b includ exactli edg g conclud follow theorem theorem 1 minimum span tree undirect graph found olog n time use linear number processor erew pram r new connect msf algorithm shu faster determinist algorithm minimum span tree minimum span tree algorithm inverseackermann type complex find minimum span tree erew pram find connect compon olog n loglog n time erew pram parallel merg sort find minimum span forest logarithm time linear work use random sampl approxim exact parallel schedul applic list upper lower time bound parallel random access machin without simultan write fibonacci heap use improv network optim algorithm optim random parallel algorithm find connect compon graph sharedmemori model serv bridg model parallel comput proceedingsin proceed 9th acm symposium parallel algorithm architecturesproceed fast ecient parallel connect compon algorithm comput connect compon parallel comput connect compon olg 3 parallel algorithm comput minimum span tree random sampl graph optim problem random lineartim algorithm nd minimum span tree fast connect compon algorithm erew pram parallel algorithm sharedmemori chine parallel ear decomposit search undirect connect olog 15 n space find minimum span tree random timework optim parallel algorithm find minimum span forest optim minimum span tree algo rithm random linear work erew pram algorithm find minimum span forest structur network algorithm bridg model parallel comput tr data structur network algorithm upper lower time bound parallel random access machin without simultan write effici algorithm find minimum span tree undirect direct graph fibonacci heap use improv network optim algorithm new connect msf algorithm shuffleexchang network pram parallel ear decomposit search ed italicstnumb graph parallel merg sort bridg model parallel comput parallel algorithm sharedmemori machin connect compon italicoitaliclgsupscrpt32supscrptitalicvital parallel time crew pram extend abstract introduct parallel algorithm parallel algorithm comput minimum span tree fast connect compon algorithm erew pram random lineartim algorithm find minimum span tree effici fast parallelconnect compon algorithm random sampl graph optim problem find minimum span forest logarithm time linear work use random sampl sharedmemori model serv bridg model parallel comput isli myampersandsubeilisup43sup find connect compon italicoitaliclog italicnital loglog italicnital time erew pram optim random erew pram algorithm find span forest basic graph connect problem minimum span tree algorithm inverseackermann type complex effici parallel algorithm graph problem comput connect compon parallel comput optim minimum span tree algorithm random linear work erew pram algorithm find minimum span forest random timework optim parallel algorithm find minimum span forest faster determinist algorithm minimum span tree find minimum span tree om alphamn time ctr tsansheng hsu simpler faster biconnect augment journal algorithm v45 n1 p5571 octob 2002 stavro nikolopoulo leonida palio parallel algorithm p toshihiro fujito takashi doi 2approxim nc algorithm connect vertex cover tree cover inform process letter v90 n2 p5963 vladimir trifonov olog n log log n space algorithm undirect stconnect proceed thirtyseventh annual acm symposium theori comput may 2224 2005 baltimor md usa david bader guoj cong fast sharedmemori algorithm comput minimum span forest spars graph journal parallel distribut comput v66 n11 p13661378 novemb 2006 aaron windsor nc algorithm find maxim acycl set graph proceed sixteenth annual acm symposium parallel algorithm architectur june 2730 2004 barcelona spain seth petti vijaya ramachandran optim minimum span tree algorithm journal acm jacm v49 n1 p1634 januari 2002