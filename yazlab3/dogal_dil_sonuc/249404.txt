resourc bound selfstabil messagedriven protocol selfstabil messagedriven protocol defin discuss class weak exclus contain mani natur task ellexclus token pass defin shown execut selfstabil protocol task class configur size must grow least logarithm rate last lower bound valid even system support timeout mechan prevent commun deadlock present three selfstabil messagedriven protocol token pass rate growth configur size three protocol match aforement lower bound protocol present twoprocessor system easili adapt ring arbitrari size result interest interpret term automata theori b introduct distribut system set state machin call processor commun either share variabl messagepass first case system share memori system second case system messagepass system distribut system selfstabil start possibl global state start system regain consist without kind outsid intervent selfstabil properti use system processor may crash recov spontan arbitrari state intermedi period one recoveri next crash long enough systemstabil selfstabil system defin discuss first fundament paper dijkstra dij74 work dij74 well follow work selfstabil system assum commun model share variabl among paper kr79 tc81 dij82 la86 bgw87 bu87 bp88 ij90 ij90a dim90 dim91 studi fault toler messagepass system customarili assum messag might corrupt link henc processor may enter arbitrari state link content may arbitrari selfstabil protocol treat problem natur sinc design recov inconsist globalst surprisingli paper address selfstabil messagepass system earliest research model done gouda multari mu89 gm91 work develop selfstabil slide window protocol twoway handshak use unbound counter prove selfstabil messag pass protocol must use timeout infinit number safe state follow gm91 two addit work dealt selfstabil protocol model work katz perri kp90 present gener tool extend arbitrari messagepass protocol selfstabil protocol work afek brown ab89 present selfstabil version wellknown alternatingbit protocol see eg bsw69 work research complex issu relat selfstabil messagepass sy tem defin configur messagepass system list state processor messag transit link size configur messagepass system number bit requir encod configur entir protocol messagepass system messagedriven action processor initi receiv messag work gouda multari gm91 proven messagedriven protocol possibl configur processor wait messag messag link unwant situat call commun deadlock selfstabil system stabil start possibl initi configur includ configur commun deadlock impli nontrivi complet asynchron selfstabil system messagedriven problem dealt least two method gouda multari gm91 propos use timeout mechan preserv messag driven structur protocol expens compromis complet asynchronis hand katz perri kp90 chosen give messagedriven structur present protocol configur least one processor whose next oper send messag thu execut everi atom step messag sent messag ever receiv execut size configur grow linearli work defin studi class selfstabil messagedriven protocol argument gm91 exist selfstabil messagedriven protocol complet asynchron sinc look protocol whose configur size grow linear rate resort slightli limit assumpt asynchron behavior lower bound assum abstract timeout devic detect commun deadlock initi system upon occurr consequ lower bound present take account execut commun deadlock occur upper bound assum everi initi configur least one messag link assumpt much weaker assumpt gener timeout mechan specif task studi detail tokenpass inform tokenpass task pass singl token fairli among system processor usual assum system predefin initi configur exist singl token selfstabil system predefin initi configur execut reach configur exactli one token present entir system tokenpass basic task fault toler system among work studi dk86 fault toler messagepass system ij90 selfstabil share memori system tokenpass task look special case mutualexclus sinc possess singl token interpret permiss enter critic section first part present prove lower bound configur size protocol larg class task call weakexclus weakexclus class contain nontrivi task requir continu chang system configur particular class includ exclus tokenpass show configur size selfstabil protocol realiz weakexclus task least logarithm number step execut protocol lower bound hold messagedriven protocol weekexclus task includ protocol system equip timeout mechan result compar result gm91 shown messagedriven selfstabil protocol necessarili weekexclus task must infinit mani safe system configur specif execut must contain infinit mani distinct configur impli result lower bound specifi part system grow size memori use state machin size messag store link number messag store link togeth present three selfstabil messagedriven protocol tokenpass commun deadlock problem avoid assumpt least singl messag present commun link use assumpt present three tokenpass protocol two processor rate growth configur size three protocol match aforement lower bound protocol present system two processor easili adapt work ring arbitrari size without increas asymptot complex done consid ring singl virtual link first protocol processor memori messag size grow unboundedli time protocol use idea similar idea slide window protocol gm91 second protocol improv first protocol size memori processor grow logarithm rate size link content bound second protocol improv determinist altern bit protocol ab89 third protocol selfstabil tokenpass protocol processor determinist finit state machin messag fix size grow part system number messag link rate growth match lower bound mention result describ also term automata theori follow let sigma alphabet defin queue machin q finit state machin equip queue initi contain arbitrari non empti word sigma initi q arbitrari state step perform follow read delet letter head queue b add one letter sigma tail queue c move new state comput power queue machin sever limit fact input alphabet work alphabet ident particular queue machin perform simpl task like comput length input word even decid whether input word contain specif letter assum alphabet contain specifi subset token letter queue machin tokencontrol start nonempti queue arbitrari content eventu queue contain exactli one occurr letter forev lower bound result impli tokencontrol exist everi comput size queue must grow least logarithm number move machin third protocol impli token control whose configur size growth match lower bound exist view fact queue machin comput estim number occurr letter input word latter result appear somewhat counter intuit selfstabil messagedriven system 21 asynchron messagedriven system asynchron distribut messagepass system contain n processor processor state machin processor commun use messagepass along link edg stand two direct link one p p j p j p messag sent p p j delay unbound amount time connect link messag reach destin yet store link transfer fifo first first order processor uniqu defin set atom step whenev processor activ execut one atom step messagedriven protocol atom step processor p begin receiv oper p receiv messag one incom link atom step end zero send oper send messag along outgo link atom step p defin state 1 e link p receiv messag msg e 1 outgo link along p send msg respect 2 state p follow execut atom step let n number processor link respect system denot set state p configur system vector state processor togeth list list everi link messag store link configur denot cs 1 theta 2 theta delta delta delta n theta e 1 theta e 2 em list messag store e j 1 j let c configur atom step applic p c p state 1 c msg first messag store e c applic c yield result configur c 0 denot fact c sequenc atom step applic configur c 0 first atom step sequenc 1 applic c 0 second atom step applic c 1 1 delta finit infinit sequenc start arbitrari configur c 0 everi 0 c sequenc atom step applic c 0 note sinc deal selfstabil system assum particular initi configur everi configur valid initi configur execut e fair everi atom step applic infinit often execut infinit often execut e defin partial order atom step e relat happen lamport la78 1 j atom step execut processor e appear j e happen j 2 messag msg sent j messag msg receiv happen j 3 happen j j happen k happen k also adopt definit concurr atom step la78 atom step 1 said concurr execut e 1 happen j j happen e follow proposit give suffici condit set step concurr execut k distinct processor let set atom step j aplic p configur c exist execut atom step 1 delta delta delta k concurr proof observ step applic processor p configur c step remain applic p subsequ configur execut e defin execut start c processor p activ one processor p j execut j proof follow sinc processor distinct sinc e messag sent receiv k execut note proposit hold system step applic remain applic long execut asynchron protocol pr defin set n processor definit asynchron protocol defin set execut satisfi follow 1 delta arbitrari execut pr everi prefix e also execut pr 2 arbitrari finit execut pr everi atom step configur c satisfi c r c pr execut e ffi c 1 1 sequenc 1 denot concaten 1 22 selfstabil messagedriven protocol selfstabil system demonstr legitim behavior time start arbitrari configur natur way specifi behavior abstract way set sequenc configur defin task set legitimatesequ semant specif task express requir sequenc intuit legitim sequenc thought execut protocol requir formal instanc mutualexclus task defin set sequenc configur processor subset state call critic section configur one processor critic section everi processor critic section infinit mani configur formal defin task one specifi possibl system st set legitim sequenc st task defin union legitim sequenc set possibl system configur c system safe respect task protocol pr fair execut pr start c belong prove lower bound result selfstabil messagedriven protocol assum system recov commun deadlock call deadlock word prove lower bound assum protocol stabil execut deadlock occur purpos distinguish two type deadlock global local configur c global deadlock configur atom step applic c first lower bound hold asynchron system recov global deadlock appli global timeout mechan abstract mechan initi system global deadlock configur default initi configur deadlock occur bring requir selfstabil system equip global timeout mechan definit system requir reach safe configur everi infinit fair execut note definit infinit fair execut deadlock configur assum global timeout mechan let pr le messag driven protocol set legitim sequenc respect protocol pr sellfstabil rel le everi c execut pr start c everi infinit fair execut reach safe configur respect le pr later prove lower bound hold system immun stonger type commun deadlock call local deadlock processor p local deadlock execut e p activ ie execut atom step finit mani time e second lower bound hold system equip abstract local timeout mechan prevent execut eg enabl processor idl suffici long time initi system default configur deadlock possibl note local timeout mechan strictli stronger global timeout mechan assum local timeout mechan let pr le messag driven protocol set legitim sequenc respect protocol pr sellfstabil rel le everi c execut pr start c everi infinit fair execut processor activ infinit often reach safe configur respect le pr 3 lower bound section prove lower bound rate configur size grow along everi execut protocol larg class task call weakexclus class contain nontrivi task requir continu chang system configur particular class includ exclus tokenpass execut e denot e set distinct atom step execut p e task belong class weakexclus set legitim sequenc le satisfi e 2 le exist set two atom step j 2 j e atom step b never concurr e first consid selfstabil protocol system equip global timeout mech anism protocol prove everi execut commun deadlock occur configur distinct conclud configur size everi selfstabil protocol realiz weakexclus task least logarithm number step execut protocol throughout proof assum pr selfstabil messagedriven protocol arbitrari weakexclus task system global timeout mechan end section present slightli weaker lower bound system local timeout mechan configur c link e denot c e sequenc messag present e c execut e denot e es er sequenc messag sent receiv along e e proposit 2 everi execut everi link e c 0 er cr e proof left hand side equat contain messag present e c 0 concaten messag sent e e right hand side equat contain messag receiv e e concaten messag left e c r hard verifi side equat repres sequenc messag execut configur c equal initi configur c 0 call circular execut link e activ circular execut e messag receiv henc circular e messag sent along e e repeat circular execut e forev yield infinit execut e 1 necessarili fair origin execut may applic step never execut e step applic throughout e 1 never execut avoid problem origin circular execut chang remov messag link activ throughout e result execut still call e still circular infinit repetit e 1 fair infinit execut observ execut certain configur appear circular subexecut thu show everi execut pr configur distinct assum pr circular subexecut e reach contradict show pr selfstabil use e construct initi configur c init chang list messag transit system link link e list messag transit e c init obtain concaten list messag transit e c 0 list messag sent e e roughli speak effect chang creat addit layer messag help decoupl send counterpart receiv achiev addit flexibl system enabl proof lower bound formal c init obtain c 0 follow ffl state processor c init equal state c 0 ffl activ link e c init e e es nonact link e c init e empti let ai sequenc atom step execut p e defin mergea set sequenc obtain possibl merg sequenc ai 1 keep intern order ai note sequenc mergea finit length contain atom step differ order lemma 3 everi 2 mergea applic c init result execut circular execut pr proof let arbitrari sequenc mergea let p arbitrari processor system initi state p c init equal initi state c 0 ii c init messag p receiv e store p appropri incom link right order iii atom step p appear order appear ai impli sequenc applic c init applic c init yield execut ea result configur c re whose state vector equal state vector c init everi activ link ea es es ea er er prove obtain execut circular remain shown content everi link result configur c re equal content c init ie c init e cre e arbitrari link e hold 1 c init e es er cre e proposit 2 fact ea es es er er 2 c 0 e proposit 2 circular e replac c init e equat 1 explicit content yield 3 c 0 cre e use equat 2 replac c 0 e es er e equat 3 give 4 e er e es er cre drop er two side equat 4 yield desir result c init cre e prove lemma defin blowup set execut whose initi sate c init whose sequenc atom step belong mergea notic everi circular execut e everi execut hold lemma 4 set atom step e execut e 2 blowup contain configur atom step b concurr proof notat simplic assum g let sequenc construct follow first take step a1 preced 1 take step a2 preced 2 take step preced n appli sequenc construct far c init result configur applic sequenc complet sequenc mergea take remain atom step arbitrari order keep intern order pr selfstabil messagedriven protocol arbitrari weak exclus task system global timeout mechan pr circular execut pr infinit fair execut e 1 none whose configur safe proof let e arbitrari execut blowup defin e 1 infinit execut obtain repeat e forev definit blowup e 1 fair remain show configur e 1 safe assum way contradict configur c 0 e 1 safe construct finit circular execut e 0 whose sequenc atom step 0 obtain concaten sequenc mergea pr protocol weak exclus task e 0 set atom step never applic singl configur c e 0 reach contradict refut statement choos arbitrari enumer set contain n atom step n distinct processor execut e 0 construct first continu comput c 0 e configur c init reach appli lemma 4 extend e 0 consecut execut contain configur step b k applic end c init proof follow note execut e 0 repeat forev obtain infinit execut suffix le thu protocol pr even pseudo selfstabil see bgm90 proof lower bound complet follow theorem theorem 6 let pr selfstabil messagedriven protocol arbitrari weak exclus task system global timeout mechan everi execut e pr configur e distinct henc everi 0 size least one first configur e least dlog 2 te proof assum way contradict exist execut e pr configur distinct e contain circular subexecut e lemma 5 exist infinit execut e 0 pr obtain infinit repetit execut blowup never reach safe configur contradict prove similar lower bound system local timeout mechan definit circular execut must modifi remov messag non activ link construct infinit execut e proof theorem 6 may yield infinit execut processor enabl finit mani time order allow repetit finit execut form infinit fair execut everi processor activ infinit often requir finit execut contain atom step processor system need concept round execut let e 0 minim prefix execut e everi processor receiv messag e 0 first round e let 00 suffix e satisfi second round e first round prefix contain first atom step e let number round e next theorem present lower bound system equip local timeout mechan proof similar proof theorem 6 theorem pr selfstabil messagedriven protocol arbitrari weak exclus task system local timeout mechan everi execut e pr contain circular subexecut contain complet round conclud execut pr e first round contain least distinct configu ration henc everi 0 size least one configur e least dlog 2 particular fair execut configur size unbound 4 upper bound tokenpass task defin inform set execut singl token present entir system pass fairli among system processor tokenpass special case mutualexclus sinc possess singl token interpret permiss enter critic section reason tokenpass also satisfi weakexclus properti henc lower bound section 3 hold particular mean selfstabil messagedriven protocol pr tokenpass must use unbound resourc sinc infinit execut system size grow beyond bound section present three selfstabil tokenpass protocol system two proce sor protocol configur size grow everi execut rate match lower bound protocol easili adapt work ring arbitrari size without increas asymptot complex consid ring singl virtual link similar idea use adapt protocol arbitrari root tree system standard symmetri argument exist selfstabil determinist tokenpass protocol processor ident henc section assum system consist two distinct processor call sender receiv connect two link first link carri messag sender receiv second link carri messag receiv back sender receiv processor ident three protocol probabl simplest possibl finitest machin program copi messag receiv incom link outgo link without alter outsid world combin behavior receiv two link look like behavior singl queue whose head tail use receiv analysi ignor receiv consid system singl processor sender commun use singl link messag kept fifo order step sender consum messag head link put one messag back tail link token repres special symbol append messag protocol specifi messag carri token use explicitli token symbol protocol guarante eventu uniqu messag system append protocol assum initi least one messag link assumpt weaker global local version timeout mechan last assumpt requir link never becom empti equival requir whenev messag receiv least one messag sent henc everi step protocol sender receiv messag head singl link put one messag link end three protocol present protocol 1 protocol sender infinit state machin everi execut link capac unbound protocol 2 protocol sender infinit state machin infinit execut link capac bound bound specif execut depend initi configur protocol 3 protocol processor finit state machin forev 3 msg counter counter token arriv 4 begin send new token 5 counter msg counter 1 6 sendcount 8 els sendcount 9 end figur 1 protocol 1 protocol 1 sender appear figur 1 sender use variabl call counter messag consist present valu counter possibl token symbol whenev sender receiv messag whose counter valu msg counter smaller counter set counter msg counter send new valu counter togeth token otherwis sender send current valu counter without token token letter use protocol correct protocol base fact eventu valu counter larger valu appear messag present link initi configur asymptot size counter execut number messag sent detail proof omit 41 aperiod sequenc protocol 2 3 use follow method messag associ ternari number call color protocol consid messag whose color differ color previou messag carri token sender local variabl call token color given configur sender send sequenc messag whose color equal valu token color time sender wait messag whose color equal token color long sender receiv messag differ color send messag whose color equal token color sender receiv messag whose color equal token color choos new token color initi new sequenc messag whose color new token color send first messag new sequenc first messag carri virtual token sender continu send messag new token color without token receiv messag new token color goal reach configur link alway hold two consecut sequenc messag color messag sequenc equal everi step sender consum singl messag first sequenc whose color previou token color produc one messag whose color equal present token color last messag whose color previou token color consum link contain singl sequenc messag whose color token color next step sender receiv token carri sequenc send initi new sequenc messag whose color new token color describ configur exist singl token carri first messag sequenc whose color token color correct protocol follow fact sequenc tokencolor sent receiv aperiod defin sequenc 1 posit integ k sequenc eventu period suffix period aperiod eventu period aperiod sequenc integ f0 1 2g use ab89 order obtain self stabil data link protocol sequenc creat either random number gener infinit state machin first case algorithm random element sequenc use protocol ab89 whenev decid ternari number sent new messag paper aperiod sequenc gener use counter sequenc xor defin definit integ xori sum bit mod 2 binari represent eg 0 sequenc denot xor show later sequenc xor aperiod sender appear figur 2 improv protocol appear ab89 sens achiev lower bound previou section sens achiev lower bound previou section amount memori use produc aperiod sequenc address specifi ab89 protocol 2 forev token color token arriv 4 begin send new token 6 counter counter 1 8 sendtoken color 9 end figur 2 protocol 2 sender keep counter local memori whenev messag new color sent counter increment new color 2 f0 1 2g determin previou color appli xor counter roughli speak correct protocol impli fact sinc xor aperiod sequenc color gener sender aperiod well natur variabl correct proof protocol 2 easili deriv descript protocol 3 correct proof henc omit 42 inform descript protocol 3 present protocol 3 processor finit state machin easili observ aperiod sequenc suppli extern devic finit state machin use sequenc perform protocol ab89 construct use fact finit state machin augment previous describ fifo link gener aperiod sequenc finit state machin use link messagepass gener aperiod sequenc size kept within optim bound protocol 3 easili transform selfstabil data link protocol processor finit state machin protocol 3 appear figur 3 protocol messag pair color bit 1g local variabl color token color ternari variabl variabl counter bit counter xor carri new counter bit binari binari xor oper denot phi sequenc messag ns denot integ whose binari represent bit k bit least signific bit maxim sequenc consecut messag color sent sender call block block b nb denot integ describ jbj denot number messag b first messag block view token show protocol selfstabil prove eventu link contain exactli one messag first messag block goal achiev make sequenc color block aperiod sender use local variabl call token color denot color block send continu send messag color long color messag receiv differ token color sender receiv messag whose color equal token color eventu mean messag link belong block possibl send one last messag current block b chang valu token color c send first messag new block new color forev receivecolorcount bit token color token arriv new token 6 token color color 7 counter xor 0 9 end counter xor counter xor phi counter bit new counter bit carri phi counter bit carri carri counter bit send token colornew counter bit 14 end figur 3 protocol 3 lemma 8 show everi execut sender initi infinit mani block sequenc block initi sender color b integ repres nb defin protocol design follow properti kept p1 sequenc colorb 1 p2 everi larg enough nb bit field last messag b nb const constant const represent nb b lead zero impli jb prove p1 impli eventu one token system p2 guarante size system logarithm number step show protocol inde satisfi p1 p2 describ two rule sender comput bit color send need follow definit 1 denot k sequenc messag whose color differ receiv sender send block b k ns k integ repres k note k consist one complet block rule 1 rule comput counter bit counter bit sent messag sent k nb k eg word counter bit sent block b k obtain ad 1 binari number repres messag receiv block sent rule 2 rule comput token color receiv messag whose color equal valu token color new valu token color color next block b k1 determin follow colorb k1 note rule 1 implement binari adder set zero initi new block rule 2 implement counter mod 2 thu rule easili implement finit state machin 43 correct complex proof protocol 3 lemma 8 everi fair execut e sender initi infinit number block proof sender initi new block whenev receiv messag whose color equal current valu token color everi atom step sender receiv messag whose color equal token color send messag say whose color token color sinc link carri messag fifo order messag eventu receiv sender initi new block later upon receipt lemma follow configur execut call limit configur next step sender new token color comput color next arriv messag equal present valu token color observ limit configur c link contain finit possibl zero number complet block one possibl incomplet block tail link block may incomplet sinc upon receipt next messag sender may send one messag block execut line 5 code first block color last possibl incomplet block execut e denot k index kth limit configur e word c k limit configur b k initi next prove number block consecut limit configur increas lemma 9 let k number block limit configur c k includ possibl incomplet block k k1 equal k singl block number block k subexecut start c k end c k1 one block ad link name b k k block k remov therefor next show number block limit configur must eventu get one first need technic lemma lemma 10 sequenc xor aperiod b let 1 delta eventu period sequenc let b sequenc delta also eventu period c let 1 delta eventu period sequenc sequenc delta also eventu period proof assum contradict sequenc xor eventu period exist st q nonneg integ 2 q let integ satisfi q consid follow case 1 definit hold xor2 thu thu exist b 1 b 2 xorb contradict b claim trivial c let j j everi p 1 hold k kp thu sequenc ai p eventu period period length lemma 11 everi fair execut e exist suffix number block limit configur alway one proof lemma 9 number never increas henc eventu remain l constant l 0 forev shall assum l 1 deriv contradict call limit configur c k ultim k number block c k l c k ultim henc lemma 9 k singl block must b kgammal thu first block follow k b kgammal1 protocol b k termin sender receiv messag whose color equal color b k therefor color messag block b kgammal1 equal color messag b k henc sequenc eventu period period length way colorb k1 comput ultim configur c k xornb eventu period bxor shall deriv contradict show sequenc bxor aperiod impli order show bxor aperiod suffici show posit p sequenc bxori delta aperiod observ ultim configur c k must hold nb k 1 henc integ thu bxoril suffix sequenc xor aperiod lemma 10 henc bxoril also aperiod yield desir contradict lemma 11 proof impli properti p1 p2 hold properti p1 hold sinc proof lemma 11 show sequenc color aperiod properti p2 prove follow let e 0 suffix e satisfi lemma 11 let c k limit configur e 0 rule 1 nb easili impli p2 show space complex protocol 3 inde match lower bound previou section sinc number state processor number distinct messag protocol constant size configur proport number messag therefor bound size configur enough bound number messag next lemma show execut delta protocol size ith configur e c olog 2 let denot kth limit configur e let b k correspond block shall prove jb k lemma 12 everi larg enough k number messag limit configur c k dlog 2 proof lemma 11 exist suffix e 0 e everi limit configur contain one block clearli suffic prove lemma e 0 observ properti p2 eventu hold everi limit configur e 0 lemma follow corollari 13 number messag c th configur e olog 2 proof let e 0 suffix e lemma 12 assum larg enough c belong e 0 number messag c equal number messag next limit configur c k olog 2 k proof complet observ sinc j j j sinc configur c preced c e 44 larger system describ use protocol direct ring two processor processor ring denot p receiv whenev processor p messag p send similarli whenev p n receiv messag p send p 1 thu ring behav like virtual link sender p 1 hard see exist singl messag entir ring prevent commun deadlock thu assum timeout mechan guarante condit timeout mechan invok recov initi deadlock configur prove way similar previou proof protocol guarante eventu exactli one token encircl ring sender actual protocol use connect system hardwir direct ring span entir system 45 construct token control subsect defin queue machin token control interpret result term queue machin q finit state machin equip queue initi contain nonempti word sigma finit alphabet sigma step comput q perform follow read delet letter head queue b add zero letter sigma tail queue c move new state comput termin q halt queue becom empti prevent q perform step main differ queue machin variou type ture machin input alphabet work alphabet queue machin ident reason queue machin perform simpl task like decid length input word even decid whether input word contain specif letter 2 defin token control special type queue machin assum alphabet sigma contain specifi subset token letter queue machin token control start nonempti queue arbitrari content eventu queue contain exactli one occurr letter forev priori clear token control exist observ token control exist queue never becom empti sinc queue empti remain forev importantli token control exist never halt sinc guarante upon halt queue contain exactli one occurr token letter last two observ impli token control view special case tokenpass system sigma set messag sent protocol set messag carri token show transform sender protocol 3 token control defin alphabet sigma set triplet color bit color bit protocol 3 either case messag carri token ie first messag block nil case set defin set possibl triplet whose third compon two antiparallel fifo link sender receiv consid singl queue receiv messag regard delet letter head queue send messag regard append messag end queue sinc protocol 3 guarante eventu exactli one messag everi configur carri token queue machin describ token control moreov lower bound result impli tokencontrol optim respect rate size queue grow stabil simul share memori section present method simul selfstabil sharedmemori protocol selfstabil messagedriven protocol simul protocol assum variant queue machin use arbitrari work alphabet fact oblivi ture machin power standard ture machin sharedmemori model defin dim90 model commun neighbor carri use twoway link link implement two share regist support read write atom oper processor p read one regist write function revers p j implement system everi link simul two direct link one p p j p j p heart simul selfstabil implement read write oper propos simul implement oper use selfstabil tokenpass protocol pair neighbor run protocol two link connect order implement selfstabil tokenpass protocol need defin link processor act sender processor act receiv assum processor distinct identifi everi messag sent processor carri identifi processor eventu processor know identifi neighbor link processor larger identifi act sender processor act receiv sinc pair neighbor use differ instanc protocol separ timeout mechan need everi pair word correct oper simul requir pair neighbor exist least singl messag one two link connect neighbor describ simul arbitrari link e connect p share memori model e implement regist r ij p write p j read regist r ji role revers simul protocol processor p local variabl call r ij r ji keep valu r ij r ji respect everi token addit field call valu everi time p receiv token p j current valu r ij valu field token write oper p r ij simpli implement local write r ij read oper p r ji implement follow step 1 receiv token p j 2 p receiv anoth token p j valu read valu attach second token correct simul prove show everi execut e whose initi configur contain least one messag link possibl linear simul read write oper execut e eventu everi simul read oper r ij return last valu written ie protocol simul execut sharedmemori model regist eventu atom see la86 defin time simul write oper r ij time local write oper r ij execut defin time simul read oper p j r ij time p send valu local variabl r ij attach token later reach p j step 2 simul read link hold singl token oper regist r ij linear everi read oper r ij return last valu written r ij acknowledg thank alan feket help remark r selfstabil alternatingbit protocol selfstabil token system stabil pseudo stabil uniform selfstabil ring note reliabl fullduplex transmiss halfduplex link selfstabil ring without demon selfstabil system spite distribut control selfstabil system spite distribut control ewd391 self stabil dynam system assum readwrit atom resourc bound self stabil messag driven protocol uniform dynam selfstabil leader elec tion token surviv stabil commun protocol token manag scheme random walk yield self stabil mutual exclus selfstabil ring orient selfstabil extens messagepass system selfstabil spite distribut control treestructur system time clock order event distribut system solv problem unsolv problem nonproblem concurr interprocess commun part basic formal toward theori selfstabil protocol tr ctr rodney r howel mikhail nesterenko masaaki mizuno finitest selfstabil protocol messagepass system journal parallel distribut comput v62 n5 p792817 may 2002 kleoni ioannid transform selfstabil algorithm journal high speed network v14 n1 p85105 januari 2005 bertrand ducourthi sbastien tixeuil selfstabil path algebra theoret comput scienc v293 n1 p219236 3 februari paolo boldi sebastiano vigna univers dynam synchron selfstabil distribut comput v15 n3 p137153 juli 2002