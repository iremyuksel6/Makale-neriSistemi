design mask faulttoler via nonmask faulttoler abstractmask faulttoler guarante program continu satisfi specif presenc fault way contrast nonmask faulttoler guarante mere guarante fault stop occur program execut converg state program continu resatisfi specif present paper compon base method design mask faulttoler program method compon ad faultintoler program stepwis manner first transform faultintoler program nonmask faulttoler one enhanc faulttoler nonmask mask illustr method design program agreement presenc byzantin fault data transfer presenc messag loss tripl modular redund presenc input corrupt mutual exclus presenc process failstop exampl also serv demonstr method accommod varieti faultclass provid altern design program usual design extant design method offer potenti improv mask faulttoler program b introduct paper present new method design mask faulttoler system 14 focu attent mask faulttoler often desir ideal properti system design mask effect fault ensur system alway satisfi problem specif henc user system alway observ expect behavior token user system system design system becom simpler motiv design method note design mask faulttoler system often face potenti conflict constraint maxim reliabl minim overhead result design avoid method yield complex design sinc complex may result reduc reliabl moreov avoid method yield ineffici implement sinc system user gener unwil pay signific cost price perform sake mask faulttoler therefor key goal method yield wellstructur henc reliabl system still offer potenti effici implement goal method includ abil deal varieti faultclass abil provid design albeit altern one mask toler system typic design use classic method replic except handl recoveri block goal mind method base use compon add toler properti faultintoler system divid complex design faulttoler system design rel simpler compon ad compon fault intoler system focus attent effici implement compon offer potenti effici implement result system call compon ad first stage corrector ad second stage detector effici implement corrector detector import note offer potenti effici mask faulttoler implement manag complex ad compon system method proce stepwis fashion inform speak instead ad compon ensur problem specif satisfi presenc fault method add compon two stage first stage method mere add compon nonmask faulttoler nonmask faulttoler intuit mean fault stop occur system execut eventu reach good state system continu satisfi problem specif second stage method add compon addit ensur problem specif violat program reach good state follow faulttoler system enhanc nonmask mask compon base design prove correct result composit system need ensur compon interfer ie continu accomplish task even execut concurr compon end first stage ensur faultintoler system corrector ad interfer second stage ensur result nonmask faulttoler system detector ad interfer demonstr method accommod varieti faultclass use design program mask faulttoler byzantin fault input corrupt messag loss failstop failur specif design 1 byzantin agreement program whose process subject byzantin fault 2 alternatingbit data transfer program whose channel messag may lost 3 tripl modular redund tmr program whose input may corrupt 4 new tokenbas mutual exclus program whose process may failstop detect manner tmr byzantin agreement exampl also serv provid altern design program usual associ method replic alternatingbit protocol exampl serv provid altern design program usual associ method except handl rollback recoveri mutual exclus case studi serv demonstr focus addit effici compon method enabl design improv program proceed follow first section 2 recal formal definit program fault mean program mask nonmask faulttoler section 3 present twostag method design mask faulttoler next section 4 illustr method design standard mask faulttoler program byzantin agreement data transfer tmr section 5 present case studi design mask faulttoler tokenbas mutual exclus final compar method extant method design mask faulttoler program make conclud remark section 6 program fault mask nonmask toler section recal formal definit mask nonmask faulttoler program 5 order character relationship two toler type motiv design method present section 3 program program p defin recurs consist possibl empti program q set superposit variabl set superposit action superposit variabl p disjoint remain variabl p name variabl q superposit action p one two form hnamei hguardi gamma hstatementi hnamei haction qi k hstatementi guard boolean express variabl p thu evalu guard may involv access variabl q note guard action p particular guard action second ie k form correspond action q statement atom termin updat zero superposit variabl p thu superposit action first form updat variabl q wherea second may sinc base action q note sinc statement p updat variabl q action p updat variabl q action q thu program design superposit variabl action underli program 6 superposit action may access updat underli variabl wherea underli action may access updat superposit variabl oper speak superposit action first form execut independ asynchron action second form execut parallel synchron underli action base upon state state program p defin valu variabl p chosen predefin domain variabl state predic p boolean express variabl p action p enabl state iff guard true state use term state denot state satisfi state predic closur action preserv state predic iff state hold action enabl execut statement action instantan parallel yield state hold close set action iff action set preserv follow definit close action p execut sequenc action p start state hold yield state hold comput comput p fair maxim sequenc step everi step action p enabl current state chosen statement instantan execut parallel recal action second form consist multipl statement compos parallel fair sequenc mean action p continu enabl along state sequenc eventu chosen execut maxim sequenc mean sequenc finit guard action p fals final state problem specif problem specif p satisfi consist safeti specif live specification7 safeti specif identifi set bad finit comput prefix appear program comput dualli live specif identifi set good comput suffix everi comput suffix set assum problem specif suffix close ie comput satisfi problem specif suffix remark definit live stronger alpern schneider definit 7 two definit becom ident live specif fusion close ie comput hff x fli hfi x ffii satisfi live specif comput hff x ffii hfi x fli also satisfi live specif ff fi finit comput prefix fl ffi comput suffix x program state invari invari p state predic 6fals close p everi comput p start state satisfi problem specif p inform invari p includ state reach faultfre execut p note may multipl invari techniqu design invari articul dijkstra 8 use notion auxiliari variabl gri 9 use heurist state predic balloon shrink techniqu mechan calcul invari discuss alpern schneider 10 converg state predic q converg r p iff q r close p start state q hold everi comput p state r hold note convergesto relat transit lemma 21 q converg r p everi comput p start state r hold satisfi live specif everi comput p start state q hold satisfi live specif proof consid comput c p start q state sinc q converg r p c suffix c 1 start r state sinc everi comput p start r state satisfi live specif c 1 suffix c 2 identifi live specif also suffix c follow c also satisfi live specif thu everi comput p start q state satisfi live specif fault fault program subject systemat repres action whose execut perturb program state emphas represent possibl notwithstand type fault stuckat crash failstop omiss time perform byzantin natur perman transient intermitt observ detect repair correct case represent fault introduc auxiliari variabl exampl repres failstop fault state perturb introduc auxiliari variabl action restrict execut true failstop fault repres action chang true fals therebi disabl action detect manner moreov repair failstop program repres fault action chang fals true initi state j initi may retain state process failstop provid inform nonvolatil storag may initi predetermin valu ignor detail depend problem hand word failstop repair fault respect repres follow fault action failstop gamma fals repair gamma true f initi state process g repres byzantin fault state perturb introduc auxiliari variabl b specifi action program restrict execut b fals ie program nonbyzantin b true ie program byzantin program allow execut action chang state arbitrarili thu byzantin fault repres action chang b fals true therebi enabl program enter mode execut action chang state arbitrarili word byzantin fault repres follow byzantin b gamma b true faultspan faultspan program p faultclass f predic close p f inform faultspan includ set state p reach execut presenc action f note p may multipl faultspan f program p invari subject faultclass f result state p may longer satisfi howev state satisfi faultspan p say moreov everi state also satisfi faulttoler mask nonmask readi give formal definit faulttoler 5 instanti definit yield definit mask nonmask faulttoler let p program f set fault action invari p say p f toler iff exist state predic p follow three condit hold closur close p f converg converg p definit may understood follow state invari hold execut action p yield state continu hold execut action f may yield state hold nonetheless follow three fact true last faultspan hold ii subsequ execut action p f yield state hold iii action f stop execut subsequ execut action p alon eventu yield state hold point program resum intend execut definit instanti faultspan ident invari get p mask f toler definit instanti differ get p nonmask f faulttoler rest paper predic p denot invari program p moreov predic p denot faultspan predic program p f toler p final faultclass f clear context omit mention f thu mask toler abbrevi mask f toler 3 method design mask toler definit previou section observ mask nonmask faulttoler relat follow theorem 31 program p exist p p p nonmask f toler p everi comput p start state p hold satisfi safeti specif p exist p p mask f toler p proof let np np state predic satisfi anteced everi comput p start state np hold satisfi problem specif start state np hold satisfi safeti specif lemma 21 follow everi comput p start np state satisfi problem specif thu choos p np satisfi consequ method theorem 31 suggest intoler program made mask toler two stage first stage intoler program transform one nonmask toler say invari np faultspan np second stage toler result program enhanc nonmask mask follow nonmask toler program transform everi comput upon start state np hold addit eventu reach state np hold also satisfi safeti specif problem hand address detail stage next stage 1 faultintoler program say p problem specif satisfi comput p start state invari hold necessarili start state faultspan hold henc add nonmask toler p program compon ad p restor faultspan state invari state call program compon ad p nonmask toler corrector wellknown exampl corrector includ reset procedur rollbackrecoveri forward recoveri error correct code constraint resatisfact voter except handler altern procedur recoveri block design corrector studi extens literatur note corrector design stepwis hierarch fashion word larg corrector design parallel andor sequenti composit small corrector one simpl parallel composit strategi superpos small corrector other exampl sequenti composit strategi due arora gouda varghes 11 order small corrector linear manner gener wellfound manner corrector interfer recoveri task corrector lower chosen order detail discuss corrector composit refer reader 12 stage 2 nonmask program say np even though problem specif satisfi comput np converg invari state safeti specif need satisfi comput np start faultspan state therefor second stage restrict action np safeti specif preserv converg comput np invari state theorem 31 follow result program mask toler see restrict action np suffici preserv safeti converg recal safeti specif essenti rule certain finit prefix comput np consid prefix comput np rule safeti specif execut action follow prefix increas length comput prefix one long elong prefix one prefix rule safeti specif safeti violat word suffic whenev action execut result prefix one rule safeti specif follow exist action np set comput prefix execut action preserv safeti specif assum exist auxiliari state worst case would record histori comput step action np exist state predic true exactli state execut action preserv safeti call state predic safe predic action follow action execut state safe predic satisfi safeti preserv restrict action np enhanc toler np mask state precis action np restrict execut safe predic hold moreov action np detect safe predic may requir addit program compon np call program compon ad np detect safe predic action hold detector wellknown exampl detector includ snapshot procedur accept test error detect code compar consist checker watchdog program snooper program except condit analog composit design larg corrector larg detector design stepwis hierarch fashion parallel andor sequenti composit small detector thu sum second stage add one detector per action np restrict action np execut detector action wit safe predic hold conclud discuss stage make three observ applic 1 safe predic sever program action trivial true 2 safe predic action requir simpl detector compon introduc littl histori state check safe predic 3 problem specif fusion close suffix close histori state requir check safe predic observ 1 follow fact action mask toler program conceptu character either critic noncrit respect safeti specif critic action action whose execut presenc fault violat safeti specif henc requir nontrivi safe predic word safe predic noncrit action mere true exampl termin program eg feedforward circuit databas transact action produc output commit result critic reactiv program eg oper system plant control action control progress maintain safeti critic rich class total program distribut system 13 eg distribut consensu infima find garbag collect global function comput reset rout snapshot termin detect decid action declar outcom comput critic observ 2 follow fact convent specif languag typic yield safeti specif test current state current comput step ie set finit prefix safeti specif rule deduc last last two state comput prefix thu safeti specif practic requir mainten unbound histori variabl detect safe predic action observ 3 follow fact problem specif fusion close suffix close requir histori inform alreadi exist current state proof observ present 12 verif oblig addit corrector detector compon describ may add variabl action intoler program henc invari faultspan result program may differ origin program addit corrector detector compon thu creat verif oblig design specif corrector ad intoler program design ensur corrector action intoler program action interfer even corrector faultintoler program execut concurr accomplish task corrector restor intoler program state problem specif intoler program resatisfi start state intoler program satisfi problem specif similar oblig creat detector ad nonmask program even detector nonmask program execut concurr design ensur detector compon compon nonmask program accomplish respect task anoth set verif oblig due fact corrector detector compon subject fault intoler program subject henc design oblig show compon accomplish task spite fault precis corrector toler fault ensur fault action stop execut eventu restor program state desir word corrector nonmask toler fault detector toler fault never fals wit detect predic even presenc fault word detector mask toler fault expect twostag design method use design mask toler detector origin design yield mask toler detector ad detector compon superposit one way simplifi verif oblig add compon program superpos program program p design superposit program q trivial true p interfer q although convers need true ie q may interfer p particular superposit wellsuit addit detector compon nonmask toler program np stage 2 sinc detector need read updat state np reason state definit program section 2 term superposit thu detector interfer task corrector compon np superposit use verif convers oblig ie np interfer detector may handl follow ensur corrector np termin restor np invari state long termin prevent detector wit safe predic abort detector execut corrector guarante detector never wit safe predic incorrectli eventu termin corrector guarante eventu detector prevent wit safe predic specif simplifi verif oblig result superposit explain theorem 32 33 let program p design superposit q p q theorem 32 q nonmask f toler q p converg q p theorem 33 q nonmask f toler q converg p p converg p p proof sinc q nonmask faulttoler q converg q q sinc p design superposit q follow p q converg p q sinc convergesto relat transit p q converg p q follow p q converg p q ie converg p p theorem 32 33 impli p design superposit nonmask toler program q reason p suffic assum q alway satisfi invari q even presenc fault discuss altern strategi verifi interfer freedom refer reader 12 section demonstr method well suit design classic exampl mask toler span varieti faultclass specif exampl mask toler achiev byzantin agreement presenc byzantin failur data transfer presenc messag loss network channel tripl modular redund tmr presenc input corrupt notat conveni present design partit action program process 41 exampl agreement recal byzantin agreement problem uniqu process gener g assert binari valu dg everi process j system requir eventu final decis follow two condit hold 1 g nonbyzantin final decis reach everi non byzantin process ident dg 2 even g byzantin final decis reach nonbyzantin process ident fault corrupt process perman undetect corrupt process byzantin well known mask toler byzantin agreement possibl iff least 3f1 process f number byzantin process 14 eas exposit restrict attent case total number process includ g 4 henc f 1 gener multipl byzantin fault present elsewher 15 prescrib method design mask toler solut byzantin agreement problem two stage start intoler program byzantin agreement first transform program add nonmask toler subsequ enhanc toler mask intoler byzantin agreement follow simpl program suffic agreement toler fault process g assum priori final decis dg process j g receiv valu dg process g final decis valu end program maintain two variabl process j boolean fj true iff j final decis dj whose valu denot decis j program two action process j first action ib1 copi dg decis variabl dj denot j yet copi dg add special valu domain dj thu j copi dg dj second action ib2 final decis dj j copi decis truthifi fj formal action intoler program ib follow invari program ib g priori final decis moreov process final decis dj differ final decis nonbyzantin process ident dg henc invari program ib ib fault action fault exampl make one process byzantin provid process byzantin discuss section 2 fault would repres follow fault action j nonmask toler byzantin agreement program ib intoler g becom byzantin process final decis g may keep chang dg arbitrarili henc final decis reach nonbyzantin process may differ add nonmask toler ib eventu decis reach nonbyzantin process ident sinc ib eventu reach state decis process differ ie 0 1 follow eventu decis least two three process g ident henc process ensur decis major result program nonmask toler nonmask toler program consist four action process j first two ident action ib third action nb3 execut j byzantin action nondeterminist chang dj either 0 1 fj either true fals fourth action nb4 chang decis j major three process formal action nonmask program nb follow gamma dj fj 0j1 truejfals majdefin dj 6maj gamma dj maj majdefin remark formula oper may read valu obtain perform commut associ oper xj valu j case j process satisfi rj special case oper conjunct oper disjunct may read rj true xj may read exist process rj xj true moreov rj true ie xj comput process omit rj notat gener 16 invari faultspan program ib program nb nonbyzantin process final decis dj 6 also g remain nonbyzantin nonbyzantin process reach decis valu process g henc faultspan nb tnb observ g nonbyzantin start state tnb nonmask program work correctli also g byzantin nonmask program work correctli start state process correctli final decis henc invari program nb enhanc toler mask program nb yet mask toler non byzantin process j may first final decis incorrectli later correct decis major process henc enhanc toler nb mask suffic j final decis dj major mask program thu consist four action process j three action ident action nb1nb3 nb4 fourth action mb2 restrict j final decis dj major formal action mask program mb follow majdefin dj maj gamma fj true invari faultspan nonmask program tnb impli invari smb mask program also smb j final decis dj major thu smb theorem 41 byzantin agreement program mb mask faulttoler invari smb 42 exampl 2 data transfer recal data transfer problem infinit input array sender process copi one array item time infinit output array receiv process sender receiv commun via bidirect channel hold one messag direct time requir input array item copi output array exactli order sent moreov eventu number item copi receiv grow unboundedli data transfer subject fault lose channel messag design mask toler data transfer two stage result program well known alternatingbit protocol intoler program iter simpl loop follow sender send copi one array item receiv r upon receiv item r send acknowledg enabl next array item sent end program maintain binari variabl rs rr rs 1 receiv acknowledg last item sent rr 1 r receiv item yet sent acknowledg 0 1 item transit r denot sequenc cs 0 1 acknowledg transit r denot sequenc cr final index input array correspond item send next denot ns index output array correspond item r last receiv denot nr intoler program contain four action first two last two r id1 send item r id2 receiv acknowledg r id3 r receiv item id4 r send acknowledg formal action intoler program id follow c1 ffi c2 denot concaten sequenc c1 c2 id2 cr 6hi gamma rs cr ns ns remark breviti ignor actual data transfer sender receiv use array index data invari r receiv item ns hold equat continu hold receiv acknowledg receiv acknowledg ns exactli one larger nr equat continu hold r receiv next item also cs nonempti cs contain one item hnsi final state exactli one four action enabl henc invari program id id rs fault action fault exampl lose either item sent r acknowledg sent r correspond fault action follow cs 6hi gamma cs tailc cr 6hi gamma cr tailcr nonmask toler program program id intoler deadlock fault lose item acknowledg henc add nonmask toler fault ad action detect item acknowledg lost recov id retransmit item thu nonmask program consist five action four action ident action program id fifth action retransmit last item sent action execut channel cs cr empti rs rr zero practic action implement wait predetermin timeout sender sure either item acknowledg lost present abstract version action formal action nonmask program nd follow gamma cs cs ffi hnsi faultspan invari item acknowledg lost program reach state cs cr empti rs rr equal zero also even presenc fault cs nonempti contain exactli item whose index input array hnsi thu faultspan nonmask program rs invari invari id ie enhanc toler mask program nd yet mask toler sinc r may receiv duplic item acknowledg r lost henc enhanc toler mask need restrict action id3 r copi item output array iff duplic upon receiv item r check nr exactli one less index number receiv item r receiv everi item exactli thu enhanc toler mask ad check program nd howev check forc size messag sent r grow unboundedli howev exploit fact nd ns nr differ 1 order simul check send singl bit item follow process add one bit bs everi item send bit valu ad two consecut item differ bit valu ad item duplic thu detect messag duplic r maintain bit br denot sequenc number last messag receiv follow item receiv r duplic iff br sequenc number messag mask program consist five action action follow gamma rs cs 0 cs ffi hn bsi md2 cr 6hi gamma rs cr ns bs ns gamma cs cs ffi hn bsi gamma headc 2 6br cs rr tailc 1 gamma remark observ mask program array index ns nr need sent channel suffic send bit bs br modif result program altern bit protocol invari state reach presenc program fault action cs nonempti cs exactli one item hn bsi also r receiv item nr ns hold equat continu hold receiv acknowledg moreov bs ns mod 2 br nr mod 2 exactli one five action enabl final nr ns nr one less ns thu invari mask program smd rs bsn mod ns theorem 42 alternatingbit program md mask toler invari smd 43 exampl 3 tmr recal tmr problem three process share output binari valu input inj process j requir output set binari valu fault corrupt input valu one three process intoler tmr absenc fault suffic set inj process j henc action program ir process j follow denot output yet set fault action exampl fault corrupt input valu inj one process repres follow fault action one j k also rang nonmask tmr program ir intoler sinc may set incorrectli corrupt inj therefor add nonmask toler ir add corrector eventu correct sinc one inj corrupt correct output differ one inj henc differ inj two process corrector reset inj valu two thu nonmask program nr consist two action process j action nr1 ir1 action nr2 corrector formal two action follow phi denot modulo 3 addit gamma inj gamma inj enhanc toler mask program nr yet mask toler sinc may set incorrectli correct therefor enhanc toler mask restrict action nr1 output alway set uncorrupt inj safe predic restrict action nr1 restrict action nr1 safe predic yield stronger version action nr2 thu result mask toler program mr consist one action j gamma inj invari program mr equal inj j exist anoth process whose input valu inj henc invari program mr smr theorem 43 tripl modular redund program mr mask toler invari smr section design new improv mask toler solut mutual exclus problem use twostag method recal mutual exclus problem multipl process may access critic section provid time one process access critic section moreov process wait forev access critic section assum process leav critic section finit time assum process uniqu integ id instant process either process execut program action action execut process j may involv commun process connect j via channel channel bidirect fault failstop one process ie render process failstop may occur finit number order time process long set process remain connect one class solut mutual exclus base token tokenbas solut uniqu token circul process process enter critic section necessarili token ensur process wait forev token fair strategi chosen process request access critic section eventu receiv token eleg tokenbas program independ due raymond 17 snepscheut 18 program use fix tree circul token case studi organ follow section 51 recal abstract version intoler mutual exclus program raymond snepscheut section 52 transform faultintoler program nonmask toler one ad corrector final section 53 enhanc toler mask ad detector result solut compar mask toler tokenbas mutual exclus solut next section 51 faultintoler program process organ tree process j maintain variabl pj denot parent j tree variabl hj denot holder process j neighbor j direct process token variabl requestj denot set request receiv neighbor j tree pend j program consist three action process first make propag holder process request get token second transmit token satisfi pend request neighbor third access critic section hold token action follow j need request critic section requestj 6 oe gamma gamma hk hj j j requestk gamma access critic section action maintain holder relat form direct tree root process token holder relat moreov conform parent tree ie k holder adjac tree thu invari faultintoler program im j p n 52 nonmask toler version presenc fault parent tree use im may becom partit result holder relat may also becom inconsist moreov token circul im may lost eg process token ie whose holder equal failstop henc add nonmask toler failstop need add corrector restor parent tree holder tree build corrector superpos two corrector nt correct parent tree nh correct holder tree particular ensur presenc failstop eventu parent tree construct holder relat ident parent relat henc root process token 521 design corrector nt parent tree corrector reconstruct parent tree reus arora program 19 tree main tenanc program allow fault yield program state multipl tree unroot tree continu execut program ensur converg fixpoint state exactli one root span tree deal multipl tree program action merg tree merg action use integ variabl rootj denot id process j believ tree root follow process j merg tree neighbor process k rootk rootj upon merg j set rootj equal rootk pj k also j align holder relat along parent relat set hj k observ merg thu cycl form root valu process remain root valu parent merg action enabl follow root process root valu deal unroot tree program action inform process unroot tree root process action use variabl colj denot color j follow process detect parent fail color parent red process set color red leaf process obtain color red separ tree reset color green thu form tree consist leaf separ tree align holder relat along parent relat set holder formal action corrector nt process j follow adjj denot set neighbor process j gamma colj red gamma pj rootj hj k rootk k fault action formal failstop action process j follow failstop upj gamma upj fals faultspan invari presenc fault action nt preserv acycl graph parent relat well fact root valu process root valu parent also preserv fact process color red parent also color red thu faultspan corrector nt predic tnt graph parent relat forest fault stop occur eventu program ensur process color red children color red ie process unroot tree color red furthermor program reach state process color green ie process unroot tree final graph parent relat form root span tree particular root valu process ident remark henceforth breviti use term chj denot children j term j root denot parent j j colj green j term nbrsx denot set process adjac process set process x includ x formal j root j pj j colj green upj 522 design corrector nh holder tree parent tree reconstruct holder relat may still inconsist two way 1 holder j need adjac j parent tree 2 holder j may adjac j tree holder relat form cycl henc corrector nh restor holder relat consist two action action nh1 correct holder j 1 hold set hj pj action nh2 correct holder j 2 hold parent k j holder j k holder k j j break cycl set hj pj net effect execut action eventu holder relat ident parent relat henc root process token gamma hj pj gamma hj pj faultspan invari corrector nh ensur holder j adjac j parent tree everi edg j pj parent tree either hj pj hpj j thu nh correct program state 523 ad corrector verifi interfer freedom describ earlier corrector add im built superpos two corrector nt nh nh updat holder relat nt read holder relat therefor nh interfer nt also nt reconstruct tree satisfi snt none action enabl therefor nt interfer nh im updat variabl read nt therefor im interfer nt also nh reconstruct holder relat satisfi predic snh1 j snh2 j process j snh1 j snh2 j respect preserv im therefor im interfer nh final tree holder relat reconstruct nt snh satisfi action nt nh disabl therefor nt nh interfer im follow corrector consist nt nh ensur state satisfi nt snh reach even execut concurr im sinc nt snh may add corrector im obtain nonmask toler program nm whose action process j follow faultspan invari invari program nm conjunct snt snh thu invari nm faultspan program nm equal tnt ie theorem 51 mutual exclus program nm nonmask faulttoler snm 53 enhanc toler mask action nm5nm7 nm8 affect safeti program execut process execut set holder therebi gener new token safe predic hold gener token therefor condit process token toward detect safe predic exploit fact nm nonmask toler token lost nm eventu converg state graph parent relat root tree holder process parent henc suffic check whether program state perform check let j initi diffus comput whenev j execut action nm5nm7 nm8 j complet diffus comput success safe gener token action nm2 nm3 respect let process k transmit token process j critic section affect safeti program execut involv spuriou token gener presenc failstop safe predic hold action execut would certifi token spuriou toward detect safe predic exploit fact failstop detect fault henc let failstop process forc neighbor process particip diffus comput recal new token safe gener diffus comput complet defin safe predic nm2 k particip diffus comput action nm3 j particip diffus comput observ safe predic detect perform first set action nm5nm7 nm8 global involv state process wherea safe predic detect perform second set action nm2 nm3 local design separ detector set action superposit detector nm yield mask faulttoler program 531 design global detector gd discuss global detector gd use diffus comput check process token root process initi diffus comput upon initi root propag diffus comput children child likewis propag comput children conveni think propag propag wave leaf process receiv propag wave complet respond parent upon receiv respons children parent leaf likewis complet respond parent conveni think complet complet wave complet wave process respond parent result denot whether subtre root process token thu root receiv complet wave decid whether process token inspect result diffus comput complic follow situat multipl root process may initi diffus comput concurr process may failstop diffus comput progress process may receiv token respond parent diffus comput token deal concurr initi let diffus comput highest id process complet success other abort forc complet result fals specif process propag diffus comput observ anoth diffus comput initi higher id process start propag latter abort former diffus comput set result former parent process receiv former diffus comput fals ensur former parent complet diffus comput lower id process result fals deal failstop process abort diffus diffus comput neighbor process may propag specif j wait repli k complet diffus comput k failstop j decid descend k token henc upon detect failstop k j abort diffus comput set result fals final deal potenti race condit diffus comput miss token token sent process alreadi complet diffus comput result true ensur even occur diffus comput complet initi result fals toward end modifi global detector follow process complet diffus comput result true neighbor propag diffus comput variabl result maintain fals process ever token sinc last diffus comput propag see modif work consid first process say j receiv token complet diffus comput result true let l denot process sent token j follow l least propag diffus comput result fals moreov sinc j first process receiv token complet diffus comput result true l complet diffus comput result fals sinc result l propag toward initi diffus comput complet wave initi guarante complet diffus comput result fals sum diffus comput deal complic via abort mechan set result appropri process fals fail appropri diffus comput initi diffus comput complet result fals start yet anoth diffus comput toward end diffus comput provid initi mechan let root process initi new diffus comput distinguish differ comput initi process let process maintain sequenc number increment everi diffus comput furthermor process propag new diffus comput reset result true provid token discuss process j need maintain phase phasej sequenc number snj result resj phase j either prop comp denot whether j propag diffus comput complet diffus comput sequenc number distinguish success diffus comput initi root process final result j denot whether j complet diffus comput correctli abort diffus comput action global detector global detector consist four action viz init prop comp abort init let process j initi diffus comput increment sequenc number specifi statement init condit j execut init specifi later propag diffus comput j pj tree snj differ snpj holder relat j align along parent relat pj propag phase j propag diffus comput set result true otherwis complet diffus comput result fals comp let j complet diffus comput children complet diffus comput neighbor propag complet diffus comput result comput j set true iff result return children true neighbor j propag diffus comput result j true root complet diffus comput result true safe predic detect root process proceed safe gener new token consequ chang result fals abort let j complet diffus comput prematur result fals j abort diffus comput j also set result parent fals ensur parent j complet diffus comput result fals specifi statement condit j execut abort specifi later formal action detector gd process j follow init j pj j phasej snj prop newseq resj true gamma snj snpj phasej resj prop true els resj fals comp j phasej prop gamma resj pj els pj j resj resj fals pj 2adjj respj fals remark abort action j synchron updat state parent addit action refin sinc parent j complet diffus comput j complet diffus comput j updat state pj read state j later fault action process failstop neighbor abort diffus comput propag moreov initi abort diffus comput initi new one henc fault action denot statement xl execut process satisfi rl gamma upj fals invari releg invari sgd global detector appendix a1 532 design local detector ld safe predic action nm2 k particip diffus comput comp safe predic action nm3 j particip diffus comput phasej comp therefor action modifi follow gamma hk hj j j requestk gamma access critic section 533 ad detector verifi interfer freedom action nm5nm7 nm8 restrict execut init initi diffus comput whose success complet ie execut comp result true gener new token describ action nm2 nm3 restrict local detector obtain ld1 ld2 respect still need verifi composit free interfer note global detector gd superposit nm henc gd interfer nm ensur nm interfer gd restrict action nm nm5nm7 nm8 execut abort alert reader note last restrict overkil action nm need thu restrict leav optim exercis reader long corrector nm execut gd safe abort corrector nm termin gd make progress henc nm interfer gd also execut gd eventu reach state phase process comp thu ld interfer nm sinc ld detect safe predic atom interf nm gd formal action result mask toler program mm follow fault action fault action ident fault action describ section 531 invari invari program mm conjunct tnm sgd thu invari mm theorem 63 mutual exclus program mm mask toler smm remark leader elect program easili extract mutual exclus case studi end drop variabl h request program mm thu result program consist corrector nt action mm4gamma6 detector gd action mm9 mm10 program process leader iff root phase comp program deriv ad detector gd nonmask toler program nt detail design leader elect program present 20 6 discuss conclud remark paper present composit method design mask faulttoler program first corrector composit nonmask faulttoler program design ensur fault stop occur program eventu reach state problem specif satisfi detector composit program augment ensur even presenc fault program alway satisfi safeti specif demonstr method design classic exampl mask faulttoler program notabl exampl cover varieti faultclass includ byzantin fault messag fault input fault processor failstop repair also illustr gener method term abil provid altern design program usual associ wellknown design method mask faulttoler specif tmr byzantin exampl usual associ method replic gener statemachineapproach design clientserv program 21 alternatingbit protocol exampl usual associ method except handl rollbackrecoveri timeout action md5 exceptionhandl recoveryprocedur found judici use method offer potenti design improv mask toler solut measur term scope faultclass mask andor perform result program contrast wellknown design method method commit overhead replic instead encourag design minim compon achiev requir toler contrast sometim ad hoc treatment exceptionhandl recoveri procedur focus attent systemat resolut interfer underli program ad toler compon one exampl improv mask toler solut design use method tokenbas mutual exclus program term perform absenc fault program perform exactli faultintoler version due raymond 17 snepscheut 18 thu incur extra overhead case way contrast acyclicgraphbas program dhamdher kulkarni 22 chang singhal liu 23 incur time overhead provid faulttoler even absenc fault also tree base program agraw abbadi 24 amount work perform critic section may increas process fail especi fail process close tree root program failur process caus overhead converg phase program converg moreov term toler program toler 24 worst case intoler log n process failstop note pass mutual exclus program systemat extend toler process repair well channel failur repair also systemat transform process access state neighbor atom via asynchron messag pass exampl improv solut design use method interest reader refer design leader elect 20 termin detect 20 distribut reset 25 also note although superposit use detector composit exampl design superposit one possibl strategi detector composit advantag superpos detector underli nonmask toler program immedi guarante detector interfer closur converg properti underli program one use extens method would design program nonmask toler one faultclass mask toler anoth gener possess multipl toler properti see 12 25 26 design multitoler program motiv insight faultspan program need uniqu 5 henc multipl faultspan may associ program instanc program subject multipl faultclass follow program nonmask toler one faultclass mask toler anoth gener find multitoler sever practic applic 12 anoth use extens would augment method allow toler refin ie allow refin toler program abstract level concret level preserv toler properti toler refin orthogon toler addit consid paper add desir mask toler directli desir fix level implement extens could instanc refin mutual exclus program neighbor process commun via asynchron messag pass within scope method final altern design method base detector corrector composit would worth studi altern stepwis method would first perform detector composit perform corrector composit view design mask toler via failsaf toler 12 anoth altern stepwis method would compos detector corrector simultan would especi interest compar method respect designcomplex versu performancecomplex tradeoff acknowledg grate ted herman help comment preliminari version paper thank anonym refere detail construct suggest r composit framework fault toler specif transform system structur softwar fault toler depend comput fault toler concept terminolog closur converg foundat faulttoler comput ing parallel program design foundat defin live disciplin program scienc program prove boolean combin determinist properti constraint satisfact basi design nonmask faulttoler compon base design multitoler structur distribut algorithm byzantin gener problem composit design multitoler repetit byzantin agre ment predic calculu program semant tree base algorithm mutual exclus fair mutual exclus graph process effici reconfigur tree case studi method design nonmask ing faulttoler design mask faulttoler via nonmask faulttoler implement faulttoler servic use state machin approach tutori token base k resili mutual exclus algorithm distribut system fault toler algorithm distribut mutual exclus effici faulttoler solut distribut mutual exclus multitoler distribut reset multitoler barrier synchron tr ctr anil hanumantharaya purnendu sinha anjali agarw componentbas design composit verif faulttoler multimedia commun protocol realtim imag v9 n6 p401422 decemb ted herman superstabil mutual exclus distribut comput v13 n1 p117 januari 2000 ile yen farokh b bastani david j taylor design multiinvari data structur robust share access multiprocessor system ieee transact softwar engin v27 n3 p193207 march 2001 meng yu peng liu wanyu zang specifi use intrus mask model process distribut oper journal comput secur v13 n4 p623658 juli 2005 sushil jajodia paul ammann catherin mccollum surviv inform warfar attack comput v32 n4 p5763 april 1999 felix c grtner fundament faulttoler distribut comput asynchron environ acm comput survey csur v31 n1 p126 march 1999