complex synchron iter doall crash abil cooper common task distribut set key solv broad rang comput problem rang distribut search seti distribut simul multiag collabor doall abstract cooper activ problem perform n task distribut system p failurepron processor mani distribut parallel algorithm develop problem sever algorithm simul develop iter doall algorithm effici solut doall measur term work complex process step taken processor count work ideal express function n p f number processor crash howev known lower bound upper bound extant algorithm adequ show work depend f present first nontrivi lower bound doall captur depend work n p f model comput processor abl make perfect loadbalanc decis local also present match upper bound defin riter doall problem abstract fact repeat use doall found typic algorithm simul fsensit analysi enabl us deriv tight bound riter doall work stronger rfold work complex singl doall approach model perfect loadbalanc allow analysi specif algorithm divid two part analysi cost toler failur perform work free loadbalanc ii analysi cost implement loadbalanc demonstr util gener approach improv analysi two known effici algorithm give improv analysi effici messagepass algorithm also deriv tight complet analysi best known doall algorithm synchron sharedmemori model final present new upper bound simul synchron sharedmemori algorithm crashpron processor b introduct perform set task decentr set fundament problem distribut comput ing often challeng set processor avail comput abil commun may dynam chang due perturb comput medium abstract statement problem refer doall problem p faultpron processor perform n independ task one standard problem research complex faulttoler distribut comput 9 18 problem studi varieti set ting eg sharedmemori model writeal 19 20 26 messagepass model 7 9 11 partition network omnido 8 15 25 solut doall must perform task ecient presenc specic failur pattern ecienc assess term work time commun complex depend specic model comput design practic distributedparallel program one need ensur good perform depend unpredict load pattern caus exampl deviat synchroni failur processor complet task time common challeng perform n independ task p processor 14 task could copi larg array search collect data appli function element matrix 12 13 exampl includ check point larg solut space tri gener wit refut exist simpli perform number similar independ calcul paper focu work complex doall problem presenc arbitrari failur pattern impos adversari processor synchron assum failstop 31 work complex ect amount process step expend algorithm solv problem incorpor total number task includ multipl perform algorithm distinguish featur new result complex express term number processor crash f addit number processor p size problem n approach motiv part analys consensu problem vener flp imposs result 10 algorithm solv consensu model allow faulttoler solut teach follow asynchron model weak faulttoler 23 ii maximum number processor failur need includ upperlow bound imposs result eg toler f failur model consensu algorithm requir processor 24 29 work consid crash failur ensur solut exist long number failur f inferior number processor p aim express work synchron processor function n p f recent unsatisfactori landscap exist respect understand upper lower bound work depend f number failur work typic given function n p either elucid f impact work f part equat primarili due natur specic algorithm due inher properti doall problem exampl work best known synchron sharedmemori algorithm 18 given sole function n p also case best known asynchron sharedmemori algorithm 3 similarli best known sharedmemori lower bound work doall parameter term f 20 howev shown sharedmemori algorithm take least log p time step likewis best known lower bound applic messagepass model involv f 4 work messagepass algorithm eg 7 11 typic includ f due use singl coordin mean f coordin failur work necessarili includ factor f p messagepass algorithm use multipl coordin 5 avoid ineci includ factor depend log f show paper analysi involv f somewhat superci way thu prior lowerupp bound result doall teach adequ work complex depend number failur f consid synchron sharedmemori comput failurepron processor impact imprecis analysi work complex especi signic approach 22 30 use iter doall approach execut synchron parallel pram algorithm failurepron processor simul parallel step ideal processor help chosen doall algorithm see also relat work particular shown execut singl nprocessor step p failurepron processor exceed asymptot complex solv nsize instanc doall problem use p failurepron processor thu wnp complex solv doall instanc size n use p processor parallel timeprocessor product given nprocessor algorithm n algorithm determinist simul work wnp analysi accur ect impact number failur f result upper bound needlessli ate contribut work studi work complex determinist doall presenc arbitrari dynam pattern stopfailur let n size doall problem p number processor f number crash 0 f p n present rst complet analysi doall work complex perfect load balanc assumpt prove match upper lower bound function n p f model comput comput fulli abstract away lowlevel sharedmemori messagepass issu worstcas omnisci dynam adversari caus f crash also establish rst nontrivi lower bound doall moder number failur f p log p import contribut work denit analysi riter doall problem model repetit use doall algorithm found algorithm simul demonstr util gener result show new bound work faulttoler simul arbitrari pram algorithm crashpron processor improv analysi two known ecient algorithm deriv new complet failur sensit analysi best known algorithm synchron sharedmemori model algorithm w 18 also give improv analysi ecient messagepass algorithm algorithm 5 let doalln stand doall problem n task p processor f failur let doall n f denot doalln problem solv use omnisci oracl assist processor unlik oracl delphian colleagu predict futur oracl assumpt use tool studi work complex pattern faulttoler algorithm implement perfect workload balanc allow complex analysi specic algorithm divid two part analysi cost toler failur perform work assum perfect loadbalanc ii analysi cost implement perfect loadbalanc use exactli approach deriv new fsensit upper bound messagepass sharedmemori model recent shown 16 build prior result 19 doall n f solv work onp log p log log p f p gave match lower bound specic case log log p log log p meant long adversari caus least p log log p failur doall n p f match upper lower bound n p log p log log p also show log p doall n f solv work thu prior newest result nontrivi lower bound known f p log p ii fsensit analysi avail upper bound f p log p p log log p therefor iii exist gap upperlow bound analysi rang 1 f p log log p practic concern would well serv knowledg happen doall number failur moder particular import understand behavior best known algorithm entir rang f detail contribut work follow provid upper bound section 31 match lower bound section 32 address remain gap henc give complet analysi doall n f entir rang f bound work w 1 log log p log c 0 f f c p log c 0 1 lower bound cours appli algorithm weaker model turn quantiti q pf dene extract bound play import role analysi complex sever algorithm log p log log p f c p log c 0 f log c 0 2 use bound 1 deriv new bound algorithm extant analys integr f adequ done analyz workload balanc implement algorithm eg use coordin global datastructur show follow ii section 41 provid new analysi algorithm chlebu et al 5 doall messagepass model crash algorithm best known work moder number failur show complet analysi work w messag complex iii section 51 give complet analysi work complex w algorithm kanellaki shvartsman 18 solv doall writeal problem synchron sharedmemori system processor crash note two algorithm 5 18 design dierent model use dissimilar data control structur howev algorithm make loadbalanc decis gather global knowledg understand work expend load balanc vs inher work overhead due lower bound 1 abl obtain new result demonstr util gener approach doall algorithm use develop simul failurefre algorithm failurepron processor eg 22 30 done iter use doall algorithm simul step failurefre processor paper abstract idea iter doall problem follow riter doalln problem use p processor solv r instanc ntask doall one set task time let g stand describ upper bound describ lower bound logarithm base 2 unless explicitli speci otherwis express log x stand maxf1 log 2 xg given x descript complex result oracl rdoall n f dene similarli obviou solut problem run doall algorithm r time work complex doall given model wnpf work rdoall clearli r wnpf present substanti better analysi iv section 33 show match upper lower bound work w rdoall n f p n specic rang failur r log log p log r log pr f f p r log extract quantiti r rpf dene bound 3ab play import role analysi complex iter doall algorithm r rpf log p log log p log log p log pr f f p r log note r q pf r rpf specic rang f 4b respect r xed p f thu bound 3 asymptot better obtain comput product r noniter doall bound 1 v section 42 show rdoalln f solv synchron messagepass processor follow work complex w messag complex r log f r n r rpf vi section 52 use rdoalln f show p processor crash simul synchron nprocessor rtime sharedmemori algorithm pram work last result strictli better previou determinist bound parallel algorithm simul use doall algorithm 18 best known date simul techniqu 22 30 due relationship q pf r rpf point relat workalgorithm simul doall algorithm use iter simul parallel algorithm formul synchron failurefre processor determinist probabilist set 22 20 27 28 30 commonli requir individu processor step made idempot sinc may perform multipl time due failur asynchroni ii linear number processor auxiliari memori made avail use scratchpad store intermedi result former solv help autom tool eg compil latter requir sophist solut diculti reus auxiliari memori due late writer ie processor slow unknowingli write stale valu memori exampl random solut address problem includ 2 1 21 anoth import aspect algorithm simul use optimist approach comput may proceed sever step assum task assign activ processor success complet exampl seri potenti incorrect tent step combin complet denit step detect roll back incorrect comput step 20 overal comput ecient high probabl note determinist model optim simul possibl cf 30 howev random solut abl achiev optim whp broader rang model algorithm practic implement discuss 6 also observ parallel comput made faster essenti ignor processor slower other rest paper structur follow section 2 present model denit section 3 present bound perfect loadbalanc assumpt section 4 give new upper bound messagepass model section 5 give upper bound sharedmemori model pram simul conclud section 6 model denit dene model abstract problem perform n task distribut environ consist p processor subject stopfailur work complex measur distribut set consid distribut system consist p synchron processor assum p xed known processor uniqu identi pid set pid total order processor activ govern local clock nonfaulti synchron system processor clock ident model failur introduc delay local clock tick task dene task comput perform processor one time step execut depend task task also idempot ie execut task mani time andor concurr eect execut task task uniqu identi task identi tid set tid total order denot set n task assum known processor model failur assum failstop processor model 31 processor may crash moment comput crash restart let omnisci adversari impos failur system use term failur pattern denot set event ie crash caus adversari failur model set failur pattern given adversari failur pattern f dene size f failur pattern number failur oracl model section 3 consid comput processor assist determinist omnisci oracl processor may contact oracl per step introduct oracl serv two purpos 1 oracl strengthen model provid processor inform progress comput oracl predict futur thu lower bound establish oracl model also appli weaker model eg without oracl 2 oracl abstract away concern commun normal domin specic messagepass sharedmemori model allow gener result establish enabl us use result context specic model understand inform provid oracl simul specic algorithm commun section 4 5 deal messagepass sharedmemori model comput messagepass model assum known upper bound messag delay commun complex dene section 4 consid comput sharedmemori model assum read write memori cell take one time unit read write concurr doall problem dene doall problem follow doall given set n task p processor perform task failur pattern failur model f let doalln stand doall problem n task p processor p n pattern crash f jf j f p let doall n stand doalln problem oracl dene iter doall problem follow iter doall given r set r n task p processor perform r n task one set time failur pattern failur model f denot riter doall rdoalln oracl version rdoall n f dene similarli measur ecienc interest studi complex doall measur work cf 18 9 7 assum take unit time processor perform unit work singl task correspond unit work denit work complex base avail processor step measur 19 let f adversari model comput subject failur pattern f f 2 f denot p number processor complet unit work step comput denit 21 given problem size n p processor algorithm solv problem failur model f algorithm solv problem pattern f f jf j f time step work complex w algorithm note idl processor still consum unit work per step even though contribut comput denit 21 depend specic lowlevel target model comput eg whether messagepass sharedmemori give similar denit commun complex section 4 3 bound perfect load balanc section give complet analysi upper lower bound doall n rdoall n problem entir rang f crash f p n note use quantiti q pf r rpf dene section 1 equat 2 4 respect 31 doall upper bound studi upper bound doall give oraclebas algorithm figur 1 oracl tell processor whether task perform oraclesay task perform next oracletask correct algorithm trivial thu oracl perform termin loadbalanc comput behalf processor processor global 1n done perform task oracletaskpid od end figur 1 oraclebas algorithm lemma 31 19 16 doall n problem f p n solv use work log log p note lemma 31 teach work depend f number crash lemma 32 c 0 doall n f solv stopfailur pattern f c p log p use work proof proof base proof theorem 36 16 let f denot number processor stopfailur within singl iter comput f dierent iter though sum iter exceed f set 2f dene w n f work requir solv doall n goal show u p f work w u f 3p u p log p u op u p log p f u u n denot number undon task proof proce induct u base case observ u 3 w u desir induct case assum prove theorem u u n p f consid u investig two case case 1 u case processor assign uniqu task henc u p fp f f f u u induct hypothesi u u p f desir case 2 u case assumpt get f ratio number remain task u 0 1 fraction processor fail iter 2 see observ uc u u let u c 1 u u bcc observ 1 c bcc 2 u may appli induct hypothesi complet proof suce show 2 0 fp u 1 p log bpf upper bound 31 divid p sucient show equival log bpf 3 focu left hand side equat log bpf log bpf log bpf u log p 8p 2 2f 2 particular log bpf note f task complet iter recal p therefor desir induct proof denit give main upperbound result theorem 33 doall n f solv failur pattern use work proof follow directli lemma 31 32 2 32 doall lower bound show match lower bound doall n note result section hold also doalln problem without oracl lemma 34 18 16 algorithm alg solv doall n exist pattern f stopfailur f p result work w log log p dene specic adversari strategi use deriv lower bound let alg algorithm solv doall problem let p number processor remain end th step alg let u denot number task remain done end step initi log p 0 1 adversari adv step 1 alg adversari stop processor follow among u 1 task remain step 1 adversari choos u task least number processor assign crash processor adversari continu long u 1 soon u adversari allow remain processor perform singl remain task alg termin follow two lemma use proof lemma 37 lemma 35 18 1 sort list nonneg integ lemma 36 18 given g 1 n g integ log n log g 1 follow inequ hold z time lemma 37 given c 0 algorithm alg solv doall n adversari adv caus f stopfailur f c p log p f n denit adv follow u z time use lemma 36 get log n 1 recal log p f log log f 1 z time 0 tell us adversari adv caus algorithm alg cycl least log n log p f log log fiter let denot number iter need alg termin note algorithm cycl least one iter henc log n log p f log log f need comput lower bound p quantiti processor assign task sort ascend order let also includ quantiti unassign processor ie 1 least number processor assign task 2 next least quantiti processor etc let thu adversari stop exactli processor begin iter number processor therefor number surviv processor ij1 use lemma 35 get p 1 u substitut u use properti observ work must least p p surviv processor alg ter minat consid two case case 1 log p log p let f denot total number failstop alg termin log p log p f sinc log log p log p f log p therefor adversari adv caus processor failstop allow work caus adv case f log p case 2 log p f log log f log p log n log p f log log f p log p log p log p log p log p log p f henc adv caus failstop allow work caus adv case log n log p log n log n f log n note w 2 0 sinc p log n p recal f c p log p henc 8p 2 2c p f 2 particular suce p 4 two case denit get wnpf log n log p f lemma 38 given c 0 algorithm alg solv doall n exist adversari caus f stopfailur f c p log p f follow lemma 37 slightli modifi adversari adv 2 give main lowerbound result theorem 39 given algorithm alg solv doall n exist adversari caus proof rang failur 0 f c p log establish bound lemma 38 also obtain fact log p work must log log p larger f adversari establish worst case work use initi c p log p failur 2 33 iter doall doall algorithm use develop simul failurefre algorithm failurepron processor done iter use doall algorithm simul step failurefre processor studi iter doall problem understand complex implic iter use doall algorithm obviou rdoalln f solv run doalln time work doall solut w work riter doall r w howev show possibl obtain ner result refer doall iter round rdoall n theorem 310 rdoall n solv denot th round rdoall n number activ processor begin r f number crash r note p rst round rdoall n f p consid two case case 1 f p r log consid round r theorem 33 get work round log log log log p howev case f log p r without run processor thu work case log log p case 2 f p r log first observ reason adversari would kill p log processor round r sinc would caus work log log log p achiev f log therefor consid f log round r henc work everi round r per theorem 33 log log log p let w n f oneround upper bound upper bound rdo n f given maxim failur pattern may assum p purpos upper bound show maximum attain f simplic treat f continu paramet consid factor singl round work express given depend f c constant hidden notat rst deriv f clog p second deriv 2 clog p observ second deriv neg domain consid long p 16 henc rst deriv decreas f case given two f failur pattern obtain replac f result increas work impli sum maxim f equal specic f upper bound sum rang hold particular choic made adversari must cours caus integ number fault round therefor log pr f result follow denit r rpf combin two case 2 theorem 311 given algorithm solv rdoall n exist stop failur adversari caus r n r rpf consid two case case 1 f p r log case adversari may failstop p log p processor everi round r doall n note adversari processor remain aliv rst dr2e round per theorem 39 result dr2e log log p log log p work case 2 f p r log case adversari ideal would kill f r processor everi round case f divid r case adversari kill f r e processor r round b f r c r b round way consid rst half round appeal theorem 39 result rn p log rp f lower bound work note consid case r f otherwis work trivial 4 new bound messagepass model section demonstr util complex result perfect loadbalanc assumpt give tight complet analysi algorithm 5 establish new complex result iter doall messagepass model 41 analysi algorithm algorithm present chlebu et al 5 use multiplecoordin approach solv alln f crashpron synchron messagepass processor model assum messag incur known bound delay reliabl multicast 17 avail howev messag tofrom faulti processor may lost ecienc algorithm character term work messag complex dene messag complex similarli denit 21 work comput subject failur pattern f f 2 f denot number pointtopoint messag sent step comput given problem size n comput solv problem step presenc failur pattern f jf j f messag complex descript algorithm due space limit give brief descript algorithm addit detail given appendix avoid complet restat refer reader 5 algorithm proce loop iter task execut singl iter loop call phase phase consist three consecut stage stage consist three step stage processor use rst step receiv messag sent previou stage second step perform local comput third step send messag processor coordin worker phase may multipl coordin number processor assum coordin role determin martingal principl none expect coordin surviv entir phase number coordin next phase doubl least one coordin surviv given phase next phase one coordin phase complet least one coordin aliv call attend otherwis call unattend processor becom coordin balanc load accord processor local view processor local view contain set processor id assum aliv local view partit layer rst layer contain one processor second two processor third four processor given phase rst stage processor perform task accord load balanc rule deriv local view report complet task coordin phase determin local view second stage coordin gather report updat knowledg done task multicast inform processor accord local view aliv last stage processor receiv inform sent coordin updat knowledg done task local view given full detail algorithm dicult see combin coordin local view allow processor obtain inform would avail oracl algorithm figur 1 shown 5 work algorithm log n log log n log f messag complex new analysi work complex assess work w consid separ attend phase unattend phase execut let w part w spent attend phase w u part w spent unattend phase henc note p n lemma 41 5 execut algorithm f p w log log p w give new analysi algorithm lemma 42 execut algorithm w p log p f log p c 0 given phase execut algorithm dene p number live processor u number undon task begin phase attend phase execut last phase execut observ hold u u i1 follow construct algorithm sinc phase attend least one coordin call c aliv phase c execut one task henc least one task execut consequ least one task taken u number processor decreas sinc allow restart therefor focus attend phase proof lemma induct size undon task u note proof proce proof lemma 32 p n 2 theorem 43 execut algorithm follow lemma 41 42 fact analysi messag complex assess messag complex consid separ attend phase unattend phase execut let number messag sent attend phase u number messag sent unattend phase henc lemma 44 5 execut algorithm ow theorem 45 execut algorithm proof proof follow lemma 41 42 44 fact 42 analysi messagepass iter doall consid rdoalln f problem p n messagepass model theorem 46 rdoalln f problem solv synchron messagepass crash prone processor work r n n r rpf sketch iter doall solv run algorithm r instanc size n sequenc call algorithm analyz ecienc use approach proof theorem 310 current context base work complex argument result theorem 43 base messag complex argument result theorem 45 2 5 new bound sharedmemori model give new rene analysi workeci known doall algorithm sharedmemori model algorithm w 18 also establish complex result iter doall simul synchron parallel algorithm crashpron processor 51 analysi algorithm w algorithm w solv doalln f sharedmemori model doall better known writeal work pattern crash note bound conserv sinc includ f number crash descript algorithm give brief descript algorithm addit detail found appendix avoid complet restat refer reader 19 algorithm w structur parallel loop four phase w1 failur detect phase w2 load reschedul phase w3 work phase w4 phase estim progress comput remain work control parallel loop phase use full binari tree leav processor travers binari tree topdown bottomup accord phase travers take olog n time height tree singl processor iter loop call blockstep sinc four phase one tree travers per phase block step take olog n time algorithm w tree store share memori serv gather place global inform number activ processor remain task load balanc dicult see binari tree inde provid inform processor would avail oracl oracl model binari tree use phase w2 implement load balanc phase w3 assess remain work call progress tree use parameter version algorithm p n progress tree leav task associ leav tree nu task per leaf note blockstep still take time olog n new complex analysi give work analysi charg processor block step start regardless whether processor complet crash lemma 51 19 failur pattern f p number blockstep requir processor algorithm w u leav progress tree log log p lemma 52 failur pattern f c p log p c 0 number blockstep requir p processor algorithm w u leav progress tree f processor blockstep shown equival processor step perfect loadbalanc assumpt henc proof proof lemma 32 2 theorem 53 algorithm w solv doalln consid follow two case case 1 p n log number leav progress tree log n work phase w3 processor perform task cost singl blockstep c sinc four phase take log n time consid two subcas f p log p lemma 52 give number blocksstep b 1a case ou log p f n log log p f therefor work w 1a case b 1a c log p f log p lemma 51 give number blockstep b 1b case ou p log p log log p n log n p log p log log p therefor work w 1b case b 1b c log log p two subcas togeth denit q pf yield w case 2 n log n p n number leav progress tree work phase w3 processor perform n task thu cost singl blockstep consid two subcas f p log p lemma 52 give number blockstep b 2a case ou log p f opp log p log p f log p f therefor work w 2a case b 2a c log p f log p lemma 51 give number blockstep b 2b case op p log p log log p op log p log log p therefor work w 2b b 2b c log log p last two subcas denit q pf yield w combin case 1 case 2 result get 52 iter doall parallel algorithm simul consid complex sharedmemori rdoalln f pram simul theorem 54 rdoalln f problem solv p crashpron processor p n use share memori work sketch iter doall solv run algorithm w r instanc size n sequenc call algorithm w analyz ecienc w use approach proof theorem 310 current context base work complex argument result theorem 53 2 state anoth main result paper theorem 55 synchron nprocessor rtime sharedmemori parallel algorithm pram simul p crashpron synchron processor work n r rpf log n proof complex simul singl parallel step n ideal processor p crashpron processor exceed complex solv singl doalln instanc 22 30 result follow theorem 54 2 6 conclus paper gave rst complet analysi doall problem perfect loadbalanc assumpt introduc analyz iter doall problem model repeat use doall algorithm found algorithm simul transform uniqu contribut analys precis describ eect crash failur work comput analys obtain perfect loadbalanc assumpt immedi use use analyz algorithm simul attempt balanc load among processor final provid rst failuresensit analysi work iter doall problem messagepass sharedmemori model r tr effici parallel algorithm made robust effici robust parallel comput combin tent definit execut fast depend parallel comput achiev optim crcw pram faulttoler effici program transform resili parallel comput via random preliminari version perform work effici presenc fault workoptim asynchron algorithm share memori parallel comput complex certifi writeal algorithm timeoptim messageeffici work perform presenc fault parallel algorithm processor failur delay algorithm certifi writeal problem faulttoler broadcast relat problem failstop processor setihomemyampersandmdashmass distribut comput seti faulttoler parallel comput distribut cooper absenc commun complex synchron iter doall crash optim freliabl protocol doall problem singlehop wireless network resolv messag complex byzantin agreement beyond parallel random access machin parallel process network workstat cooper comput fragment mergeabl group ctr chryssi georgiou dariusz r kowalski alexand shvartsman effici gossip robust distribut comput theoret comput scienc v347 n12 p130166 novemb 2005 antonio fernndez chryssi georgiou alexand russel alex shvartsman doall problem byzantin processor failur theoret comput scienc v333 n3 p433454 3 march 2005