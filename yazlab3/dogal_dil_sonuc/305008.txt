integr rang comparison dataparallel compil system abstracta major difficulti restructur compil parallel program gener compar parallel perform rang system problem size execut time vari system problem size initi fast implement may becom slow system problem size scale paper introduc concept rang comparison unlik convent execut time comparison perform compar particular system problem size rang comparison compar perform program rang ensembl problem size via scalabl perform cross point analysi novel algorithm develop predict cross point automat correct algorithm proven methodolog develop integr rang comparison restructur compil dataparallel program preliminari prototyp methodolog implement test vienna fortran compil system experiment result demonstr rang comparison feasibl effect import asset program evalu restructur compil parallel program b introduct signific question parallel machin today mani decad softwar applic take advantag hardwar parallel 1 tradit distribut memori architectur program use messag pass user respons explicitli insert commun statement sequenti program develop parallel languag vienna fortran 2 fortran 3 high perform fortran hpf 4 improv situat provid highlevel featur specif data distribut among other vienna fortran compil system vfc 5 fortran compil system 3 develop support languag automat gener messag pass program howev current technolog code restructur system inher lack power fulli exploit perform offer distribut memori archi tectur primari motiv parallel process high perform effect effici restructur compil current barrier success simpl highlevel program model approach restructur program seen iter process parallel program transform iter perform current parallel program analyz predict iter base perform result next restructur transform select improv perform current parallel program iter process termin certain predefin perform criteria met result explicit user intervent integr perform analysi restructur system critic support automat perform tune iter restructur process develop fulli compil integr perform system scalabl parallel machin especi challeng ing scalabl environ perform program vari data distribut system size number processor problem size superior program implement superior rang system problem size predict perform parallel program integr perform indic automat restructur compil two major challeng face research field 6 moreov current perform analysi visual tool target messagepass program model parallel interprocessor commun explicit fall short support highlevel languag readili integr restructur compil two major function dataparallel restructur compil distribut data array processor choic appropri restructur transform key question realiz two function predict scale perform small number data distribut transform automat appropri optim decis made order compar rel perform rang problem system size scalabl predict propos solut studi scalabl abil maintain parallel process gain system problem size increas character scale properti code given machin slow code good scalabl may becom superior system problem size scale system size perform rank differ code chang call cross point paper introduc concept rang comparison concern determin cross point base analyt result given section 32 automat cross point predict automat rang comparison studi research iter algorithm first deriv predict scalabl cross point given parallel platform connect iter algorithm exist static perform estim p 3 7 discuss preliminari prototyp automat rang comparison implement vienna fortran compil system vfc final two applic test two differ data distribut verifi correct feasibl rang comparison approach current experiment result preliminari clearli demonstr feasibl effect rang comparison approach program restructur paper organ follow vfc perform estim tool introduc section 2 concept scalabl perform cross point rang comparison present section 3 iter algorithm automat perform predict describ detail experiment result given section 4 illustr newli propos algorithm integr within vfc order predict cross point automat final section 5 conclud summari compil system vfc parallel compil vienna fortran high perform fortran vfc integr sever tool program analysi transform among other provid parallel techniqu base upon domain decomposit conjunct singleprogrammultipledata spmd program model model impli processor execut program base differ data domain work distribut parallel program determin base underli data distribut accord ownercomput rule mean processor own datum perform comput make assign datum nonloc data referenc processor impli commun optim sever strategi 5 extract singl element messag loop combin vector commun vector remov redund commun commun fusion aggreg differ commun statement commun aggreg analysi describ paper target toward regular comput stencil comput reli heavili compiletim analysi optim provid vfc 21 perform estim integr tool vfc assist user perform tune regular program compil time p 3 base singl profil run obtain characterist data branch probabl statement loop execut count well known 9 10 11 12 overhead access nonloc data remot processor distribut memori architectur commonli order magnitud higher cost access local data commun overhead therefor one import metric choos appropri data distribut commun overhead two separ perform paramet number data transfer amount data transfer sake breviti issu static estim commun overhead discuss section interest reader may refer 7 8 13 inform regard perform paramet p 3 note section 4 defin commun time combin p 3 paramet mention variou machin specif metric number data transfer number data transfer critic paramet reflect high messag startup cost distribut memori architectur commonli overhead commun decreas hoist outsid nest loop moreov commun insid specif loop bodi mani case impli loop sequenti due synchron processor involv commun p 3 care model loop nest level commun place array access pattern data depend distribut control flow compil commun optim eg commun vector fusion order determin number data transfer high accuraci commun hoist outsid loop nest assum loos synchron commun model 14 impli involv processor commun simultan commun statement number data transfer determin maximum number data transfer across involv processor commun hoist outsid loop nest due data depend assum sequenti loop commun place well data transfer impli commun number data transfer commun given sum data transfer across processor involv commun amount data transfer current gener distribut memori architectur reduc impact messag length commun overhead applic transmit small data volum startup cost predomin commun cost factor howev increas data volum transmit messag transfer time per byte turn amount data transfer becom first order perform effect order provid highli accur estim amount data transfer given byte induc parallel program p 3 estim number nonloc data element access incorpor machin specif data type size purpos p 3 examin loop nest level commun place array access pattern data depend distribut control flow compil commun optim compil specifi commun pattern sourc code level target architectur part except data type size ignor consequ paramet port easili larg class distribut memori architectur perform rang comparison execut time import perform metric optim parallel program comparison bond specif pair system problem size execut time alon suffici perform comparison rang system problem size scalabl recogn import properti parallel algorithm machin recent year 15 sever scalabl metric propos 16 17 18 howev scalabl tradit studi separ independ properti recent relat scalabl execut time studi concept rang comparison introduc 19 20 unlik convent execut time comparison perform compar particular system problem size rang comparison compar perform program rang system problem size via scalabl perform cross point analysi fulli understand concept rang comparison background scalabl cross point analysi need introduc 31 isospe scalabl major drive forc behind parallel comput solv larg problem fast tradit execut time measur choic fixeds problem execut time howev adequ scalabl comput problem size scale system size speed defin work divid time propos altern primari metric scalabl comput 1 averag speed achiev speed divid number processor use averag speed quantiti ideal would unchang scale system size follow definit first given 16 isospe scalabl algorithmmachin combin algorithmmachin combin scalabl achiev averag speed algorithm given machin remain constant increas number processor provid problem size increas system size larg class algorithmmachin combin amc averag speed maintain increas problem size necessari problem size increas vari algorithm machin combin variat provid quantit measur scalabl let w amount work algorithm p processor employ machin let w 0 amount work algorithm processor employ maintain averag speed scalabl system size p system size p 0 algorithmmachin combin work w 0 determin isospe constraint final let p w time comput w work p processor system equat 2 show scale execut time comput scalabl three approach propos determin scalabl 16 comput relat problem size speed directli measur scalabl predict scalabl certain predetermin paramet three approach practic import scalabl predict seem less expens benefit compil support parallel execut time p w divid two part ideal parallel process time parallel process overhead 1 defin work gener debat scientif applic commonli agre float point flop oper count good estim work sequenti execut time delta comput capac defin time per unit work singl processor parallel process overhead contain load imbal overhead commun overhead possibl parallel degrad definit scalabl see 1 scalabl predict scale work size w 0 predict predict formula given 21 comput achiev averag speed 0 parallel process overhead p 0 proce sor parallel degrad exist ie 0 traceabl 0 necessari suffici condit equat 4 0 achiev process overhead 0 gener function problem size unknown side equat use formula 4 scalabl predict straightforward task 32 perform cross point rang comparison theorem 1 give relat scalabl execut time two differ algorithm machin combin analyt proven experiment confirm 19 theorem 1 algorithmmachin combin 1 2 execut time ff delta respec tive initi state initi system problem size combin 1 higher scalabl combin 2 scale system size execut time combin 1 smaller ff multipl execut time combin 2 solv w 0 scale system size w 0 scale problem size combin 1 theorem 1 show amc faster initi state better scalabl other remain faster scalabl rang rang comparison becom difficult initi faster amc smaller scalabl system size scale origin faster code lower scalabl becom slower anoth code better scalabl find fastslow cross point critic optim perform choos effici data distribut program transform dataparallel environ find superiorityinferior cross point howev difficult definit cross point problem size system size depend definit 2 give formal definit cross point base isospe scalabl 20 scale cross point ff 1 algorithmmachin combin 1 2 execut time ff respect initi state say scale system size 0 cross point combin 1 2 ratio isospe scalabl combin 1 combin 2 greater ff p 0 let amc 1 execut time scalabl phip p 0 scale problem size w 0 let amc 2 execut time scalabl psip p 0 scale problem size w definit 2 p 0 cross point amc 1 2 fact equat 2 phip notic sinc combin 2 smaller execut time initi state p w superiorityinferior chang execut time give mean perform cross point correct theorem 2 3 prove 20 theorem 2 algorithmmachin combin 1 larger execut time algorithm machin combin 2 initi state scale system size p 0 p 0 scale cross point combin 1 smaller scale execut time combin 2 sinc two differ algorithmmachin combin may differ scalabl perform may cross cross point p 0 differ scale problem size w 0 6 w scale cross point differ equals cross point perform cross problem size theorem 3 give relat scale cross point equals cross point theorem 3 algorithmmachin combin 1 larger execut time algorithm machin combin 2 initi state p 0 scale cross point combin 1 larger execut time combin 2 solv w 0 system size scale problem size combin 1 theorem 3 give necessari condit equals perform cross initi system size p p 0 equals cross point p must scale cross point p hand p 0 scale cross point p equals cross point p perform cross occur scale cross point even term equals perform theorem 3 provid mean rang comparison base theoret find figur 1 give procedur rang comparison term scalabl 33 automat crossingpoint predict procedur rang comparison list figur 1 term scalabl scalabl differ code implement differ algorithmmachin combin gener still need determin rang comparison scalabl differ algorithm implement prestor perform comparison mani situat howev premeasur result scale system avail predict necessari propos iter method list figur 2 comput w 0 predict scalabl automat assum underli applic scalabl work w monoton increas function scale paramet input data size also assum parallel overhead either independ paramet n ideal scalabl monoton increas n parallel degrad exist iter algorithm consist three part main program two subroutin comput function oew invers oew function oew impli equat 4 mathemat iter algorithm find fix point oew proof correct algorithm provid appendix correct proof give converg rate iter algorithm like iter method converg rate algorithm applic depend depend properti function fn scientif comput fn low degre polynomi function algorithm converg fast experiment result show algorithm requir three five iter converg solut error bound assumpt algorithm assum algorithmmachin combin 1 2 execut time fft respect initi state ff 1 object algorithm predict combin 2 superior rang system size p p 0 rang comparison begin determin scalabl combin 1 determin scalabl combin 2 combin 2 superior rang els 0 scale cross point endfifg endfrang comparison g figur 1 rang comparison via perform cross point 4 automat perform comparison vfc implement prototyp version iter algorithm within vfc predict scalabl execut time parallel code function p 3 vfc fulli implement describ section 2 figur 3 show structur scalabl predict within vfc input program parallel instrument vfc messag pass code gener code compil execut target parallel machin perform analysi tool analyz tracefil obtain comput initi perform indic use scalabl predict final scalabl predict implement iter algorithm describ section 3 iter algorithm problem size specifi sourc code automat parallel perform indic number transfer z amount data transfer estim p 3 scalabl predict perform process iter algorithm converg experiment result show approach provid effect solut captur scale properti parallel code support optim dataparallel program two case present detail section illustr iter algorithm use within vfc environ predict carri automat experi carri ipsc860 hypercub processor parallel process overhead use scalabl iter algorithm describ section 3 contain commun overhead load imbal choos two code jacobi redblack contain sever 2 dimension array impli good load balanc contain commun time obtain formula assumpt algorithm assum work w overhead increas function scale paramet n constant assum parallel code studi execut target machin w work p processor object algorithm comput scalabl system size p p 0 error ffl 0 iter method begin initi valu w comput begin iter k0 k els begin iter k0 k endfifg endfit methodg begin solv comput comput endfsubroutin oew g begin comput solv figur 2 iter method predict scalabl ttracefil comput comput computew k ye comput vfc parallel z mp code instrum execut wt zdt k1 comput perform indic scalabl predict sourc code figur 3 scalabl predict within vfc z predict compil time problem size w use p 3 machin specif paramet ae fi startup time transfer time per messag byte respect repres addit overhead network hop h number hop jacobi redblack parallel vfc perform measur 4 processor ipsc860 hypercub perform indic obtain need comput initi state scalabl predict given work w total execut time p processor p comput time c commun overhead execut model jacobi redblack base equat 3 follow assum comput jacobi redblack uniformli distribut across processor comput rate w averag speed determin measur comput time total execut time initi valu predict algorithm p comput base work w start iter new input data size n obtain k 0 commun overhead 0 scale predict use 6 4 respect scalabl processor p processor determin termin condit satisfi fix ffl 0 use experi otherwis method iter new paramet tabl show measur predict scalabl jacobi algorithm two differ data distribut strategi twodimension block distribut columnwis distribut program array twodimension onedimension processor array respect differ percentag predict measur valu given third column tabl mea pred mea diff pred mea diff p8 1000 1000 0 0842 0819 27 tabl 1 jacobi twodimension distribut predict measur scalabl mea pred mea diff pred mea diff p8 1000 1000 0 0796 0808 15 tabl 2 jacobi column distribut predict measur scalabl experiment result confirm predict scalabl accur variat scale perform variou data distribut also captur tabl 3 show predict measur scalabl valu redblack algorithm twodimension distribut tabl 4 5 6 present predict execut time versu mea pred mea diff pred mea diff tabl 3 redblack twodimension distribut predict measur scalabl measur one jacobi twodimension block distribut one dimension distribut redblack twodimension block distribut respect initi problem size use tabl 1 6 determin asymptot speed 22 best perform chosen measur averag execut time requir singl iter cover parallel p 3 scalabl predict fig 3 redblack parallel time account 07 sec p 3 03 sec scalabl predict 01 sec overal everi iter took approxim 11 sec remain constant chang problem mea diff tabl 4 jacobi 2d predict measur execut time mea diff tabl 5 jacobi c predict measur execut time size execut time redblack written fft 4 2975 accord tabl 1 2 3 scalabl jacobi higher redblack therefor theorem 1 smaller initi execut time larger scalabl show jacobi scale better redblack confirm measur result given tabl 4 5 6 interest result given two differ jacobi version tabl 1 2 see 2d distribut implement larger initi execut time better scalabl columnwis distribut accord theorem 2 cross point scale system size p 0 howev case cross point greater 16 confirm prototyp implement figur 4 show cross point rang 4 16 processor point 21 scale perform sensit small applic increas system size caus notic chang communicationcomput ratio jacobi communicationcomput ratio increas decreas problem size initi state 20 execut time jacobi columnwis distribut strategi given 4 jacobi 2d distribut fft 4 redblack 2d mea diff tabl 6 redblack 2d predict measur execut time execut time 2d distribut column distribut figur 4 equals cross point jacobi start point 1267 consid scalabl result tabl 7 8 see 2d distribut scale better columnwis distribut ratio two predict scalabl 0652 0373 1747 greater ff therefor definit 2 cross point execut time 2d distribut becom less columnwis distribut cross point due commun behavior involv ipsc860 confirm measur execut time shown figur 5a p4 1000 0652 0548 tabl 7 predict scalabl jacobi 2d distribut p4 1000 0373 0333 p8 1000 0893 tabl 8 predict scalabl jacobi columnwis distribut order verifi whether cross point equals cross point measur code accord theorem 3 correspond equals cross point result shown figur 5b execut time 2d distribut column distribut processors60001000014000 execut time 2d distribut column distribut b figur 5 scale cross point equals cross point b jacobi n20 5 conclus mani way parallel program rel perform gain differ parallel strategi vari problem size system size compar perform differ implement algorithm rang system problem size crucial develop effect parallel compil ultim reduc burden parallel program studi practic methodolog develop automat rang comparison test dataparallel compil system propos methodolog built rigor analyt model correct effici experiment result confirm effect part parallel compil paper offer sever contribut first identifi import feasibl rang comparison dataparallel compil system next iter algorithm develop experiment predict scalabl algorithmmachin combin enabl automat rang comparison exist static estim modifi integr automat rang comparison dataparallel compil system final rang comparison approach test part vienna fortran compil system experiment result demonstr feasibl high potenti rang comparison parallel compil concept analyt result given section 31 32 gener applic algorithmmachin combin scalabl predict algorithm given section 33 assum workload determinist function scale factor n assumpt quit reason algorithm requir estim parallel process overhead algorithm test p 3 static perform estim vienna fortran compil system due avail vfc p 3 experiment result present paper limit 16 node ipsc860 avail univers vienna integr rang comparison methodolog introduc research howev gener adopt larg parallel system well advanc compil system 23 appendix proof correct appendix give formal proof correct iter algorithm list figur 2 proof independ n scalabl 1 instruct main program done otherwis assumpt comput work w parallel process overhead monoton increas function scale paramet n therefor oe accord equat 4 problem size w 0 scale problem size maintain isospe sinc f g increas function n f gamma1 g gamma1 also sinc 4 p constant scalabl predict process relat 7 impli w increas increas therefor conclud oe oe gamma1 also increas function w definit scalabl 1 initi valu w satisfi equat 7 ideal scalabl scalabl equal one reach sinc parallel process overhead decreas n inequ w 0 w 0 w done instruct main program otherwis iter method need use find w 0 w case 1 main program use iter method increas function induct w also sinc w 0 less w 0 oew increas induct therefor shown inequ preserv nonneg integ k hold initi valu w 0 pass limit side 8 yield impli iter 8 converg true solut w 0 case els instruct main program shown figur 2 time iter formula use follow similar argument given case 1 conclud iter converg solut stabail iter algorithm analyz b denot purturb valu b delta b p sinc g f function polynomi purturb function b oe close oe long small enough iter w purturb magnitud deriv oe small deriv f away 0 ie k dfx therefor conclud iter w small enough definit f k dfx easili satisfi similar argument iter w small enough requir k dgx c alway satisfi satisfi definit function g parallel overhead increas much origin overhead close w case invers iter w use algorithm acknowledg author grate mr yu zhuang help strengthen proof correct iter algorithm anonym refere construct comment revis paper r next 10 000 2 year program vienna fortran fortran languag specif high perform fortran languag specif version 10 vienna fortran compil system version 20 user guid integr compil perform analysi environ data parallel program automat perform predict parallel program estim optim perform parallel program buffersaf commun optim base data flow analysi perform predict unifi framework optim commun dataparallel program commun placement framework unifi depend dataflow analysi tau static paramet base perform predict tool parallel program solv problem concurr processor develop parallel method 1024 processor hypercub scalabl parallel algorithmmachin combin introduct parallel comput perform metric keep focu runtim relat scalabl execut time perform rang comparison via cross point analysi perform predict case studi use scalabl sharedvirtu memori machin perform consider share virtual memori machin commun overhead predict influenc scalabl tr ctr xianh sun scalabl versu execut time scalabl system journal parallel distribut comput v62 n2 p173192 februari 2002 thoma fahring bernhard scholz xianh sun executiondriven perform analysi distribut parallel system proceed 2nd intern workshop softwar perform p204215 septemb 2000 ottawa ontario canada