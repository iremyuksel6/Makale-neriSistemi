model check modular verif describ framework composit verif finitest process framework base two idea subset logic ctl satisfact preserv composit preorder structur captur relat compon system contain compon satisfact formula logic correspond particular structur tableau formula preorder show assumeguaranteestyl reason within framework addit demonstr effici method model check logic check preorder sever special case implement system base method use give composit verif cpu control b introduct tempor logic model check procedur use tool verif finit state system 3 12 20 howev procedur tradit suffer state explos problem problem aris system compos mani parallel process gener size state space grow exponenti number process introduc symbol represent set state transit relat use symbol model check procedur system larg state space 10 100 state verifi 1 8 time space requir techniqu may practic polynomi number compon system research sponsor part avion laboratori wright research develop center aeronaut system divis afsc us air forc wrightpatterson afb ohio 454336543 contract f3361590c1465 arpa order 7597 part nation scienc foundat contract ccr9005992 part usisra binat scienc foundat view conclus contain document author interpret repres offici polici either express impli us govern unfortun symbol procedur still limit mani realist problem tractabl due size thu motiv search addit method handl state explos problem method work well conjunct techniqu obviou method tri avoid state explos problem use natur decomposit system goal verifi properti individu compon infer hold complet system use deduc addit properti system verifi properti compon may also necessari make assumpt environ approach exemplifi pnueli assumeguarante paradigm 23 formula logic tripl hi tempor formula program formula true whenev part system satisfi system must also satisfi typic proof show hi htrueim 0 hold conclud htrueim k 0 hi true order autom approach model checker must sever properti must abl check properti true system built use given compon gener must abl restrict given class environ check must also provid facil perform tempor reason exist model checker design provid facil instead typic assum given complet system eleg way obtain system properti provid preorder finit state model captur notion behavior use logic whose semant relat preorder preorder preserv satisfact formula logic ie formula true model also true model smaller preorder addit composit preserv preorder system smaller preorder individu compon final satisfact formula correspond smaller particular model tableau formula preorder framework reason sequenc might express tableau k assumpt may given either formula directli finit state model whichev concis conveni complex form reason induct 18 also possibl within framework choos comput model logic preorder obtain system guid follow consider first must abl realist model physic system circuit second effici procedur model check check preorder final possibl implement procedur effect use symbol techniqu paper propos preorder use subset logic ctl 11 subset strictli express ltl induc subset ctl express enough verif task effici model check algorithm also give tableau construct ctl subset construct provid mean tempor reason make possibl use formula assumpt preorder semant logic includ notion fair essenti model system commun protocol show use result verifi system compos moor machin moor machin explicit notion input output particularli suitabl model synchron circuit final suggest effici method check preorder sever interest case implement system base result system support effici composit verif tempor reason paper organ follow section 2 survey relat work section 3 present logic semant kripk structur preorder properti given section 4 next section defin semant logic moor machin given moor machin formula show effici check whether environ moor machin environ satisfi formula section 6 present tableau construct demonstr use tempor reason method check preorder discuss section 7 section 8 give composit verif simpl cpu control conclud summari direct futur work relat work much work reduc complex automat verif group two class first class includ method build reduc global state graph expand need portion global state graph local model check algorithm 6 26 29 base logic like calculu use tableaubas procedur deduc specif state initi state system satisfi given logic formula state space gener need algorithm formula small portion space may examin main drawback algorithm often entir space gener exampl check properti hold global also clear whether algorithm take good advantag symbol represent graf steffen 13 describ method gener reduc version global state space given descript system structur specif compon interact clark long mcmillan 4 describ similar attempt method still produc larg state graph state system equival much verif must redon part system chang shtadler grumberg 24 show verifi network process whose structur describ grammar approach involv find global behavior compon network arbitrari complex verifi check one repres system mani system howev number state may still prohibit clear whether method use symbol represent second class method composit properti individu compon verifi properti global system deduc represent global state space built josko 15 give algorithm check whether system satisfi ctl specif environ algorithm also allow assumpt environ specifi restrict lineartim logic system abl handl assumeguarante reason method fairli ad hoc howev complex form reason induct easili incorpor system within framework cc 22 number suggest composit reason larsen 19 investig express power formal specifi behavior process system suggest equival refin satisfact formula three interest relat implement specif howev discuss applic idea verif suggest implement walker 27 demonstr use preorder plu knowledg system oper simplifi verif bisimul equiv alenc cleaveland steffen 7 use similar idea winskel 28 propos method decompos specif properti compon system must satisfi specif hold approach appeal unfortun deal parallel composit difficult appar whether method work well symbol represent kurshan 16 describ verif methodolog base test contain regular languag homomorph reduct use map implement specifica tion specif may use implement next level abstract dill 10 propos eleg form trace theori use similar manner framework handl live properti well approach depend specif determinist effici neither approach make provis use logic formula specif assumpt shurek grumberg 25 describ criteria obtain modular framework illustr idea use ctl univers path quantifi system closest work present give provis handl fair effici use formula assumpt support tempor reason model system also associ fix decomposit compon henc unclear perform induct reason framework 3 tempor logic logic present section branchingtim tempor logic order abl effici decid whether formula true system contain given compon elimin existenti path quantifi logic thu formula may includ univers quantifi path unlik lineartim tempor logic nest path quantifi allow ensur existenti path quantifi aris via negat assum formula express negat normal form word negat appli atom proposit logic interpret form kripk structur fair constraint path quantifi rang fair path structur logic 8ctl set state formula given follow induct definit 1 constant true fals state formula everi atom proposit p p state formula 2 state formula state formula 3 path formula 8 state formula 4 state formula path formula 5 path formula 6 path formula x b u also use follow abbrevi f g path formula denot true u fals v respect 8ctl restrict subset 8ctl 8 path quantifi may preced restrict set path formula precis 8ctl logic obtain elimin rule 3 6 ad follow rule 3 state formula 8x 8 u 8 v state formula practic found mani formula use specifi verifi system express 8ctl almost express 8ctl exampl formula express 8ctl weak form absenc deadlock state alway possibl reach state p hold give semant logic use form kripk structur fair constraint tupl follow form 1 finit set state 2 0 set initi state 3 finit set atom proposit 4 l function map state set atom proposit true state 5 r theta transit relat 6 f streett accept condit repres pair set state definit 3 path infinit sequenc state infinit mani g fair path iff everi notat n denot suffix begin n consid semant logic 8ctl atom proposit drawn set definit 5 satisfact formula satisfact state formula state path formula fair path j defin induct follow 1 2 3 everi fair path start 4 state formula iff first state satisfi state formula 5 6 c indic everi 0 emerson halpern 11 compar express power three logic ltl ctl ctl show ltl ctl incompar express power ctl strictli express either other elimin existenti path quantifi ctl ctl affect rel express power logic 8ctl trivial encompass ltl 8ctl formula 8f8gp formula 8ctl equival ltl formula hand equival ltl formula 8fg p thu ltl 8ctl incompar strictli less express 8ctl 4 homomorph composit structur section defin preorder use examin properti also show properti make assumeguarante style reason possibl definit 6 structur homomorph let 0 two structur 0 let 0 state 0 respect relat h theta 0 homomorph follow condit hold 1 ht 0 2 0 hs 0 impli b everi fair path exist fair path 1 0 everi h satisfi properti 2 say h homomorph h homomorph 0 iff everi 0 2 0 0 0 hs indic two path correspond item 2b write h 0 homomorph exist homomorph 0 0 understood sometim write 0 intuit two state homomorph label agre atom proposit second structur everi fair path first state correspond fair path second state two structur homomorph everi initi state first correspond initi state second one may view second structur specif first implement sinc specif may hide implement detail may smaller set atom proposit definit 8 composit structur let 0 two structur composit 0 denot k 0 structur 00 defin follow 1 2 00 3 4 l 00 5 r 00 choic definit composit motiv correspond composit moor machin transit composit joint transit compon state composit pair compon state agre common atom proposit first note composit oper usual properti theorem 1 composit structur commut associ isomorph proof straightforward tediou 2 turn connect relat composit begin note path k 0 fair iff restrict compon result fair path follow condit equival 1 fair path 00 2 1 fair path 0 respect state 00 2 n proof assum condit 1 definit composit path let definit fair path inf 00 henc fair path similarli 1 fair path 0 assum condit 2 definit composit path 00 suppos p theta 0 first case impli second case similar henc 00 fair path 00 2 theorem 2 1 preorder 2 0 3 4 k proof 1 relat homomorph reflex thu remain show transit assum let h 0 homomorph 0 let h 1 homomorph 0 00 defin h 2 relat product h 0 h 1 ie definit homomorph exist 0 0 h 0 similarli exist 00 0 h 1 0 h 0 0 h 1 definit homomorph fair path exist fair path 0 0 0 h 0 0 sinc h 1 homomorph exist fair path 00 00 00 h 1 homomorph 00 thu 00 2 defin h initi state km 0 0 label 0 lsl 0 0 fair path k 0 previou lemma 0 1 fair path definit h h everi henc h homomorph k 0 3 let h 0 homomorph 0 defin h 1 ni show h 1 homomorph let initi state k 00 definit composit 0 0such h 0 0 state 0 k 00 sinc initi state 0 k 00 definit composit definit h 1 h 1 first note fair path k 00 00 everi previou lemma fair path start 1 fair path 00 00 sinc path 1 0 everi 2 n definit homomorph ls argu 0 state 0 k 00 h 1 definit h 1 appli previou lemma find 0 fair path start correspond path 4 first note everi state state k defin 0 2 0 definit composit initi state k trivial label use previou lemma definit composit find 0 1 fair path fair path k definit h henc h homomorph k 2 theorem 3 let 0 state 0 let h homomorph path h 0 1 everi 8ctl state formula atom proposit 0 2 everi 8ctl path formula atom proposit 0 proof proof proce induct structur formula 1 fals result trivial atom proposit definit homomorph lsa case 2 induct hypothesi impli case 3 everi fair path fair path definit homomorph exist fair path 0 0 h 0 0 0 0 induct hypothesi impli 4 path formula consist state formula 0 initi state 0 0 satisfi induct hypothesi sinc initi state 5 case conjunct disjunct path formula similar case 2 6 sinc h 0 also induct hypothesi impli 1 b impli exist n 0n j appli induct hypothesi n c case similar previou two case 2 corollari everi 8ctl formula atom proposit 0 proof immedi 2 use theorem 2 corollari see standard ctl ctl model check algorithm 3 restrict 8ctl 8ctl view determin whether formula true system contain given compon key composit verif theorem corollari also straightforward justifi sound assumeguarante paradigm assumpt given structur connect structur formula examin section 6 discharg assumpt involv check relat suppos wish check verifi follow relationship word discharg assumpt 0 assumpt discharg assumpt 0 assumpt 0 satisfi desir formula theorem 2 corollari 1 impli k 0 theorem corollari also show system contain k 0 satisfi note necessarili true either 0 may involv atom proposit 0 5 moor machin seen structur defin earlier definit 2 use composit reason synchron system howev system typic given use common finit state model moor machin 14 moor machin model comput explicit notion input output sinc input origin extern uncontrol environ machin alway receiv combin input valu moor machin synchron composit moor machin machin make singl step everi point thu suitabl model synchron circuit section show natur correspond moor machin empti set input structur defin earlier use correspond defin semant 8ctl respect moor machin show use composit reason verifi system compos moor machin definit 9 moor machin moor machin tupl follow form 1 finit set state 2 0 set initi state 3 finit set input proposit 4 finit set output proposit 5 l function map state set output proposit true state theta transit relat requir everi 2 v exist 2 rs v also let denot composit moor machin let 0 moor machin composit 0 denot km 0 moor machin 00 defin follow 1 2 00 3 4 5 l 00 r 0 turn question defin satisfact specif moor machin key consider wish composit method reason thu satisfi specif mean plu environ satisfi specif achiev consid behavior complet system involv definit 11 moor machin call close intuit behavior close machin alter machin structur natur correspond defin structur precis definit actual slightli gener assign structur nonclos machin well definit 12 structur moor machin structur 0 correspond moor machin denot km defin follow 1 2 0 3 4 l 0 v 5 r 0 definit 13 moor machin 0 call close environ 0 0 0 close environ 0 compos result moor machin close defin satisfact formula moor machin definit 14 satisfact moor machin moor machin 8ctl formula atom proposit everi close environ must demonstr effici check whether moor machin km k km 0 proof defin oe map state km km 0 state kmkkm 0 follow oe suppos map state km k km 0 definit oe immedi 0 definit moor machin composit v u disjoint 0 henc impli henc oe inject argu oe surject consid cardin two set state first consid js number state cross product km theta km 0 compat label fix pair state 0 2 ji j state km first compon 2 ji 0 j km 0 0 first compon thu potenti 2 jij state km correspond 0 howev must correspond atom proposit 0 0 0 thu exactli state km k km 0 correspond 0 thu henc oe biject initi state km k 0 0 oe initi state km kkm 0 sinc 0 initi state km 0 impli initi state km 0 similarli oe initi state km k km 0 initi state km k 0 set atom proposit two structur clearli ident label v label oe v v v l 0 r km fair set structur empti 2 definit 15 moor machin maxim close environ denot em moor machin 0 defin follow 1 2 0 3 4 5 maxim environ repres environ anyth step intuit possibl behavior arbitrari environ must also possibl behavior maxim environ logic use specifi properti hold everi possibl behavior system henc plu maxim environ satisfi formula environ satisfi formula lemma close environ suppos proof defin note everi 0 2 0 00 2 00 hs state l 0 0 00 0 relat h everi state 00 initi state hs definit h l 0 0 fact everi state 0 relat state 00 plu fact r 00 ident true impli path 00 00 h everi path 00 fair thu h homomorph 2 lemma 4 let moor machin km isomorph km k em map state 00 state 0 oe v oe obvious inject oe surject sinc subset 2 state em must 0 henc similarli 00 0 trivial equal also v v final r 00 f 00 f 0 empti 2 theorem 4 moor machin proof suppos km 4 find km k em j lemma 2 km k kem close environ lemma 3 henc theorem 2 km k km 0 appli corollari 1 km k km 0 henc lemma 4 km thu determin system 1 k 2 k k n satisfi formula instead check lemma 2 equival check formula illustr previou section use assumeguarante paradigm tri verifi latter relat thu actual verif work structur even though thing want verifi properti composit moor machin 6 tableau construct section give tableau construct 8ctl formula similar construct ltl see burch et al 1 show tableau formula maxim model formula relat thu structur gener construct use assumpt compos structur desir system appli model check algorithm discharg assumpt simpli matter check environ satisfi formula also indic tableau use tempor reason remaind section fix 8ctl formula definit 16 set sub subformula formula defin follow equat 1 atom proposit fg negat atom proposit pg 2 3 b c definit 17 set el elementari formula formula defin follow equat 1 atom proposit fpg 2 3 b c special elementari subformula 8x fals denot nonexist fair path fals indic fair path begin definit formula tableau denot structur fi defin follow 1 2 map el sub ftrue falseg defin follow equat g b c ii 3 g 4 g 5 rs iff formula 8x el 8x 2 impli 2 phi lemma 5 subformula 2 phi proof proof proce induct structur 1 everi state satisfi true result trivial atom proposit g negat atom proposit g sinc 2 induct hypothesi case 3 rs definit r 2 phi 1 induct hypothesi impli chosen arbitrarili fair path satisfi 1 second state henc b state phi either case successor trivial case induct hypothesi impli case induct hypothesi impli definit r also know rt u u 2 phi consid fair path note state path satisfi first condit two case consid j j first state path everi henc path satisfi 1 u 2 ii everi j j 6j 2 impli everi j induct hypothesi know j phi 2 definit f contradict fact fair case imposs thu c state phi either case successor trivial case also either 2 phi 1 everi u rt u u 2 phi fair path note satisfi first condit induct hypothesi impli induct hypothesi impli j j path satisfi henc let lemma 6 defin relat h 0 theta everi subformula elementari formula 0 proof proof proce induct structur base case induct elementari subformula plu true fals 1 result trivial definit h 0 2 negat atom proposit 0 3 induct hypothesi 2 case 4 given three case fair path start 0 0 induct hypothesi impli b 0 induct hypothesi 2 phi 2 2 phi c otherwis 0 induct hypothesi 2 case 2 phi8 1 u 2 5 fair path start 0 case 0 fals induct hypothesi impli 2 phi induct hypothesi 2 phi 2 also either 0 0 appli induct hypothesi either 2 case 2 phi thu case 2 lemma 7 relat h given homomorph proof note everi state 0 0 singl state hs 0 let set atom proposit assum hs 0 g definit h 2 fair path 0 let 8x 1 8x 2 8x n formula form 8x el 0 satisfi state relat 0 1 h previou definit h formula form 8x must exactli 8x 1 8x 2 8x n definit r see rs 1 sinc hs 0 continu process defin get sequenc state start hs 0 complet proof must show sequenc fair assum fair look f see must elementari subformula 8x8 u b inf phi8x 8 u b consid one state definit h impli 0 addit previou lemma impli j fair path 0 start 0 everi state path satisfi b 0 henc fact fair path theorem 5 0 proof suppos 0 lemma 5 definit tableau everi initi state satisfi ie definit everi 0 definit h everi 0 pair uniqu 0 lemma 6 impli 0 2 phi definit tableau 0 2 0 lemma 7 h homomorph 0 2 tableau construct also use reason formula typic interest whether everi model formula also model formula relat proposit proof everi model particular also model assum previou corollari sinc sometim extend set elementari formula formula ad addit atom proposit exampl wish check whether true impli p would extend set atom proposit true includ p anoth way view imagin rewrit true true p p formula nontrivi model iff case j 8x fals true everi model iff true 7 check homomorph section discuss problem determin whether exist homomorph two structur 0 goal effici determin 0 first note h 1 h 2 homomorph h 1 h 2 homomorph also trivial homomorph fact impli maxim homomorph set inclus actual give algorithm comput maxim homomorph also note follow fact 1 state fair path start homomorph exactli state 0 0 2 0 state 0 fair path start 0 0 homomorph exactli state start fair path lsa state start fair path detect polynomi time 12 elimin preprocess step henc without loss gener assum everi state 0 start fair path describ polynomi time algorithm check preorder sever import special case suppos 0 trivial accept condit ie f definit 19 defin sequenc relat h follow 1 2 h first h h exist sinc h j1 h j j h j finit theorem 6 everi 2 0 proof first note h greatest fix point equat suppos 0 state h 0 fair path start equat exist state 0 1 r 0 continu fashion find path 0 start 0 h path fair henc h homomorph 0 ie 0 show 0 impli h 0 show homomorph h fix point equat sinc h greatest fix point h henc homomorph h hs 0 enough show h subset set hs 0 earlier assumpt exist fair path henc let fair path 0 1 sinc hs 0 exist fair path 0 1 0 1 see 0 set 2 note h jsj delta js 0 j h j1 also comput polynomi time h comput polynomi time anoth import case 0 determinist ie r 0 languag contain languag 0 languag state set sequenc label occur along fair path start relat check polynomi time use techniqu clark draghicescu kurshan 2 final 0 result tableau construct say shown previou section check whether 0 reduc problem check whether 8 exampl implement bddbase model checker base theori develop previou section model checker written combin yale dialect scheme c includ facil model check tempor reason via tableau construc tion check homomorph illustr system use control simpl cpu exampl control written state machin descript languag call csml 5 compil moor machin give brief descript cpu clark long mcmillan 5 give detail cpu simpl stackbas machin ie part cpu memori contain stack instruct operand pop onto result push two part cpu control first part call access unit respons cpu memori refer enc second part call execut unit interpret instruct control arithmet unit shifter etc two part oper parallel access unit execut unit commun via small number signal three signal push pop fetch input access unit indic execut unit want push pop someth stack get next instruct signal correspond readi output access unit execut unit must wait appropri readi signal proceed one addit signal branch assert execut unit want jump new program locat order increas perform access unit attempt keep valu top stack special regist call ts regist goal keep execut unit wait memori exampl ts regist contain valid data pop oper proceed immedi addit valu push stack move regist copi memori later point access unit also load instruct queue possibl fetch requir wait memori queue flush whenev cpu branch clark long mcmillan gave number correct condit control demonstr formula verifi composit fashion form condit divid three class first class consist simpl safeti properti access unit exampl one formula state access unit output topofstack pointer memori address either read write ts regist model checker verifi properti held access unit alon henc hold system contain access unit condit second class slightli complex properti safeti properti specifi sequenc oper allow exampl one condit push 8x8tsstore pop v push tsload push abbrevi push pushrdi pop abbrevi pop poprdi formula assert push oper complet anoth push complet access unit attempt load ts regist memori either pop occur ts regist store stack word regist contain valu need push stack cpu anyth would destroy valu valu either use success store memori sinc properti class essenti specifi access unit may assert readi signal tempt check whether hold access unit alon well possibl howev properti also depend memori acknowledg signal behav verifi properti made simpl model memori see figur 1 concis figur show moor machin actual model use obtain ad fair constraint shown figur structur correspond moor machin properti class except one turn true system compos access unit model memori except analog previou formula deal occur pop counterexampl produc model checker formula show formula fals push pop could occur simultan examin access unit saw design assum oper would mutual exclus formula turn true addit assumpt 8gpush pop model checker verifi build tableau assumpt compos access unit memori model check formula f defin memrd memwr memack figur 1 memori abstract final class criteria consist singl live properti 8g8ffetch fetchrdi formula state cpu alway fetch anoth instruct demonstr two differ way verifi properti one way observ formula true must obvious case memori respond request eventu execut unit execut infinit sequenc push pop branch memori model alreadi fair constraint ensur first noth guarante second take care use simpl model execut unit see figur 2 actual model structur deriv moor machin plu indic fair constraint output idl figur abbrevi pushpopfetchbranch model checker verifi access unit plu model execut unit memori satisfi formula also verifi homomorph structur actual execut unit model thu conclud formula hold final system provid homomorph actual memori model also check execut unit model satisfi assumpt 8gpush pop use sinc homomorph execut unit model know execut unit must satisfi assumpt well final step allow us conclud composit access execut unit satisfi entir specif provid memori homomorph model use fetchrdi pushrdi poprdi fetchrdi pushrdi poprdi f defin branch fetch idl push pop figur 2 execut unit abstract also verifi final properti use seri 8ctl assumpt idea check properti execut unit order formula true access unit must eventu respond push pop request must fill instruct queue appropri guarante access unit meet condit know execut unit tri two oper remov request correspond oper complet begin properti fetch 1 2 first specifi everi pair oper execut unit perform mutual exclus two formula state execut unit make push pop request deassert request oper complet model checker verifi properti hold execut unit alon use tableau construct first properti impli assumpt 8gpush pop use use formula 1 2 assumpt check system compos access unit memori model satisfi formula specif state everi push oper complet similarli use formula 1 3 assumpt verifi system compos access unit memori model also satisfi formula 8g8ffetchrdi branch point either access unit eventu fill instruct queue branch occur final use formula formula 4 5 assumpt model checker verifi execut unit satisfi 8g8ffetch fetchrdi complet verif would demonstr homomorph actual memori model 9 conclus identifi subset 8ctl ctl appropri composit rea sone subset satisfact preserv composit henc standard model check algorithm use answer question formula true system contain specifi compon also propos preorder appropri 8ctl preorder captur relat compon system contain compon provid basi use assumeguarante style reason logic assumpt given structur discharg check preorder given tableau construct 8ctl subset 8ctl satisfact 8ctl formula correspond tableau formula preorder construct make possibl use 8ctl formula assumpt tempor reason 8ctl also effici model check algorithm implement verif system base result use verifi nontrivi system composit fashion sever direct futur work intuit 8ctl subset ctl maxim sens formula satisfact preserv composit equival formula 8ctl prove anoth idea look differ logic flavor 8ctl extend automata oper calculu delta modal would also interest tri extend tableau construct section 6 8ctl order accomplish howev almost certainli necessari use complex type structur given definit 2 anoth question whether possibl appli idea branchingtim logic existenti path quantifi exampl reason algorithm determin whether ctl formula true system contain given compon fairli easi come algorithm sound complet seem difficult achiev also wish examin problem effici check preorder arbitrari structur final essenti tri appli composit reason method consid complex system order evalu techniqu r symbol model check 10 20 state beyond unifi approach show languag contain equival variou type automat verif finitest concurr system use tempor logic specif composit model check languag composit specif verif finit state hardwar control partial verifi tempor properti sequenti machin without build state diagram trace theori automat hierarch verif speedindepend circuit sometim effici model check fragment proposit mucalculu composit minim finit state process introduct automata theori verifi correct aadlmodul use model check analysi discret event coordin structur induct theorem process express power implicit specif check finit state concurr program satisfi linear specif calculu commun system transit global modular tempor reason program network grammar modular framework computeraid verif moti vation local model check modal mucalculu bisimul diverg composit check valid finit state process model check modal tr myampersandldquosometimesmyampersandrdquo myampersandldquonot nevermyampersandrdquo revisit automat verif finitest concurr system use tempor logic specif structur induct theorem process trace theori automat hierarch verif speedindepend circuit composit model check concurr workbench network grammar commun behavior automat verif verifi correct aadl modul use model check analysi discret event coordin unifi approach show languag contain equival variou type myampersandohgrautomata transit global modular tempor reason program tableaubas model check proposit mucalculu express power implicit specif note model check model myampersandngrcalculu check finit state concurr program satisfi linear specif calculu commun system introduct automata theori languag comput local model check modal mucalculu modular framework computeraid verif verifi tempor properti sequenti machin without build state diagram composit minim finit state system design synthesi synchron skeleton use branchingtim tempor logic ctr pallab dasgupta arindam chakrabarti p p chakrabarti open comput tree logic formal verif modul proceed 2002 confer asia south pacif design automationvlsi design p735 januari 0711 2002 robert john walter check model built use graphic base formal model languag journal system softwar v76 n1 p5564 april 2005 alma l juarez dominguez nanci day composit reason portbas distribut system proceed 20th ieeeacm intern confer autom softwar engin novemb 0711 2005 long beach ca usa w b prasetya swierstra factor fault toler theoret comput scienc v290 n2 p12011222 2 januari david harel orna kupferman mosh vardi complex verifi concurr transit system inform comput v173 n2 p143161 march 15 2002 yunshan zhu jame h kukula generatorbas verif proceed ieeeacm intern confer computeraid design p146 novemb 0913 k mani chandi michel charpenti experi program composit proof formal method system design v20 n1 p721 januari 2002 arindam chakrabarti pallab dasgupta p p chakrabarti ansuman banerje formal verif modul interfac real time specif proceed 39th confer design autom june 1014 2002 new orlean louisiana usa r lazi c newcomb w rosco model check dataindepend system array without reset theori practic logic program v4 n56 p659693 septemb 2004 doron bustan orna grumberg simulationbas minim acm transact comput logic tocl v4 n2 p181206 april jason baumgartn tamir heyman vigyan singhal adnan aziz abstract algorithm verif levelsensit latchbas netlist formal method system design v23 n1 p3965 juli juergen dingel computerassist assumeguarante reason verisoft proceed 25th intern confer softwar engin may 0310 2003 portland oregon yonit kesten nir piterman amir pnueli bridg gap fair simul trace inclus inform comput v200 n1 p3561 1 juli 2005 alur radu grosu modular refin hierarch reactiv machin proceed 27th acm sigplansigact symposium principl program languag p390402 januari 1921 2000 boston usa thoma henzing orna kupferman sriram k rajamani fair simul inform comput v173 n1 p6481 februari 25 2002 ferucio laurentiu tiplea aurora tiplea petri net reactiv modul theoret comput scienc v359 n1 p77100 14 august 2006 clark grumberg jha verifi parameter network acm transact program languag system topla v19 n5 p726750 sept 1997 adnan aziz thoma shipl vigyan singhal robert brayton alberto sangiovannivincentelli formuladepend equival composit ctl model check formal method system design v21 n2 p193224 septemb 2002 peter henderson model architectur dynam system program methodolog springerverlag new york inc new york ny alur thoma henzing reactiv modul formal method system design v15 n1 p748 juli 1999 alur radu grosu modular refin hierarch reactiv machin acm transact program languag system topla v26 n2 p339369 march 2004 orna kupferman mosh vardi automatatheoret approach modular model check acm transact program languag system topla v22 n1 p87128 jan 2000 yunja choi sanjai rayadurgam mat pe heimdahl automat abstract model check softwar system interrel numer constraint acm sigsoft softwar engin note v26 n5 sept 2001 doron bustan orna grumberg applic fair simul inform comput v194 n1 p118 10 octob 2004 xudong huiqun yu tianjun shi junhua ding yi deng formal analyz softwar architectur specif use sam journal system softwar v71 n12 p1129 april 2004 edmund clark armin bier richard raimi yunshan zhu bound model check use satisfi solv formal method system design v19 n1 p734 juli 2001 arindam chakrabarti patric godefroid softwar partit effect autom unit test proceed 6th acm ieee intern confer embed softwar octob 2225 2006 seoul korea thoma henzing orna kupferman rupak majumdar univers existenti fragment calculu theoret comput scienc v354 n2 p173186 28 march 2006 ansuman banerje pallab dasgupta open famili tempor logic annot tempor oper input constraint acm transact design autom electron system toda v10 n3 p492522 juli 2005 f zaraket j baumgartn aziz scalabl composit minim via static analysi proceed 2005 ieeeacm intern confer computeraid design p10601067 novemb 0610 2005 san jose ca mat p heimdahl devaraj georg effect testsuit reduct automat gener modelbas test autom softwar engin v14 n1 p3757 march 2007 sharon barner orna grumberg combin symmetri reduct underapproxim symbol model check formal method system design v27 n12 p2966 septemb 2005 dongfeng wang farokh b bastani ling yen autom aspectori decomposit processcontrol system ultrahigh depend assur ieee transact softwar engin v31 n9 p713732 septemb 2005 chouali j julliand pa masson f bellegard pltlpartit model check reactiv system fair assumpt acm transact embed comput system tec v4 n2 p267301 may 2005 mauro caporuscio paola inverardi patrizio pelliccion composit verif middlewarebas softwar architectur descript proceed 26th intern confer softwar engin p221230 may 2328 2004 andrew gordon alan jeffrey authent type secur protocol journal comput secur v11 n4 p451519 01012004 david dharb tutori introduct symbol model check logic concurr synchronis kluwer academ publish norwel frdric herbreteau franck cassez olivi roux applic partialord method reactiv programswith event memor realtim system v20 n3 p287316 may 2001 kathi fisler mosh vardi bisimul minim symbol model check formal method system design v21 n1 p3978 juli 2002 composit analysi verif parameter system theoret comput scienc v354 n2 p211229 28 march 2006 de la riva javier tuya automat gener assumpt modular verif softwar specif journal system softwar v79 n9 p13241340 septemb 2006 r gentilini c piazza policr bisimul simul coarsest partit problem journal autom reason v31 n1 p73103 hakan erdogmu architecturedriven verif concurr system nordic journal comput v4 n4 p380413 winter 1997 tevfik bultan richard gerber william pugh modelcheck concurr system unbound integ variabl symbol represent approxim experiment result acm transact program languag system topla v21 n4 p747789 juli 1999 sara gradara antonella santon maria luisa villani use heurist search find deadlock concurr system inform comput v202 n2 p191226 1 novemb 2005 stephan merz model check tutori overview model verif parallel process springerverlag new york inc new york ny 2001 christoph kern mark r greenstreet formal verif hardwar design survey acm transact design autom electron system toda v4 n2 p123193 april 1999 edmund clark berndholg schlingloff model check handbook autom reason elsevi scienc publish b v amsterdam netherland 2001