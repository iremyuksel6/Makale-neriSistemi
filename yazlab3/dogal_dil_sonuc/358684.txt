effici address gener affin subscript dataparallel program address gener compil program written hpf execut spmd code import necessari phase parallel compil paper present effici compil techniqu gener local memori access sequenc blockcycl distribut array refer affin subscript dataparallel program memori access array refer affin subscript within twonest loop exist repetit pattern outer inner loop use tabl record memori access repetit pattern accord tabl new startcomput algorithm propos comput start element processor outer loop iter complex tabl construct oks2 k distribut block size s2 access stride inner loop tabl construct gener start element outer loop iter run o1 time moreov also show repetit iter outer loop pkgcdpks1 p number processor s1 access stride outer loop therefor total complex gener local memori access sequenc blockcycl distribut array affin subscript twonest loop opkgcdpks1ks2 b introduct gener speak dataparallel languag support three regular data distribut block cyclic blockcycl data distribut block distribut distribut contigu array element evenli onto processor cyclic distribut distribut array element onto processor one time roundrobin fashion distribut block size k distribut onto processor roundrobin fashion blockcycl distribut denot cyclick blockcycl distribut known gener data distribut block cyclic distribut repres blockcycl distribut cyclicd na e cyclic1 respect na number array element p number processor address gener problem compil array refer block cyclic distribut studi thoroughli 5 12 13 21 gener problem compil array refer blockcycl distribut also studi extens 3 7 9 11 11 14 16 19 20 22 finit state machin fsm approach propos travers local memori access sequenc processor 3 method tablebas approach tabl construct need solv k linear diophantin equat incur sort oper work improv fsm approach 3 propos 10 11 20 effici fsm tabl gener propos improv work enumer local memori access sequenc view access element integ lattic sort step 3 avoid improv work 7 author use virtual processor gener commun set processor differ viewpoint blockcycl distribut virtual processor approach actual contain two approach one term virtual block approach term virtual cyclic approach virtual block approach view blockcycl distribut block distribut set virtual processor cyclic map processor con trari virtual cyclic approach view blockcycl distribut cyclic distribut set virtual processor blockwis map processor approach similar either fsm approach virtual processor approach except modif howev consid simpl array subscript array subscript contain one induct variabl recent sever effort compil array refer affin array subscript propos 1 10 11 15 17 22 affin array subscript mean array subscript linear combin multipl induct variabl miv 1 author use linear algebra framework gener commun set affin array subscript complex loop bound local array subscript gener code incur signific overhead tablebas approach propos 22 author classifi block class use class tabl record memori access first repetit pattern use class tabl deriv commun set processor 1 22 address compil array refer affin subscript within multinest loop ever propos method effici enough deal special case compil array refer affin sub script research pay attent array refer enclos within twonest loop find better result 10 11 17 base fsm approach 3 kennedi et al propos anoth approach solv compil array refer affin subscript within twonest loop 10 11 memori access array refer affin subscript within twonest loop exist repetit pattern outer inner loop moreov fix iter outer loop affin subscript reduc simpl subscript therefor iter outer repetit pattern use fsm approach gener local memori access sequenc inner loop use fsm approach inner loop start comput decid initi state fsm iter outer loop necessari propos opk algorithm startcomput p number processor k distribut block size outer loop found repetit iter pk iter henc total complex gener local memori access sequenc array refer affin subscript within twonest loop op ramanujam et al propos improv work find local start element processor 17 first find factor basi vector jump global start processor space travers lattic hit start element enddo enddo fig 1 hpflike program model consid paper sinc travers step incur complex startcomput algorithm ok thu total complex ramanujam algorithm turn opk 2 paper also propos anoth new start comput algorithm preprocess step requir comput start element complex preprocess step ok 2 access stride inner loop preprocess done time complex gener start element processor o1 addit also discov outer loop repetit iter pk gcdpk 1 instead pk 1 access stride outer loop therefor total complex propos approach opk gcdpk 1 asymptot opk propos approach correct also effici paper organ follow section 2 formul problem describ tradit techniqu gener local memori access sequenc compil array refer affin subscript within twonest loop effici approach find start element global start propos section 3 perform analys comparison relat work demonstr section 4 section 5 conclud paper address gener affin subscript 21 problem formul specif fig 1 illustr program model consid paper array distribut onto processor cyclick distribut array refer contain two induct variabl 1 2 access stride array refer respect 1 2 1 2 respect access offset array refer fig 2 exampl program model shown fig 1 fig 2a layout array element processor color element array element access array refer twonest loop fig 2b show global address array element access everi processor howev data distribut transfer global address space processor local space therefor care gener local address processor access ele ment thu miv address gener problem gener local address array element access processor like fig 2c show 22 tabl base address gener affin subscript case array refer contain singl induct variabl siv wellknown memori access processor repetit pattern 3 finit state machin fsm built orderli iter local memori access sequenc pro cessor similarli array refer contain multipl induct variabl miv extend techniqu use siv orderli enumer local memori access sequenc processor consid program model shown fig 1 outer iter miv address gener problem reduc siv problem thu util fsm approach gener local memori access sequenc siv problem gener local memori access sequenc miv problem therefor easili solv enumer sequenc outer loop iter reach outer loop bound exampl consid exampl illustr fig 2 suppos outer loop iter 1 0 twonest loop reduc singl nest loop array refer turn a2i 2 thu finit state machin fsm built enumer local memori access sequenc siv problem fig 3 illustr fsm gener local memori access sequenc array refer contain singl induct variabl access stride 2 fig 3a show fsm tabl next record next transit state deltam record local memori gap success array element current state transmit next state fig 3b transit diagram fsm initi state fsm depend posit start array element block processor instanc start element processor p 0 0 posit b c fig 2 miv address gener exampl layout array element processor b global address array element access everi proce sor c local address array element access everi processor state next deltam b fig 3 finit state machin fsm gener local memori access sequenc siv problem access stride 2 block 0 thu initi state fsm case 1 0 state 0 addit initi state fsm also need know local address start element sinc fsm record local memori gap success array element alloc processor fsm enough inform show start term local address word although fsm initi state still know start local address case exam ple besid initi state fsm state 0 know figur local address start element obvious local address start element 0 processor p 0 0 therefor local memori access sequenc processor p 0 0 2 4 likewis twonest loop reduc singl nest loop array refer simplifi 37 finit state machin built case 1 still reus sinc memori access stride still 2 exampl 1 1 start element processor 49 posit block 1 thu initi state fsm case 1 1 state 1 howev start term local address key point 1 1 start element processor p 0 local address processor p 0 13 therefor local memori access sequenc processor p 0 13 15 similarli done likewis outer loop iter accordingli obtain local memori access sequenc processor fig 2c show actual need iter outer loop iter 0 n 1 found iter outer loop iter pk gcdpk 1 time enough repetit pattern outer loop discoveri save lot time due avoid recomput repetit pattern follow theorem demonstr repetit period outer loop pk gcdpk 1 iter sinc space lim ite proof theorem omit paper one refer 18 detail theorem 1 program model shown fig 1 memori access array refer repetit pattern repetit period respect outer loop iter pk gcdpk 1 tion 2 accord descript evid determin local address start element outer loop iter primari step solv miv address gener problem problem find local address start element outer loop iter describ next section new approach gener local address start element present next section well gener start element find start element outer loop iter import solv miv address gener problem obviou given outer loop iter memori access depend inner loop access stride 2 therefor section use indic inner loop access stride 2 except otherwis notifi method find start element case k found 10 17 o1 com plexiti howev method find start element case k opk ok spectiv propos new approach find start element case k time complex algorithm o1 problem solut describ follow 31 problem descript given overal descript miv address gener problem section 22 find start element processor given outer loop iter play import role deal miv address gener problem follow formal describ induc problem let access element fix outer loop iter b fig 4 start element everi processor exampl shown fig 2 global address start element everi processor b local address start element everi processor global start g local address global start specif given global start g processor p g alloc processor q would like find start element problem figur q local address start element processor q exampl consid exampl shown fig 2a gray color element element access array refer deepcolor shade element global start correspond everi outer loop iter lightcolor shade element processor start element correspond everi global start suppos given global start 37 local address 9 processor start element processor p 0 p 3 49 41 45 respect term global address problem figur local address start element 13 9 9 respect start element everi outer loop iter shown fig 4 global local address start element everi processor list fig 4a 4b respect goal induc problem obtain tabl contain local address start element requir processor everi global start fig 4b show requir processor 32 preprocess given global start g propos new approach find local address start element q processor q case k propos approach tablebas approach approach necessari precomput tabl order evalu start element given global start section describ charact fig 5 onelevel map exampl illustr idea tabl use paper assum array element distribut 4 processor cyclic4 distribut access stride 5 istic tabl work propos approach complex time space analyz section 4 sake space limi tation construct tabl omit paper detail pleas refer 18 321 c2p p2c offset tabl wellknown access element block repetit pattern 22 block classifi class accord posit access element block note block class format block number term class accord rule b mod b block number block repetit pattern contain block class 0 class 1 term class cycl 22 addit sinc k one access element block therefor use tabl record posit access element everi class differ 22 assum access element block class 0 first posit posit 0 block access element record tabl easili effici get posit access element block class number block given therefor easili deduc q g sinc block classifi class denot tabl record posit access element everi class c2p tabl exampl let us suppos array element distribut 4 processor cyclic4 distribut access stride 5 layout array element processor illustr fig 5 figur access element element white text black background obvious block classifi 5 class class color gradat gray color class number block label bottom block block bound dash line indic repetit pattern access element class posit 0 1 2 3 respec tive therefor valu c2p0 1 2 3 0 1 2 3 respect moreov access element class 4 c2p4 thu obtain c2p tabl fig 7a illustr c2p tabl exampl shown fig 5 get posit access element block accord class number block use c2p tabl contrast c2p tabl p2c tabl record class number accord posit access element block thu obtain class number block accord posit access element block gener speak obtain class number block accord posit access element block use c2p tabl howev requir search oper case recogn class number block accord c2p tabl instanc number class smaller block size possibl posit class access element posit would caus confus recogn class number posi tion therefor p2c tabl necessari p2c tabl construct c2p tabl exampl consid c2p tabl shown fig 7a one scan tabl obtain p2c tabl p2c tabl illustr fig 7b note case number class smaller block size posit class number correspond assum class number posit class number previou po sition exampl suppos distribut block size 4 access stride 6 block classifi 3 class access element class 0 1 2 posit 0 2 respect result posit 0 2 correspond class 0 1 spectiv p2c0 1 obvious posit 1 3 suitabl class number correspond assumpt class number correspond posit 1 0 previou posit similarli class number correspond posit 3 1 thu p2c0 0 1 1 basic c2p p2c tabl sens like hash tabl reason make assumpt p2c tabl construct solv offset prob lem offset problem solv assumpt conjunct anoth tabl offset gener speak global start g posit block howev construct c2p tabl assum access element block class 0 posit 0 construct p2c tabl posit class number correspond assign class number previou valu current valu nevertheless accord c2p tabl class number real posit correspond consequ differ real posit assum posit make assumpt order make use c2p tabl everi case use anoth tabl record differ order make shortcom c2p tabl tabl denot asoffset tabl paper discuss number class larger block size posit suitabl class number correspond case offset tabl use fig 5 exampl condit offset tabl shown fig 7c hand number class smaller block size follow exampl use explan p2c tabl assum distribut block size 4 access stride 6 c2p p2c tabl 0 2 0 0 1 1 respect sinc posit 1 suitabl class number correspond assign class number correspond posit 0 posit 1 although posit 1 correspond class 0 real posit access element block class 0 posit 0 accord c2p ta ble thu 1 differ assum valu real valu result offset11 similarli offset31 problem posit 0 2 sinc suitabl class number correspond consequ offset tabl 0 1 0 1 322 nextact jump tabl previous describ block contain one access element access stride larger block size cours block may contain access element case thu name block element access activ block otherwis term empti block tabl nextact jump would like introduc use jump empti b fig one group order sequenc b multipl group order sequenc block activ block one import observ processor viewpoint block processor repetit pattern term class explain concret let us take look exampl shown fig 5 block processor class 0 4 3 2 1 repeat class 0 similar situat also happen processor sequenc class number p 1 1 0 4 3 2 p 2 2 1 0 4 3 p 3 3 2 1 0 4 interest sequenc class number processor except initi class number processor sequenc class number processor view sequenc 0 4 initi class number p 0 p 3 0 1 2 3 respect use notat 0 4 3 2 1 denot order sequenc clearli class number appear order sequenc thu say one group order sequenc fig 6a illustr one group order sequenc exampl address possibl sequenc class number processor may differ may one group order sequenc howev group mutual disjoint processor belong one one group give exampl illustr phenomenon suppos array element distribut 2 processor cyclic3 distribut access stride 12 4 class exampl sequenc class number 2 p 1 1 3 order sequenc repres 0 21 3 obvious order sequenc contain two group one 0 2 anoth 1 3 0 2 1 mutual disjoint processor p 0 belong group 0 belong group 1 3 fig 6b illustr multipl group order sequenc c offset nextact fig 7 tabl use start element find exampl import discoveri sinc obtain class number next block processor current block class number current block known base discoveri use one tabl record class number next activ block current block processor anoth record mani empti block need skip name nextact jump respect construct two tabl base order sequenc c2p tabl current block empti block need jump block thu valu nextact tabl block record class number jump tabl record 0 otherwis travers order sequenc find activ block valu nextact tabl block record class number activ block jump tabl record number block travers find activ block valu nex tact jump tabl record exampl array element distribut 4 processor cyclic4 distribut access stride 8 nextact jump tabl 0 0 respect although processor belong one one group nextact tabl suitabl processor sinc construct tabl base class number group nextact jump tabl exampl shown fig 5 illustr fig 7d e respect 33 algorithm tabl evalu start element given global start o1 time complex iti fig 8 illustr algorithm evalu start element given global start term algorithm start comput algorithm basic concept start comput algorithm algorithm start comput algorithm case k input g global start p processor global start alloc q processor would like find start element q 6 p k distribut block size p number processor access stride c number class c2p p2c offset nextact jump tabl output q start element processor q step 1 po 2 dist 3 4 po 5 po 7 return start element q 8 els po jumpclambdak 9 endif 10 endif 12 q p 13 14 endif 16 return q fig 8 start comput algorithm case viewpoint global start tri figur distanc start element global start distanc therefor get local address start element ad distanc local address global start detail algorithm describ follow given g local address global start g alloc step 1 calcul posit block global start obtain valu store po g step 2 measur distanc processor p q store dist step 3 p2cpo g obtain class number block global start thu step 3 get class number block processor q may contain start element class number obtain step 3 repres c accord c2p tabl c2pc get posit access element block class c ever therefor step 4 obtain posit block start element processor q obtain posit repres po po equal mean access element block cours access element start element go direct step 11 evalu distanc start element global start q p still need add size block distanc sinc start element must one cours global start step 1214 done result local address start element obtain step 15 show hand po mean access element block use nextact tabl obtain class number next activ block nextactc impli exist activ block processor certainli start element pro cessor otherwis mean find activ block processor get number block requir jump current block next activ block posit access element activ block jump nextact tabl respect sinc po step 4 repres posit start element block cours global start henc distanc caus number block requir jump activ block ad po case thu step 8 step 11 explain previou paragraph let us take fig 9 exampl assum given global start 37 whose local address 9 processor first find start element processor input start comput algorithm tabl use exampl shown fig 7 follow step 1 4 algorithm obtain po 2 sinc po equal go direct step 11 obtain offset 1 due invalid condit step 12 go direct step 15 2 correspond array element 42 term global address input except take find start element processor p 0 fig 9 layout array element processor case 2 k anoth miv exampl anoth exampl execut step 4 po 4 po sinc po equal mean block contain access element go step 6 accord nextact jump tabl activ block one block empti block processor p 0 step 8 po 7 step 11 offset 6 need add 4 size block turn correspond array element 67 term global address evid time complex start comput algorithm o1 complex analys tabl use algorithm perform comparison exist method discuss section 4 perform analys comparison perform analys tabl use start comput algorithm shown tabl 1 perform comparison method exist method shown tabl 2 sake space limit pleas refer 18 detail conclus paper present effici approach evalu start element processor given global start key step solv miv address gener problem tabl 1 perform analys tabl complex time space offset nextact oc c tabl 2 perform comparison 10 17 start comp o1 o1 o1 preprocess o1 o1 os 2 start comp opk ok o1 outer loop repetit pk pk pk iter total dataparallel program assum array block cyclic distribut subscript affin approach tablebas approach construct tabl requir os plexiti 2 access stride inner loop tabl start comput algorithm run o1 time addit discov exist repetit pattern everi iter therefor miv address gener problem solv access stride outer loop futur would like appli address gener approach evalu commun set furthermor address gener commun set evalu gener affin subscript also investig r linear algebra framework static hpf code distribut program vienna fortran gener local address commun set data parallel program automat parallel distributedmemori multiprocess system concret mathemat compil array express effici execut distributedmemori machin high perform fortran forum effici address gener blockcycl distri bution lineartim algorithm comput memori access sequenc dataparallel program compil global namespac parallel loop distribut execu tion local iter set comput blockcycl distribut comput local iter set blockcycl distribut refer affin subscript optim represent local iter set access sequenc blockcycl distribut code gener complex subscript dataparallel program gener commun array state ment design effici comput address sequenc data parallel program use close form basi vector optim fortran compil mimd distributedmemori machin compil array refer affin function dataparallel program tr concret mathemat foundat comput scienc compiletim gener regular commun pattern vienna fortranmyampersandmdasha fortran languag extens distribut memori multiprocessor high perform fortran handbook gener commun array statement compil techniqu blockcycl distribut optim fortran compil mimd distributedmemori machin gener local address commun set dataparallel program lineartim algorithm comput memori access sequenc dataparallel program effici address gener blockcycl distribut compil array express effici execut distributedmemori machin effici comput address sequenc data parallel program use close form basi vector empir studi fortran program parallel compil compil global namespac parallel loop distribut execut code gener complex subscript dataparallel program