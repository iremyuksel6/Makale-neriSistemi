data local enhanc memori reduct paper propos memori reduct new approach data local enhanc approach use compil reduc size data repeatedli referenc collect nest loop reus data like remain higherspe memori devic cach specif present optim algorithm combin loop shift loop fusion array contract reduc temporari array storag requir execut collect loop appli 20 benchmark program techniqu reduc memori requir count data code 51 averag transform program gain speedup 140 averag due reduc footprint consequ improv data local b introduct compil techniqu tile 29 30 improv tempor data local interchang nest order time iter loop arraysweep loop unfortun data depend mani program often prevent loop interchang therefor import seek local enhanc techniqu beyond tile paper propos memori reduct new approach data local enhanc approach use compil reduc size data repeatedli referenc collect nest loop end end end ei end b ei ei end end ei end c figur 1 exampl 1 reus data like remain higherspe memori devic cach even without loop inter chang specic present optim algorithm combin loop shift loop fusion array contract contract number dimens array exam ple twodimension array may contract singl dimens whole array may contract scalar opportun memori reduct exist often natur way specifi comput task may memoryeci program written array languag f90 hpf often memori ineci consid extrem simpl exampl exampl 1 figur 1a array assum dead loop l2 rightshift loop l2 one iter figur 1b l1 l2 fuse figur 1c array contract two scalar a1 a2 figur 1d show posit sideeect tempor local array e also improv aggress fusion propos also improv tempor data local dierent loop nest 8 fraboulet et al present network ow algorithm memori reduct base retim theori 16 given perfect nest retim techniqu shift number iter either left right statement loop bodi dierent statement may dierent shift factor three issu remain unresolv work algorithm assum perfectlynest loop appli one loop level loop realiti ever mostli multipl level arbitrarili nest perfectlynest loop although one may appli algorithm one level time approach provabl minim memori requir program transform loop coalesc coalesc multipl loop level singl level unfortun howev algorithm applic result loop requir loop model longer satis sinc work target data local relationship memori minim local ityperform enhanc studi gener minim memori requir guarante better local better perform care must taken control scope loop fusion lest increas loop bodi may increas regist spill cach replac even though footprint whole loop nest may reduc experiment data show memori requir actual reduc use algorithm moreov sinc algorithm address memori minim experiment data verifi conjectur reduc memori requir result better local better perform especi scope loop fusion care control paper make follow main contribut present network ow algorithm provabl minim memori requir multidimension case handl imperfectli nest loop contain collect perfect nest combin loop shift loop fusion array contract complet reformul network ow exactli model problem multidimension gener case work 8 could also appli program model loop fusion appli rst possibl enabl loop shift howev new algorithm prefer 1 multidimension case algorithm optim polynomialtim solvabl complex heurist 8 2 algorithm model imperfectlynest loop directli gener case propos heurist control fusion estim number regist spill cach miss greater one origin loop nest even though benchmark case test far small util heurist import bigger case mani realist program may immedi program model even though alreadi gener 8 use number compil algorithm transform program order model implement memori reduct techniqu research compil appli techniqu benchmark program experi result show memori requir reduc substanti also reduct inde lead better cach local faster execut test case averag memori requir benchmark reduc 51 count code data use arithmet mean transform program averag speedup 140 use geometr mean origin program rest paper present preliminari section 2 formul network ow problem prove complex section 3 present control fusion discuss enabl techniqu section 4 section 5 provid experiment result relat work discuss section 6 conclus given section 7 2 preliminari section introduc basic concept present basic idea algorithm present program model section 21 introduc concept loop depend graph section 22 make three assumpt algorithm section 23 section 24 illustr basic idea algorithm section 25 introduc concept refer window base algorithm develop lastli section 26 show origin loop depend graph simpli preserv correct algorithm 21 program model consid collect loop nest l1 l2 1 lexic order shown figur 2a label l denot perfect nest loop indic l i1 start outmost loop exampl 1 ie figur 1a loop l ij lower bound l ij upper bound respect l ij u ij loop invari simplic present loop nest l 1 assum nest level n appli techniqu dierent loop level increment 27 case strictli satisfi requir transform model use techniqu code sink 30 array region referenc given collect loop divid three class input array region upwardli expos begin l1 output array region live lm local array region intersect input output array region util exist depend analysi region analysi live analysi techniqu 4 11 12 19 comput input output local array region ecient note input output region overlap exampl 1 figur 1a e0 n input array c b e figur 2 origin transform loop nest region output array region a1 n local array region figur 3a show complex exampl exampl 2 resembl one wellknown livermor loop exampl 2 declar array dimens jn zz za12kn zb2jnkn1 input array region zp zr zq zz output array region za2jn2kn zb2jn2kn local array region figur 2b show code form loop shift loop fusion p j l repres shift factor loop l ij rest paper assum loop coalesc singlelevel loop 30 27 loop shift loop fusion figur 2c show code form loop coalesc loop fusion l lower upper loop bound coalesc loop nest l figur 2d show code form loop fusion loop coalesc eas code gener gener case howev common case loop coalesc unnecessari 27 figur 2e show code form loop fusion without loop coalesc appli array contract appli code shown either figur 2d figur 2e 22 loop depend graph extend denit tradit depend distanc vector depend graph 14 collect loop follow denit 1 given collect loop nest l1 lm figur 2a data depend exist iter n loop l1 iter j1 loop l2 say distanc vector j1 denit 2 given collect loop nest l1 l2 lm loop depend graph ldg direct graph e node v repres loop nest direct edg e repres data depend ow anti output depend l end end l2 end end l3 end end l4 end end b c figur 3 exampl 2 origin simpli loop depend graph edg e annot distanc vector 1 dve depend edg e distanc vector constant replac set edg follow let set depend distanc e repres let lexicograph minimum distanc let f d1 6 d1g vector 29 30 u lexicograph greater n d1 s1 subset lexic neither smaller equal vector replac origin edg e js1 annot d0 figur 3b show loop depend graph exampl figur 3a without show array region exampl ow depend l1 l3 due array region figur 3b multipl depend type ow anti output exist one node anoth use one arc repres gure associ distanc vector mark singl arc 23 assumpt make follow three assumpt order simplifi formul section 3 assumpt 1 loop trip count perfect nest l l j equal correspond loop level h n also state u ih l ih assumpt 1 satis appli techniqu loop peel loop partit dierenc iter count small loop peel quit eectiv otherwis one partit iter space certain loop equal piec throughout paper use h denot loop trip count loop l level h constant symbol icli constant wrt program segment consid erat denot equal number accumul leveln loop iter execut one levelh loop iter let paper also denot number static write refer due local array region 2 loop l arbitrarili assign static write refer l number 1 k order distinguish take loop figur 3b exampl assumpt 2 sum absolut valu depend distanc loop level h loop depend graph e less onefourth trip count loop level h assumpt also state jej dvek j 1 ek 2 e annot depend distanc vector assumpt 2 reason program constant depend distanc gener small nonconst depend distanc exist techniqu discuss section 42 loop interchang circular loop skew may util reduc depend distanc 2 rest paper term static write ref erenc mean static write refer due local array region d2 d2 b figur 4 illustr memori minim assumpt 3 static write refer r instanc r write distinct memori locat ifstat within loop guard statement contain refer r dierent static refer write dierent memori locat static write refer write distinct memori locat loop iter appli scalar array expans refer 30 later techniqu minim total size local array region case statement assum branch taken 27 discuss case region written two dierent static write refer overlap 24 basic idea loop shift appli loop fusion order honor depend associ integ vector pl loop nest l loop depend graph denot shift factor l j loop level k figur 2b depend edg distanc vector dv new distanc vector pl dv pl memori minim problem therefor reduc problem determin shift factor p j l loop l ij total temporari array storag requir minim loop coalesc legal fuse dv pl distanc vector dv loop shift paper v2 denot inner product v1 v2 loop coalesc distanc vector v becom v call coalesc depend distanc order make loop fusion legal must hold legal transform stand key memori minim count number simultan live local array element transform loop shift loop coalesc loop fusion exampl figur 4a show part iter space three loop nest loop coalesc loop fusion rectangl bound iter space loop nest point gure repres one iter two arrow repres two ow depend d1 d2 due static write refer say r1 r1 sourc d1 d2 loop fusion iter space dierent loop nest map common iter space figur 4b show three separ iter space map common one base assumpt 3 v also repres number simultan live variabl due v common iter space figur 4b number simultan live variabl 1 d1 3 d2 howev could overlap simultan live local array element due dierent depend figur 4b simultan live array element depend d1 d2 overlap case number simultan live local array element due static write refer r1 greater two due depend d1 d2 ie 3 case given collect loop fusion total number simultan live local array element equal sum number simultan live local array element due static write refer 25 refer window 9 gannon et al use refer window quantifi minimum cach footprint requir depend loopinvari distanc shall use concept quantifi minimum temporari storag satisfi ow depend denit 3 9 refer window w x depend variabl x time dene set element x referenc s1 also referenc accord depend s2 figur 1a refer window due ow depend l1 l2 due array begin loop l2 iter f ai ai g refer window size rang 1 n figur 1c refer window due ow depend caus array begin loop iter f ai 1 g refer window size 1 next extend denit 3 set ow depend follow denit 4 given ow depend edg e1 e2 es suppos refer window time w1 w2 respect dene refer window f es g time sinc refer window character minimum memori requir carri comput problem minim memori requir given collect loop nest equival problem choos loop shift factor loop legal coalesc fuse fusion refer window size ow depend due local array region minim given collect loop nest legal fuse need predict refer window loop coalesc fusion denit 5 loop node l ldg write local array region r suppos iter j1 becom iter j loop coalesc fusion dene predict refer window l iter j1 refer window ow depend due r begin iter j coalesc fuse loop suppos predict refer window iter jn largest size due r dene predict refer window size entir loop l due r dene predict refer window due static write refer r l predict refer window l due array region written r conveni l write nonloc region dene predict refer window empti base denit 5 follow lemma lemma 1 predict refer window size kth static write refer r l must smaller predict refer window size ow depend due r proof predict refer window size ow depend smaller minimum requir memori size carri comput depend predict refer window size kth static write refer r l smaller memori size carri comput ow depend due r theorem 1 minim memori requir equival minim predict refer window size ow depend due local array region proof denit 5 lemma 1 given depend distanc vector dv depend distanc loop coalesc loop fusion also call coalesc depend distanc due assumpt 3 dv also repres predict refer window size coalesc iter space origin iter space lemma 2 loop fusion legal coalesc depend distanc nonneg proof preserv origin depend take loop node l2 figur 3c exampl predict refer window size l2 due static write refer zbj k predict refer window size l2 sinc zbj k write refer l2 26 ldg simplif loop depend graph simpli keep depend edg necessari memori reduct simplic process base follow three claim claim 1 depend l automat preserv loop shift loop coalesc loop fusion reorder comput within loop l 2 among depend edg l l j suppos edg e lexicograph minimum depend distanc vector loop shift coalesc depend distanc associ e nonneg legal fuse loop l l j loop shift coalesc depend distanc depend edg remain equal greater edg e thu remain nonnega tive word fusionprev depend ex ist prove claim section 3 lemma 3 3 amount memori need carri comput determin lexicograph maximum owdepend distanc vector due local array region accord lemma 1 simplic also classifi edg two class ledg medg ledg use determin legal loop fusion medg determin minimum memori requir medg ow depend edg ledg could ow anti output depend edg possibl edg classi ledg medg simplic process follow combin node l static refer r l 0 among depend edg l due r keep one whose ow depend distanc vector lexicograph maximum edg medg node l remov depend edg l node l 0 among depend edg l l j j 6 keep one depend edg legal depend distanc vector lexicograph minimum edg ledg static write refer r l among depend edg l l j j 6 due r keep one ow depend edg whose distanc vector lexicograph maximum edg medg node l among depend edg l l j j 6 keep depend edg whose depend distanc vector lexicograph minimum edg ledg process simpli program formul make graph travers faster figur 3c show loop depend graph simplic figur 3b figur 3c mark class depend edg exampl depend edg l1 l3 mark 0 0 ledg one mark 0 1 medg latter edg associ static write refer zaj k 3 object function section rst formul graphbas system minim number simultan live local array el ement reduc problem network ow problem solvabl polynomi time 31 formul problem 1 given loop depend graph g object function minim number simultan live local array element loop nest formul follow edg g subject call system dene problem 1 2 ik repres number simultan live array element due kth static write refer l constraint 3 say coalesc depend distanc must nonneg ledg loop coalesc loop fusion constraint 4 say number simultan live local array element due kth static write refer l must smaller number simultan live local array element everi medg origin l due kth static write refer l combin constraint 3 assumpt 2 follow lemma say coalesc depend distanc also nonneg medg lemma 3 constraint 3 hold pl hold medg e g proof dve hold otherwis assum rst nonzero compon dve hth compon base assumpt 2 medg e2 must exist ledg e1 constraint 3 guarante hold pl dve1 denit ledg medg similar proof case prove hold proof lemma 3 also see depend elimin simplic process section 26 coalesc depend distanc also nonneg given constraint 3 hold henc coalesc depend distanc origin depend simplic section 26 nonnega tive loop shift coalesc loop fusion loop fusion legal accord lemma 2 section 26 know ow depend edg e3 l l j due static write refer r elimin simplic process must exist medg e4 l l j due r proof hold henc constraint 4 comput predict refer window size ow depend origin l due kth static write refer unsimpli loop depend graph see section 22 accord lemma 1 constraint 4 correctli comput predict refer window size ik 32 transform problem 1 dene new problem problem 2 ad follow two constraint problem 1 e edg g lemma 4 given optim solut problem 1 construct optim solut problem 2 valu object function 2 proof search space problem 2 subset problem 1 given ldg g optim object function valu 2 problem 2 must equal greater problem 1 given optim solut problem 1 nd shift factor p ik valu problem 2 follow 1 initi let p ik valu problem 1 solut problem 2 follow step adjust valu constraint problem 2 satis valu object function 2 chang 2 p valu satisfi constraint 5 go step 4 otherwis go step 3 3 step nd p valu satisfi constraint 5 follow topolog order node g nd rst node l exist ledg constraint 5 satis ignor self cycl sinc must repres medg g suppos sth rst nonzero compon let two nonzero compon sth pl new p valu includ pl j satisfi constraint 3 4 valu object function 2 also chang pl lexicograph nega tive repeat process process termin within n time sinc otherwis constraint 3 would hold optim solut problem 1 note node l select base topolog order shift factor pl j increas compar origin valu ledg destin node l j constraint 5 hold updat pl j still hold updat properti guarante process termin go step 2 4 step nd ik valu satisfi constraint 6 given nd valu satis constraint 6 constraint 6 becom equal least one edg achiev satis constraint 4 done otherwis increas nth compon ik valu constraint 4 hold becom equal least one edg find valu valu object function 2 chang p ik valu valu object function 2 problem 2 problem 1 henc get optim solut problem 2 valu object function 2 theorem 2 optim solut problem 2 also optim solut problem 1 proof given optim solut problem 2 take p ik valu solut problem 1 p ik valu satisfi constraint 34 valu object function 2 problem 1 problem 2 solut must optim problem 1 otherwis construct problem 1 anoth solut problem 2 lower valu object function 2 accord lemma 4 contradict optim origin solut problem 2 expand vector problem 2 integ program problem result gener solut ip problem howev take ldg graphic characterist account instead solv ip problem 1 1 figur 5 transform graph g1 figur 3c transform network ow problem discuss next subsect 33 transform problem 2 given loop depend graph g gener anoth graph node l creat correspond node g1 node l outgo medg let weight l w static refer rk 1 k l creat anoth node g1 call sink due rk let weight w node l 2 g outgo medg let weight medg g due static write refer rk suppos distanc vector dv add edg g1 distanc vector dv ledg suppos distanc vector dv add edg g1 distanc vector dv origin graph figur 3c figur 5 show transform graph assign vector q node g1 follow node node new system call problem 3 dene follow edg g1 annot dk subject dk 0 8e 8 theorem 3 problem 3 equival problem 2 proof 0 henc object function 2 equival 7 edg e g1 inequ 8 equival e1 ledg g l l j inequ 10 equival 5 henc inequ 8 equival 5 edg e g1 inequ 8 equival e1 medg g l l j due kth static write refer l inequ 11 equival 6 henc inequ 8 equival 6 similarli easi show constraint 3 4 equival constraint 9 note one edg g could ledg edg correspond two edg g1 assumpt 2 follow inequ hold transform graph dvek j 1 ek 2 e1 annot depend distanc vector problem 2 problem 3 solv linear vector represent origin problem becom integ program problem gener form npcomplet next subsect howev show achiev optim solut polynomi time problem 3 util network ow properti 34 optim condit develop optim condit solv problem 3 util network ow properti network ow consist set vector vector fe correspond edg e 2 e1 node v 2 v1 sum ow valu inedg equal wv plu sum ow valu outedg ek v repres inedg v repres outedg v lemma 5 given exist least one legal network ow proof find span tree g1 assign ow valu 0 edg henc nd legal network ow ow assign also legal g1 assign ow valu edg revers topolog order sinc total weight node equal 0 legal network ow exist base equat 13 given legal network ow node v 2 v1 1 network ow algorithm abstract factor wv wv repres c abstract give ow valu ck integ constant suppos fek 0 edg ek 2 e1 equival ck 0 constraint 9 henc therefor equat 14 fek 0 collect optim condit state follow theorem hold inequ becom equal optim achiev problem 3 theorem 4 follow three condit hold 1 constraint 8 9 satis 2 legal network ow fek exist ck 3 jv 1 j dk hold ie inequ becom equal problem 3 achiev optim solut dk proof obviou discuss solv problem 3 let us consid vector wv dk singl comput unit base dualiti theori 24 2 problem 3 exclud constraint 9 equival subject constraint 9 mandatori equival problem 3 dual problem follow develop optim condit section 34 1 constraint 19 dual system precis dene ow properti edg e associ ow vector fe dene problem 4 system 78 18 20 similar wv vector fek repres ck although appar search space problem 4 enclos problem 3 problem 4 correct solut within search space dene problem 3 base properti dualiti problem 4 achiev optim solut constraint 8 19 20 hold object function valu 7 18 equal dk hold prove constraint 9 hold optim solut problem 4 solut must also optim problem 3 accord theorem 4 exist plenti algorithm solv problem 4 1 2 although algorithm target scalar system vector length equal 1 directli adapt system vector summat subtract comparison oper network simplex algorithm 2 directli util solv sy tem algorithm complex howev exponenti worst case term number node edg g1 sever graphbas algorithm 1 hand polynomialtim complex exampl includ success shortest path algorithm complex scale algorithm complex ojv1 jje1 jlogjv1 j 1 current fastest polynomialtim algorithm solv network ow problem enhanc capac scale algorithm complex logjv1 j algorithm follow lemma lemma 6 optim solut q problem 4 exist span tree g1 edg proof true due foundat simplex method 2 let span tree lemma 6 x q 0 determin uniqu uniquelydetermin ds e dk inequ 21 ds j 22 inequ 22 base inequ 12 annot lemma 7 annot dk subject constraint 8 23 proof hold otherwis assum rst nonzero compon hth dk q q h constraint 23 henc inequ 12 guarante constraint hold optim problem 4 achiev optim solut problem 4 also optim solut problem 3 36 success shortest path algorithm brie present one network ow algorithm success shortest path algorithm 1 use solv problem 4 algorithm depict figur 6 let fek scalar rst iter algorithm alway output procedur initi set select node vk 2 e v l 2 determin shortest path distanc j node vk node g1 respect residu cost c edg annot ij g1 let p denot shortest path vk v l updat ow valu residu network ow graph augment unit ow along path p residu graph figur success shortest path algorithm maintain feasibl shift factor nonneg ow valu satisfi constraint 8 20 adjust ow valu constraint 19 hold edg g1 algorithm end complet descript algorithm includ concept reduc cost residu network ow graph semant set e etc pleas refer 1 exampl 2 figur 3 appli success shortest path algorithm pl1 pl2 figur 7 show transform code exampl 2 memori reduct 4 refin 41 control fusion although array contract loop fusion decreas overal memori requir loop fusion mani loop level potenti increas work set size loop bodi henc potenti increas regist spill cach miss particularli true larg number loop consider control number fuse loop comput shift factor minim memori requir use simpl greedi heurist pick reject see figur 8 increment select loop nest actual fuse new addit caus estim cach miss regist spill wors fusion loop nest consider fuse heurist continu select fusion candid remain loop nest loop nest examin order loop whose fusion save memori consid rst estim regist spill use approach 22 estim cach miss use approach 7 may also import avoid perform loop fusion mani loop level correspond loop shift loop shift loop fusion mani loop level potenti increas number oper either due ifstat ad loop bodi due eect loop peel coalesc appli may also introduc subscript comput overhead although cost tend less signic cost cach miss regist spill still care end end end end end end figur 7 transform code figur 3a memori reduct control fusion innermost loop rate increas oper fusion exce certain threshold fuse outer loop 42 enabl loop transform use sever wellknown loop transform enabl eectiv fusion long backward datadepend distanc make loop fusion ineect memori reduct long distanc sometim due incompat loop 26 correct loop interchang long backward distanc may also due circular data depend correct circular loop skew 26 fur thermor techniqu appli loop distribut node depend distanc vector origin l dierent case distribut loop may allow dierent shift factor distribut loop potenti yield favor result 5 experiment result implement memori reduct techniqu research compil panorama 12 implement net work ow algorithm success shortest path algorithm 1 loop depend graph experi rel simpl success shortest path algorithm take less 006 second benchmark measur eectiv test memori reduct techniqu 20 benchmark sun ultra ii uniprocessor workstat mip r10k processor within sgi procedur pick reject input 1 collect loop nest 2 estim number regist spill np estim number cach miss nm origin loop nest output set loop nest fuse fs procedur 1 initi fs empti let os initi contain loop nest 2 os empti return fs otherwis select loop nest l os local array region r written l reduc ie dierenc size r number simultan live array element due static write refer l lexic neither smaller equal loop nest os let tr set loop nest os contain refer r estim number regist spill b number cach miss fuse loop fs tr perform array contract fuse loop npb nm fs fstr os os tr otherwis os os fl g go step 2 figur 8 procedur pick reject origin 2000 multiprocessor present experiment result r10k result ultra ii similar 27 r10k processor 32kb 2way setassoci data cach 32byte cach line 4mb 2way setassoci uni l2 cach 128byte cach line cach miss penalti 9 machin cycl l1 data cach 68 machin cycl l2 cach 51 benchmark memori reduct tabl 1 list benchmark use experi descript input paramet benchmark chosen either readili program model transform enabl algorithm addit enabl algorithm develop futur hope collect test program tabl mn repres number loop loop sequenc maximum loop nest level n note array size iter count chosen arbitrarili ll14 ll18 jacobi dierenti benchmark swim spec95 spec2000 denot spec95 version swim95 spec2000 version swim00 program swim00 almost ident swim95 except larger data size combust chang array size n1 n2 1 10 execut time last sever second program climat laplacejb laplaceg purdu set problem hpf benchmark suit rice univers 20 21 except luca benchmark written f77 manual appli techniqu luca written f90 among 20 benchmark program algorithm nd purdueset program luca ll14 combust need perform loop shift benchmark tabl 1 loop fuse togeth swim95 swim00 hydro2d outer loop fuse benchmark n loop level fuse benchmark examin three version code ie origin one one loop fusion array contract one array contrac tabl 1 test program benchmark name descript input paramet mn ll14 livermor loop 14 jacobi jacobi kernel wo converg test tomcatv mesh gener program spec95fp refer input 51 swim95 weather predict program spec95fp refer input 22 swim00 weather predict program spec2000fp refer input 22 hydro2d astrophys program spec95fp refer input 102 luca promal test spec2000fp refer input 31 mg multigrid solver npb23serial benchmark class w 21 combust thermochem program umd chao group purdue02 purdu set problem02 refer input 21 purdue03 purdu set problem03 refer input 32 purdue04 purdu set problem04 refer input 32 purdue07 purdu set problem07 refer input 12 purdue08 purdu set problem08 refer input 12 purdue12 purdu set problem12 refer input 42 purdue13 purdu set problem13 refer input 21 climat twolay shallow water climat model rice refer input 24 laplacejb jacobi method laplac rice laplaceg gaussseidel method laplac rice combust purdue02 purdue03 purdue04 purdue07 purdue08 purdue12 purdue13 climat laplacejb laplaceg benchmark benchmark left right origin transform code normal occupi memori size code data data size origin program unit kb swim00 hydro2d luca mg combust 191000 11405 142000 8300 89 purdue12 purdue13 climat laplacejb laplaceg 4194 4194 169 6292 1864 figur 9 memori size transfor mation tion among program combust purdue07 purdue08 program model 8 case algorithm 8 deriv result need list result version benchmark use nativ fortran compil produc machin code simpli use optim ag o3 follow adjust ment switch prefetch laplacejb softwar pipelin laplaceg loop unrol purdue03 swim95 swim00 nativ compil fail insert prefetch instruct innermost loop bodi memori reduct manual insert prefetch instruct three key innermost loop bodi follow exactli prefetch pattern use nativ compil origin code figur 9 compar code size data size origin transform code comput data size base global data common block local data dene main program data size shown origin program normal 100 actual data size vari greatli dierent benchmark list tabl associ gure mg climat memori requir dier littl program transform due small size contract local array benchmark techniqu reduc memori requir consider arithmet mean reduct rate count data code 51 benchmark sever small purdu benchmark reduct rate almost 100 52 perform figur compar normal execut time mid repres execut time code loop fusion array contract final repres execut time code array contract geometr mean speedup memori reduct 140 benchmark best speedup 567 achiev program purdue03 combust purdue02 purdue03 purdue04 purdue07 purdue08 purdue12 purdue13 climat laplacejb laplaceg normal execut time origin mid final figur 10 perform transfor combust normal cach refmiss count dl1hit dl1miss l2miss origin mid final left right figur 11 cach statist tran format program contain two local array a1024 1024 p 1024 carri valu three adjac loop nest techniqu abl reduc array scalar fuse three loop one 53 memori refer statist understand eect memori reduct perform examin cach behavior dier ent version test benchmark measur refer count dynam loadstor instruct miss count l1 data cach miss count l2 uni cach use perfex packag get cach statist figur 11 12 compar statist total refer count origin code normal 100 array contract scalar regist reus often increas figur 11 12 show number total refer get decreas case total number refer count benchmark reduc 211 howev case total refer count get increas instead examin assembl code found number reasons50150250350purdue02 purdue03 purdue04 purdue07 purdue08 purdue12 purdue13 climat laplacejb laplaceg normal cach refmiss count dl1hit dl1miss l2miss origin mid final left right figur 12 cach statist transform cont 1 fuse loop bodi contain scalar refer singl iter fusion increas regist pressur sometim caus regist spill 2 nativ compil perform scalar replac 3 refer noncontract array fuse loop bodi may prevent scalar replac two reason regist pressur high certain loop nativ compil may choos perform scalar replac loop fusion array data ow may becom complex may defeat nativ compil attempt perform scalar replac 3 loop peel may deceas eectiv scalar replac sinc fewer loop iter benet despit possibl increas memori refer count case due reason figur 11 12 show cach miss gener reduc memori duction total number cach miss bench mark reduc 638 memori reduct total number l1 data cach miss reduc 573 memori reduct improv cach perform seem often bigger impact execut time total refer count 54 experi 27 report memori reduct techniqu aect prefetch softwar pipelin regist alloc unrollandjam conclud techniqu seem creat diculti optim 6 relat work work fraboulet et al closest memori reduct techniqu 8 given perfectlynest loop use retim 16 adjust iter space individu statement total buer size minim compar algorithm introduct section 51 callahan et al present unrollandjam scalar replac techniqu replac array refer scalar variabl improv regist alloc 3 howev consid innermost loop perfect loop nest consid loop fusion neither consid array partial contract gao sarkar present collect loop fusion 10 perform loop fusion replac array scalar consid partial array contract perform loop shift therefor fuse loop fusionprev depend sarkar gao perform loop permut loop revers enabl collect loop fusion 23 enabl techniqu also use framework lam et al reduc memori usag highlyspeci multidimension integr problem array subscript loop index variabl 15 program model allow fusionprev depend lewi et al propos appli loop fusion array contract directli array statement array languag f90 17 result achiev array statement transform variou loop loop fusion array contract appli consid loop shift formul strout et al consid minimum work set permit tile loop regular stencil depend 28 method appli perfectlynest loop 6 ding indic potenti combin loop fusion array contract exampl ever appli loop shift provid formal algorithm evalu loop fusion studi extens name public kennedi mckinley prove maxim data local loop fusion nphard 13 provid two polynomialtim heurist singhai mckinley present parameter loop fusion improv parallel cach local 25 perform memori reduct loop shift recent dart analyz complex loop fusion 5 claim problem maximum fusion parallel loop constant depend distanc npcomplet combin loop shift goal nd minimum number partit loop within partit fuse possibl enabl loop shift fuse loop remain parallel mainli dierent object function problem yield complet dierent complex manjikian abdelrahman present shiftandpeel 18 shift loop order enabl fusion none work list address issu minim memori requir collect loop techniqu dierent 7 conclus paper propos enhanc data local via memori reduct techniqu combin loop shift loop fusion array contract reduc memori reduct problem network ow problem solv optim ojv j 3 time experiment result far show techniqu reduc memori requir signicantli time speed program execut factor 140 averag furthermor memori reduct seem creat diculti number backend compil optim also believ memori reduct vital import comput sever memoryconstrain applic extrem memorydemand 8 acknowledg work sponsor part nation scienc foundat grant ccr9975309 aciitr0082834 mip9610379 indiana 21st centuri fund purdu research foundat donat sun microsi tem inc 9 r network flow theori linear program network flow improv regist alloc subscript variabl interprocedur array region analys complix loop fusion improv estim enhanc cach e loop align memori access optim strategi cach local memori manag global program transform collect loop fusion array contract structur data ow analysi array use optim compil experi ecient array data ow analysi array privat maxim loop parallel improv data local via loop fusion distribut structur comput comput optim memori usag commun requir class loop implement multidimension integr retim synchron circuitri implement evalu fusion contract array languag fusion loop parallel local array data ow analysi use array privat applic benchmark set fortrand high perform fortran problem test parallel vector languag optim unrol nest loop optim array access collect loop transform theori linear integ program parameter loop fusion algorithm improv parallel cach local new tile techniqu improv cach tempor local perform enhanc memori reduct improv local parallel nest loop high perform compil parallel comput tr theori linear integ program strategi cach local memori manag global program transform linear program network flow 2nd ed structur dataflow analysi array use optim complier improv regist alloc subscript variabl optim array access collect loop transform network flow arraydata flow analysi use array privat improv local parallel nest loop interprocedur array region analys fusion loop parallel local experi effici array data flow analysi array privat implement evalu fusion contract array languag scheduleindepend storag map loop new tile techniqu improv cach tempor local optim unrol nest loop high perform compil parallel comput structur comput comput optim memori usag requir class loop implement multidimension integr estim enhanc cach effect collect loop fusion array contract maxim loop parallel improv data local via loop fusion distribut complex loop fusion loop align memori access optim improv effect bandwidth compil enhanc global dynam cach reus ctr g chen kandemir j irwin g memik compilerdirect select data protect soft error proceed 2005 confer asia south pacif design autom januari 1821 2005 shanghai china yonghong song cheng wang zhiyuan li polynomialtim algorithm memori space reduct intern journal parallel program v33 n1 p133 februari 2005 david wonnacott achiev scalabl local time skew intern journal parallel program v30 n3 p181221 june 2002 g chen kandemir karakoy constraint network base approach memori layout optim proceed confer design autom test europ p11561161 march 0711 2005 apan qasem ken kennedi profit loop fusion tile use modeldriven empir search proceed 20th annual intern confer supercomput june 28juli 01 2006 cairn queensland australia alain dart guillaum huard new complex result array contract relat problem journal vlsi signal process system v40 n1 p3555 may 2005 benni thrnberg qubo hu martin palkov mattia onil per gunnar kjeldsberg polyhedr space gener memori estim interfac memori model realtim video system journal system softwar v79 n2 p231245 februari 2006 daniel cociorva gerald baumgartn chichung lam p sadayappan j ramanujam marcel nooijen david e bernholdt robert harrison spacetim tradeoff optim class electron structur calcul acm sigplan notic v37 n5 may 2002 geoff pike paul n hilfing better tile array contract compil scientif program proceed 2002 acmiee confer supercomput p112 novemb 16 2002 baltimor maryland yonghong song rong xu cheng wang zhiyuan li improv data local array contract ieee transact comput v53 n9 p10731084 septemb 2004 zhiyuan li yonghong song automat tile iter stencil loop acm transact program languag system topla v26 n6 p9751028 novemb 2004 chen ding ken kennedi improv effect bandwidth compil enhanc global cach reus journal parallel distribut comput v64 n1 p108134 januari 2004 mahmut taylan kandemir improv wholeprogram local use intraprocedur interprocedur transform journal parallel distribut comput v65 n5 p564582 may 2005