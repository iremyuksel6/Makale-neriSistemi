comparison three round algorithm ieee floatingpoint multipl abstracta new ieee compliant floatingpoint round algorithm comput round product carrysav represent product present new round algorithm compar round algorithm yu zyner 26 quach et al 17 round algorithm logic descript block diagram given correct proven latenc analyz conclud new round algorithm fastest round algorithm provid inject depend round mode sign ad reduct partial product carrysav encod digit string doubl precis format latenc new round algorithm 12 logic level compar 14 logic level algorithm quach et al 16 logic level algorithm yu zyner b introduct everi modern microprocessor includ oatingpoint multipli compli ieee 754 standard 13 latenc fp multipli critic oatingpoint perform sinc larg portion fp instruct consist fp multipl exampl oberman report fp multipl account 37 percent fp instruct benchmark applic 17 lot research devot optim latenc ad partial product produc product eg 1 2 6 9 15 16 18 19 20 21 26 28 29 30 recent work round product accord ieee 754 standard publish 4 7 10 22 23 24 25 31 33 34 assum multipli output carrysav encod digit string repres exact product follow natur question aris fastest method comput round product given exact product repres carrysav encod digit string consid compar three round algorithm algorithm quach et al 23 denot qtf algorithm b algorithm yu zyner 31 denot yz algorithm c new algorithm base inject base round 10 denot es algorithm provid block diagram round algorithm optim speed measur latenc algorithm logic level enabl technolog independ comparison main build block algorithm similar consist compound adder comput sticki carri bit thu cost three algorithm similar interest question nding fastest algorithm focu doubl precis multipl signicand repres 53 bit algorithm assum signicand normal name rang 1 2 therefor product rang 1 4 consid case deal denorm special valu sinc support denorm valu obtain use extend expon rang 14 25 32 comput special valu done parallel 12 three algorithm share follow techniqu 1 product repres carrysav encod digit string 106 digit case doubl precis partit lower part upper part upper part ad compound adder comput binari represent sum sum ulp ulp denot unit last posit sum denot sum upper part carrybit roundbit stickybit comput lower part 2 round decis comput two path nonov ow path work assumpt exact product rang 1 2 ow path work assumpt product rang 2 4 although sum upper part denot sum equal exact product signic bit sum control select two path main dierenc three round algorithm outlin follow 1 round decis qtf es algorithm simplifi round decis earli addit valu valu call predict qtf algorithm inject es algorithm qtf algorithm predict depend round mode carrysav digit posit 53 digit right radix point es algorithm inject depend round mode assum ad partial product thu product alreadi includ inject round decis yz algorithm base customari round tabl 2 posit carrysav encod product partit lower part upper part dier three algorithm yz algorithm lower upper part separ buer three carrysav digit posit 51 53 posit digit denot mani digit right radix point two algorithm upper part consist posit lower part consist posit 53 104 latenc propos design implement algorithm term logic level follow latenc es algorithm 12 logic level latenc qtf algorithm 14 logic level latenc yz algorithm 16 note modi adapt qtf yz algorithm minimum latenc support four round mode ieee 754 standard error prone task therefor provid correct proof three algorithm formal clarifi tricki aspect point view yz algorithm easiest prove qtf algorithm intric especi round decis logic paper organ follow section 2 preliminari issu describ notat convent use regard ieee round gener set section 3 straightforward round algorithm review algorithm describ provid outlin task round exact product comput attempt parallel task round therefor long latenc section 46 round algorithm describ proven analyz section 7 discuss latenc algorithm increas precis increas section 8 summari conclus given due space limit section omit found full version 11 preliminari notat let x x binari string denot binari string x z1 x z 1 1 x z 2 also sometim refer x xi sinc deal fraction index binari encod bit string x x associ weight 2 valu encod xz denot jxz ieee round ieee7541985 standard dene four round mode round toward 0 round toward 1 round toward 1 round nearest even base sign number round mode round toward 1 round toward 1 reduc round mode rz round zero ri round inniti 23 thu leav three round mode ri rz rne round nearest even furthermor quach et al 23 suggest implement rne round nearest denot rnu round mode rnu dene follow x two success represent r rnu reason rne implement rnu r rnu x 6 r rne x least signic bit lsb binari encod 2 1 therefor obtain r rne x r rnu x accomplish pull lsb sake clariti dene round zero rz signicand rang 1 4 doubl precis note denit exclud postnorm shift take place number binad 2 4 denit 1 let x 2 1 4 r rz x dene r rz x div 2 integ q satis gener set paper consid doubl precis multipli assum signicand prenorm name valu two signicand rang 1 2 signicand repres binari string bit posit 0 52 exact product two signicand rang 1 4 encod binari string bit posit note weight bit posit 1 2 sake simplic ignor expon signbit path float point multipli perform comput two phase rst phase addit tree reduc partial product carrysav encod digit string repres exact product second phase binari string repres round product comput carrysav encod string paper discuss implement second phase 3 naiv ieee round section review simpl slow ieee compliant algorithm round multipl 5 31 descript input consist two binari string sum carri 106 bit index 1 104 sum binari number repres sum carri equal exact product exact 2 1 4 round comput follow comput expon string omit 1 reduc round mode one three round mode base one sign product 2 21compress sum carri string ad obtain singl binari string name note sinc exact product rang 1 4 signic bit x posit 1 3 normal jxj 2 jx jxj implement condit shift one posit right note x 0 index 0 4 comput sticki stickybit equal 5 comput round decis round decis rd 2 f0 1g base round mode bit stickybit note round mode stage alreadi incorpor sign 6 increment comput binari string repres sum 7 postnorm jy signicand string round product given 0 32 delay analysi latenc step 1 3 5 naiv round procedur least logarithm length binari string sum carri step requir constant delay everi pipelin stage accommod one logarithm depth circuit implement naiv round procedur requir least 3 pipelin stage 4 es round algorithm section review inject base round 10 present implement doubl precis requir assumpt speci sec 45 12 logic level 41 inject base round round inject reduc round mode ri rnu rz 10 reduct base ad inject depend round mode follow eect ad inject summar follow equat mode 2 frzrnurig figur 1 depict reduct rnu ri rz inject assum number round rang 1 2 exact product denot exact rang 2 4 inject must xed order make reduct rz correct correct amount denot inj correct dene therefor x rang 2 4 eect ad inject correct amount summar follow equat mode 2 frzrnurig assumpt inject ad multipli adder array therefor complet descript inject base round number rang 1 4 42 round algorithm section present new es algorithm round oatingpoint multipl base inject base round figur 2 depict block diagram es round algorithm round algorithm work assumpt sum carrystr alreadi includ inject inject correct proce follow 1 sum carrystr divid high part low part high part consist posit low part consist posit 53 104 2 low part input box comput carri round stickybit dene follow 52 104 binari string satis 3 higher part input line half adder produc output x sum note bit lx posit 52 carri gener posit 2 exact product less 4 even ad inject 4 input compound adder output sum increment sum jy 5 increment decis box receiv roundbit r carrybit c52 lsb lx msb 0 1 round mode rn ri output signal inc indic whether 0 1 select 6 signic bit 0 1 1 1 indic whether 0 1 rang 2 4 depend bit 0 1 normal follow shif righti shif righti 7 round result except least signic bit select z0 z1 accord increment decis inc follow 8 case round mode rne least signic bit need correct sinc rne rnu alway result least signic bit correct least signic bit comput two parallel path one path work assumpt round result ow ie greater equal 2 path work assumpt round result ow path comput correct lsb noover ow assumpt implement box call x l novf input x l novf box round bit r sticki bit signal rne indic whether round mode round nearest even output denot notpd equal zero lsb pull path comput correct lsb ow assumpt implement box call x l ovf input x l ovf box lx bit carrybit c52 round bit r sticki bit signal rne output denot notpd equal zero lsb pull note pull signal inact round mode rne 9 least signic bit round result xing lsb case discrep rne rnu equal one three valu round result ow lsb equal lx c52 b round result ow increment decis increment c round result ow increment decis increment lsb xing lsb implement combin use andgat pulldown signal correspond candid lsb signal output 3 andgat denot l 0 inc l 0 ninc linc sake clariti introduc signal lninc equal linc 10 lsb round result equal lninc ow occur increment took place lsb round result equal linc ow occur increment took place lsb round result equal l 0 ninc ow occur increment took place lsb round result equal l 0 inc ow occur increment took place accord 4 case lsb round result select depend ow signal increment decis 43 detail section describ function three box gure 2 fulli describ yet fix l novf box belong path assum product rang 1 2 recal might discrep rne rnu tie occur name exact product equal midpoint two success represent number let exact denot valu exact product fix l novf gener signal notpd satis exact 2 1 occur rne tie occur two possibl rnu rne agre yield round result lsb equal zero pull lsb case requir caus damag b rnu rne disagre lsb rnu result must pull without addit inject tie occur inject 2 53 alreadi includ tie occur therefor notpd signal dene fix l ovf box belong path assum product rang 2 4 fix l ovf gener signal notpd satis exact 2 2 occur rne dierenc notpd notpd notpd use assumpt product greater equal 2 without addit inject tie occur case ow lx inject 2 53 alreadi includ tie occur lx therefor notpd signal dene increment decis increment decis box two path depend whether ow occur path work assumpt ow occur ie 0 produc increment decis lx 2 path work assumpt ow occur ie 0 need take account correct inject denot inj correct produc increment decis lx 2 therefor inc signal dene 44 correct proof tricki part algorithm correct inc signal long bit 0 1 indic correctli whether exact product greater equal 2 equat 1 2 impli inc signal correct one also consid case 0 1 fail indic correctli binad exact product name 0 exact product greater equal 2 b 0 exact product without inject less 2 sourc error due fact jy alway equal 53 mostsignic bit exact product recal lower part product correspond posit 53 104 regist sum carri well lx eect valu 0 1 howev inject might eect 0 1 sinc addedin multipli array depend multipli array implement wallac tree etc follow claim show mismatch occur round product equal 2 moreov case path one work assumpt ow occur one work assumpt ow occur yield result 2 therefor correct round obtain even 0 1 fail indic correctli binad exact product exact denot exact product let sum carri satisfi jsumj exact inject correct round exact comput follow r mode r rz exact r rz exact proof consid two main case 0 suppos 0 exact 2 claim follow eq 1 exact 2 exact reason possibl contribut lx 2 52 2 f0 2 52 g therefor exact correct inject satis 0 inj correct 2 52 therefor exact accord eq 2 case r mode howev case r rz exact round zero map interv 2 b suppos 0 exact 2 claim follow eq 2 exact 2 sinc inject 2 0 2 52 follow exact proof follow proof case 2 prove 0 1 use control select right round result follow claim prove implement comput r mode exact correct note claim deal xing lsb obtain rne rnu r rz exact 2 0 r rz exact exact tail 2 0 2 52 impli r rz exact inc signal case equal 1 addit lx c52 gener carri posit 51 inc 0 simpl addit take place r rz exact inc 1 two case rst case increment caus ow simpl addit take place ow caus sinc 53 bit output bit l x c52 discard complet proof rst part lemma suppos 0 therefor exact impli r rz exact lemma follow 2 45 delay analysi section present delay analysi round algorithm depict fig 3 analysi base follow assumpt 1 consid carri lookahead adder let dcla denot delay 53bit adder measur logic level assum msb sum delay dcla 1 logic level assumpt easi satisfi carri lookahead adder brent kung use 3 otherwis satisfi assumpt may requir arrang parallelprex network msb readi one logic level earlier 2 compound adder implement delay sum dcla delay increment sum dcla 1 obtain ore carrygener carrypropag signal 27 lemma 1 3 consid box carri round sticki bit comput accord rst assumpt sinc width box compound adder similar delay carri bit dcla 1 logic level delay round bit dcla logic level delay sticki bit estim dcla 2 logic level base fast sticki bit comput present 31 4 assum delay associ buer fanout 53 one logic level figur 3 depict block diagram inject base round algorithm annot time estim assign dcla valu 8 logic level impli sticki bit valid 6 logic level carrybit c52 valid 7 logic level roundbit valid 8 logic level similarli sum 0 valid 9 logic level msb 0 1 valid 8 logic level increment sum 1 valid 10 logic level msb 1 1 valid 9 logic level figur 4 depict implement fix l novf fix l ovf increment decis box annot time estim time estim use fig 3 obtain estim delay 12 logic level round product 5 yz round algorithm section review analyz round algorithm yu zyner report implement ultrasparc risc microprocessor 31 refer algorithm yz round algorithm 51 descript figur 5 depict block diagram yz round algorithm descript dier descript 31 two way 1 31 sum output 3bit adder three bit believ mistak sum four bit denot sum z50 53 2 sum increment sum 31 fed 4 1mux select one either shift right propos normal sum increment sum select take place earli normal help reduc delay round circuit cost two shifter rather one algorithm describ 1 sum carrystr divid high part low part high part consist posit low part consist posit 54 104 2 low part input box comput carri sticki bit dene follow 53 104 binari string satis 3 higher part input line half adder produc output x sum note carri gener posit 2 exact product less 4 4 high part x sum divid two part posit fed compound adder output sum increment sum jy ad carri bit c53 produc sum z50 53 5 process z50 53 split two path one work assumpt round product ow ie less 2 path work assumpt round product ow noover ow path comput round decis rd52 round dec novf box round decis rd52 ad z50 52 novf box produc sum claim 3 prove 3 bit addit produc carri bit posit 49 sum z novf 50 52 two role posit result bit posit 51 52 ow occur posit 50 use detect carri gener posit 50 ow occur bit z novf 50 decid whether upper increment sum 10 50 select noover ow case ow path comput round decis rd 0 51 round dec ovf box round decis rd 0 51 ad z50 51 ovf box produc sum claim 3 prove 2 bit addit produc carri bit posit 49 sum z ovf 50 51 two role posit 51 serv result bit posit 52 ow occur posit 50 use decid whether increment take place upper part 6 decis path chosen made select decis box first ow signal ovf comput follow ow signal ovf determin whether z ovf 50 z novf 50 chosen carrybit eect posit 50 therefor determin increment decis inc z ovf 50 z novf 50 7 two least signicand bit round product comput follow ow occur therefor lower mux select bit result51 52 ow occur 51 bit result51 depend whether increment take place 050 inc 0 note inc z ovf 50 ovf 1 sinc signal z ovf 50 readi earlier inc use z ovf 50 control select 150 z ovf 050 z ovf select 150 050 done sel multiplex fig 5 8 signic bit 0 1 0 1 indic whether 0 1 rang 2 4 depend bit 0 1 normal follow shif righti shif righti 9 round result except least signic bit select z0 z1 accord increment decis inc signal follow 52 correct section provid proof ad round decis gener carrybit posit 49 claim appli noover ow path ow path denot sum output 3bit adder depict fig 5 let rd52 denot round decis noover ow path let rd 0 51 denot round decis ow path proof partial compress 8 caus halfadd line impli jx sum follow fact x sum x carri equal one ad c53 increas rang 2 4 yield contribut rd 0 51 2 2 rang 0 416 therefor eq 13 follow contribut rd52 2 3 rang 0 216 therefor eq 14 follow 2 53 delay analysi figur 6 depict yz round algorithm annot time estim use assumpt delay signal use sec 45 argu least 16 logic level requir path sum increment sum comput lie critic path critic path consist carrybit comput 3bit adder round dec novf box novf box select decis box driver upper mux consid follow optim minim delay lower bound requir number logic level 1 3bit adder implement condit sum adder late carryin bit c53 select sum increment sum fast implement bit x carri x sum valid one logic level carrybit c53 valid 7 logic level 2 round decis box implement cascad two level multiplex control z52 53 noover ow path z51 52 ow path ow path z53 combin stickybit henc round decis requir 3 logic level noover ow path 2 logic level requir 3 addit round decis bit requir one logic level use condit sum adder 4 inc signal valid 3 logic level due need comput signal ovf two logic level see eq 11 one select accord eq 12 5 inc signal pass driver due larg fanout driver incur delay one logic level control upper mux output result 16 logic level 6 qtf round algorithm quach et al 23 present method ieee compliant round techniqu gener round algorithm santoro et al 24 section present round algorithm base method quach et al aim minimum delay apart reduc round mode rzrnu ri key idea use method quach et al santoro et al inject predict bit base round mode valu sum53 carry53 inject predict bit reduc number possibl round result section deviat quach et al 23 follow point 1 present paper quach et al separ accord round mode sinc investig round algorithm support round mode integr round mode one algorithm 2 quach et al suggest sever option choic predict logic rnu one possibl suggest mode rz ri sinc predict logic lie critic path chose simplifi predict logic much possibl dene pred 3 quach et al separ round decis compound adder use 3way compound adder comput sum sum 2 correct sum select control logic interest faster design therefor break 3way adder halfadd line 2way compound adder mux control logic use output 2way compound adder lsb case ow gener control logic well increment decis 61 descript figur 7 depict block diagram round algorithm suggest base quach et al 23 mani similar round algorithm base inject round round algorithm base quach et al point dierenc new notat input compound adder high part sum carri pass two line halfadd rst line make room predict bit second pass enabl separ bit lx 0 posit 52 fact part 3way compound adder increment decis two path one ow noover ow msb 0 1 select path output increment decis inc addit increment decis comput lsb xing rne case ow occur 62 detail section describ detail increment decis box lsbx rne box increment decis box output increment decis box increment decis inc bit l equal lsb round product xing case ow occur increment decis partit two path one case ow occur comput signal inc ovf path case ow occur comput signal incnovf follow equat dene signal inc ovf inc novf inc inc r pred pred inc r pred pred output inc equal inc novf inc ovf bit accord bit 0 1 inc novf 0 inc ovf 0 bit l equal lsb round product xing case ow occur dene r lx 0 c52 rnu pred ri note case ri complic due possibl pred 6 c52 pred c52 pred 6 c52 eect wrong predict revers pred c52 lsbx rne lsbx rne box output two signal notpd use pulldown lsb tie occur ow occur notpd 0 use pulldown lsb tie ow occur signal dene follow contrast inject base round inject predict contain lx 0 r sbit comput rne ow occur tie occur 0 case lsb pull rne therefor ow occur tie occur case lsb pull rne therefor 63 correct section prove correct select signal inc proof divid two part rst part assum 0 exact product rang 2 4 second part prove even 0 1 signal ow incorrectli select signal inc still correct correctli whether exact product rang 2 4 inc signal signal correctli whether increment requir round proof consid separ case ow ow case consid three possibl round mode question address whether round decis conjunct compress lower part carrysav represent produc carri posit 51 inc signal 1 carri gener posit 51 suppos ow occur name 0 1 round mode rz truncat take place therefor carri posit 51 gener 2 2 round mode rnu round decis increment posit 52 roundbit equal 1 increment gener carri posit 52 henc carri gener posit 51 2 3 round mode ri round decis increment posit 52 one need take account predict alreadi ad product consid two subcas pred contribut pred c52 cancel therefor c52 ignor round decis gener carri posit 51 r b c52 6 pred impli therefor round decis without predict would increment posit 52 pred 1 increment alreadi took place addit carri gener posit 51 suppos ow occur name 0 1 round mode rz sinc truncat take place case ident case ow 2 round mode rnu round decis determin bit posit 52 therefor two case either carri gener posit 51 sinc lx 0 carri gener posit 51 round decis combin case impli carri gener posit 51 3 round mode ri consid two case pred may ignor c52 predict sinc contribut cancel case round decis increment l x pred consid two subcas lx eect predict restrict chang lx 0 0 1 therefor round decis base r sinc round decis increment b lx eect predict gener carri posit 51 second halfadd line chang lx 0 1 0 mean without predict lx 0 would equal 1 impli round decis would increment sinc increment alreadi took place addit increment requiredth select inc ovf inc novf control 0 1 although 0 1 might signal correctli case ow follow claim show 0 1 signal ow correctli choic equal henc inc signal correct signal ow correctli name 0 exact 2 0 exact 2 inc inc novf proof proof divid two case 1 0 exact 2 case occur pred therefor restrict round mode ri sinc pred 2 52 follow lx impli case inc ovf inc novf requir 2 0 exact 2 discrep occur therefor smaller 2 multipl 2 52 follow impli lx 1 consid three round mode rz inc inc novf ri exclud possibl case rnu sinc claim follows64 delay analysi figur 8 depict round algorithm base quach et al 23 delay annot delay assumpt use similar use two previou round algorithm round algorithm depict fig 8 use predict logic lie critic path delay predict logic two logic level follow quach et al fig 8 depict nonoptim process order post normal shift take place round select increment decis box assum organ follow bit c52 r 0 1 valid 6 7 8 10 logic level respect minim delay implement round equat 4 level multiplex result select condit signal arriv thu total delay 15 logic level obtain perform postnorm round select take place one logic level save obtain total delay 14 logic level 7 higher precis round algorithm scale higher precis use one see part present round algorithm depend length signicand halfadd compound adder sticki round carrybit comput select multiplex driver amplifi signal control wide multiplex precis increas width upper lower part carri save string grow still stay almost equal impli assumpt rel delay carrybit comput compound adder need chang moreov expect precis grow gap delay comput carrybit stickybit grow stickybit comput lie critic path impli rst order estim ignor addit delay due increas fanout interconnect length delay round algorithm precis p state follow 1 delay inject base round algorithm 4 logic level plu delay sum comput pbit compound adder dcla p 2 delay yz round algorithm 8 3 delay round algorithm base quach et al23 optim postnorm take place select 6 level 8 summari conclus new ieee compliant oatingpoint round algorithm comput round product carrysav represent product present new round algorithm compar two previou round algorithm make comparison relev possibl consid optim previou algorithm improv delay round algorithm logic descript block diagram given correct proven latenc analyz conclus new es round algorithm fastest round algorithm provid inject ad reduct partial product carrysav encod digit string es algorithm round product comput 12 logic level doubl precis ie signicand 53 bit long precis independ term critic path consist compound adder 4 addit logic level inject ad reduct partial product carrysav encod digit string extra step ad inject requir step amount carrysav addit latenc associ fulladd name 2 logic level thu inject ad late latenc es round algorithm 14 logic level addit inject reduct partial product accomplish without slowdown small slowdown justic partial product usual obtain booth recod select eg 51 multiplex henc valid much later inject b delay ad partial product increas strictli monoton function number partial product delay incur ad inject depend length signicand organ adder tree two round algorithm requir inject doubl precis latenc qtf round algorithm 14 logic level critic path consist compound adder 6 addit logic level yz round algorithm rank slowest round algorithm latenc 16 logic level critic path consist compound adder 8 addit logic level r area perform optim cmo multipli fast multipl algorithm implement regular layout parallel adder method round use redund code multipli result scheme parallel multipli method apparatu round highspe multipli recod partial compress round fast multipli bitproduct matrix reduct use bit order pariti gener dual mode ieee multipli comparison three round algorithm ieee oat point multipl parallel method apparatu detect complet oat point oper involv special operand ieee standard binari oatingpoint arithmet multistep gradual round design strategi optim multipli circuit design issu high perform float point arithmet unit snap project design oat point arithmet unit method speed optim partial product reduct gener fast parallel multipli use algorithm approach reduc number counter need integ multipl gener high speed cmo multipli accumul float point multipli perform ieee round addit parallel fast ieee round round algorithm ieee multipli half latenc ieee compliant oatingpoint multipl reducedarea scheme carryselect adder fast multipl algorithm vlsi implement suggest parallel multipli new design techniqu column compress multipli oat point multipli method apparatu partial suport subnorm operand oat point multipl share round hardwar multipli divisionsquar root unit use condit sum adder circuitri round oat point multipli 9l 13l 13l 14l 15l 14l 13l 16l 16l 9l 8l 10l tr ctr petermichael seidel guy even delayoptim implement ieee floatingpoint addit ieee transact comput v53 n2 p97113 februari 2004 ahmet akka michael j schult dualmod floatingpoint multipli architectur parallel oper journal system architectur euromicro journal v52 n10 p549562 octob 2006 nhon quach naofumi takagi michael j flynn systemat ieee round method highspe floatingpoint multipli ieee transact larg scale integr vlsi system v12 n5 p511521 may 2004