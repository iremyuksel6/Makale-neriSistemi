trace cach microarchitectur evalu abstracta instruct issu width superscalar processor increas instruct fetch bandwidth requir also increas eventu becom necessari fetch multipl basic block per clock cycl convent instruct cach hinder effort long instruct sequenc alway contigu cach locat trace cach overcom limit cach trace dynam instruct stream instruct otherwis noncontigu appear contigu paper present evalu microarchitectur incorpor trace cach microarchitectur provid high instruct fetch bandwidth low latenc explicitli sequenc program higher level trace term 1 control flow predict 2 instruct suppli spec95 integ benchmark tracelevel sequenc improv perform 15 percent 35 percent otherwis equal sophist contigu multipleblock fetch mechan perform improv due trace cach howev one benchmark whose perform limit branch mispredict perform gain almost entir due improv predict accuraci b introduct high perform superscalar processor organ divid natur instruct fetch mechan instruct execut mechan two mechan separ instruct issu buffer exampl issu queue reserv station conceptu instruct fetch mechan act produc fetch decod dispatch instruct buffer instruct execut engin consum issu instruct buffer execut subject data depend resourc constraint instruct issu buffer collect call instruct window window mechan expos instructionlevel parallel ilp sequenti pro gram larger window increas opportun find dataindepend instruct may issu execut parallel thu trend superscalar design construct larger instruct window provid wider sueexecut path exploit correspond increas avail ilp trend place increas demand instruct suppli mechan particular peak instruct fetch rate match peak instruct issu rate benefit aggress ilp techniqu diminish paper concern instruct fetch bandwidth becom perform bottleneck current fetch unit limit one branch predict per cycl therefor fetch one basic block per cycl previou studi shown howev averag size basic block integ code small around four six instruct 30 3 fetch singl basic block cycl suffici implement issu four instruct per cycl processor higher peak issu rate multipl branch predict 30 3 4 26 use fetch unit least fetch multipl contigu basic block cycl shown paper fetch multipl contigu basic block import upper bound fetch bandwidth still limit due frequenc taken branch therefor taken branch encount necessari fetch instruct taken path cycl branch fetch 11 trace cach job fetch unit feed dynam instruct stream decod problem instruct place cach compil order store program static form favor fetch code infrequ taken branch larg basic block neither case typic integ program figur 1a show exampl dynam sequenc basic block store instruct cach arrow indic taken branch even multipl branch predict per cycl four cycl requir fetch instruct basic block abcd instruct store noncontigu cach locat instruct cach b trace cach figur 1 store noncontigu sequenc instruct reason sever research propos special instruct cach captur long dynam instruct sequenc 15 22 23 24 21 structur call trace cach line store snap shot trace dynam instruct stream refer figur 1 dynam sequenc block appear noncontigu instruct cach contigu trace cach figur 1b primari constraint trace maximum length determin trace cach line size may number implementationdepend constraint number type embed control transfer instruct special termin condit tune variou perform factor 25 trace fulli specifi start address sequenc branch outcom describ path fol low first time trace encount alloc line trace cach line fill instruct fetch instruct cach trace encount cours execut program ie start address predict branch outcom avail trace cach fed directli decod singl cycl otherwis fetch proce normal instruct cach high bandwidth fetch mechan propos base convent instruct cach 30 4 3 26 everi cycl instruct noncontigu locat fetch instruct cach assembl predict dynam sequenc typic requir multipl pipelin stage 1 level indirect special branch target tabl gener pointer noncontigu instruct block 2 moder highli interleav instruct cach provid simultan access multipl line possibl bank conflict 3 complex align network shift align block dynam program order readi decod ingrenam trace cach approach avoid complex cach dynam instruct sequenc rather inform construct predict dynam sequenc exist trace cach recreat fli instruct cach static represent cost approach redund instruct storag instruct may resid primari cach trace cach redund among differ line trace cach 12 relat prior work altern high bandwidth fetch mechan four previou studi focus mechan fetch multipl possibl noncontigu basic block cycl instruct cach branch address cach 30 subgraph predictor 4 collaps buffer 3 multipleblock ahead predictor 26 trace cach develop melvin shebanow patt propos fill unit multinodeword cach 18 16 first work qualit describ perform implic smaller larger atom unit work instructionset architectur isa compil hardwar level author argu small compil atom unit larg execut atom unit achiev highest perform fill unit propos hardwar mechan compact smaller compil unit larg execut unit store reus decod instruct cach evalu perform potenti larg execut atom unit although work evalu size singl vax instruct basic block also suggest join two consecut basic block interven branch highli predict 17 softwar basic block enlarg discuss spirit trace schedul 5 trace select 11 compil use profil identifi candid basic block merg singl execut atom unit hardwar sequenc level execut atom unit creat compil advantag approach compil optim schedul across basic block boundari franklin smotherman 6 extend fill unit role dynam assembl vliwlik instruct word risc instruct stream store shadow cach structur eas issu complex wide issu processor appli fill unit decod instruct cach improv decod perform complex instructionset comput cisc 27 case cach line augment store tree improv util line four work independ propos trace cach complexityeffect approach high bandwidth instruct fetch johnson 15 propos expans cach address cach align branch predict throughput instruct run merg expans process also predetermin execut schedul instruct line unlik pure vliw cach schedul may consist multipl cycl via cycl tag peleg weiser 22 describ design dynam flow instruct cach store instruct independ virtual address defin characterist trace cach rotenberg bennett smith 23 24 motiv concept comparison high bandwidth fetch mechan propos literatur defin trace cach design space patel friendli patt 21 expand upon present detail evalu design space argu promin role trace cach mispredict recoveri cach propos bondi nanda dutta 1 cach instruct thread altern path mispredict branch goal work quickli bypass multipl fetch decod stage long cisc pipelin follow branch mispredict nair hopkin 19 employ dynam instruct format cach larg schedul group similar spirit cycl tag approach expans cach also recent work incorpor trace cach new process model vajapeyam mitra 29 sundararaman franklin 28 rotenberg jacobson sazeid smith 25 exploit data control hierarchi impli trace overcom complex architectur hurdl superscalar processor jacob son rotenberg smith 14 propos control predict model well suit trace cach call next trace pre diction discuss later section friendli patel patt propos new process model call inact issu reduc effect branch mispredict 7 dynam optim trace store trace cach reduc execut time significantli 8 microcod vliw blockstructur isa clearli concept trace exist softwar realm instructionlevel parallel earli work fisher 5 hwu chang 11 other trace schedul trace select microcod recogn problem impos branch code optim subsequ vliw architectur novel isa techniqu exampl 12 10 promot abil schedul long sequenc instruct contain multipl branch 2 trace cach microarchitectur section 11 introduc concept trace cach instruct cach captur dynam instruct sequenc trace present microarchitectur organ around trace 21 tracelevel sequenc premis propos microarchitectur shown figur 2 provid high instruct fetch bandwidth low latenc achiev explicitli sequenc program higher level trace 1 control flow predict 2 suppli instruct cach instruct branch trace trace cach outstand trace buffer execut engin branch outcom updat figur 2 microarchitectur next trace predictor 14 treat trace basic unit explicitli predict sequenc trace trace unit predict rather individu branch high branch predict throughput implicitli achiev singl trace predict per cycl jacobson et al 14 demonstr explicit trace predict remov fundament constraint number branch trace usual consequ adapt singl branch predictor multipl branch predictor counterpart 23 also hold potenti achiev higher overal branch predict accuraci singl branch predictor detail next trace predict present section 23 output trace predictor trace identifi given trace uniqu identifi start pc outcom condit branch embed trace trace identifi use lookup trace trace cach index trace cach deriv start pc combin pc branch come use branch outcom index advantag provid path associ multipl trace emi nate start pc resid simultan trace cach even direct map 24 output trace cach one trace depend cach associ trace identifi store trace order determin trace cach hit analog tag convent cach desir trace present cach one cach trace identifi match predict trace identifi trace predictor trace cach togeth provid fast tracelevel sequenc unfortun tracelevel sequenc alway provid requir trace particularli true start program new region code reach neither trace predictor trace cach learn trace yet instructionlevel sequenc discuss next section requir construct nonexist trace repair trace mispredict 22 instructionlevel sequenc outstand trace buffer figur 2 use 1 construct new trace trace cach 2 track branch outcom becom avail execut engin allow detect mispredict repair trace contain fetch trace dispatch execut engin outstand trace buffer case trace cach miss trace predict receiv alloc buffer trace predict provid enough inform construct trace instruct cach although typic requir multipl cycl due predictedtaken branch case trace cach hit trace dispatch buffer allow repair partial mispredict trace ie branch outcom return execut match path indic within trace event branch mispredict trace buffer begin reconstruct tail trace trace start pc incorrect use correct branch target instruct cach subsequ branch trace secondlevel branch predictor use make predict advoc aggress instruct cach design provid robust perform broad rang trace cach miss rate instruct cach 2way interleav full cach line fetch cycl independ pc align 9 secondlevel branch predict mechan simpl 2bit counter branch target store branch logic instruct counter target store instruct cach oppos separ cach branch target buffer allow fast parallel predict number nottaken branch call instruct fetch mechan seqn keep terminolog 24 number de note n sequenti basic block line size fetch singl cycl trace buffer construct trace written trace cach dispatch execut engin newli construct trace result mispredict recoveri trace identifi also sent trace predictor repair path histori 23 next trace predict next trace predictor shown figur 3 base jacobson work pathbas highlevel control flow predict 13 14 index correl predict tabl form sequenc past trace identifi hash function use gener index call dolc func tion depth specifi path histori depth term trace oldest indic number bit select trace identifi except two recent one last path pc path pc path hash pc path predict tabl path trace cach figur 3 jacobson next trace predictor current indic number bit select secondmost recent recent trace identifi respect entri correl predict tabl contain trace identifi 2bit counter replac predictor augment sever mechan 14 ffl hybrid predict addit correl tabl second smaller tabl index recent trace identifi second tabl requir shorter learn time suffer less alias pressur ffl return histori stack call instruct path histori push onto special stack correspond return point reach path histori call restor improv accuraci control flow follow subroutin highli correl control flow call altern trace identifi entri correl tabl may augment altern trace predic tion form associ predictor trace mispredict detect outstand trace buffer respons repair trace use altern predict consist known branch outcom trace trace buffer resort secondlevel branch predic instructionlevel sequenc avoid altogeth altern trace also hit trace cach 24 trace select perform trace cach strongli depend trace select algorithm use divid dynam instruct stream trace trace select primarili affect averag trace length trace cach hit rate turn affect fetch bandwidth interact trace length hit rate howev well stood preliminari studi indic longer trace result lower hit rate may artifact naiv trace select polici sophist select techniqu consciou control flow construct loop backedg loop fallthrough point call site reconverg point gener may lead differ conclus reader refer 21 25 20 interest controlflow consciou select heurist trace select paper constrain maximum trace length 16 instruct indirect branch return jumpcal indirect termin trace 25 hierarch sequenc figur 4a portion dynam instruct stream shown solid horizont arrow left right stream divid trace t5 sequenc trace produc independ instruct come trace predictortrac cach trace predictorinstruct cach branch predictorinstruct cach mispredict branch hierarch mispredict branch b nonhierarch figur 4 two sequenc model exampl trace predictor mispredict t3 trace buffer assign t3 resort instructionlevel se quenc shown diagram seri step depict smaller block fetch instruct cach trace buffer strictli adher boundari t3 t4 dictat trace select even final instruct cach fetch produc larger block sequenti instruct need t3 call process hierarch sequenc exist clear distinct intertrac control flow intratrac control flow intertrac control flow ie trace boundari effect predetermin trace select unaffect dynam effect trace cach miss mispredict contrast sequenc model shown figur 4b model trace select reset point mispredict branch produc shift trace t3 0 t4 0 t5 0 sequenc model work well pathbas next trace predict resolv branch mispredict trace t3 0 subsequ trace must somehow predict howev requir sequenc trace lead t3 0 sequenc avail dicat question mark diagram potenti problem hierarch sequenc mispredict recoveri latenc explicit next trace predict use level indirect trace first predict trace cach access impli extra cycl ad latenc mispredict recoveri ever extra cycl expos first consid case altern trace predict use primari altern predict suppli trace predictor time store togeth trace buffer therefor altern predict immedi avail access trace cach mispredict detect second altern use secondlevel branch predictor instruct cach use fetch instruct correct path case instruct cach access immedi correct branch target pc return execut engin evalu assum trace must fulli construct instruct dispatch execut engin trace effici renam unit 29 25 aggrav trace mispredict trace cach miss recoveri latenc want make clear howev due fundament constraint fetch model artifact dispatch model 3 simul methodolog 31 fetch model evalu perform trace cach microar chitectur compar sever constrain fetch model first determin perform advantag fetch multipl contigu basic block per cycl convent singl block fetch benefit fetch multipl noncontigu basic block isol model next trace predictor use control predict two reason first next trace predict highli accur whether predict one mani branch time compar better best singl branch predictor literatur second desir common underli predictor fetch model separ perform due fetch bandwidth due branch predict section 32 differenti follow model trace select algorithm ffl seq1 sequenti 1 block trace singl basic block 16 instruct length ffl seqn sequenti n block trace may contain number sequenti basic block instruct limit trace cach trace may contain number condit branch taken nottaken instruct first indirect branch seq1 seqn model use trace cach interleav instruct cach capabl suppli trace singl cycl 9 consequ sequenti select constraint therefor one may view seq1seqn fetch unit ident trace cach microarchitectur figur 2 except trace cach block replac convent instruct cach next trace predictor drive convent instruct cach trace buffer use construct trace l2 cachemain memori present cach final establish upper bound perform noncontigu instruct fetch introduc fourth model tcperfect ident tc trace cach alway hit 32 isol trace predictortrac cach perform interest sideeffect trace select significantli affect trace predict accuraci gener smaller trace result constrain trace selec tion result lower accuraci determin least two reason first longer trace natur captur longer path histori compens use trace identifi path histori trace small good dolc function one trace length necessarili good anoth tc model dolc depth 7 trace consist perform well benchmark 14 seq1 seqn brief search design space show depth 17 trace perform well observ howev tune dolc paramet enough trace select affect accuraci way graph figur 5 show trace predictor perform use unbound tabl ie use full unhash path histori make predict graph show trace mispredict per 1000 instruct seq1 seqn tc trace select histori depth var i go benchmark trace mispredict seqn model dip 88 per 1000 instruct wherea tc model reach 80 trace mispredict per 1000 instruct unconstrain trace select result creation mani uniqu trace trace explos gener neg impact trace cach perform hypothes also creat mani uniqu context make predict larg predict tabl exploit addit context ideal trace predict go913171 6 11 histori depth trace trace misp1000 instr seqn figur 5 impact trace select unbound trace predictor perform conclud difficult separ perform advantag trace cach trace predictor show posit improv longer trace nonetheless compar tc seqn seq1 would like know much benefit deriv trace cach end develop methodolog statist adjust overal branch predict accuraci given fetch model match anoth model trace predictor adjust produc predict normal fashion howev make predict predict trace compar actual trace determin advanc function simul run parallel time simul predict correct actual trace substitut mispredict trace probabl word fraction mispredict trace correct probabl inject correct chosen perbenchmark basi achiev desir branch mispredict rate methodolog introduc two addit fetch mod el seq1adj seqnadj correspond ad just seq1 seqn model clearli model unrealiz use perform comparison adjust branch mispredict rate match tc model 33 simul benchmark detail fullyexecut driven superscalar processor simul use evalu trace cach microarchitec ture simul develop use simplescalar platform 2 platform use mipslik instruct set gccbase compil creat binari datapath fetch engin shown figur 2 faith model next trace predictor 2 tri dolc function compress path histori 16bit index describ earlier section 32 tc seq model trace cach configur size associ index vari suffici outstand trace buffer keep instruct window full trace buffer share singl port combin instruct cach secondlevel branch predic tor instruct cach 64kb 4way setassoci 2way interleav line size 16 instruct cach hit miss latenc 1 cycl 12 cycl respect secondlevel branch predictor consist 2bit counter branch target assum logic store branch instruct cach instruct window 256 instruct use experi processor 16way superscalar ie processor fetch issu 16 instruct cycl five basic pipelin stage model instruct fetch dispatch take 1 cycl issu take least 1 cycl possibl instruct must stall operand 16 instruct includ load store may issu cycl execut take fix latenc base instruct type plu time spent wait result bu instruct retir order load store address gener take 1 cycl cach access 2 cycl hit data cach 64kb 4way setassoci line size 64 byte miss penalti 14 cycl realist aggress memori disambigu model load may proceed ahead unresolv store memori hazard detect store address becom avail recoveri via select reissu misspecul load depend instruct 25 seven spec95 integ benchmark shown tabl simul complet tabl 1 benchmark benchmark input dataset dynam instr count gcc o3 genrecogi 117m jpeg vigoppm 166m li queen 7 202m perl scrabblpl scrabblin 108m vortex persons250 101m 4 result 41 perform fetch model figur 6 show perform six fetch model term retir instruct per cycl ipc model section use 64kb instruct storag 4way setassoci trace cach trace cach index use pc ie explicit path associ except afford 4 ways357go gcc jpeg li perl m88k vortex ipc tcperfect figur 6 perform fetch model draw sever conclus graph figur 6 first compar seqn model seq1 model appar predict fetch multipl sequenti basic block provid signific perform advantag convent singleblock fetch graph figur 7 show perform advantag seqn model seq1 model rang 5 25 major benchmark show greater 15 improv similar result hold whether branch predict accuraci adjust seqn seq1 model first observ import seqn model requir sophist highlevel control flow predictor retain moreorless convent instruct cach microarchitectur 0 5 10 15 20 30 go gcc jpeg li perl m88k vort improv ipc seqn seq1 seqnadj seq1adj figur 7 speedup seqn seq1 second abil fetch multipl possibl noncontigu basic block improv perform significantli sequentialonli fetch graph figur 8 show perform advantag tc model seqn model rang 15 35 speedup tc seqn 0 5 10 15 20 30 40 go gcc jpeg li perl m88k vort improv ipc trace cach trace predictor figur 8 speedup tc seqn figur 8 also isol contribut next trace predict trace cach perform lower part bar speedup model seqnadj seqn sinc overal branch mispredict rate seqn adj adjust match tc model part bar approxim isol impact next trace predict perform top part bar therefor isol impact trace cach perform go suffer notic branch mispredict benchmark benefit model come next trace predict case longer trace tc model clearli valuabl improv context use next trace predictor provid raw instruct bandwidth gcc howev next trace predict trace cach contribut equal perform five benchmark benefit mostli higher fetch bandwidth final figur 6 show moder larg trace cach tc model nearli reach perform upper bound establish tcperfect within 4 tabl show trace branchrel measur averag trace length tc rang 124 li 158 jpeg instruct 16 2 time longer seqn trace tabl also show predictor perform primari altern trace mispredict per 1000 instruct overal branch mispredict rate latter comput check branch retir see caus mi predict whether origin trace predictor secondlevel branch predictor case predict improv longer trace tc 20 45 fewer trace mispredict seq1 result 15 jpeg 41 m88ksim fewer total branch mispredict note adjust branch mispredict rate seq model nearli equal tc shorter trace howev gener result better altern trace predict accuraci shorter trace result 1 fewer total trace thu less alias 2 fewer possibl altern trace given start pc benchmark except gcc go altern trace predict almost alway correct given primari trace predict incorrect predict taken togeth result fewer 1 trace mispredict per 1000 instruct trace cach introduc redund instruct appear multipl time one trace tabl 2 show two redund measur overal redund factor rf overal comput maintain tabl uniqu trace ever retir redund ratio total number instruct total number uniqu instruct trace collect tabl rf overal independ trace cach configur captur dynam behavior dynam redund factor rf dyn comput similarli use trace trace cach given cycl final valu averag cycl rf dyn measur use 64kb 4way trace cach rf overal vari 29 vortex 14 go rf dyn less rf overal rang 2 4 fix size trace cach limit redund perhap tempor less redund 42 trace cach size associ section measur perform tc model function trace cach size associ figur 9 show overal perform ipc 12 trace cach config urat direct map 2way 4way associ four size 16kb 32kb 64kb 128kb associ notic impact perform tabl 2 trace statist model measur gcc go jpeg li m88k perl vort trace length 49 62 83 42 48 51 58 trace misp1000 88 145 52 69 35 34 15 seq1 alt trace misp1000 21 45 branch misp rate 50 110 77 37 22 22 11 adjust misp rate 36 82 66 32 13 14 08 trace length 72 80 96 63 60 71 82 trace misp1000 73 127 46 69 33 31 12 seqn alt trace misp1000 27 54 05 09 06 03 03 branch misp rate 44 101 70 37 21 20 09 adjust misp rate 36 81 67 31 13 14 08 trace length 139 148 158 124 131 130 144 trace misp1000 54 96 42 55 20 21 10 alt trace misp1000 27 53 09 13 05 03 03 branch misp rate 36 82 67 31 13 15 08 control instr per trace 28 23 13 29 25 25 23 rf overal 71 144 53 31 37 41 29 rf dyn 30 33 37 32 31 29 213545556575 trace cach size ipc jpeg perl vort go gcc li4 figur 9 perform vs sizeassoci benchmark except go go particularli larg work set uniqu trace 25 total capac import individu trace conflict curv jpeg li fairli flat size littl import yet increas associ improv perform two benchmark suffer gener conflict miss otherwis size improv perform yet conflict among trace start pc signific associ allow simultan cach pathassoci trace perform improv largest configur 128kb 4way respect smallest one 16kb direct map rang 4 go 10 gcc figur show trace cach perform miss per 1000 instruct trace cach size vari along x axi six curv direct map dm 2 way 2w 4way 4w associ cach without index path associ pa chose somewhat arbitrarili follow index function achiev path associ loword bit pc form set index highord bit index xore first two branch outcom trace identifi gcc go benchmark fit entir within largest trace cach observ earlier go mani heavilyreferenc trace result fewer 20 misses1000 instruct path associ reduc miss substanti particularli direct map cach except vortex path associ close gap direct map 2way associ cach half often entir misses1000 instr go253545 misses1000 instr li51525m88ksim2610misses1000 instr perl5152535 trace cach size trace cach size misses1000 instr dm dmpa 4wpa figur 10 trace cach miss 5 summari import design instruct fetch unit capabl fetch past multipl possibl taken branch cycl trace cach provid capabl without complex latenc equivalentbandwidth instruct cach design evalu microarchitectur incorpor trace cach follow major result ffl trace cach improv perform 15 35 otherwis equallysophist contigu multipleblock fetch mechan ffl longer trace improv trace predict accuraci mispredictionbound benchmark go factor contribut almost entir observ perform gain ffl moder larg associ trace cach perform well perfect trace cach go howev trace mispredict mask poor trace cach perform ffl overal perform sensit trace cach size associ one might expect due part robust instructionlevel sequenc ipc vari 10 wide rang configur ffl complex advantag trace cach come price redund instruct storag gcc factor 7 redund among trace creat correspond factor 3 redund trace cach ffl instruct cach combin aggress trace predictor fetch number contigu basic block per cycl yield 5 25 improv singleblock fetch acknowledg research trace cach genesi stimul group discuss guri sohi student todd austin scott breach andrea moshovo dionisio pnevmatikato n vijaykumar contribut grate acknowledg would also like give special thank quinn jacobson valuabl input provid access next trace predict simul work support part nsf grant mip 9505853 mip9307830 us armi intellig center fort huachuca contract dabt63 95c0127 arpa order d346 eric rotenberg support ibm fellowship r integr mispredict recoveri cach mrc superscalar pipelin evalu futur mi croprocessor simplescalar toolset optim instruct fetch mechan high issu rate control flow predict treelik subgraph superscalar processor trace schedul techniqu global microcod compact altern fetch issu polici trace cach fetch mechan put fill unit work dynam optim trace cach microproc sor branch fixedpoint instruct execut unit increas instruct fetch rate via blockstructur instruct set ar chitectur trace select compil larg c applic program microcod control flow specul multiscalar processor expans cach superscalar processor perform benefit larg execut atom unit dynam schedul machin exploit finegrain parallel combin hardwar softwar techniqu hardwar support larg atom unit dynam schedul machin exploit instruct level parallel processor cach schedul group improv trace cach effect branch promot trace pack critic issu regard trace cach fetch mechan dynam flow instruct cach memori organ around trace segment independ virtual address line trace cach low latenc approach high bandwidth instruct fetch ing trace cach low latenc approach high bandwidth instruct fetch ing trace processor improv cisc instruct decod perform use fill unit multiscalar execut along singl flow control improv superscalar instruct dispatch issu exploit dynam code se quenc increas instruct fetch rate via multipl branch predict branch address cach tr ctr emil talp diana marculescu power reduct work reus proceed 2001 intern symposium low power electron design p340345 august 2001 huntington beach california unit state bartolini c prete propos inputsensit analysi profiledriven optim embed applic acm sigarch comput architectur news v32 n3 p7077 june 2004 emil talp diana marculescu execut cachebas microarchitectur powereffici superscalar processor ieee transact larg scale integr vlsi system v13 n1 p1426 januari 2005 emil talp diana marculescu increas scalabl power effici use multipl speed pipelin acm sigarch comput architectur news v33 n2 p310321 may 2005 michael behar avi mendelson avinoam kolodni trace cach sampl filter acm transact comput system toc v25 n1 p3e februari 2007 oliverio j santana ayos falcn alex ramirez mateo valero branch predictor guid instruct decod proceed 15th intern confer parallel architectur compil techniqu septemb 1620 2006 seattl washington usa oliverio j santana alex ramirez josep l larribapey mateo valero lowcomplex fetch architectur highperform superscalar processor acm transact architectur code optim taco v1 n2 p220245 june 2004 sangjeong lee penchung yew augment trace cach highbandwidth valu predict ieee transact comput v51 n9 p10741088 septemb 2002 xianglong huang stephen blackburn david grove kathryn mckinley fast effici partial code reorder take advantag dynam recompilatior proceed 2006 intern symposium memori manag june 1011 2006 ottawa ontario canada bartolini c prete optim instruct cach perform embed system acm transact embed comput system tec v4 n4 p934965 novemb 2005 yoav almog roni rosner naftali schwartz ari schmorak special dynam optim highperform energyeffici microarchitectur proceed intern symposium code gener optim feedbackdirect runtim optim p137 march 2024 2004 palo alto california michel co dee b weikl kevin skadron evalu trace cach energi effici acm transact architectur code optim taco v3 n4 p450476 decemb 2006 independ trace processor proceed 32nd annual acmiee intern symposium microarchitectur p415 novemb 1618 1999 haifa israel roni rosner yoav almog micha moffi naftali schwartz avi mendelson power awar select dynam optim trace acm sigarch comput architectur news v32 n2 p162 march 2004 roni rosner micha moffi yiannaki sazeid ronni ronen select long atom trace high coverag proceed 17th annual intern confer supercomput june 2326 2003 san francisco ca usa alex ramirez oliverio j santana josep l larribapey mateo valero fetch instruct stream proceed 35th annual acmiee intern symposium microarchitectur novemb 1822 2002 istanbul turkey