adapt effici algorithm lattic agreement renam sharedmemori system n independ asynchron process distinct name rang 0 n1 commun read write share regist algorithm waitfre process complet execut regardless behavior process paper consid waitfre algorithm whose complex adjust level content system algorithm adapt total content step complex depend actual number activ process k number unknown advanc may chang differ execut algorithmadapt algorithm present two import decis problem lattic agreement 6k1renam step complex algorithm ok log k interest compon 6k1renam algorithm algorithm 2k1renam improv best previous known 2k1renam algorithm onnk step complexityth effici renam algorithm modifi implement atom snapshot use dynam singlewrit multiread regist best known implement atom snapshot step complex log n use static singlewrit multiread regist use multiwrit multiread regist b introduct asynchron sharedmemori system contain n process run arbitrari speed commun read write share regist process distinct name rang waitfre algorithm process termin finit number step even process slow even stop take step complet step complex mani waitalgorithm depend n exampl collect uptod inform process typic requir read array index process name real distribut system need accommod larg number process ie n larg often small number process take part comput system step complex depend n n undesir prefer step complex adjust number process particip algorithm algorithm adapt total content step complex depend total number process particip algorithm denot k k unknown advanc may chang differ execut algorithm step complex adapt algorithm adjust number activ process constant singl process particip algorithm gradual grow number activ process increas weaker guarante provid rangeindepend algorithm whose step complex depend n maxim number process clearli n fix execut 1 advantag rangeindepend algorithm quit restrict requir priori knowledg n often difficult determin moreov extend abstract paper appear proceed 17th acm symposium principl distribut comput june 1998 pp 277286 2 depart comput scienc technion haifa 32000 israel hagitcstechnionacil leonfcstechnionacil support fund promot research technion 1 moir anderson 27 use term fast conflict paper 3 25 2 attiya fouren algorithm union 23 ok log lattic agreement algorithm renam 27 algorithm ok log algorithm 1renam algorithm 1renam log n algorithm 1renam fig 1 algorithm present paper doubl box indic main result step complex optim actual number particip process much lower upper bound yet show use tool construct adapt algorithm paper present adapt waitfre algorithm lattic agreement name use read write oper along way improv step complex nonadapt algorithm renam figur 1 depict algorithm present paper oneshot renam problem 10 process requir choos distinct name rang size k bound function paper consid gener longliv renam problem 9 process repeatedli acquir releas name adapt renam serv intermedi step adapt algorithm problem 9 26 27 28 new name replac process origin name make step complex depend number activ process algorithm employ techniqu well 6 7 effici adapt algorithm renam could deriv known algorithm best previous known algorithm renam linear name space 18 onnk step complex yield ok 3 step complex best made adapt thu first present 2k gamma 1renam algorithm step complex neither adapt rangeindepend algorithm base new shrink network construct consid novel algorithm contribut paper new linear renam algorithm employ rangeindepend algorithm 1renam log n step complex process start adapt ok 2 renam algorithm whose step complex ok simpl modif rangeindepend renam algorithm moir anderson 27 process reduc rang name ologn iter iter use new linear renam algorithm rangeindepend renam algorithm use construct adapt 6k gamma 1renam algorithm ok log complex algorithm process partit ologk disjoint set accord view obtain adapt lattic agreement algorithm describ partit bound number process set allow employ rangeindepend 2k gamma 1 adapt lattic agreement renam 3 renam algorithm design bound differ set use disjoint name space coordin set requir lattic agreement problem 15 process obtain compar contain ment subset set activ process waitfre lattic agreement algorithm turn waitfre implement atom snapshot object addit readwrit oper 15 atom snapshot object allow process get instantan global view snapshot share memori thu simplifi design waitfre algorithm step complex adapt algorithm lattic agreement ok log k algorithm process first obtain name rang size ok 2 use simpl algorithm ok step complex base reduc name process enter adapt variant tree use lattic agreement algorithm inou et al 23 appendix c describ shrink network modifi get lattic agreement algorithm step complex use dynam singlewrit singleread regist give implement atom snapshot complex previou implement atom snapshot either log n step complex use static singlewrit multiread regist 16 step complex use multiwrit multiread regist 23 renam problem introduc solv attiya et al 10 messagepass model barnoy dolev 17 solv problem sharedmemori model burn peterson 19 consid lassign problem dynam alloc l distinct resourc process present waitfre lassign algorithm assum l number process tri acquir resourc algorithm exponenti step complex 21 borowski gafni 18 present algorithm oneshot 2k gamma 1renam use onnk readwrit oper anderson moir 9 defin longliv renam present rangeindepend algorithm oneshot longliv renam algorithm use testset op erat moir anderson 27 introduc build block later call split ter employ rangeindepend algorithm longliv renam use readwrit oper moir garay 28 26 give rangeindepend longliv oknrenam algorithm use readwrit oper combin longliv 1renam algorithm 19 obtain rangeindepend longliv 1renam algorithm step complex domin exponenti step complex burn peterson algorithm herlihi shavit 22 show oneshot renam requir name impli rangeindepend renam algorithm provid optim name space name space provid adapt renam algorithm optim linear number activ process follow origin public paper 12 afek merritt 4 use algorithm obtain adapt waitfre 2k gamma 1renam algorithm ok 2 step complex anoth paper 13 present adapt collect algorithm ok step complex deriv adapt algorithm atom snapshot immedi snapshot 1renam paper emphas modular use collect oper make known algorithm adapt algorithm higher step complex present algorithm adapt total number particip process 4 attiya fouren process ever perform step influenc step complex algorithm throughout execut use algorithm adapt current content whose step complex decreas process stop particip afek dauber touitou 3 present implement longliv object adapt current content use loadlink storecondit oper recent paper present algorithm longliv renam 2 14 collect 6 snapshot 7 adapt current content use readwrit oper lamport 25 suggest mutual exclus algorithm requir constant number step singl process wish enter critic section use readwrit oper sever process compet critic section step complex depend rang name alur taubenfeld 8 show behavior inher mutual exclus algorithm choy singh 20 present mutual exclus algorithm whose time complexityth time consecut entri critic sectioni ok use readwrit oper afek stupp touitou 6 use adapt collect algorithm deriv adapt version bakeri algorithm 24 present anoth mutual execlus algorithm 5 recent attiya bortnikov 11 present mutual exclus algorithm whose time complex olog k algorithm employ unbalanc tournament tree structur adapt lattic agreement tree 2 preliminari 21 model sharedmemori model process appli oper share object process p model possibl infinit state machin process p distinct name id share object consid paper atom readwrit regist access read write oper readr oper chang state r return current valu store r writevr oper chang state r v multiwrit multiread regist allow process perform read oper singlewrit multiread regist allow singl process perform write oper process perform read oper singlewrit multiread regist dynam ident singl process write regist vari differ execut otherwis static event comput step singl process process determin oper perform accord state next state accord state valu return oper comput system captur sequenc event execut ff finit infinit sequenc event process perform event oe r appli read write oper singl regist chang state accord transit function constraint interleav event differ process reflect assumpt process asynchron bound rel speed consid execut ff algorithm process number readwrit oper p perform ff step complex ff denot stepa ff maximum stepa ff process activ ff take step ff stepa ff denot number activ process ff algorithm rangeindepend function f n 7 n everi execut ff stepa ff fn name step complex everi execut bound function total number process known advanc depend rang initi name adapt lattic agreement renam 501 6 diagon fig 2 grid use ok 2 renam depict algorithm adapt total content function f n 7 n everi execut ff stepa ff fkff name step complex ff bound function number activ process ff clearli number activ process known priori waitfre algorithm guarante everi process complet comput finit number step regardless behavior process sinc kff bound n follow adapt algorithm waitfre 22 problem renam problem 10 requir process choos distinct name rang depend number activ process name function n 7 n everi execut ff process output distinct name rang 1g lattic agreement problem 15 everi process p output v subset activ process eq view follow condit hold compar either v j 23 simpl ok 2 renam ok oper first step algorithm simpl adapt ok 2 renam algorithm algorithm reduc rang name depend number activ process later stage use distinct name without sacrif adapt describ algorithm first sinc employ adapt algorithm present paper basic build block algorithm splitter moir anderson 27 process execut splitter obtain right stop one process obtain stop singl process execut splitter obtain stop two process execut splitter obtain valu way set process access splitter split smaller subset 27 splitter arrang grid size n theta n figur 2 process start upper left corner grid splitter direct process either continu move right grid obtain number associ current splitter grid spread process process eventu stop distinct splitter differ algorithm moir anderson 27 algorithm number splitter row number splitter diagon splitter j row column j 0 figur show number number moir anderson appear squar bracket 6 attiya fouren algorithm 1 adapt kk 12renam procedur adapt kk privat j integ initi 0 row column indic privat move fdown right stopg initi direct 1 move 6 stop 2 move splitteri j execut splitter grid posit 3 move increas row 4 move right j increas column 5 returni name base current splitter procedur splitteri j moir anderson 27 share initi share yi j boolean initi fals 1 xi j id 2 yi j returnright 3 els yi j true 4 xi 5 els returndown algorithm 1 present pseudocod grid splitter 2 say splitter step away splitter 0 0 top left corner grid shown 27 section 31 k process access grid process stop ok oper distinct splitter k gamma 1 step away 0 0 simpl count argument show splitter number rang 1g theorem 21 algorithm 1 solv kk 12renam ok step complex 3 1renam oper explain introduct step complex adapt renam depend new linear renam algorithm neither rangeindepend adapt algorithm organ network reflector reflector two distinguish entranc process access reflector chang direct movement anoth process access reflector depend entranc enter reflector network consist n column number left right see figur 3 column gammac top bottom process q name c start topmost reflector column c descend column c see anoth process access reflector q move left right toward column output row exit column n gamma 1 column c cgamma1 set process start column 1 main properti network process cgamma1 enter column c distinct row among lowest 2j one therefor process cgamma1 access reflector column c larger may interfer singl process descend column c algorithm declar privat variabl usag obviou initi valu import adapt lattic agreement renam 7 process q descend column c access reflector row r process cgamma1 pass q move column c remain row r process p 2 cgamma1 access reflector q pass p move one row column c reflector q pass p move one row column c 1 therefor process cgamma1 enter column c row move one row process cgamma1 enter column c row r move one row process q leav one free row row occupi two subset fqg leav column c distinct row sinc new name process row leav network output distinct name interact process column c guarante process cgamma1 move upper row column c activ two addit row occupi figur 5b q activ process leav column c exactli number row enter figur 5a thu activ process caus two row occupi k activ process leav network lowest row formal reflector two entranc 0 1 two lower exit 0 1 two upper exit 0 1 process enter reflector entranc leav reflector exit see top left corner figur 3 singl process enter reflector must leav lower exit one process leav lower exit possibl two process enter reflector leav upper exit reflector easili implement two boolean regist see algorithm 2 reflector column c denot connect follow upper exit 0 sc r connect entranc 0 sc upper exit 1 sc r connect entranc 0 sc lower exit 0 sc r connect entranc 0 sc lower exit 1 reflector sc r connect entranc 1 reflector lowest reflector column c connect entranc 0 reflector sc algorithm 2 process name c start entranc 1 upper reflector column c descend column c leav exit 1 see anoth process reach bottom column point process leav exit 1 next column move toward column column enter exactli one reflector entranc 0 leav exit 0 see anoth process exit 0 otherwis suppos p j enter reflector entranc 2 f0 1g process enter reflector entranc 1gammai sinc process write r 1gammai p j read fals r 1gammai leav reflector lower exit impli follow lemma lemma 31 singl process enter reflector leav lower exit similar argument use proof next lemma lemma 32 singl process enter reflector 0 singl process enter reflector 1 one process leav reflector lower exit proof assum p enter reflector 0 p j enter reflector 1 process read true r 1 r 0 algorithm exitp lemma hold otherwis without loss gener p read 8 attiya fouren reflector 0 1 0 fig 3 network reflector 2k gamma 1renam depict fals r 1 sinc p read fals r 1 p j write r 1 line 1 p read r 1 line 2 therefor p j read r 0 line 2 p write r 0 line 1 consequ obtain true r 0 algorithm exitp prove lemma recal c contain activ process start column everi process c valu local variabl row p access first reflector column c 1 next lemma show process exit column distinct row lemma 33 everi pair process proof proof induct column c base case lemma trivial hold sinc one process may access reflector column 0 induct step suppos lemma hold column c 0 two case adapt lattic agreement renam 9 algorithm 1renam procedur shrinknam renam algorithm privat col row integ initi name start top reflector column name 1 name descend column name 2 exit reflectorrowcol1 enter 1 3 4 els rowgammagamma 5 row gammacol col reach lowest reflector column 6 move toward column 7 exit reflectorrow col0 enter 0 8 9 els col rowgammagamma 10 returnrow n procedur reflectorentr r 01 2 r 3 els returnup r case 1 process start column c 1 algorithm reflector column c1 access 1 lemma 31 everi process p 2 c leav column algorithm figur 4a lemma hold induct hypothesi case 2 suppos process q start column c 1 let sc last reflector access q column c 1 q leav reflector sc access reflector lemma 32 everi process p 2 c enter column c 1 row r higher exit column c 1 0 lemma 31 everi process p 2 c enter column c1 row r lower exit column c 1 0 consid process q algorithm q leav column c 1 either exit 1 lowest reflector column sc 1 exit 1 reflector q leav reflector sc1 gammac1 1 figur 4b algorithm process b c fig 4 illustr proof lemma 33column c 1 q leav reflector sc algorithm lemma 32 process p j 2 c access sc1 r 0 rowp algorithm ae leav 0 induct hypothesi equat impli case rowp 1 everi pair process therefor process exit network differ row henc obtain distinct name next lemma show process c leav column c lowest row lemma 34 everi process proof proof induct c base case process id sinc process access reflector s0 0 0 therefor algorithm rowp lemma hold induct step suppos lemma hold column c 0 two case case 1 process start column c 1 process access reflector column c 1 entranc 1 figur 5a therefor lemma 31 process induct hypothesi also sinc js c1 lemma follow inequ case 2 suppos process q start column c 1 induct hypoth esi process c access lowest 2j c reflector column c1 sinc process access upper reflector sc 0 lemma 31 q access reflector reach reflector sc1 r 0 adapt lattic agreement renam 11 b fig 5 illustr proof lemma 34column c 1 access anoth process reach lowest reflector sc column figur 5b therefor q leav column c 1 either exit 1 reflector 1 exit 1 reflector sc 1 algorithm impli 1 accord algorithm process ae togeth induct hypothesi impli 2 also lemma follow inequ 1 2 3 lemma 34 impli process leav network row 2 sinc js n name chosen line 10 rang process 2id reflector column id j exactli one reflector column id reflector requir constant number oper impli next theorem theorem 35 algorithm 2 solv 2k gamma 1renam step complex network consist 2 reflector reflector implement two regist regist r reflector written process enter reflector entranc entranc 1 reflector access singl process start column entranc 0 access one process lemma 33 therefor use 2 dynam singlewrit singleread regist 12 attiya fouren shrink1 shrink2 shrink3 shrink7 shrink6 shrink5 shrink4 12renam algorithm 1 fig 6 rangeindepend algorithm 2k gamma 1renam depict algorithm 3 rangeindepend 2k gamma 1renam n process procedur indrenamingn 1 tempnam adapt kk 2 height tree 3 side tempnam mod 2 4 tempnam 0 5 1 6 tempnam shrinktempnam 7 side mod 2 8 b2c 9 returntempnam 4 2k gamma1renam log n oper rangeindepend 2k gamma1 renam obtain combin adapt ok 2 renam nonadapt 1renam first name reduc rang size 2 algo rithm 1 name use enter shrink network algorithm 2 reduc rang size 2k gamma1 shrink network start name size 2 henc step complex simpl algorithm 2 algorithm present section obtain log n step complex reduc name space gradual olog n iter distinct copi shrink algorithm associ vertic complet binari tree height copi shrink design name rang size 4n gamma 2 employ network process start algorithm 3 acquir name use ok 2 renam name determin leaf start process perform shrink network associ vertex v path leaf root start column determin name obtain previou vertex ascend left subtre v start one first 2n gamma 1 column network otherwis start one last column process output name obtain root vertic tree number bf order figur 4 root number vertex v number left child number 2 right child number 2 1 copi algorithm 2 associ vertex number denot shrink lemma 41 everi vertex v process execut shrinkv obtain distinct temporari name rang proof proof induct height v base case adapt lattic agreement renam 13 algorithm 4 adapt 6k gamma 1renam 1 v adaptivela algorithm 5 present 2 r dlog jvje 3 tempnam indrenam 2 r algorithm 3 4 5 els returntempnam execut algorithm 1 process get distinct name rang 1g therefor one process access v left execut shrinkv temporari name 0 one process access v right execut shrinkv temporari name 1 thu execut shrinkv differ temporari name rang 3g theorem 35 impli obtain distinct name rang f0 1 2g therefor lemma hold induct step assum lemma hold vertic height let v vertex height 1 induct hypothesi algorithm access v left child distinct temporari name rang access v right child distinct name rang f2n 3g thu process execut shrinkv distinct name rang distinct name rang 2g theorem 35 therefor process obtain distinct name rang complet shrink root process perform shrink n vertic tree vertex requir oper theorem 35 impli follow theorem theorem 42 algorithm 3 solv 2k gamma 1renam log n step complex 5 1renam ok log oper adapt 6k gamma 1 renam algorithm process estim number activ process perform copi rangeindepend 2k gamma 1renam algorithm algorithm design number process may differ estim k number activ process perform differ copi algorithm 3 instead consolid name obtain differ copi disjoint name space alloc copi number activ process estim size view obtain lattic agreement sinc view compar estim within constant factor see lemma 51 algorithm 4 process p belong set j size view view obtain lattic agreement partit guarante js j j 2 j moreov number activ process k js dlog ke dlog ne copi algorithm 3 denot indrenam 2 indrenam 2 dlog ne process j perform indrenam 2 j design 2 j process obtain name rang size 2j j 1 name space ne overlap size linear k figur 7 lemma 51 view process set satisfi compar selfinclus properti lattic agreement size view k jsj k proof assum v view maxim size let v view process selfinclus properti impli compar 14 attiya fouren adapt lattic agreement renam rangeindepend fig 7 adapt 6k gamma 1renam properti impli v v therefor v impli jsj jv j k algorithm process p j jv j 2 j lemma 51 impli next lemma lemma 52 k activ process js everi process sinc view contain activ process therefor impli next lemma lemma 53 k activ process js lemma 52 2 j process invok indrenam 2 j therefor process p invok indrenam 2 j obtain tempnam 2g theorem 42 algorithm p return tempnam set name return process perform indrenam 2 j denot namespac next lemma follow algorithm lemma 54 1 namespac namespac dlog ne 2 lemma 55 k activ process return distinct name rang proof two activ process p p j execut copi indrenam obtain distinct name theorem 42 otherwis obtain distinct name lemma 541 lemma 53 process invok indrenam 2 j 0 j dlog ke lemma 542 process invok indrenam rang 2g theorem 42 process p invok last nonempti copi indrenam 2 dlog ke obtain temporari name rang algorithm p return name rang f2 dlog 3 dlog ke1 name form 2 use therefor name obtain algorithm map name space size 6k gamma dlog 2 adapt lattic agreement renam 15 thu output name rang whose size greater 2 dlog correct algorithm follow lemma 55 k activ process process perform adaptivela pre sent next section ok log oper lemma 53 copi indrenam less 2k process invok therefor process complet indrenam ok log oper theorem 56 algorithm 4 solv 6k gamma 1renam ok log upper bound size name space 6k gamma 1 tight algorithm 4 assum process execut lattic agreement obtain maxim view size access indrenam 2 dlog ke process leav rang 2g unus sinc unknown whether previou copi indrenam empti return name rang f2 dlog 2g k integr power 2 output name rang size 2 log k2 integr power 2 output name rang size merritt privat commun note name reduc partit activ process set size integ 2 activ process partit set adaptiverenam j design j particip obtain new name rang size 2j j 1 algorithm k process activ adaptiverenam j access 0 j dlog ke process access copi adaptiverenam j name space size p dlog 2 log k1 gamma1 tend 2k 1 process access last nonempti copi adaptiverenam dlog new name rang size 2k gamma 1 thu size total name space 6 lattic agreement ok log oper lattic agreement algorithm base algorithm inou et al 23 algorithm process start distinct leaf base name complet binari tree height climb tree root vertex path perform procedur merg togeth two set view set contain compar view procedur call union leaf process use name input union inner vertic use view obtain previou vertex input union process output view obtain root specif union take two paramet input view v integ side 2 f0 1g return output view properti specifi next lemma 23 lemma 6 lemma 61 input view process invok union compar satisfi selfinclus properti similarli input view process invok union 1 output view process exit union compar 2 output view process exit union contain input view appendix describ union detail explain next lemma lemma 62 step complex union ok adapt algorithm use unbalanc binari tree r defin induct follow 0 root v 0 singl left child figur 8a r 0 suppos r attiya fouren22 37 29 vr cr t0 b tr1 fig 8 unbalanc binari tree use adapt lattic agreement algorithm defin identifi vertex v r last vertex inord travers r notic v r right child r r1 obtain insert new vertex v r1 right child v r insert complet binari tree c r1 height r left subtre v r1 figur 8b construct v r1 last vertex inord travers r1 vertic tree number follow root number 1 vertex number left child number 2 right child number figur 8 construct leav r leav complet binari subtre therefor total number leav r follow simpl lemma prove appendix b state properti r lemma 63 let w ith leaf r 1 count left right 1 depth w 2blog ic 2 w number 2 algorithm 5 use 2 log ngamma1 n leav 4 process start algorithm obtain new name rang size kk 12 use algorithm 1 name determin leaf process start climb tree process new name x start algorithm x th leaf tree count left right sinc kk leav temporari name rang size kk 12 lemma 63 x th leaf number 2 23 distinct copi union associ inner vertex tree process perform copi union associ vertic along path root return view obtain root simpl induct distanc vertex v leav show view obtain process execut union v satisfi compar self inclus properti base case v leaf claim trivial sinc singl process start leaf induct step follow immedi lemma 61 henc view obtain root lattic agreement properti k activ process process p get uniqu name x 4 simplic assum n power 2 adapt lattic agreement renam 17 algorithm 5 adapt lattic agreement procedur adaptivela 1 tempnam adapt kk 2 blog tempnamec 3 tempnam leaf correspond tempnam 4 v fp g input processs name 5 1 6 side mod 2 calcul side 7 b2c calcul father 8 v unionv side 9 returnv 12g line 1 lemma 632 start leaf depth 2blog x therefor p access 2blog x vertic vertex execut union requir ok oper lemma 62 thu total step complex algorithm ok log k impli follow theorem theorem 64 algorithm 5 solv lattic agreement ok log 7 discuss work present adapt waitfre algorithm whose step complex depend number activ process lattic agreement 1renam readwrit asynchron sharedmemori model step complex algorithm ok log k clearli complex algorithmsth number step number size regist usedcan improv exampl algorithm ok renam ok step complex would immedi yield lattic agreement algorithm step complex also would interest see idea effici algorithm improv complex algorithm adapt current content 2 6 acknowledg thank yehuda afek eli gafni help discuss yossi levanoni comment earlier version paper review mani suggest improv organ present r atom snapshot share memori result fast mutual exclus use localspin kexclus algorithm improv waitfre object implement renam asynchron environ adapt effici mutual exclus adapt waitfre algorithm lattic agreement renam atom snapshot use lattic agreement atom snapshot log n oper partial equival sharedmemori messagepass asynchron failstop distribut environ ambigu choos adapt solut mutual exclus problem exponenti exampl two renam algorithm topolog structur asynchron comput new solut dijkstra concurr program problem fast longliv renam improv simplifi tr ctr michel raynal waitfre comput introductori lectur futur gener comput system v21 n5 p655663 may 2005 hagit attiya faith ellen fich yaniv kaplan lower bound adapt collect relat object proceed twentythird annual acm symposium principl distribut comput juli 2528 2004 st john newfoundland canada wojciech golab danni hendler philipp woelfel o1 rmr leader elect algorithm proceed twentyfifth annual acm symposium principl distribut comput juli 2326 2006 denver colorado usa hagit attiya ari fouren eli gafni adapt collect algorithm applic distribut comput v15 n2 p8796 april 2002 hagit attiya ari fouren algorithm adapt point content journal acm jacm v50 n4 p444468 juli