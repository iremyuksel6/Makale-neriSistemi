cooper strategi solv bicriteria spars multipl knapsack problem hard optim problem difficult design heurist algorithm exhibit uniformli superior perform problem instanc result becom necessari tailor algorithm base problem instanc paper introduc use cooper problem solv team heurist evolv algorithm given problem instanc efficaci method examin solv six difficult instanc bicriteria spars multipl knapsack problem result indic tailor algorithm uniformli improv solut compar use predesign heurist algorithm b introduct one major goal product facil util inventori best possibl way satisfi demand maketoord product system process industri surplu inventori accumul due cancel order reject product unit fail satisfi qualiti requir clearli advantag product facil util surplu inventori plan product acitivit rais problem assign list order product unit inventori object maxim total amount order assign minim total wast product unit manufactur consider compat order product unit term qualiti size etc impos addit assign constraint product oper involv complex process larger product varieti problem becom constrain bicriteria spars multipl knapsack problem consid studi motiv applic paper focu use team heurist algorithm cooper gener nondomin solut problem short comput time although exist sever heurist approach solv multipl knapsack problem exist singl domin algorithm moreov perform heurist vari problem instanc result specif heurist often demonstr poor aggreg perform set problem instanc howev heurist allow cooper ffl solut gener one heurist subsequ improv anoth ffl appropri subset heurist use construct solut given problem instanc aggreg perform collect cooper heurist set problem instanc may greatli improv purpos develop collect fast heurist incorpor ateam architectur provid comput framework implement cooper strategi among heurist present result experiment analysi compar effect heurist work individu cooper within ateam framework addit calibr purpos compar result feasibl solut deriv use integ program formul sinc import consider real applic comput time requir gener solu tion also compar perform cooper problem solv strategi tradit integ program techniqu paper organ follow first formal problem section 2 section 3 provid overview relat work literatur two version problem singl object present collect heurist discuss cooper problem solv strategi use section 4 section 5 summari result experiment analysi final conclud section 6 problem definit given set item ng set knapsack item j 2 n weight w j knapsack capac c associ w j c posit real number addit item j 2 n set j knapsack hold item j specifi conveni also specifi knapsack set b n item assign knapsack knapsack need choos subset item n assign knapsack 1 disjoint item assign one knapsack 2 subset b assign restrict satisfi total weight item assign knapsack exceed capac knapsack w j maxim total weight item assign maxim i2i denot set indic non empti due unus portion util knapsack minim refer problem bicriteria spars multipl knapsack problem bsmk without loss gener assum w remov b problem becom trivial j disjoint p case b disjoint problem decompos singl 01 knapsack problem thu exclud case consider note assign restrict also repres bipartit graph two disjoint node set graph correspond set n let e correspond bipartit graph exist edg represent sparsiti problem refer edg sparsiti bipartit graph g bicriteria problem relev sparser problem constrain problem solut maximum assign weight necessarili small wast 3 relat problem literatur singl object version bicriteria problem slightli modifi form two wellknown problem literatur consid object maxim total assign weight alon problem variat multipl knapsack problem call spars multipl knapsack problem smk object minim total wast alon problem reduc variat variables bin pack problem refer spars bin pack problem sbp classic multipl knapsack problem item go knapsack henc bipartit graph repres problem complet wherea gener problem allow bipartit graph hand multipl knapsack problem gener object function exist posit profit p j assign item j knapsack object function maxim total profit assign item applic motiv us profit assign item assum proport weight item henc maxim total assign weight multipl knapsack problem known np hard strong sens kar72 mt90 reduct 3partit problem still valid object function coeffici equal weight item instanc smk complet bipartit graph represent also np hard strong sens thu object maxim total assign weight problem strongli np hard exist fulli polynomi time approxim scheme smk unless multipl knapsack problem sever exact heurist solut method develop test literatur see martello toth mt90 survey exact solut method consist branch bound cut plane branch bound method use bound base either lagrangean relax 1 hung fisk hf78 surrog relax 2 martello toth mt80 mt81a problem cut plane method use minim cover 1dconfigur multipl cover inequ ferreira martin weismantel fmw96 unfortun exact solut method solv larg instanc aris real applic reason comput time heurist method includ fast greedi algorithm follow local exchang heurist martello toth mt81b well nonpolynomi time approach solv singl knapsack problem success martello toth mt81a obtain feasibl solut surrog relax hung fisk hf78 consid object minim wast alon produc illpos problem trivial optim solut assign item henc consid 1 relax assign constraint decompos problem singl knapsack problem get linear combin capac constraint result singl knapsack problem version impos condit item n specifi subset n must assign goal use knapsack minimum total capac problem gener variables bin pack problem allow assign restrict addit bin pack problem known np hard ie gj79 thu gener problem sbp nphard well binpack problem extens studi literatur one first problem effici approxim algorithm develop recent survey cook garey johnson cover worst averag case analys onlin offlin algorithm previou survey author cgj84 consid also variat problem exact algorithm develop martello toth mt89 variables bin pack problem studi friesen langston fl86 provid modif wellknown bin pack heurist next fit first fit best fit heurist cooper problem solv given nphard optim problem difficult design heurist algorithm exhibit uniformli superior perform problem instanc altern approach tackl difficult problem organ collect heurist algorithm cooper uniformli exhibit superior perform might possibl use separ approach especi attract collect heurist algorithm vari perform problem instanc unpredict way anoth ingredi requir cooper problem solv architectur facilit cooper heurist algorithm control strategi defin rule collabor among heurist follow paragraph discuss detail organ ie architectur control strategi use build cooper problem solv team heurist multipl knapsack problem also discuss detail collect heurist use build cooper problem solv team 41 asynchron team architectur asynchron team ateam tdsm93 architectur facilit multipl heurist work togeth common problem cooper heurist allow share popul candid solut figur 1 provid schemat architectur architectur similar blackboard system solut post onto blackboard share heurist algorithm heurist access entir popul solut choos appropri partial solut work heurist use architectur usual classifi three categori base follow ffl constructor heurist use creat initi solut ffl improv heurist take exist partial solut popul modifi produc new solut criteria use decid whether solut ad popul depend choic control strategi pure hill climb approach genet algorithm solut nondomin would ad popul variant simul anneal might allow entri domin solut popul expect might allow better solut creat later ffl destroy heurist remov redund solut popul intent manag size popul determin whether solut redund difficult usual destroy design retain redund solut nonzero probabl note destroy typic use control strategi allow inclus domin solut popul domin solut constructor destroy improv domin solut nondomin solut figur 1 schemat ateam architectur typic approach gener solut use architectur involv creat initi popul solut use constructor heurist subsequ evolv popul solut repeat applic improv destroy heurist time set nondomin solut constitut paretofronti provid set nondomin solut problem control strategi solut approach prescrib rule collabor heurist control strategi specifi two rule ffl first rule specifi improv heurist pick solut popul improv ffl second rule specifi criteria incorpor new solut creat improv heurist popul implement use stochast hill climb approach control strat egi stochast hill climb algorithm search space aim find state optim properti algorithm make success improv current state ae 2 context paper state ae correspond popul solut bicriteria multipl knapsack problem algorithm attempt improv current state ae make transit one neighbor ae within ateam implement transit made randomli pick improv heurist randomli pick solut popul improv work new solut gener improv nondomin ad popul correspond new state sinc hill climb approach allow nonimprov move explicitli need worri manag size popul result implement ateam bicriteria spars multipl knapsack problem requir destroy ateam architectur use obtain good feasibl solut variou combinatori optim problem tsp problem talukdar de souzatds93 schedul problem aris steel paper manufactur industri lee et al lmhm96 murthi et al marw97 reader refer talukdar de souza murthi tdsm93 ateam architectur 42 heurist aim gener nondomin solut bsmk develop collect constructor improv heurist heurist simpl greedi heurist adapt heurist literatur use multipl knapsack variables bin pack problem addit random heurist construct heurist mainli greedi heurist variou item knapsack select rule addit coupl heurist round lp relax solut smk constructor aim maxim total assign weight improv heurist either local exchang heurist aim improv object heurist rearrang assign item among knapsack unassign item purpos minim total wast next two subsect give descript heurist 43 constructor heurist simpl greedi heurist heurist first sort item nonincreas order weight knapsack nondecreas order capac two version first one next knapsack order say pick next item order say j pick item j allow go knapsack j ie exceed residu capac knapsack item j assign knapsack knapsack pick mani item possibl pack second version item order pick assign next feasibl knapsack possibl heurist run time log n log mnm call heurist greedyknapsack greedyitem greedi heurist variou knapsack select rule heurist decis pick next knapsack depend assign made upto point heurist sort item nonincreas order weight pick next item j pick knapsack 2 j accord one three rule three version base pick knapsack 1 minimum residu capac iti residu capac 3 minimum surplu demand call greedyminrc greedymaxrc greedyminsd respect surplu demand knapsack total weight unassign item b minu residu capac knapsack reason pick knapsack minimum surplu demand smaller surplu demand like item fit knapsack greedymaxrc greedyminsd heurist tend maxim assign without consid wast greedyminrc heurist tend minim wast addit success assign heurist anoth greedi heurist rather pick knapsack item pick item knapsack one one item match knapsack success object maxim total weight item match iter maximum weight bipartit match assign problem solv bipartit graph edg exist weight w j w j exceed residu capac knapsack initi bipartit graph g use assign given maximumweight bipartit match solut perform bipartit graph updat delet assign node edg j w j exce residu capac knapsack j node degre zero heurist repeat graph remain edg heurist call successiveassign random heurist greedi heurist modifi randomli order break pattern greedi choic suppos item j pick greedi heurist item consid assign probabl p j run item heurist repeat order assign remain item two version base choic p j first one p j proport weight item j weight itemlambdac c constant factor item larger weight like pick call heurist randomweight second version call randomdegre degre g c degj degre node j g idea defer assign item choic knapsack give prioriti item may go knapsack heurist base lp relax smk heurist solv lp relax problem singl object maxim total assign weight construct feasibl solut round fraction lp solut ip formul smk follow st p 01 variabl x ij denot whether item j assign knapsack lp relax correspond relax integr variabl although lp relax multipl knapsack problem solut construct easili time 3 lp relax solut spars problem identifi immedi howev relax still solv effici maximum flow algorithm continu problem reduc maximum flow problem direct graph construct bigraph g follow edg j g direct item node j knapsack node assign capac sourc node connect item node j via arc addit sink node connect knapsack node via arc capac c maximum flow equal lp relax valu amount flow arc j divid w j give valu x ij thu flow assign knapsack 0 1 variabl said fraction correspond solut two version heurist first one simpl greedi heurist use assign item correspond fraction variabl remain 3 amount solv lp relax singl 01 knapsack problem item second version fraction variabl sort nonincreas order valu fraction variabl order assign done feasibl remain item assign greedili first version two heurist call lpgreedi lpround 44 improv heurist local exchang heurist aim improv object repeat improv occur 1 exchang item assign differ knapsack consid pair item assign differ knapsack swap two item swap feasibl allow unassign item assign one two knapsack exchang item perform pick knapsack whose residu capac increas repetit assign item maximumweight assign feasibl heurist call exchang 2 replac assign item unassign item replac assign item pair assign item singl unassign item pair unassign item larger weight heurist call replacesingl replacepair base whether singl item pair item replac 3 rearrang rearrang assign item differ knapsack aggreg residu capac one knapsack use aggreg capac assign new item swap two item assign two differ knapsack exchang feasibl maximum residu capac knapsack increas pair item consid repeat assign new item maximum weight knapsack maximum residu capac feasibl heurist call rearrang heurist reduc wast 1 empti underutil knapsack random heurist two paramet pick randomli minimum allow util maximum allow percentag decreas assign weight cancel assign knapsack util less minimum allow util decreas weight less maximum allow percentag heurist call empti 2 empti knapsack randomli reassign item knapsack util empti knapsack probabl util knapsack reassign item greedyminrc heurist heurist call emptyandreassign 3 pack variables bin pack heurist cancel assign knap sack reassign origin assign item first fit decreas best fit decreas heurist ie greedyitem greedyminrc heurist heurist call packagainffd packagainbfd respect heurist increas assign weight constructor heurist use improv assign remain item feasibl implement use simpl greedyitem heurist purpos refer assignremain comput experi section examin perform cooper problem solv strategi compar behavior tradit integ program base techniqu problem use comput experi also compar perform cooper strategi individu heurist effort quantifi improv gain cooper final analyz nondomin solut identifi concaten heurist gener good solut 51 data use real data inventori applic problem steel mill industri kdtl97 instanc avail us number item vari 111 439 number knapsack 1843 sparsiti problem rang 10 28 size sparsiti instanc summar tabl 1 52 implement individu heurist code heurist present section 4 c languag use leda librari nu95 perform test ibm rs4000 machin oper aix first collect solut output constructor improv heurist found nondomin solut among collect solut run improv use solut provid greedyknapsack constructor tot cap tot weight d3 393 d4 209 43 106 88921 352804 d6 155 tabl 1 inform reallif data sparsiti denot edg densiti bipartit graph represent percentag number edg complet bipartit graph last two column denot total capac knapsack total weight item input random heurist run time best solut among run output ateam incorpor individu heurist ateam architectur set paramet stop time probabl pick constructor improv initi test probabl improv replacesingl replacepair empti emptyandreassign effect initi run increas examin converg solut popul run ateam code cycl 100 500 1000 1500 2000 3000 heurist observ number nondomin solut output maximum averag valu assign weight minu wast nondomin solut decid cycl length ateam run data set statist chosen cycl length given tabl 5 appendix ip base approach order assess perform heurist comput difficulti problem tri solv two ip singl object gener branchandcut method first problem consid compar result spars multipl knapsack problem smk object maxim assign weight ip formul smk given section 4 second problem consid object function sum two object maxim assign weight minu wast call problem mkbp combin multipl knapsack bin pack aspect ip formul follow st p introduc 01 variabl z denot whether item assign knapsack object function equal 2 p lp relax correspond relax integr variabl lp relax smk mkbp problem optim valu optim solut lp relax mkbp zero wast henc refer relax problem lp relax order obtain best bound possibl reason comput time ad best lower bound obtain heurist ip formul smk mkbp solv gener integ program solver cplex403 co94 use default set 1 hour cpu time ad upper bound output cplex formul ran cplex wait longer larger instanc d1 d3 repeat procedur better bound found 2 hour comparison lp relax valu upper bound gener branch bound method data set d1 d6 given tabl 2 run time given tabl 2 also give crude idea comput difficulti solv problem exact method took 24 hour get optim solut smk data set d2 could obtain optim solut problem data lp bound ub gap time hr ub gap time hr d1 64185 63970 034 92 63970 034 26 d2 61264 47214 2976 24 40383 5170 44 d3 38537 38499 010 62 38114 111 80 d4 78567 68763 1405 40 60686 2946 69 d6 44401 42420 467 82 41437 715 50 tabl 2 comparison lp relax valu best upper bound ub obtain branch bound method smk mkbp problem column gap denot deviat lp bound best avail bound time denot cpu time obtain given bound note problem get sparser get harder sens solut maxim assign weight necessarili small wast henc choic knapsack item assign becom critic problem get relax bipartit graph represent get closer complet graph problem get closer multipl knapsack problem usual maxim assign weight suffic minim wast time sparsiti problem play role also determin strength lp relax sparsiti increas gap lp relax valu optim valu get larger problem also collect feasibl solut output cplex record cpu time obtain solut run provid bound object function initi reran cplex previous obtain bound whenev stop due memori problem stop procedur improv could obtain till comput ran memori one may also consid use best lower bound output individu heurist ip formul oppos cooper strategi howev use heurist way improv upon perform branchandcut method cplex significantli even use better bound output cooper strategi yield optim solut reason comput time seen tabl 2 addit cooper strategi advantag gener mani nondomin solut two object ip formul specifi one object function 53 compar evalu cooper strategi qualiti solut qualiti solut gener use cooper strategi significantli better one gener individu run especi wast object comparison solut maximum assign weight gener ateam implement individu run provid tabl 3 wast solut also given tabl see cooper heurist use decreas wast solut maximum assign weight also note could obtain solut better assign weight exact solut method use cplex problem except d2 solut maximum valu assign weight wast gener ateam implement individu heurist cplex given tabl 4 observ signific differ assign weight wast solut gener cooper strategi versu gener individu heurist especi harder instanc d2 d4 slightli better solut could obtain cplex d2 d4 44 69 hour respect larger instanc d1 d3 feasibl solut output cplex significantli inferior data aw ratio wast wast cpu time 63660 09952 525 082 439906 d1 ii 61769 09656 2416 376 3781 iii 47098 09975 10824 1869 7001 iii 47214 10000 11004 1890 823605 38320 09954 564 145 983442 d3 ii 38233 09931 652 168 7232 iii 36610 09509 2274 585 4600914 68699 09990 11097 1391 31817 d4 ii 67339 09793 15554 1876 344 iii 68699 09990 14068 1700 3992320 59233 09899 9692 1406 18370 d5 ii 59023 09864 9902 1437 306 iii 59133 09882 9792 1421 3936016 40612 09574 3095 708 7646 d6 ii 40292 09498 3415 781 163 iii 40297 09500 3410 780 4657032 tabl 3 comparison solut maximum assign weight obtain ateam implement ii individu run heurist iii branchandcut aw assign weight ratio ratio aw best avail bound assign weight object tabl 2 wast ratio unus capac total capac util knapsack percentag cpu time given second output cooper strategi differ 10 7 best upper bound avail respect collect heurist abl gener significantli nondomin solut cooper ateam implement heurist abl effect improv object time result individu heurist good enough maxim assign weight capabl minim wast time hand use cooper organ heurist favor maxim assign weight favor minim wast chanc take output one anoth input therefor gener solut better valu object plot nondomin solut gener ateam implement individu heurist given figur 2 3 4 appendix note problem d1 d3 less spars compar problem solut larg assign weight small wast time mani nondomin solut gener attribut fact two object almost parallel problem data awwast ratio aw wast wast cpu time 63135 09869 63660 525 082 439906 d1 ii 59353 09278 61769 2416 376 3781 iii 56562 08842 60374 3811 594 4454333 39672 09835 45059 5387 1068 7001 d2 ii 32648 08094 33814 1166 333 148 iii 39886 09888 47131 7245 1332 1568126 37756 09906 38320 564 145 983441 d3 ii 37581 09860 38233 652 168 7232 iii 35436 09297 37160 1724 443 2872318 59555 09814 65799 6245 867 31817 d4 ii 56641 09333 64901 8261 1129 344 49714 09733 58033 8319 1254 18370 d5 ii 49121 09617 59023 9902 1437 306 iii 46590 09121 56462 9908 1493 2311735 37517 09054 40612 3095 708 7646 d6 ii 36870 08898 40292 3415 781 163 iii 36583 08829 x 40145 3562 815 1820367 tabl 4 comparison solut maximum assign weight wast obtain ateam implement ii individu run heurist iii branch andcut ratio obtain use best avail upper bound maxim assign weight minu wast obtain tabl 2 cpu time given second run time clearli combin heurist cooper strategi increas run time cycl 1500 3000 heurist run howev still run time reason rang significantli smaller compar branchandcut method singl run individu heurist take second depend size problem heurist use run time individu heurist given tabl 6 appendix timeconsum heurist replacesingl heurist take 45 second d3 024 second d2 constructor heurist take littl time greedi heurist run less second lpround lpgreedi heurist take slightli time 017 131 second timeconsum constructor successiveassign take 032 425 second cpu time ateam implement take time approxim 1 minut 3 hour depend size problem still run time significantli small compar branchandcut approach cplex order 3 13 hour run time given tabl 3 4 tabl run time individu heurist total time heurist best solut pick run heurist concaten heurist ateam implement examin nondomin solut pareto frontier shown figur 2 identifi heurist sequenc appli yield particular solut natur question aris whether realli necessari random sequenc heurist act other solut possibl identifi one sequenc concaten heurist yield paretofronti problem instanc might abandon stochast control strategi construct solut section show concaten heurist use gener paretofronti vari significantli problem instanc illustr need tailor solut strategi problem instanc autom stochast control strategi adopt paper nondomin solut gener ateam implement trace heurist whose output solut use obtain nondomin solut conclud heurist effect repeat nevertheless observ regular pattern sequenc agent call across differ problem instanc justifi use ateam approach concaten heurist oppos identifi effect pattern use pattern instead ateam implement total number occurr heurist particip gener nondomin solut problem instanc given tabl 7 appendix see lpround frequent use constructor local exchang heurist replacesingl replacepair wast reduct heurist empti emptyandreassign effect improv gener nondomin solut also give heurist output nondomin solut individu run tabl 8 comparison purpos statist present tabl clearli indic pattern use construct paretofronti vari significantli across problem instanc figur 58 appendix illustr construct nondomin solut gener ateam implement 6 conclus paper introduc bicriteria spars multipl knapsack problem character comput complex problem experiment comput gap lp relax best deriv bound show increas sparsiti make problem difficult integ program techniqu unabl gener solut reason amount time new cooper problem solv techniqu introduc use collect fast heurist algorithm embed cooper problem solv architectur call ateam solut gener use approach shown superior deriv use heurist individu feasibl solut deriv integ program techniqu cooper problem solv strategi shown altern approach autom design heurist hard combinatori problem r approxim algorithm binpack updat survey approxim algorithm binpack survey variabl size bin pack solv multipl knapsack problem cut plane comput intractibilitya guid theori np algorithm 01 multipl knapsack problem reduc among combinatori problem surplu inventori match problem process industri primari product schedul steelmak industri solut zeroon multipl knapsack prob lem bound bound algorithm zeroon multipl knapsack problem heurist algorithm multipl knapsack problem knapsack problem lower bound reduct procedur bin pack problem leda user manual version r 32 asynchron organ multi algorithm problem organ computerbas agent tr ctr jayant r kalagnanam andrew j davenport ho lee comput aspect clear continu call doubl auction assign constraint indivis demand electron commerc research v1 n3 p221238 juli 2001