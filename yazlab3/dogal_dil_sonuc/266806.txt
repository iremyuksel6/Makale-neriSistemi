runtim spatial local detect optim dispar processor main memori perform grow number execut cycl spent wait memori access complet also increas result latenc hide techniqu critic improv applic perform futur processor present microarchitectur scheme detect adapt vari spatial local dynam adjust amount data fetch cach miss spatial local detect tabl introduc paper facilit detect spatial local across adjac cach block result detail simul sever integ program show signific speedup improv due reduct conflict capac miss util small block small fetch size spatial local absent prefetch effect larg fetch size spatial local exist b introduct paper introduc approach solv grow memori latenc problem 2 intellig exploit spatial local spatial local refer tendenc neighbor memori locat referenc close togeth time tradit two main approach use exploit spatial local first approach use larger cach block natur prefetch effect howev larg cach block result wast bu bandwidth poor cach util due fragment underutil cach block neg effect occur data littl spatial local cach second common approach prefech multipl block cach howev prefetch benefici prefetch data access cach otherwis prefetch data may displac use data cach addit wast bu bandwidth similar issu exist alloc cach effect prefetch data cach block contain written address particu technic report longer version 1 larli use larg block size write alloc amount prefetch fix howev spatial local henc optim prefetch amount vari across often within program avail chip area increas meaning spend resourc allow intellig control latencyhid techniqu adapt variat spatial local numer program sever known compil techniqu optim data cach perform contrast integ nonnumer program often irregular access pattern compil detect optim exampl tempor spatial local link list element hash tabl data often difficult determin compil time paper focus cach perform optim integ program focu attent data cach techniqu present applic instruct cach order increas data cach effect integ program investig method adapt cach hierarchi manag intellig control cach decis base usag characterist access data paper examin problem detect spatial local access data automat control fetch multipl smaller cach block data cach buffer abl reduc conflict capac miss smaller cach line fetch size spatial local absent also reduc cold start miss prefetch use data larger fetch size spatial local present introduc new hardwar mechan call spatial local detect tabl sldt sldt entri track access multipl adjac cach block facilit detect spatial local across block cach result inform later record memori address tabl 3 longterm track larger region call macroblock show extens cach microarchitectur significantli improv perform integ applic achiev 17 26 improv 100 200cycl memori latenc respect scheme fulli compat exist instruct set architectur isa remaind paper organ follow section relat work section 3 discuss gener spatial local issu code exampl common applic use illustr role spatial local cach line size determin applic cach perfor manc well motiv spatial local optim techniqu section 4 discuss hardwar techniqu section 5 present simul result section 6 perform cost analysi ad hardwar section 7 conclud futur direct relat work sever studi examin perform effect cach block size 45 one studi allow multipl consecut block fetch one request 4 found data cach optim staticallydetermin fetch size gener twice block size work also examin fetch size larger block size howev allow fetch size vari base detect spatial local anoth method allow number block fetch miss vari across program execut across differ data 6 hardwar 7891011 softwar 121314 prefetch method uniprocessor machin propos howev mani method focu prefetch regular array access within wellstructur loop access pattern primarili found numer code method gear toward integ code 1516 focu compilerinsert prefetch pointer target could use conjunct techniqu dual data cach 17 attempt intellig exploit spatial tempor local howev tempor spatial data must place separ structur therefor rel amount type data must determin priori also spatial local detect method tune numer code constant stride vector integ code spatial local pattern may regular split temporalspati cach 18 similar structur dual data cach howev runtim local detect mechan quit differ dual data cach paper 3 spatial local cach seek exploit principl local store referenc item cach exploit tempor local tendenc item rereferenc soon addit store multipl item adjac referenc item exploit spatial local tendenc neighbor item referenc soon exploit tempor local result cach hit futur access particular item exploit spatial local result cach hit futur access multipl nearbi item thu avoid long memori latenc shortterm access item well tradit exploit spatial local achiev either larger block size prefetch addit block defin follow term use throughout paper element data item maximum size allow isa system 8 byte spatial reus refer cach element element caus referenc element fetch cach spatial local applic data set predict effect spatial local optim unfortu nate quantit measur spatial local exist forc adopt indirect measur one indirect measur amount spatial local via invers rela tioship distanc refer space time view measur spatial reus 64kbyte fullyassoci cach 32byte line give us approxim time bound time taken block displac space bound within 32byte block boundari chose block size past studi found 16 32byte block size maxim data cach perform 4 measur techniqu differ 19 explicit measur reus distanc time goal measur reus unus portion cach block differ cach organ figur 1a show spatial local estim fullyassoci cach number dynam cach block broken number 8byte element access block cach lifetim block one element access spatial local within measur context graph show rel locat access element within 32byte cach block figur 1a show 1383 cach block spatial reus figur 1b show distribut chang 16kbyte directmap cach case 3093 block spatial reus 32byte cach block half time extra data fetch cach simpli wast bu bandwidth cach space similar observ made numer code 19 therefor would benefici tune amount data fetch cach miss spatial local avail data optim investig work discuss sever issu involv vari fetch size includ cost effici accur spatial local detect fetch size choic cach support vari fetch size 31 code exampl section use code exampl spec92 gcc illustr difficulti involv static analysi annot spatial local inform motiv dynam approach one main data structur use gcc rtl ex pression rtx whose definit shown figur 2 rtx structur contain twobyt code field onebyt mode field seven onebit flag array operand field operand array defin contain one fourbyt ele ment howev rtx dynam alloc contain mani array element operand depend rtx code rtl express type therefor rtx instanc contain eight byte frequent execut rtx renumb equal tine use jump optim two rtx 026compress 072sc 099go 147vortex pcode lmdes2custom 085cc1 130li 134perl 124m88ksim benchmark total block block access four element block access three element block access two element block access one element 64kbyte fullyassoci 0 20 40 80 100 026compress 072sc 099go 147vortex pcode lmdes2custom 085cc1 130li 134perl 124m88ksim benchmark total block block access four element block access three element block access two element block access one element b 16kbyte directmap figur 1 breakdown block cach l1 data cach mani 8byte element access block cach result two cach configur shown 32byte block struct rtxdef kind express enum kind valu express enum machinemod mode 8 variou bit flag unsign int unsign int call unsign int unchang unsign int volatil unsign int instruct unsign int use unsign integr first element operand rtx number operand type control code field accord rtldef rtunion fld1 common union element rtx int rtint char struct struct enum machinemod rttype figur 2 gcc rtx definit structur compar determin equival figur 3 show slightli abbrevi version renumb equal routin check code mode field two rtx structur ident routin compar operand determin also ident four branch target figur 3 annot execut weight deriv execut profil use spec refer input roughli 1 time code field two rtx structur compar exit case first two byte rtx structur access 46 time x const int rtx first operand access therefor first eight byte rtx structur access spatial local within eight byte mani type rtl express routin use loop iter operand last first compar mismatch found case spatial local slightli larger distanc space previou case instruct type contain one operand common operand type loop rtl express result recurs call rtx renumb equal p routin illustr amount spatial local vari particular load refer depend function argument therefor origin access rtx structur routin miss optim amount data fetch cach vari correspond ingli exampl access getcodey line 10 figur 3 perform access ycode miss l1 cach spatial local data depend whether program later fall case bodi switch statement line 11 bodi loop line 24 rtx type x determin initi valu loop howev time cach miss line 10 inform avail highli datadepend neither static analysi even possibl profil result definit accur spatial local inform load instruct dynam analysi spatial local data offer greater promis routin dynam analysi instanc access routin would obtain accur spatial local detect also dynam scheme requir profil mani user unwil perform isa chang case labelref return nextrealinsn xfld0rtx nextrealinsn yfld0rtx case symbolref 19 return xfld0rtstr yfld0rtstr 22 compar element pair correspond element fail match return 0 whole thing regist int j 26 switch fmti case 28 xfldirtint yfldirtint return 0 29 break case return 0 36 break 37 case e 38 access xyfldirtvec return 43 3 regist int 4 regist rtxcode 5 regist char fmt 9 rare enter case e switch code case pc case cc0 case addrvec case addrdiffvec return 0 34 rtxrenumberedequalp xfldirtx yfldirtx 14 case constint return xfld0rtint yfld0rtint exit 448 time exit time case match time exit 30014 time figur 3 gcc rtx renumb equal routin execut 63173 time 32 applic asid vari data cach load fetch size spatial local optim could use control instruct cach fetch size write alloc versu noalloc poli cie bypass fetch size bypass employ latter case discuss briefli 3 greatli expand paper paper examin applic techniqu control fetch size l1 l2 data cach also studi optim conjunct cach bypass complementari optim also aim improv cach perform 41 overview prior work section briefli overview concept mac roblock well memori address tabl mat introduc earlier paper 3 util work show cach bypass decis could effect made runtim base previou usag memori address access bypass scheme includ 20211722 particular scheme dynam kept track access frequenc memori region call macroblock macroblock static defin block memori uniform size larger cach block size macroblock size larg enough total number access macroblock excess larg small enough access pattern cach block contain within macroblock rel uniform determin 1kbyte macroblock provid good costperform tradeoff order keep track macroblock run time use mat ideal contain entri macroblock access macroblock address support dynam bypass decis entri tabl contain satur counter counter valu repres frequenc access correspond mac roblock detail mat bypass scheme see 3 also introduc paper optim gear toward improv effici l1 bypass track spatial local bypass data use mat use inform determin much data fetch l1 bypass paper introduc robust spatial local detect optim scheme use sldt enabl much effici detect spatial local new scheme also support fetch vari amount data level data cach without bypass practic spatial local optim perform combin pass order achiev best possibl perform well amort cost mat hardwar cost combin hardwar address section 6 set 31 set 00 set 01 set set tag data 8 byte 0x000000 0x000000 tag data 8 byte 0x000000 0x000000 figur 4 layout 8byte subblock 32byte block start address 0x00000000 512byte 2way setassoci cach 8byte line shade block correspond locat four 8byte subblock follow present experiment result 42 support vari fetch size vari fetch size optim could support use subblock case block size largest fetch size subblock size gcdfetch n number fetch size support current support two poweroftwo fetch size level cach subblock size simpli smaller fetch size howev cach line underutil smaller size fetch instead use cach small line equal smaller fetch size option fill multipl consecut block larger fetch size chosen approach similar use prefetch strategi 23 result cach fulli util even smaller size fetch also elimin conflict miss result access differ subblock howev approach make detect spatial reus much difficult describ section 43 also smaller block size increas tag array cost address section 6 scheme max fetch size data alway align boundari result techniqu fetch data either side access element depend locat element within max fetch size block experi spatial local data cach either direct spatial referenc element 43 spatial local detect tabl facilit spatial local track spatial counter sctr includ mat entri role sctr track medium longterm spatial local correspond macroblock make fetch size decis explain section 44 counter increment whenev spatial miss detect occur portion larger fetch size block data resid cach element current ac cess therefor hit might occur larger fetch size fetch rather smaller fetch size implement multipl cach block fill larger fetch size chosen spatial miss trivial detect cach fullyassoci tag differ block resid larger fetch size block lie consecut set shown figur 4 data one 32byte block highlight search cach block larger fetch size block data requir access tag consecut set thu either addit cycl access addit hardwar support one possibl restructur tag array design allow effici access multipl consecut set tag altern separ structur use detect inform approach investig work structur call spatial local detect tabl sldt design effici detect spatial reus low hardwar overhead role sldt detect spatial local data cach record mat data displac sldt basic tag array block larger fetch size allow singlecycl access necessari inform figur 5 show overview sldt interact mat l1 data cach doublearrow line show correspond four l1 data cach entri singl sldt entri order track cach block sldt would need n entri n number block cach repres worst case fetch smaller line size block cach differ larger size block howev order reduc hardwar overhead sldt use much smaller number entri allow us captur shorterterm spatial reus sldt could use track spatial local aspect structur level memori hierarchi data cach instruct cach perform bypass bypass buffer sldt tag correspond maximum fetch size block sz field one bit indic either larger size block fetch cach smaller block fetch vc valid count field logmax fetch sizemin fetch size bit length indic mani smaller block larger size block current valid data cach actual number valid smaller block vc1 sldt entri valid larger size block constitu block current valid data cach bit mask could use implement vc rather counter design reduc oper complex howev larg maximum minimum fetch size ratio bit mask result larger entri final sr spatial reus bit set spatial reus detect discuss later larger size block data fetch cach sldt entri alloc possibl caus replac exist entri valu sz vc set 1 max fetch sizemin fetch size gamma 1 respect smaller size block fetch sldt entri current exist correspond larger size block entri alloc sz vc initi 0 entri alreadi exist vc increment indic addit valid constitu block data cach fetch size sr bit initi 0 cach block replac data cach correspond sldt entri access vc valu decrement greater 0 vc alreadi 0 valid block sldt entri invalid spatial reus hit mat sctr fetch updat sctr hit spatial reus result l1 data cach addr tag sz vc sr figur 5 sldt mat hardwar sldt entri invalid sr bit check see spatial reus data cach correspond entri mat access sctr decrement effect deposit inform mat longerterm track sldt manag cach entri replac case action taken fi fetch initi bit ad data cach tag help detect spatial hit fi bit set 1 cach refil cach block contain referenc element ie cach block caus fetch otherwis reset 0 therefor hit block 0 fi bit spatial hit data fetch cach miss element tabl 1 summar action taken sldt memori access sr bit initi zero set type spatial miss spatial hit two type spatial miss detect first type spatial miss occur portion larger fetch size block fetch independ indic valid sldt entri sz 0 therefor might cach hit larger size block fetch correspond entri mat access sctr increment second type occur larger size block fetch one constitu block displac cach indic cach miss valid sldt entri sz 1 trivial detect miss element caus origin fetch element larger fetch size block sr bit conserv set sctr correspond mat entri increment spatial hit occur two situat larger size block fetch fi bit set one load cach block hit load cach block without fi bit set spatial hit describ earlier increment sctr spatial hit fetch size correct updat sctr fetch size chang futur multipl smaller block fetch hit one also character spatial hit case detect check vc larger 0 sz 0 howev increment sctr case either spatial miss would detect earlier second element larger fetch size block first access miss cach sldt access access fi sz vc action miss hit 0 cach entri vc 0 replac vc 0 invalid sldt entri sldt entri replac sr 0 invalid sr 1 action tabl 1 sldt action dash indic correspond valu blank indic valu matter 44 fetch size decis memori access lookup mat correspond macroblock entri perform parallel data cach access entri found sctr valu compar threshold valu larger size fetch sctr larger threshold otherwis smaller size fetch entri found new entri alloc sctr valu initi threshold valu larger fetch size chosen paper threshold 50 maximum sctr valu 5 experiment evalu 51 experiment environ simul ten benchmark includ 026compress 072sc 085cc1 spec92 benchmark suit use refer input 099go 147vortex 130li 134perl 124m88ksim spec95 benchmark suit use train input last two benchmark consist modul impact compil 24 felt repres mani realworld integ applica tion pcode front end impact run perform depend analysi intern represent combinec file gnu cc input lmdes2 custom machin descript optim run optim supersparc machin descript optim oper link list complex data structur util hash tabl effici access inform order provid realist evalu techniqu futur highperform highissu rate system first optim code use impact compil 24 classic optim appli optim perform increas instruct level parallel code schedul regist alloc optim eightissu scoreboard superscalar processor regist renam isa extens hp parisc instruct set support compiletim specul perform cyclebycycl emulationdriven simul hewlettpackard parisc 7100 workstat model processor memori hierarchi includ relat buss instruct latenc use hewlettpackard parisc 7100 given tabl 2 base machin configur describ tabl 3 sinc simul entir applic level detail would impract uniform sampl use reduc simul time 25 howev emul still perform function latenc function latenc memori load 2 fp multipli 2 memori store 1 fp divid singl prec 8 branch tabl 2 instruct latenc simul experi l1 icach 32kbyte splitblock direct map 64byte block l1 dcach 16kbyte nonblock 50 max direct map 32byte block multiport writeback write alloc l1l2 bu 8byte bandwidth splittransact 4cycl latenc return critic word first l2 dcach l1 dcach except 256kbyte 64byte block system bu l1l2 bu except 100cycl latenc issu 8issu uniform except 4 memori opscycl max regist 64 integ 64 doubl precis floatingpoint tabl 3 base configur sampl simul sampl 200000 instruct length space evenli everi 20000000 instruct yield 1 sampl ratio smaller ap plicat time sampl reduc maintain least 50 sampl 10000000 instruct evalu accuraci techniqu simul sever configur without sampl found improv report paper close obtain simul entir applic 52 macroblock spatial local variat present perform improv achiev optim first examin accuraci macroblock granular track spatial local import accur spatial local inform mat scheme success mean data element macroblock similar amount spatial local phase program execut divid main memori macroblock describ section 41 macroblock subdivid smaller section size 32byte cach block simpli call smaller section block order determin dynam cach block spatial local behavior examin access block gather inform twice per simul sampl everi 100000 instruct end 100000instruct phase determin fraction time block memori least one spatial reus time cach phase call spatial reus fraction block figur 6 show graphic represent result inform three program row graph repres 1kbyte macroblock access particular phase everi phase particular macroblock access correspond row row contain one data point everi 32byte block access correspond phase lie macroblock purpos clariti row sort averag block spatial reus fraction per macroblock averag increas bottom top graph cach block macroblock also sort spatial reus fraction increas left right row full mean block access correspond phase final cach block spatial reus fraction fall within rang plot marker figur 6a show spatial local distribut 026compress block correspond lighter gray point spatial reus fraction 0 025 mean spatial reus block less 25 time cach block correspond black point spatial reus 75 time cach repres fairli optim scenario macroblock contain block approxim amount reus figur 6b show distribut 134perl around 34 macroblock id 0 6500 contain block littl spatial reus spatial reus fraction less 025 29 macroblock id 13500 18900 contain block larg fraction spatial reus spatial reus fraction 075 37 macroblock contain cach block differ amount spatial reus medium gray point row correspond block spatial reus fraction 025 075 howev inform reveal time interv spatial reus block vari possibl certain small phase program execut spatial local behavior uniform chang drastic one small phase execut anoth type behavior possibl due dynamicallyalloc data particular section memori may alloc one type data one part program freed realloc anoth type later final figur 6c show distribut 085gcc similar characterist 134perl macroblock nonuniform spatial reus fraction 53 perform improv section examin perform improv execut cycl elimin base 8issu configur describ section 51 support vari fetch size use sldt mat level cach hierarchi l1 l2 sldt directmap entri larg number simul show directmap sldt perform well fullyassoci design 32 entri perform almost well larger poweroftwo number entri 1024 entri maximum size examin l1 l2 mat util 1kbyte macroblock examin one fourbit sctr first present result infinit entri mat studi effect limit number mat entri 531 static versu vari fetch size left bar benchmark figur 7a show perform improv achiev use 8byte l1 data cach block static 8byte fetch size base 32 byte block fetch size bar show better choic block size highli applicationdepend right bar show improv achiev spatial local optim l1 level use 8byte data cach block size fetch either 8 32byte l1 data cach miss depend valu 026compress b 134perl b 085gcc figur reus fraction srf cacheblocksizeddata access macroblock three applic correspond sctr result show scheme abl obtain either almost perform abl outperform best static fetch size scheme case 1 4bit sctr perform similarli one case 4bit sctr achiev almost 2 greater perform improv four leftmost bar benchmark figur 7b show perform improv use differ l2 data cach block static fetch size l1 spatial local optim 4bit sctr base configur configur describ section 51 64byte l2 data cach block fetch size bar show better static blockfetch size highli applicationdepend exampl 134perl achiev much better perform 256byte fetch size 026compress achiev best perform 32 byte fetch size obtain 14 perform degrad 256byte fetch rightmost two bar figur 7b show perform improv achiev l2 spatial local optim use 32byte l2 data cach block size fetch either 32 256 byte l2 data cach miss depend valu correspond l2 mat sctr spatial local optim abl obtain almost better perform best static fetch size scheme benchmark figur 8 show breakdown processor stall cycl attribut differ type data cach miss percentag total base configur execut cycl left right bar benchmark stall cycl breakdown base configur spatial local optim respect spatial local optim perform cach level use configur figur 7b 4bit sctr benchmark larg amount spatial local indic result figur 7 obtain larg reduct l2 cold start stall cycl fetch 256 byte l2 cach miss benchmark littl spatial local l1 data cach 026compress pcode obtain reduct l1 capac miss stall cycl fetch fewer small cach block l1 miss case l1 cold start stall cycl increas indic l1 optim less aggress term fetch data howev increas gener compens reduct type l1 stall cycl conflict miss stall cycl increas lmdes2 custom tend fetch fewer block l1 miss expos conflict interpret capac miss base configur revisit exampl section 31 found access ycode line 10 figur 3 miss 11223 time fetch byte 47 miss 8 byte remain 53 also found averag 099 spatial hit 002 spatial miss result data occur per miss illustr techniqu success choos appropri amount data fetch miss 532 setassoci data cach increas setassoci data cach reduc number conflict miss may turn reduc advantag offer optim howev 800 1000 026compress 072sc 099go 147vortex pcode lmdes2custom 085cc1 130li 134perl 124m88ksim benchmark improv base l1 static 8byte blockfetch size vari fetch 1bit sctr vari fetch 4bit sctr l1 trend 1500 1000 500 500 1000 1500 2000 026compress 072sc 099go 147vortex pcode lmdes2custom 085cc1 130li 134perl 124m88ksim benchmark improv base l2 static 32byte blockfetch size l2 static 64byte blockfetch size l2 static 128byte blockfetch size l2 static 256byte blockfetch size vari fetch 1bit sctr vari fetch 4bit sctr b l2 trend l1 vari fetch figur 7 perform variou staticallydetermin blockfetch size spatial local optim use 1 4bit sctr 1000 2000 3000 4000 5000 7000 8000 9000 026compress base opti base opti base opti 147vortex base opti pcode base opti lmdes2custom base opti base opti base opti 134perl base opti base opti benchmark total base execut cycl cold start stall cycl l2 capac miss stall cycl conflict miss stall cycl cold start stall cycl l1 capac miss stall cycl conflict miss stall cycl figur 8 stall cycl breakdown base spatial local optim reduct capac cold start stall cycl optim achiev remain investig effect data cach configur discuss section 51 modifi 2way setassoci l1 data cach 4way setassoci l2 data cach figur 9 show new perform improv optim left bar show result appli optim l1 data cach right bar show result appli techniqu l1 l2 data cach use fourbit sctr improv reduc significantli benchmark shown figur 7 howev larg improv still achiev benchmark particularli appli optim l2 data cach level due reduct achiev l2 cold start stall cycl data spatial local 200 200 400 600 800 1000 1200 1400 1600 2000 026compress 072sc 099go 147vortex pcode lmdes2custom izer benchmark improv base vari fetch 4bit sctr vari fetch 4bit sctr figur 9 perform spatial local optim 2way 4way setassoci l1 l2 data cach respect 533 grow memori latenc effect discuss section 1 memori latenc increas trend expect continu figur 10 show improv achiev optim appli directmap cach 100 200cycl la tenci rel base configur memori latenc benchmark see much larger improv optim except 026compress 026compress littl spatial local exploit longer latenc hidden effect although raw number cycl elimin grow percentag associ base execut cycl count becom smaller 534 comparison integr techniqu doubl data cach memori latenc increas intellig cach manag techniqu becom increasingli import examin perform improv achiev integrat 026compress 072sc 099go 147vortex pcode lmdes2custom izer benchmark improv base 100cycl latenc 200cycl latenc figur 10 perform spatial local optim grow memori latenc 500 1000 1500 2000 3000 026compress 072sc 099go 147vortex pcode lmdes2custom izer benchmark improv base doubl 32k512k l1l2 vari fetch 4bit sctr bypass infinit mat vari fetch 4bit sctr bypass 1kentri mat vari fetch 4bit sctr bypass 512entri mat figur 11 comparison doubl cach integr spatial local bypass optim infinit 1024 entri 512entri directmap mat examin ing spatial local optim intellig bypass ing use 8bit access counter mat entri 3 4way setassoci buffer use hold bypass data l1 l2 cach contain 128 8byte entri 512 32byte entri respect sldt mat cach level use detect spatial local control fetch size data cach bypass buffer level figur 11 show improv achiev combin techniqu cach level 100cycl memori latenc show result three directmap mat size infinit 1kentri 512entri also shown perform improv achiev doubl l1 l2 data cach doubl cach bruteforc techniqu use improv cach perform figur 11 show perform integr optim cach level outperform simpli doubl level cach case doubl cach perform significantli better optim 026compress improv mostli come doubl l2 data cach result hash tabl fit data block tag tag cach cost size size cost level byte byte set bit byte tabl 4 hardwar cost doubl data cach 512kbyte cach pcode benchmark perform degrad significantli reduc mat size howev 1kentri mat still outperform doubl cach compar figur 11 bypass improv 3 show often signific improv achiev intellig control fetch size data cach bypass buffer 6 design consider section examin hardwar cost spatial local optim scheme describ section 4 compar cost doubl data cach level discuss section 41 cost mat hardwar amort perform spatial local bypass optim reason comput hardwar cost hardwar support opti mizat combin perform compar perform doubl cach section 534 addit hardwar cost incur spatial local optim scheme small compar doubl cach size level particularli l2 cach 16kbyte directmap l1 cach use gener result section 53 bit tag use per entri assum 32bit address doubl cach result 17bit tag line size 32 byte total addit cost increas tag array 17lambda2 1k byte 1 addit extra 16k data need similar comput show cost doubl 256kbyte l2 cach extra 6144 byte tag 256k byte data total tag data cost doubl l1 l2 cach shown tabl 4 directmap mat 8bit access counter 4bit spatial counter tabl 12 give hardwar cost data tag mat size discuss section 534 sinc address within macroblock map mat counter number lower address bit discard access mat size result mat address 1kbyte macroblock shown column 3 tabl 12a tabl 12b show data tag array cost directmap data cach spatial local optim scheme data cost remain base configur cost tag array cost increas due decreas line size addit support scheme requir 1bit fetch initi bit per tag entri cost l1 buffer 4way setassoci cach 8byte line shown tabl 12c optim data cach bypass buffer requir 1bit fetch initi bit addit address tag cost l2 bypass buffer comput similarli tabl 12c 1 ignor valid bit state mat data cost size mat tag size tag cost entri byte address bit bit byte hardwar cost 512 1k entri mat cost l1 l2 cach level data fetch block tag tag cach cost size size size cost level byte byte byte set bit byte b hardwar cost optim data cach block data tag tag cach fetch size cost size cost level entri size byte byte byte bit byte c hardwar cost bypass buffer cach sldt tag size tag cost level entri bit byte hardwar cost sldt figur 12 hardwar cost breakdown spatial local optim final compon spatial local optim scheme 32entri sldt organ directmap tag array vc 1bit sz 1bit sr field includ tag entri l1 sldt requir 2 bit vc 4 8byte line per 32byte maximum fetch l2 sldt requir 3bit vc due 8 32 byte line per 256byte maximum fetch bit mask could use implement vc rather counter design reduc oper complex howev larg maximum minimum fetch size ratio 8to1 ratio l2 cach bit mask result larger entri tabl 12d show total tag array cost l1 l2 sldt final combin cost mat optim data cach bypass buffer sldt result total l1 cost 24376 byte 512entri mat 25848 byte 1kentri mat therefor save doubl l1 data cach 10k 8k byte 512 1kentri mat respect similar calcul show l2 optim save 247k byte 245k byte 512 1kentri mat spectiv doubl l2 data cach translat 26 44 less tag data doubl data cach l1 l2 level respect larger 1kentri mat compar perform spatial local bypass optim perform obtain doubl data cach level shown figur 11 illustr much smaller hardwar cost optim usual outperform simpli doubl cach reduc hardwar cost could potenti integr l1 mat tlb page tabl macroblock size larger equal page size tlb entri need hold one 8bit counter valu macroblock size less page size tlb entri need hold sever counter one macroblock within correspond page case small amount addit hardwar necessari select counter valu howev studi need determin full effect tlb integr 7 conclus paper examin spatial local characterist integ applic show spatial local vari program also vari vastli data access applic result vari spatial local within across applica tion spatial local optim must abl detect adapt vari amount spatial local within across applic order effect present scheme meet object detect amount spatial local differ portion memori make dynam decis appropri number block fetch memori access spatial local detect tabl sldt introduc paper facilit spatial local detect data cach inform later record memori address tabl mat longterm track use tune fetch size miss access detail simul sever applic show signific speedup achiev techniqu improv due reduct conflict capac miss util small block small fetch size spatial local absent util prefetch effect larg fetch size spatial local exist ad dition show speedup achiev scheme increas memori latenc increas memori latenc increas import cach perform improv level memori hierarchi continu grow also avail chip area grow make sens spend resourc allow intellig control cach manag order adapt cach decis dynam access behav ior believ scheme extend gener framework intellig runtim manag cach hierarchi acknowledg author would like thank mark hill santosh abraham wenhann wang well member impact research group comment suggest help improv qualiti research research support nation scienc foundat nsf grant ccr9629948 intel corpo ration advanc micro devic hewlettpackard sun mi crosystem ncr nation aeronaut space administr nasa contract nasa nag 1613 cooper illinoi comput laboratori aerospac system softwar iclass r runtim spatial local detect optim predict preclud problem memori latenc runtim adapt cach hierarchi manag via refer analysi perform impact block size fetch strategi line block size choic cpu cach memo rie fix adapt sequenti prefetch share memori multipro cessor cach memori improv directmap cach perform addit small fullyassoci cach prefetch buffer effect onchip preload scheme reduc data access penalti quantifi perform potenti data prefetch mechan pointerintens numer program stride direct prefetch scalar processor softwar method improv cach perform supercomput applic design evalu compil algorithm prefetch data access microarchitectur superscalar processor compilerassist data prefetch compilerbas prefetch recurs data structur spaid softwar prefetch pointer call intens environ data cach multipl cach strategi tune differ type local iti split temporalspati cach initi perform analysi quantit analysi loop nest local effici simul cach optim replac applic miss character modifi approach data cach manag reduc conflict directmap cach temporalitybas design data prefetch multiprocessor vector cach memori impact architectur framework multipleinstructionissu processor simul 100 billion refer cheapli tr line block size choic cpu cach memori data prefetch multiprocessor vector cach memori impact data access microarchitectur superscalar processor compilerassist data prefetch effect onchip preload scheme reduc data access penalti design evalu compil algorithm prefetch direct prefetch scalar processor data cach multipl cach strategi tune differ type local modifi approach data cach manag compilerbas prefetch recurs data structur runtim adapt cach hierarchi manag via refer analysi cach memori predict preclud problem memori latenc softwar method improv cach perform supercomput applic ctr guest editor introductioncach memori relat problem enhanc exploit local ieee transact comput v48 n2 p9799 februari 1999 afrin naz mehran rezaei krishna kavi philip sweani improv data cach perform integr use split cach victim cach stream buffer acm sigarch comput architectur news v33 n3 june 2005 jike cui mansur h samadzadeh new hybrid approach exploit local lrfu adapt prefetch acm sigmetr perform evalu review v31 n3 p3743 decemb sanjeev kumar christoph wilkerson exploit spatial local data cach use spatial footprint acm sigarch comput architectur news v26 n3 p357368 june 1998 jie tao wolfgang karl detail cach simul detect bottleneck miss reason optim potenti proceed 1st intern confer perform evalu methodolgi tool octob 1113 2006 pisa itali srikanth srinivasan roy dzching ju alvin r lebeck chri wilkerson local vs critic acm sigarch comput architectur news v29 n2 p132143 may 2001 gokhan memik mahmut kandemir alok choudhari ismail kadayif integr approach improv cach behavior proceed confer design autom test europ p10796 march 0307 mccorkl programm busmemori control modern comput architectur proceed 43rd annual southeast region confer march 1820 2005 kennesaw georgia neungsoo park bo hong viktor k prasanna tile block data layout memori hierarchi perform ieee transact parallel distribut system v14 n7 p640654 juli jaeheon jeong per stenstrm michel duboi simpl penaltysensit replac polici cach proceed 3rd confer comput frontier may 0305 2006 ischia itali hur calvin lin memori prefetch use adapt stream detect proceed 39th annual ieeeacm intern symposium microarchitectur p397408 decemb 0913 2006 prateek pujara aneesh aggarw increas cach capac word filter proceed 21st annual intern confer supercomput june 1721 2007 seattl washington hantak kwak ben lee ali r hurson sukhan yoon woojong hahn effect multithread cach perform ieee transact comput v48 n2 p176184 februari 1999 ben juurlink pepijn de langen dynam techniqu reduc memori traffic embed system proceed 1st confer comput frontier april 1416 2004 ischia itali toni givargi improv index cach miss reduct embed system proceed 40th confer design autom june 0206 2003 anaheim ca usa mirko loghi paolo azzoni massimo poncino tag overflow buffer energyeffici cach architectur proceed confer design autom test europ p520525 march 0711 2005 timothi sherwood brad calder joel emer reduc cach miss use hardwar softwar page placement proceed 13th intern confer supercomput p155164 june 2025 1999 rhode greec soonta kim n vijaykrishnan mahmut kandemir anand sivasubramaniam mari jane irwin partit instruct cach architectur energi effici acm transact embed comput system tec v2 n2 p163185 may razvan cheveresan matt ramsay chri feucht ilya sharapov characterist workload use high perform technic comput proceed 21st annual intern confer supercomput june 1721 2007 seattl washington jonathan weinberg michael mccracken erich strohmaier allan snave quantifi local memori access pattern hpc applic proceed 2005 acmiee confer supercomput p50 novemb 1218 2005