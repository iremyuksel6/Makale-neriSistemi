random fulli dynam graph algorithm polylogarithm time per oper paper solv longstand open problem fulli dynam algorithm present first fulli dynam algorithm maintain connect bipartit approxim minimum span tree polylogarithm time per edg insert delet algorithm design use new dynam techniqu combin novel graph decomposit random lasvega type random algorithm use simpl data structur small constant factorlet n denot number node graph sequenc ohgrm0 oper m0 number edg initi graph expect time p updat op log3 n througout paper logarithm base 2 connect bipartit worstcas time one queri olog nlog log n kedg wit problem remov k given edg disconnect graph expect time p updat op log3 n expect time q queri oqk log3 n given graph k differ weight minimum span tree maintain sequenc p updat expect time opk log3 n impli algorithm maintain 1 egrapproxim minimum span tree expect time op log3 n loguegr p updat weight edg 1 u b introduct mani area comput scienc graph algorithm play import role problem model graph solv comput properti graph underli problem instanc chang increment algorithm need quickli comput properti modifi graph algorithm make use previou solut thu solv problem faster recomput scratch call fulli dynam graph algorithm precis fulli dynam graph algorithm data structur support follow three oper 1 insert edg e 2 delet edg e 3 test graph fulfil certain properti e g two given vertic connect depart comput scienc cornel univers ithaca ny email mhrcscornelledu author maiden name monika h rauch research support nsf career award depart comput scienc univers victoria victoria bc email valcsruvicca research support nserc grant 1 throughout paper logarithm base 2 previou work recent year lot work done fulli dynam algorithm see 1 3 4 6 7 8 10 11 13 16 17 19 connectivityrel work undirect graph also larg bodi work restrict class graph insertionsonli algorithm current best time bound fulli dynam algorithm undirect nnode graph n per updat minimum span forest 3 n per updat o1 per queri connect 3 log n per updat olog 2 n per queri cycleequival remov given 2 edg disconnect graph 11 n per updat o1 per queri bipartit graph bipartit 3 lower bound cell probe model ofomegagamma32 n log log n amort time per oper problem appli random algorithm 9 11 1 shown averag updat time variant connect bipartit algorithm log n edg use updat chosen uniformli given edg set thu dens graph averag perform nearli match lower bound planar graph fulli dynam algorithm minimum span forest connect given 5 close lower bound take time olog 2 n per delet olog n per insert queri howev constant factor algorithm quit larg 5 thu follow question pose open question 4 5 1 properti maintain dynam polylogarithm time gener 2 constant factor fulli dynam algorithm small effici implement possibl new result paper give posit answer question present new techniqu design fulli dynam algorithm polylogarithm time per oper appli techniqu fulli dynam connect bipartit 1fflapproxim minimum span tree cycleequival problem result algorithm lasvega type random algorithm use simpl data structur small constant factor sequenc omegagamma number edg initi graph follow amort expect updat time worstcas queri time achiev 1 connect updat time olog 3 n queri time olog n log log n 2 bipartit updat time olog 3 n queri time o1 3 minimum span tree graph k differ weight updat time ok log 3 n immedi consequ result achiev faster fulli dynam algorithm follow problem 1 algorithm maintain 1fflapproxim minimum span tree expect time op log 3 n log uffl p updat weight edg 1 u 2 algorithm kedg wit problem remov given k edg disconnect graph updat time olog 3 n amort expect queri time ok log 3 n note cycleequival equival 2edg wit problem 3 fulli dynam algorithm maintain maxim span forest decomposit order k graph time ok log 3 n per updat keep k fulli dynam connect data structur maxim span forest decomposit order k decomposit graph k edgedisjoint span forest f f maxim span forest g maxim span forest decomposit interest sinc f graph okn edg kedg connect compon g 15 addit use data structur present simpl determinist algorithm maintain minimum span tree connect fulli dynam amort time per updat minimum span tree algorithm log n improv log n use sparsif techniqu 4 amort time per updat connect algorithm log n even though algorithm improv run time best known algorithm interest sinc present complet differ approach previou algorithm use simpl data structur addit connect algorithm first fulli dynam algorithm use sparsif techniqu achiev run time less main idea new techniqu combin novel decomposit graph random edg graph partit olog n level edg highlyconnect part graph cut dens lower level loos connect part cut spars level span forest maintain graph whose edg level tree edg delet level sampl edg level high probabl either 1 find edg reconnect two subtre 2 cut defin delet edg spars level case 1 found replac edg fast case 2 copi edg cut level recurs level 1 knowledg previou use random fulli dynam algorithm montecarlo type approxim algorithm minimum cut 12 14 paper structur follow section 2 give fulli dynam connect algorithm section 3 present result kweight minimum span tree 1fflapproxim minimum span tree bipartit section 4 5 contain determinist algorithm random connect algorithm 21 deletionsonli connect algorithm definit notat let e jv use convent element v refer vertic let l 1 edg g partit l level l keep forest f tree edg f span forest v l span tree g edg e n f refer nontre edg span tree level tree f nontre edg incid vertic store data structur describ detail weight denot wt number nontre edg incid span tree edg whose endpoint lie span tree count twice size denot st number vertic tree smaller anoth tree size greater other say level level 1 211 algorithm initi edg e 1 comput f 1 span tree g edg e delet remov e graph contain e tree edg let level e 2 e call replace let level tree contain edg e let 1 2 two subtre result delet e st 1 2 ffl sampl sampl c log 2 nontre edg e incid vertic 1 appropri constant c edg endpoint 1 pick probabl 2wt 1 edg one endpoint 1 pick probabl 1wt 1 case 1 replac edg found one sampl edg connect 1 2 add f j j ffl case 2 sampl unsuccess none sampl edg connect 1 2 search edg incid 1 determin g choos one element add f j j remov element e insert add one newli insert edg f j j l 212 proof correct first show edg contain il e ie replace l call case 2 occur edg insert e l1 use fact argu replac edg exist found number edg ever e lemma 21 smaller tree 1 level proof proof follow 6 tree split two tree endpoint edg contain smaller tree size tree contain endpoint halv thu cours algorithm endpoint edg inci dent smaller tree log n time given level tree 1 level lemma 22 mc 0igamma1 proof show lemma induct clearli hold assum hold sum smaller tree 1 p log n edg ad e corollari 21 p total number edg ever level impli total number edg e greater mc choos c observ edg never move higher level level less 2 log n edg give follow corollari corollari 23 contain e l follow relationship use run time analysi also evid corollari 24 p theorem 25 f span forest v proof initi true sinc comput f 1 span tree consid first time fail tree edg e delet replac edg exist found corollari 23 replac edg lie let minimum level replac edg exist let e e k claim k assum let fr sg replac edg level sinc r connect path r f sinc e 2 f k e path henc sg replac edg e thu k delete call either replac edg found sampl everi edg incid 1 examin claim everi replac edg fr sg incid 1 suppos assumpt path r ji f j path includ e either r 1 doesnt includ e fr sg form cycl f gamma e contradict assumpt fr sg replac edg 213 euler tour data structur subsect present data structur use implement algorithm previou section effici encod arbitrari tree n vertic use sequenc symbol gener follow root tree arbitrari vertex call et root et defin follow visit x child c x visit x edg visit twice everi degre vertex time except root visit time time vertex u encount call occurr vertex denot u new encod tree result split join previous encod tree easili gener let et sequenc repres arbitrari tree procedur modifi encod 1 delet edg fa bg let 1 2 two tree result 2 1 encount two travers fa bg thu et 2 given interv et splice et sequenc 2 chang root r let occurr splice first part sequenc end occurr remov first occurr r tack end sequenc begin add new occurr end 3 join two root tree 0 edg e let given occurr creat new occurr splice sequenc et immedi sequenc et store balanc search tree degre b height olog n log b one may insert interv splice interv time ob log n log b maintain balanc tree determin two element tree one element preced order time olog nb asid list array data structur use connect algorithm tree repres sequenc store balanc bari search tree next describ data structur data structur two option store nontre edg first simpler explain second shave factor log log n updat time reduc cost sampl describ last subsect section span tree level l occurr et store node balanc binari search tree call etttre tree last level l et store balanc log nari search tree note nontre edg level vertex arbitrarili choos one occurr activ occurr u activ occurr vertex v keep unord list nontre edg level incid v store array node ettre contain number nontre edg number activ occurr store subtre thu root et contain weight size addit store g f use adjac list keep array list ffl vertex level pointer vertex activ occurr level ffl tree edg level k e 2 f k pointer four three endpoint leaf occurr associ travers f k ffl nontre edg pointer locat two list nontre edg contain edg revers pointer ffl level list contain pointer root etttre span tree level root pointer back list ffl level list tree edg e edg pointer back posit list 214 implement use data structur describ follow oper execut span tree level let span tree level ffl treex return pointer et span tree level contain vertex x ffl nontre edgest return list nontre edg store et edg return twice randomli select nontre edg e least one endpoint edg endpoint pick probabl 2wt edg exactli one endpoint pick probabl 1wt test exactli one endpoint return edg ffl insert treee join e two tree level contain endpoint e ffl delet treee remov e tree level contain ffl insert nontree insert nontre edg e e ffl delet nontree delet nontre edg e follow run time achiev use binari search tree tree sampletest insert non tree delet non tree delet tree insert tree olog n nontre edgest om 0 log n 0 number move edg last level l log nari tree use run time delet tree insert tree increas olog 2 n log log n run time tree reduc olog n log log n describ implement detail oper treexi follow pointer activ occurr x level travers path et tree activ occurr root return pointer root nontre edgest travers node et output everi nonempti list nontre edg encount node let level tree pick random number j 1 wt find j th nontre edg fu vg store et treeu l 6 treev l return edg insert treeei determin activ occurr endpoint e level follow procedur 3 join two root tree updat pointer root new tree list tree edg level delet treeei let vg determin four occurr associ travers e tree level contain e delet e follow procedur 1 updat pointer root new tree list tree edg necessari activ occurr u v insert nontreeei determin activ occurr endpoint e level add e list edg store delet nontree follow pointer two locat e list nontre edg remov e use function delet algorithm implement follow initi data structur given graph g comput span forest g comput et forest select activ occurr set pointer describ initi set tree level insert nontre edg appropri activ occurr level 1 comput number nontre edg subtre node answer queri x connect test treex updat data structur delet edg efuvg e e delet treee e tree edg execut delet nontree 2 repeat time case 1 replac edg e 0 found delet nontree 0 case 2 sampl unsuccess edg fu vg 2 nontre treeu l 6 treev l add fu vg fedg exactli one endpoint 1 g g case 21 jsj wt 1 2c 0 log n select one e case 22 choos one edg e 0 2 remov everi edg e 00 2 delet non treee 00 insert nontree 00 case 23 215 analysi run time show amort cost per delet olog 3 n delet case replac edg found olog n insert tree oper execut cost olog 2 n addit case 1 sampl success cost sampletest olog n repeat olog 2 n time total olog 3 n case 2 sampl success wt 1 refer execut nontre test edg cost gather test nontre edg first oper cost olog n per nontre edg second olog n log log n per nontre edg total cost owt 1 log n three possibl case case 21 jsj wt 1 2c 0 log n wt 1 cost gather test delet oper otherwis probabl subcas occur total cost case owt 1 log n thu contribut expect cost olog n per oper case 22 23 jsj wt 1 2c 0 log n delet nontre insert nontre tree cost olog n total cost owt 1 log n case treeu treev reconnect note edg incid smaller tree 1 gather test thu cours algorithm cost incur case level sum taken smaller tree 1 level lemma 21 p corollari 24 p give total cost om log 2 n 22 fulli dynam connect algorithm 221 algorithm next also consid insert edg fu vg insert g add fu vg e l u v previous connect g ie treeu l 6 treev l add fu vg f l let number level l d2 log ne rebuild data structur execut period rebuild level 1 done move edgesi oper move tree nontre edg e j also j tree edg e j insert f k rebuild level contain edg f ie span tree level j span connect compon g insert increment number insert modular 2 d2 log ne sinc start algorithm let j greatest integ k 2 k ji edg insert rebuild level l execut repres binari counter whose bit b b 0 signific bit rebuild level occur time th bit flip 1 222 proof correct proof correct one deletionsonli case except must set valu l d2 log ne alter argument show edg contain defin iperiod period begin right rebuild level j start algorithm end right next rebuild level j 0 ie iperiod start right flip 1 bit j start algorithm end next flip note two type iperiod begin immedi rebuild level edg e move e j flip 1 b begin immedi rebuild level ie edg move e b flip 1 easi see i1period consist two part one type iperiod follow one sinc flip 1 bit b j must follow flip b 1 second bit b j 0 flip 1 theorem 26 let number edg e iperiod proof proof analog lemma 21 lemma 27 smaller tree 1 level search two consecut rebuild level bound note may restrict attent edg move one i1period sinc e empti start i1 period thu edg e either pass e one i1period move singl rebuild level empti start i1period edg move e rebuild level pass e igamma1 e e igamma1 type iperiod ie first part i1period insert g type iperiod h igamma1 maximum number edg pass e igamma1 e singl ie iperiod follow b iperiod b number edg insert g singl iperiod number edg insert g iperiod 2 lgammaigamma1 bound h use lemma 27 bound p sum smaller tree 1 search level proof lemma 22 bound h choos substitut h b yield choos log ne note 1 n 2 induct proof show impli l 2 edg never pass l1 corollari 28 log ne edg e contain e l 223 analysi run time analyz run time note analysi case 1 case 21 affect rebuild howev 1 bound cost incur insert ie cost oper move edg 2 case 22 23 argument om log n edg gather test use nontre edg tree level cours algorithm must modifi cost 1 ie cost execut move edgesi cost move tree edg nontre edg cost updat f k analyz first part note move edg e cost olog n per edg number edg move greater p thu cost incur cost insert one tree edg given level olog n per edg tree edg ad level sinc tree edg never pass thu cost may charg edg total cost olog 2 n per edg analyz cost 2 insert sinc start algorithm rebuild occur level lower analysi level deletionsonli argument hold cost incur level bound om log 2 nc number edg initi graph appli lemma 27 conclud cost gather test edg smaller tree 1 level iperiod o2a log n log l note sinc o1 edg e l given time sinc cost olog n per edg gather test total cost instanc gather test level olog n use potenti function argument charg cost 1 2 insert new insert contribut c 00 log 2 n token toward bank account level total thetalog 3 n token sinc iperiod occur everi n 2 2 insert token contribut insert pay 2 log 2 n2 cost gather test level iperiod 2 log n2 cost move edgesi incur iperiod 23 improv section present simpl trick reduc cost test nontre edg incid smaller tree 1 o1 per edg total cost gather test edg incid 1 o1 per edg 231 constant time gather test note sinc nontre edg incid ettre avail list time need retriev edg o1 per edg one also test nontre edg o1 time ie determin set nontre edg contain one endpoint run list three time edg list initi entri n theta n array use entri count number time edg appear list travers list add edg whose count one 232 constant queri test time deletionsonli algorithm note determin whether two vertic j compon ie treej speed o1 deletionsonli algorithm compon split replace l call replac edg found case label node smaller compon 1 new label cost proport size 1 cours algorithm cost log n sinc node appear smaller compon log n time label improv affect asymptot run time random connect algorithm domin cost random sampl howev use determinist algorithm present later paper random algorithm dynam graph problem section show dynam graph problem polylogarithm expect updat time reduc problem connect give altern algorithm maintain minimum span tree 31 kweight minimum span tree algorithm kweight minimum span tree problem maintain minimum span forest dynam graph k differ edgeweight given time e initi graph comput minimum span forest f g defin sequenc subgraph g fedg weight rank ig f initi l k distinct edgeweight call extra span forest g maintain connect algorithm forest f also store dynam tree subgraph order weight edgeset store balanc binari tree insert edg fu vg g determin u v connect f find maximum cost edg e path u v f weight e greater weight fu vg replac e f fu vg u v previous connect add fu vg f otherwis add fu vg e j j rank weight fu vg fu vg edg weight g creat new subgraph ad fu vg extra insert order g updat e reflect chang f delet edg fu vg g delet fu vg graph contain updat f fu vg f tree f divid two compon find minimum u v connect g use binari search list subgraph search path u v span forest g find edg cross cut use binari let x midpoint path recurs portion path u x u x connect f els recurs path x v correct edg fu vg insert cost less cost maximum cost edg tree path u v minimum span forest f unchang cost fu vg less cost maximum cost edg e 0 tree path u v replac e 0 fu vg decreas cost minimum span tree maximum possibl amount give thu minimum span tree g fu vg analysi run time algorithm 1 determin f chang 2 updat data structur 1 insert maximum cost edg tree path u v determin time olog n use dynam tree data structur f delet take time olog 2 n log log n find minimum u v connect g sinc connect queri level take time olog n log log n midpoint tree path u v g determin time olog n use dynam tree data structur span tree g algorithm recurs log n time determin replac edg fu vg total olog 2 n 2 insert delet fu vg e rank weight fu vg take amort expect time olog 3 n f chang one addit insert delet execut everi e j updat constant number oper dynam tree f span tree everi e j cost olog n thu amort expect updat time ok log 3 n 32 fflapproxim minimum span tree algorithm given graph weight 1 u 1fflapproxim minimum span tree span tree whose weight within factor 1ffl weight optim problem maintain 1ffl approxim easili seen reduc kweight mst problem weight rank fall interv 1 yield algorithm amort cost olog 3 n log uffl log log n 33 bipartit algorithm bipartit graph problem answer queri g bipartit o1 time g dynam graph reduc problem 2weight minimum span tree problem use fact graph g bipartit iff given span forest f g nontre edg form even cycl f call edg even edg remain edg odd also use fact edg e f replac even edg set even edg preserv let c cut f induc remov e e replac odd edg nontre edg e 0 cross c pariti e 0 chang replac edg odd replac edg exist even replac edg thu pariti even edg never chang f store dynam tree algorithm gener span forest f initi graph g tree even nontre edg weight 0 odd edg weight 1 edg weight 1 graph bipartit edg insert determin odd even use dynam tree data structur f give weight 1 0 accordingli edg delet tree edg replac odd edg weight 0 replac remov odd edg find next replac remov etc replac relabel replac edg even add back g correct edg insert algorithm determin even odd edg delet replac even edg possibl affect pariti remain edg even replac edg exist odd replac edg pariti everi edg cut chang howev sinc even edg exist cut suffic make odd edg even edg analysi run time even edg never becom odd thu weight edg chang show insert edg caus edg ad data structur weight 1 weight 0 delet edg lead remov edg data structur thu amort expect updat time olog 3 n 4 determinist minimum span tree algorithm section present fulli dynam determinist minimum span tree algorithm amort time log n per oper current number edg g note techniqu sparsif 4 appli top algorithm yield algorithm log n amort time per oper 41 deletionsonli minimum span tree algorithm data structur use similar random connnect algo rithm instead random sampl alway exhaust search edg incid smaller compon edg store p level accord weight move level deletionsonli data structur kept old edg newli insert edg kept separ level period rebuild execut deletionsonli data structur revis includ newli insert edg e jv rank edg weight edg g partit l level l e l contain edg rank j comput minimum span forest f g keep forest f tree edg f minimum span forest v note f n f 411 algorithm updat data structur delet edg efuvg e tree edg delet nontree e tree edg e delet treee replaceu v els gather test nontre edg incid 1 case 1 replac edg found let e 0 minimum weight replac edg case 2 replac edg found 412 implement analysi run time use data structur random algorithm store nontre edg e appropri ettre level ettre store binari tree nontre edg store ntlist gather test edg incid 1 may done wt time see improv section 231 tree edg delet replac edg sought total cost gather test nontre edg given level charg delet replac edg found level consid latter case first 1 becom new compon f cost gather test edg incid 1 owt 1 given level log n see lemma 21 level total cost om log n cost gather test level replac edg found greater cost gather test everi edg level addit tree edg p insert tree oper execut per level total cost log n cost delet nontre olog n cost thu log n per edg delet plu total cost om log n cours algorithm 42 fulli dynam minimum span tree algorithm 421 algorithm partial rebuild data structur execut p number edg graph last rebuild initi rebuild edg refer old edg still g store deletionsonli data structur describ newli insert edg store separ set e l1 f l minimum span tree consist old edg ie gv f minimum span tree gv e ie old new edg store f dynam tree data structur e l keep list edg order rank rebuild number updat insert delet sinc last rebuild start algorithm reach p reset current number edg graph insert edg e l1 appropri e l redistribut old edg among l e contain edg rank j gamma 1 p edg old edg tree edg level move level 0 add edg level remov edg level delet edg e g e old tree edg updat deletionsonli data structur e belong f stop otherwis delet vg f find minimum cost edg e 0 exactli one endpoint 1 e l1 add f smallercost edg e 0 replac edg delet data structur exist insert edg e g add edg e l1 test replac edg f use dynam tree find heaviest edg path es endpoint path determin e lighter ye modifi f accordingli 422 analysi run time cost edg insert olog n sinc consist constant number oper dynam tree data structur cost edg delet may includ cost updat dynam tree data structur olog n cost test edg e l1 log n cost updat deletionsonli data structur show bound latter cost involv deletionsonli data structur rebuild given analysi section 412 p per delet tree edg plu overal cost om 0 log n rebuild log n per updat oper bound next cost rebuild first discuss ad edg appropri level discuss rebalanc size level determin appropri level edg take time olog n use binari search move nontre edg e l1 e l cost olog n per edg total move tree edg e l1 e requir insert edg level j cost per edg total om 0 log n edg e l never move one level rebalanc ie either e cost olog n per tree nontre edg thu time rebuild om 0 log n cost rebuild amort p occur p number edg current graph oper occur sinc cost algorithm per edg delet insert log n 5 determinist connect algorithm minimum span tree algorithm easili convert algorithm connect run time section give altern connect algorithm log n amort updat time without use sparsif data structur use similar use previous present algorithm two import dif ferenc previou algorithm edg partit level level contain p edg level ad need initi level edg creat new edg insert highest level contain less p edg newli creat empti highest level otherwis data structur whole never rebuilt new level ad one time edg level delet level discard use term level denot ith nonempti level previou algorithm edg move level f defin keep forest f tree edg f span forest v f store relax version ettre call rettre unlik ettre use previou algorithm rettre follow properti edg level delet replac edg found level j j rettre level updat allow us keep larger number level 51 rettre data structur let span tree level let ct tree creat contract everi span tree level one node node ct call big node thu edg ct belong f retttre consist ettre sequenc et ct list edg activ occurr vertex replac ffl list nodesa vertic g contract form follow first vertic incid edg e vertic vertex v g nodesa keep 1 list edg f incid v 2 list nontre edg incid v 3 number nontre edg incid v 4 pointer ffl number edg incid vertic nodesa addit keep order list nonempti level store doubli link list l nonempti level array whose jth entri pointer locat vertex j nodeslist level contain j oper rettre defin ettre omiss sampletest addit two oper defin ffl big nodeu return big node level contain vertex u oper assum e delet edg f whose endpoint still contain big node level 1 let 1 2 span tree level contain endpoint e 1 smaller two tree split two big node repres implement big nodeu follow pointer level vertex u nodeslist level contain u pointer big node contain u call big node domin cost find level l take time olog n implement split big smaller two subtre let vg travers et ct 1 level determin set u vertic g 1 use big one node u determin big node repres node u remov node u nodesa creat new node b add node u new order nodesb list updat number edg incid node nodesa nodesb accordingli call split big node take time proport number vertic 1 plu olog n call big node implement ettre oper need modifi slightli run time olog n insert nontreet e delet nontree endpoint e may move begin end nodeslist contain implement treex nontre edgest insert treee delet treee unchang except constant number call big node 52 algorithm updat data structur delet edg efuvg e tree edg execut delet nontree e tree edg level delet treee call replaceu v gather test nontre edg incid 1 case 1 replac edg e 0 found delet nontree 0 insert treee case 2 replac edg found let j next lowest nonempti level split big node j replaceu v j updat data structur insert edg efuvg number edg level p build data structur new level reset l new level u connect call insert nontree treeu l els insert treee l 53 implement analysi run time gather test nontre edg store nontre edg ntlist see section 231 gather test edg incid 1 may done time owt 1 number nontre edg incid 1 show amort time per updat oper log n sinc build data structur new level take time occur everi p n insert total time insert charg n insert next show total cost delet om log n 0 number edg initi graph k total number updat oper search replac edg take time owt 1 separ consid cost search last level search occur either termin success discontinu level cost level search occur total cost search delet last level p per search om 0 log n total cost search level replac edg found sum 1 creat level appli lemma 21 total cost om log n cost split big node charg node 1 total cost n log n per level sinc om n level creat whole cours algorithm total cost split big node om log n thu cost updat oper amort updat log n 6 acknowledg thank david albert comment present r averag case analysi dynam graph algo rithm main tenanc minimum span forest dynam planar graph improv sparsif sparsif techniqu speed dynam graph algorithm separ base sparsif dynam planar graph algorithm onlin edgedelet problem data structur onlin updat minimum span tree ambival data structur dynam 2edgeconnect k smallest span tree lower bound fulli dynam connect problem graph fulli dynam algorithm 2edg connect fulli dynam cycleequival graph approxim minimum cut insert spars certif dynam biconnect graph use random sparsif approxim minimum cut linear time algorithm find spars kconnect span subgraph kconnect graph fulli dynam biconnect graph improv data structur fulli dynam biconnect graph data structur dynam tree find updat span tree shortest path tr data structur dynam tree amort analysi algorithm set union backtrack mainten minimum span forest dynam plane graph fulli dynam algorithm 2edg connect complex model increment comput separ base sparsif ambival data structur dynam 2edgeconnect iki smallest span tree sparsificationmyampersandmdasha techniqu speed dynam graph algorithm polylogarithm determinist fullydynam algorithm connect minimum span tree 2edg biconnect sampl provid bound onlin edgedelet problem improv data structur fulli dynam biconnect certif fast algorithm biconnect fullydynam graph ctr mihai ptracu erik demain lower bound dynam connect proceed thirtysixth annual acm symposium theori comput june 1316 2004 chicago il usa david eppstein dynam gener topolog embed graph proceed fourteenth annual acmsiam symposium discret algorithm januari 1214 2003 baltimor maryland glencora borradail philip klein n log n algorithm maximum stflow direct planar graph proceed seventeenth annual acmsiam symposium discret algorithm p524533 januari 2226 2006 miami florida robert e tarjan renato f werneck selfadjust top tree proceed sixteenth annual acmsiam symposium discret algorithm januari 2325 2005 vancouv british columbia umut acar guy e blelloch robert harper jorg l vitt leung maverick woo dynam static algorithm applic dynam tree histori independ proceed fifteenth annual acmsiam symposium discret algorithm januari 1114 2004 new orlean louisiana camil demetrescu giusepp f italiano algorithm techniqu maintain shortest rout dynam network electron note theoret comput scienc entc v171 n1 p315 april 2007 david r karger minimum cut nearlinear time journal acm jacm v47 n1 p4676 jan 2000 timothi chan dynam subgraph connect geometr applic proceed thiryfourth annual acm symposium theori comput may 1921 2002 montreal quebec canada jacob holm kristian de lichtenberg mikkel thorup polylogarithm determinist fullydynam algorithm connect minimum span tree 2edg biconnect journal acm jacm v48 n4 p723760 juli 2001 mikkel thorup worstcas updat time fullydynam allpair shortest path proceed thirtyseventh annual acm symposium theori comput may 2224 2005 baltimor md usa eran eyal dan halperin dynam mainten molecular surfac conform chang proceed twentyfirst annual symposium comput geometri june 0608 2005 pisa itali camil demetrescu giusepp f italiano fulli dynam pair shortest path real edg weight journal comput system scienc v72 n5 p813837 august 2006