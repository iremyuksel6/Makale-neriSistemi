develop verifi erlang program resourc lock paper describ tool verifi erlang program show mean industri case studi tool use tool includ number compon includ translat compon state space gener compon model check compon verifi properti code tool first translat erlang code process algebra specif outcom translat made effici take advantag fact softwar written erlang build upon softwar design pattern clientserv behaviour label transit system construct specif use crl toolset result label transit system model check set properti formul calculu use caesaraldbaran toolseta case studi focu simplifi resourc manag model real implement control softwar axd 301 atm switch key properti verifi program mutual exclus nonstarv sinc toolset support regular alternationfre calculu ingenu need check live properti nonstarv case studi refin step step provid function step motiv correspond formal verif use model check b introduct within ericsson function program languag erlang 1 use develop concurrentdistribut safeti critic softwar face task creat support develop formal veri erlang program subtask built tool enabl use model check program tool aim access erlang programm without forc learn extra languag specic model check tool use use model check formal veric softwar well known eld research basic two branch either one use spec icat languag combin model checker obtain correct spec icat use write implement program languag one take program code start point abstract model check model checker either way implement prove correct approach error encount may indic error implement use model check seen accur debug method rst approach one success mani exampl combin specic languag promela model checker spin 14 attract merit promela languag close implement languag c becom rather easi deriv implement specic direct fault free way case one use uml specic languag java c implement languag one might need eort apart fact model check uml specic still unsettl topic also respect second approach mani exampl among pathfind 13 bandera 6 start java code exist even earlier attempt use model check erlang code huch 15 approach could ad list probabl dierenc use knowledg occur design pattern use erlang code obtain smaller state space cf 2 follow similar approach translat java promela check spin 13 howev translat erlang crl 12 model check use csarald ebaran 9 compar huch approach focu much data part abstract case statement nondeterminist choic realli check data involv reason check mutual exclus absenc deadlock small locker program lead exampl paper one abstract data program way case statement translat nondeterminist choic mutual exclus longer guarante henc shown one main goal approach abl deal erlang code written accord design principl advoc within ericsson start point distribut locker algorithm run ericsson axd 301 atm switch 4 start redesign locker way formal veric guid develop paper illustr idea one rst locker prototyp develop process section 2 describ locker algorithm consid paper show section 3 locker implement erlang use gener server supervis tree design principl erlang modul automat translat crl specic section 4 describ contribut form translat tool veric crl specic classic properti deadlock mutual exclus starvat describ section 5 conclus section 6 discuss merit shortcom approach put context respect approach 2 design algorithm casestudi hand paper classic locker algorithm sever process want access one resourc given nite set locker process play arbit respond request access resourc way client eventu get demand access two client get access resourc time client send one messag contain resourc request wait access grant access resourc give resourc free start ask resourc sever fault situat easi imagin guid us toward solut rudimentari problem describ analysi situat prestudi actual implement howev tool discuss later one could nd result experi fashion implement idea erlang obtain possibl run program automat discuss fault situat use special notat scenario scenario sequenc state locker process state locker contain xed set resourc everi resourc three eld name resourc client access resourc list client want access resourc exampl notat sketch possibl starvat situat two resourc b three client 3 algorithm demand set resourc avail certain client client get access resourc client 1 request resourc client 2 request resourc b thereaft client 3 request resourc client 1 releas request resourc client 2 releas request b continu oper way caus client 3 wait ever get access ie client 3 starv access 1 pend access pend access pend 3 3 access 2 pend 3 3 access pend 3 3 access 1 pend 3 3 access pend 3 3 scenario indic gener one pay price optim resourc usag viz possibl starvat clearli one want starvat program one still may accept algorithm one good evid believ resourc access frequent situat might unlik one might choos loos perform client 3 favor better overal perform howev assum frequenc access resourc rather high dierent client may overlap demand resourc 1 therefor need decid upon solut problem choos use rst come rst serv strategi resourc avail client client 1 2 3 would ask resourc starvat problem would occur wait ie access eld list pend process demand resourc empti access pend access pend 1 access pend access 2 pend 3 3 thu solut client could wait resourc even demand resourc unus moment optim possibl exampl timestamp pend process give access resourc rst pend process yet wait certain amount time involv consid optim version action upon client request list resourc look whether demand resourc avail resourc avail process access process pend resourc demand resourc avail client noti given access resourc demand resourc unavail everi demand resourc client place end list pend process client assum releas previous demand resourc one releas messag upon releas client remov resourc calcul perform see whether one client get access demand resourc similar reason give access client demand resourc avail even one resourc case clear need take rst come rst serv polici thu one resourc sever client would give client head pend list access resourc howev one could wonder happen two resourc one client pend list access pend need algorithm decid whether client 2 3 get access resourc client 1 releas possibl could think boil construct one list pend process rst client list demand resourc avail get access resourc ie noti remov pend list put access eld sever way construct combin list 1 merg list sort client identi mean client lowest identi highest prioriti henc starvat obviou problem exampl client 2 given access client 1 request resourc time client 2 releas client 1 grant access repeatedli 1 2 request access caus 3 starv 2 append list use small optim uniqu append ie append client yet present list clearli starvat problem occur solut 3 construct list contain head pend list occur one tail pend list reason work client alway request resourc henc client put pend list sort manner situat like access pend occur set sinc either client 2 follow client 3 pend list vice versa might client order revers 4 add timestamp incom request save client inform timestamp list obtain append sort timestamp equival approach separ store list request client use order request prioriti order give access experi version 3 4 present version 3 3 locker implement erlang idea sketch previou section implement erlang client locker implement erlang process commun messag pass locker implement server follow one gener design pattern given erlang distribut 8 gener server design pattern prescrib implement locker call callback modul actual loop save state server receiv messag implement standard modul whenev messag arriv appropri function callback modul execut callback function return new state possibl repli messag standard modul part send caller way gener server principl implement synchron commun top erlang asynchron commun primit detail oper semant refer 2 ow control client locker follow client request locker exclus lock sever resourc request resourc avail locker give ok client client perform necessari oper resourc noti locker releas lock locker schedul client rstcome rstserv basi explain previou section note howev schedul rel resourc client request resourc taken may serv later client request anoth free resourc client program simpl process use gener server call principl commun locker gen servercal function hide synchron commun server second argument function contain messag sent server call handl call function callback modul client suspend handl call return repli valu pass server return valu gen servercal particular client interest actual return valu use synchron spawn link function use creat new process case run loop function argument locker resourc modulecli startlockerresourc okspawnlinkclientlooplockerresourc looplockerresourc criticalsect looplockerresourc atom critic section two synchron call request releas implement call critic section real implement critic code place critic section abstract implement lock use record follow eld resourc name resourc exclus client use resourc pend list client want access resourc erlang program locker process given gener server callback modul accept messag frequestresourcesg releas modulelock behaviourgenserv initresourc end resourc init function return everi resourc given list resourc record type lock rst eld contain name resourc two eld instanti default valu empti list case checkavailablesresourceslock true repli ok end lock fals norepli end lock handlecallreleas client lock end lock sendreplynewlocksallpendingsnewlock repli ok locksupd gener server automat support everi messag gen servercal process identi sender tag kind time stamp distinguish dierent messag client obtain request locker store combin identi tag pair pend list exclus eld releas new tag use pair sinc new messag remov pair list done look process identi note locker remov tag alreadi moment receiv request client sinc tag necessari repli implement send repli function check everi pend client whether resourc avail client noti lock updat case obtainableslockspend true promotependinglockpend end lock fals sendreplylockspend end function contain side eect viz send receiv messag function sideeect free easi implement addit client locker code also implement call supervis tree commonli use design principl monitor individu process 8 basic code supervis tree describ process start monitor two process one locker new supervisor process monitor client code describ happen one process crash instruct restart client locker process process togeth start one function call viz supervisorstart argument number client one want start list resourc one consid 4 crl specic erlang modul describ previou section automat translat one crl specic data directli translat erlang crl without abstract specic use gener transit system use model check translat perform two step first appli sourcetosourc transform level erlang result erlang code execut way origin optim veric second translat collect erlang modul one crl specic advantag intermedi erlang format programm easili understand sever manipul code therefor better abl understand smaller step crl notat moreov intermedi code input veric tool 41 erlang erlang transform sourcetosourc transform erlang modul contain mani step mention relev one skip trivial step like remov debug statement code use supervis tree structur obtain nite set initi process start translat argument would need build start supervis tree allow us bind number client resourc certain valu everi dierent number need run dierent transform supervisor process taken away new initi function creat process locker client handl process crash left detect transit system replac preden set higher order function like map rstorder altern sinc target specic languag support higher order function thu call mapfunx fxy1yn end xs replac call new function map fxsy1yn dene ad code fxy1yn mapfxsy1yn next phase determin function sideeect ie function send receiv messag call function callgraph problem keep list sideeect free function librari modul gen servercal function handl call function typic ad function contain sideeect involv oper get rid use return valu function sideeect crl process may sideeect return valu hand function crl return valu may contain sideeect case erlang function indirectli caus sideeect comput part sideeect part split sourcetosourc transform suce make sure return valu match variabl provid decomposit data structur return valu mean sideeect free function current deal basic data type compound data type list tupl record mixtur 42 erlang crl transform given erlang modul transform describ gener one crl specic modul erlang dynam type wherea crl strongli type therefor construct crl data type erlangterm erlang data type embed sideeect free function ad term rewrit system erlangterm data type standard transform use translat erlang statement term rewrit formal addit dene equival relat data type rather involv particular case 14 dierent atom 7 data constructor 440 equat reserv compar data type roughli two third whole specic respect part sideeect benet fact erlang erlang transform gener specic congur contain inform process start allow us dene initi congur crl specic erlang process coincid crl process nontermin erlang function describ main loop process erlang case howev translat loop translat recurs call erlang function sideeect direct way crl crl comput sideeect intermingl solut found denit separ crl process implement call stack commun call stack use return valu comput certain restrict respect crl function taken account one function claus possibl sequenti com posit nondeterminist choic ifthenels statement control translat case statement pattern match use ifthenels construct call newli introduc process function handl call gen servercal translat commun action crl differ claus handl call function combin one crl loop use state mention argument handl call state loop uniqu process identi use erlang integr argument self process call instanti rst call initi part comm genservercal genserverrepli return return proc lockerself termlock sumresourc term handlecallselftuplerequestresourcescli genserverreplyclientokself lockerself eqcheckavailablesresourceslockstru lockerself handlecallselfreleasecli allpendingsmapreleaselocklockscli rcallresultselflocks2 genserverreplyclientokself lockerselflocks2 wcallresultselflock eqequalmcrlarg1niltru genserverreplyhdmcrlarg1okself sendreplyself eqobtainableslockshdmcrlarg1tru automat transform verifi specic congur client repeatedli request avail resourc order perform sever veric particular verifi situat client repeatedli request arbitrari vari subset resourc modi crl specic hand use crl possibl express nondetermin crl specic use gener transit system number state gener system depend congu ration tri sever congur three client four resourc largest result million state creat larg state space take hour singl processor workstat even though time consum improv highest prioriti plan focu small exampl develop phase softwar larger exampl take time test develop onth model check parallel model checker might increas perform dramat later stage 5 verifi model three properti want verifi locker absenc deadlock mutual exclus starvat classic properti well studi literatur rst trivial shown second third need right formul support model checker mutual exclus safeti properti wherea starvat live properti safeti properti easier check live properti explain later depend fact innit trace specic exclud real erlang execut underli erlang schedul 51 mutual exclus properti mutual exclus express resourc access one client time order show ad two action crl specic use free resourc argument soon enter critic section use action appli resourc client request leav critic section resourc use macro state possibl path 1 action 1 action must preced 2 action mutual exclus properti depend number resourc fact need dierent formula number resourc system two resourc r 1 r 2 mutual exclus properti formal new version model check tool within csarald ebaran toolset 9 construct new releas abl formul one properti arbitrari number resourc mutual exclus properti shown congur 2 resourc 2 3 client client repeatedli request arbitrari none empti subset resourc well situat 4 resourc 3 client latter consist model million state took hour verifi mutual exclus properti recent develop parallel model checker use check largest transit system hour reduc nine minut fti processor 5 promiss develop scale approach 52 starvat prove starvat process turn problem caus fact trace transit system correspond fair run erlang program erlang process schedul use certain schedul model purpos abstract schedul consid possibl sequenc action even one singl process get execut time want base starvat properti notion action eventu follow anoth action particular request resourc eventu follow use resourc one way formul properti use context instanti action 1 2 request resourc enter critic section respect latter use conrmat locker ie return ok messag actual properti like mutual exclus case depend number client resourc three client two resourc unfortun properti hold even simpl scenario denit starvat occur exampl consid follow simpl scenario three client two resourc client repeatedli request one resourc client 1 2 request client 3 request b scenario starvat sinc client may access resourc releas request crl specic possibl loop client 3 continu request releas resourc b client request resourc simpli get schedul time sequenc howev erlang program loop present schedul thu problem disregard unrealist loop transit system remov loop transit system could nd way incorrect realist set loop could execut time schedul enabl process realist set exclud innit travers loop would like weaken evtfollow properti nonfair path exist model implement due schedul erlang runtim system ignor limit model check tool evalu 30 need express properti altern free calculu extern advic requir come follow reformul evtfollow describ even loop exist reach 2 still possibl everi state loop reach 2 nite number step modal h 2 itru properti weaker combin properti 1 hold mention scenario unfortun weak ie ignor loop consid properti 1 weaker evtfollow hold rst scenario mention section 2 starvat erlang context recal scenario client 1 2 turn take prioriti client 3 thu ignor loop action client 1 2 although caus client 3 starv need precis kind action ignor loop think littl longer turn action may appear loop neither request releas client ignor matter action one would like ignor alway plausibl scenario possibl clear one ignor action even whole loop principl allow long occur innit often action along path also enabl opinion goe beyond express logic use current investig sever possibl work around problem viz ad explicit schedul crl specic model checker chang use dierent logic model checker enabl reason fair one might wonder whether starvat import properti sinc even theoret starvat problem occur might happen realiti process alway get serv regular implement timer set send messag starvat show time client site time normal follow retri process might get serv attempt experi ad time out remov check pend list function check avail lead starvat scenario discuss section 2 run program show starvat rst sight client get access resourc occasion implement client access time say 500 ms critic section starvat show form time client total number serv request get lower particular client know theoret starv interest context detect perform problem sucient increas time spent critic section one argu test would sucient error could show unexpectedli softwar use long time henc nd starvat import properti verifi 6 conclus main contribut work lay develop automat translat class erlang program crl enabl develop erlang program goe hand hand formal veric lead formal veri program expect smart abstract clever trick perform user tool assum limit knowledg veric issu provid pushbutton veric ts exist develop cycl lead exampl develop tool use implement locker algorithm veric locker algorithm partli success absenc deadlock mutual exclus could prove could shown eectiv algorithm starvat free subject research nd way around problem number state model much million real perform problem encount take complet veric hour still consid accept stage major work put get specic right formul right properti case particular starvat spent much time formul still satisfactori properti use approach similar pathfind bandera project 13 6 would interest see java version case studi could easili handl use tool found opportun run model check approach huch 15 directli exampl imposs sinc version support gener server design principl could chang program remov gener server implement use direct implement erlang instead howev approach huch would translat choic whether return ok messag client store client pend list nondeterminist choic abstract away data way mutual exclus hold obtain transit system anoth approach veric erlang program dier model check use theorem prover check properti swedish institut comput scienc cooper ericsson develop kind theorem prover special focuss erlang program 3 advantag use tool compar model check approach possibl use full calculu instead altern free possibl reason unbound number client resourc complet approach ie proof given hold program specic sinc model check allow easier autom aim use techniqu prototyp use theorem prover approach version satis veric locker casestudi post sever question research solv sever practic issu way continu ad featur locker share lock faulttoler therewith increas need even better translat tool acknowledg would like thank radu mateescu hubert garavel inria rhone alp izak van langeveld jaco van de pol wan fokkink cwi lar ake fredlund dilian gurov sic take part discuss case studi support us advis r verifi gener erlang clientserv implement new gener atm switch system local parallel model check altern free introduct process algebra model concurr system protocol veri syntax semant time model check java program use java pathfind design valid comput protocol tr ctr thoma noll chanchal kumar roy model erlang picalculu proceed 2005 acm sigplan workshop erlang septemb 2628 2005 tallinn estonia chanchal kumar roy thoma noll banani roy jame r cordi toward automat verif erlang program calculu translat proceed 2006 acm sigplan workshop erlang septemb 1616 2006 portland oregon usa larsk fredlund clara benac earl model check erlang program function approach proceed 2006 acm sigplan workshop erlang septemb 1616 2006 portland oregon usa koen claessen han svensson semant distribut erlang proceed 2005 acm sigplan workshop erlang septemb 2628 2005 tallinn estonia