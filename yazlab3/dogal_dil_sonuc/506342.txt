strong normaliz nondeterminist catchthrow calculi catchthrow mechan common lisp provid simpl control mechan nonloc exit studi type calculi nakano sato formal catchthrow mechan calculi correspond classic logic curryhoward isomorph one characterist point nondeterminist reduct rule calculi repres variou comput mean classic proof paper mainli concern strong normaliz calculi name prove strong normaliz calculi open problem first formul nondeterminist variant parigot calculu show strongli normal translat catchthrow calculi variant sinc translat preserv type reduct obtain strong normal catchthrow calculi also briefli consid secondord extens catchthrow calculi copyright 2002 elsevi scienc bv b introduct catch throw mechan provid mean implement nonloc exit follow simpl exampl written common lisp 19 show use catch throw mechan defun multipli x catch zero multiply2 x defun multiply2 x null x 1 car x car x multiply2 cdr x rst function multipli set catchpoint tag zero immedi call second function second one multiply2 perform actual comput recurs given list integ calcul multipl member list 0 found list result must 0 without comput return 0 throwexpress catchthrow mechan use one want escap nest function call time especi runtim error nakano 1114 propos calculi infer rule give logic interpret catchthrow construct lisp calculi dier actual catchthrow construct common lisp follow two way 1 chang scope rule catchconstruct dynam one lexic one exampl express throw zero 0 lexic scope correspond catchexpress indic catchexpress dynam scope common lisp 1 nakano calculi tag variabl rather constant correspond throw catch repres ordinari variabl bind mechan scope binder lexic 2 introduc tagabstract tagappl mechan exist common lisp 2 motiv recov express lost chang scope rule catchconstruct let us see exampl written nakano style defun multipli x catch zero multiply2 x zero defun multiply2 x u null x 1 car x throw u car x multiply2 cdr x u modi program catchconstruct lexic scope scope tag zero multiply2 x zero throw object anoth function multiply2 function abstract tag variabl u use function multiply2 must provid tag zero second paramet nakano also introduc new type constructor call otherwis tag abstract mechan term type u tagvari type b abstract u type b characterist point nakano formul 1 l ct restrict side condit implicationintroduct rule exclud term correspond classic proof actual l ct correspond intuitionist calculu curryhoward isomorph 2 l ct allow mani reduct possibl henc nondeterminist con uent two featur may look strang sinc classic logic said essenti noncon uent intuitionist logic con uent 3 consid classic version l ct obtain remov restrict natur calculu suitabl extract algorithm mean classic proof call l k ct classic version l ct 1 similarli except mechan standard ml dynam scope 2 except mechan standard ml abstractionappl 3 refer girard 6 parigot 15 discuss con uenc classic logic year later nakano second author sato propos anoth formul catchthrow mechan 17 motiv elimin type tag abstract otherwis l ct sinc equival disjunct unifi throwexpress tagabstract mechan obtain simpler calculu nj ct also show l ct interpret nj ct nj ct essenti restrict implicationintroduct rule henc correspond intuitionist logic also dene nk ct throw away restrict show correspond classic logic summari propos four calculi catchthrow mechan author intuitionist logic classic logic nakano l ct l k ct sato nj ct nk ct paper investig strong normaliz sn four calculi particular l k ct nk ct sn l ct prove nakano 14 proof base complex modeltheoret argument previou work prove sn nj ct 8 sn larg fragment l k ct 9 sn full fragment classic calculi l k ct nk ct open problem paper solv problem arm way rst formul nondeterminist variant parigot calculu ad sever reduct rule prove strong normaliz use reduc method translat catchthrow calculi variant sinc translat preserv type well reduct obtain proof strong normaliz four calculi nalli brie discuss secondord extens 2 catchthrow calculi 21 nakano formul nakano propos sever calculi catchthrow mechan among l ct given 14 strongest one paper also studi l k ct extens l ct although nakano present l k ct publish paper latter obtain l ct simpli throw away restrict implic introduct rule therefor regard l k ct one nakano calculi follow shall dene l k ct mention dierenc l k ct l ct assum nite mani atom type use k metavari atom includ falsiti denit 21 type denit type function space product sum curryhoward isomorph may identifi logic connect implic conjunct disjunct connect introduc give type tag abstract usual abbrevi assum type innit mani individu variabl x type innit mani tag variabl u type use x z individu variabl u v w tag variabl regard u u b dierent tag variabl 6 b impli may sometim use variablenam dierent entiti dierent type preterm l ct l k ct dene follow denit 22 preterm among preterm construct catch throw tapp introduc nakano repres catch throw mechan refer follow tabl correspond similar construct common lisp standard ml ct common lisp standard ml note introduct tag common lisp except name standard ml repres tagvari rather constant preterm ut tagabstract mechan like abstract xt preterm tappt u tagappl mechan 4 like function applic applyt u sometim omit type variabl also write applya b ab individu variabl bound construct caseconstruct tag variabl bound catchconstruct construct identifi two term equival renam bound individualtag variabl fvt ftvt denot set free individu variabl set free tag variabl respect type infer rule given natur deduct style list tabl 1 infer rule use deriv judgment form nite set form fx g nite set form g set understand variabl appear context individu variabl context tag variabl l ct implicationintroduct rule mark restrict free tag variabl b l k ct restrict intuitionist calculu l ct preterm x b welltyp x essenti occur scope throwconstruct b one nakano main result restrict neatli correspond intuitionist proposit calculu curryhoward isomorph actual actual nakano use word tapp rather simpli wrote tu tappt u paper use dierent function symbol dierent termconstruct clarifi syntax tabl type infer rule l ct l k ct restrict complex due exist caseconstruct paper give precis denit essenti occurr refer 11 14 detail among infer rule rst ten standard rule throw catch ect intend semant name abort current context term type regardless type b type catchu also type possibl thrown term term u b tagabstract assign new type b convers type b appli tag variabl u b gener term type exampl type infer follow correspond doubl negat ag one type infer gure l k ct l ct format x throwu x abstract variabl x occur free throwu nakano restrict let b c metavari term deriv infer rule say term type context onestep reduct rule l ct l k ct given tabl 2 tabl onestep reduct rule l ct l k ct 6 x x 2 fv denit c repres context hole dene usual also substitut abx avu dene usual instanc follow reduct tappvthrowv instead onestep reduct like catchu athrowu bx 1 b catchthrow mechan split two step follow sinc restrict evalu strategi reduct l k ct nondeterminist moreov con uent instanc follow reduct sequenc put catchu dene b zero step reduct b one step reduct usual theorem 21 nakano subject reduct properti hold l ct l k ct 22 sato formul 17 sato propos anoth formul catchthrow mechan primari motiv get rid logic connect l k ct yet obtain system power l k ct logic point view redund sinc equival disjunct sato success elimin calculu unifi two binder tag variabl catch shall give denit nk ct follow nj ct obtain nk ct restrict introduct rule way l ct l k ct type l ct delet preterm dene follow denit 23 preterm individu variabl bound caseconstruct tag variabl bound construct construct replac catch l ct construct replac throw l ct tapplyconstruct replac tapp l ct type infer rule new construct given tabl 3 tabl type infer rule nj ct nk ct infer rule construct throw l ct term u may construct even type dier b mean u b comput end normal return 0 return inj 1 0 term b thrown comput return inj 2 b henc u b type b type tapplyconstruct may dicult understand invers oper tag abstract tapplyu b reduc av b u b type infer rule construct calculu restrict implic introduct rule call nj ct one without restrict nk ct former correspond intuitionist logic latter classic logic onestep reduct rule new construct given follow u 62 ftva last reduct may look strang use write concis proof 17 necessari simul reduct tappva u 1 auv l ct l k ct theorem 22 sato subject reduct properti hold nj ct nk ct 23 nondetermin classic logic four calculi catchthrow mechan nondeterminist reduct rule con uent think defect 1 far strong normaliz concern good mani reduct rule possibl corollari strong normaliz strongest calculu obtain strong normaliz subcalculu 2 classic logic said inher nondeterminist order express possibl comput classic proof calculu nondeterminist later choos one answer xing evalu strategi murthi gave exampl show classic proof may contain multipl comput mean 10 second author show 18 murthi exampl express nk ct style calculu 3 nondeterminist variant parigot section give nondeterminist variant parigot target translat catchthrow calculi parigot calculu 16 secondord proposit calculu classic logic naturaldeduct system whose sequent multipl consequ calculu quit nice formul classic logic time comput interest sinc variou control structur repres construct whose type given follow import reduct rule construct call structur reduct afc cbg term obtain substitut cb everi subterm form c free refer 16 denit calculu simul simpli version catchthrow mechan l k ct construct follow catchu uua throwu vua v appear ua howev catchthrow calculi consid con uent moreov one term reduc dierent variabl x saw previou section sinc calculu con uent calculu direct simul catchthrow calculi possibl possibl solut add reduct instanc callbyvalu version structur reduct symmetr structur reduct howev known system structur reduct symmetr structur reduct strongli normal 5 instead naiv ad reduct rule slightli modifi calculu add nondeterminist reduct name classifi use three case 1 uua 2 uva u 62 ftvva 3 uva u 6 v u 2 ftva need 1 2 simul catchconstruct throwconstruct respec tive need extend reduct rule 2 reduct rule 1 remain need 3 simul catchthrow calculi term construct exclud anoth modic calculu longer distinct individu variabl tag variabl name term ua repres ordinari applic ua modic directli abstract variabl correspond name key simul tagabstractiontag applic mechan l k ct represent essenti due de groot 3 formal except mechan ml fujita 4 recent studi similar calculu except mechan notat conveni write ua term uua abortva term uva also extend reduct rule abortconstruct nondeterminist featur call result system nd 31 nondeterminist calculu nd type nd dene follow denit 31 type recent fujita5 indic system shown strongli normal translat barbanera berardi symmetr calculu restrict system rstorder howev need secondord version paper sinc nd secondord type redund logic point view howev includ primit type sinc want interpret dierent 8xx type variabl x bound type abstract 8x identifi two type ident modulo renam bound type variabl abbrevi preterm follow note adopt currystyl implicit type nd calculu 6 henc attach type variabl consid reduct rule denit 32 preterm contrari origin one sort variabl variabl x may use ordinari variabl also name tagvari sens also distinct ordinari term name term variabl bound construct identifi two term dier bound variabl preterm abortt new nd explain judgment nd form nite set form g type infer rule deriv judgment shown tabl tabl type infer rule nd 8introduct rule mark x may occur freeli deriv use rule say typabl term type sometim written reduct rule deriv calculu ad sever rule abort make nd nondeterminist sinc shall use substitut 6 16 parigot also dene churchstyl system tabl onestep reduct rule nd form xuxbu mani time abbrevi b u use notat alway assum x fresh variabl also abbrevi composit substitut often write b sequenc hb 1 b n henc success applic ab 1 b n abbrevi b success substitut last case assum b 1 b n contain u free also use simultan substitut b 1 x um mutual distinct c contain u use notat b b follow lemma prove easili lemma 31 let substitut b 1 x um b b 32 strong normaliz nd subsect prove strong normaliz sn nd proof slight modic parigot origin proof sn nevertheless give proof complet let set preterm nd sn set strongli normal preterm nd note restrict nd subset typabl term follow 16 maximum length reduct sequenc start 2 sn unden 62 sn f let f set nite sequenc element f name particular f contain empti sequenc hi let f g subset subset introduc follow notat special case g denit 33 reduc candid reduc candid subset induct dene follow 1 sn reduc candid 2 f g reduc candid f g 3 ff g i2i famili reduc candid nonempti set reduc candid note index set may innit set reduc candid denot rc lemma 32 f 2 rc follow four claus hold 1 f sn 2 variabl contain f 3 2 sn aborta 2 f 4 exist set sn claus 3 ad parigot origin proof mean aborta strongli normal term contain reduc candid main dierenc proof parigot case term form caborta may reduc aborta alway consid aborta reduct howev term contain reduc candid strongli normal lemma therefor alway handl term easili proof prove four claus simultan induct f 2 rc case f sn claus 4 prove take fhig claus trivial case f g induct hypothesi abbrevi ih x prove claus 1 ih g sn exist set 0 sn take g g prove claus 4 let x variabl 2 sn b sinc reduct form xb 0 n abortdbk1 b 0 prove claus 2 also abortab prove claus 3 case f easili prove ih also ih sn g prove claus 4 ut claus 4 lemma put f largest name preterm neutral either variabl form bc lemma 33 f 2 rc follow two claus hold 1 2 f 1 0 0 2 f 2 neutral 0 2 f 0 1 0 2 f proof lemma prove induct f 2 rc key case f g h shall prove claus 2 suppos neutral 0 2 g h 0 1 0 take arbitrari preterm b 2 g shall prove ab 2 h induct b sinc b sn preterm ab reduc one step either one 0 b 1 0 ab 00 abortcx abortd b b 00 abortdx easili prove four term belong h ih ab 2 h consequ 2 g h ut denit 34 interpret type interpret map type variabl reduc candid note exist interpret map type variabl sn interpret natur extend type follow way interpret fx dene 6 x lemma 34 let b type interpret lemma prove induct structur lemma 35 let f 2 rc x u variabl b term c sequenc term 1 abx 2 f b sn xab 2 f 2 u ad udc 2 sn c 3 c 4 2 sn u 2 sn proof 1 prove claus induct abx b use lemma 31 lemma 33 must take care reduct xab may form abortc case treat use claus 3 lemma 32 2 prove claus induct u ad udc 3 claus 1 prove ubc 2 sn b 2 f sinc 4 prove analyz reduct rule ut theorem 31 assum deriv nd assum also interpret b rst look statement theorem look ambigu instanc given proof x c may split lefthand side two way result follow conclus hold b 1 2 c b 2 2 hold b 2 c c 2 actual theorem impli hold ambigu aris state proof theorem proof theorem prove induct type infer let substitut b 1 x case assumptionrul case x prove x 2 two subcas x x c x b assumpt b 2 c x 2 ii x u x zu zc lemma 35 x 2 case introduct case x c b c c term type c suitabl renam x c take 2 b ih henc lemma 35 x cd 2 c henc c case elimin case bc henc bc 2 case 8introduct case 8x b b deriv let f 2 rc 0 fx sinc type variabl x occur freeli b henc ih 2 0 b final 2 8x b case 8elimin case 8x b bcx 2 8x b ih henc 2 cxb lemma 34 2 bcx case introduct case ub b suitabl renam u b ih henc b 0 c 2 sn therefor claus 4 lemma 35 u b 0 c 2 sn claus 2 lemma 35 u bc 2 sn consequ case elimin case abortb ih b 2 32 abortb 2 ut choos x theorem obtain 2 term type interpret sinc exist interpret sn follow theorem corollari 31 nd strongli normal 4 translat catchthrow calculi nd section give translat catchthrow calculi nd follow give translat classic catchthrow calculi l k ct nk ct translat work also l ct nj ct sinc subcalculi 41 translat nakano calculu shall translat l k ct nd translat standard encod proposit logic secondord logic except catchthrowconstruct first translat type l k ct variabl nd point type ab translat b translat ect intent abstract translat abstract translat preterm l k ct nd assum individu variabl x l k ct x variabl nd tag variabl u l k ct u variabl nd also assum map variabl inject preterm translat follow x x aborta aborta x xa ab ab axyx xyxa tappa translat extend context variabl follow way let context individu variabl fx 1 context tag variabl l k ct dene note type tag variabl negat translat translat preserv type reduct shall see lemma 41 preserv type assign deriv l k ct deriv nd proof sinc translat proposit connect standard verifi case ih sinc fu ag fu ag ua deriv fu ag catchu introduct rule throw ih sinc fu ag abortua deriv elimin rule elimin rule ih sinc b b deriv introduct rule tapp ih elimin rule deriv lemma 42 translat compat substitut name abx abx av b avu lemma prove straightforward induct construct omit lemma 43 preserv reduct b typabl term 1 b l k ct b nd proof lemma prove induct structur term prove key case 1 6 x x 2 fva lemma 42 athrowu bx aabortubx induct term aabortcx abortc c aabortubx abortub 2 catchu 1 u 62 ftva sinc u 62 fv catchu ua 1 3 catchu throwu catchu throwu uabortua u 62 fva 4 tappua tappua v uav reduc avu lemma 42 avu avu henc done ut lemma follow theorem theorem 41 system l k ct strongli normal henc l ct strongli normal remark translat l k ct nd realli need second order quantier name elimin 8 add nd translat ct modi calculu sinc prove sn modi calculu elementari method 16 also prove sn l k ct elementari method howev need second order quantier 8 translat nk ct shall see next section therefor prove sn l k ct base reduc method 42 translat sato calculu subsect translat nk ct nd dene translat tri give naiv translat nk ct l k ct explain fail natur candid translat type tapplya type c suppli type infer term moment let us ignor obtain c translat interpret one reduct rule nk ct except follow one lefthand side interpret tapplyua v casecatchu inj 1 necessarili reduc avu henc naiv translat nk ct ct fail moreov seem dicult nd suitabl extens l k ct strongli normal reduc term avu howev situat chang consid secondord calculu disjunct type primit dene b shall see later term tapplyua v reduc avu encod let us dene translat nk ct nd translat type translat l k ct nd translat preterm except translat new construct dene follow tapplya assum x use term translat may look complex result secondord encod naiv translat nk ct ct translat extend context individu variabl way context tag variabl need chang translat sinc tag variabl type b translat variabl type c b c type bodi enclos express word determin type c reach enclos express solv problem introduc map set tag variabl nk ct set type nd make translat context tag variabl depend let context tag variabl fu b1 g map fu b1 n g type nd dene denit 0 abbrevi dene c 0 8x result translat lemma 44 preserv type assign deriv nk ct map whose domain contain tag variabl deriv nd proof prove induct deriv verifi key case deriv fix map suppos otherwis proof shorter 0 bg let 0 map 0 v v v 6 u 0 u ih deriv 0 0 bg also fact deriv desir type infer introduct rule deriv fix ih deriv b abortuxyya deriv desir type infer elimin rule deriv ih deriv b bg tapplya u b axxyabortuzwwi calcul type term deriv desir type infer ut next lemma use prove preserv reduct translat lemma 45 let typabl term nk ct let substitut xvxt 1 2 v v result translat tag variabl v b nk ct 1 xx 2 yabortuzwwi auv nd proof prove lemma induct structur term state key case case v follow reduct sequenc case tapplyb v b follow reduct sequenc lemma 46 preserv reduct b typabl term 1 b nd b nd proof check key case tapplyexpress follow put 1 xx 2 yabortuzwwi 1 tapplyinj 1 tapplyinj 1 2 tapplyinj 2 tapplyinj 2 abortuzwwa last term u b 3 tapplyva u tapplyva u vzwzat 1 2 auv henc desir properti ut lemma follow theorem theorem 42 system nk ct henc nj ct strongli normal remark proof use second order quantier 8 indispens give translat nk ct sinc nk ct rstorder system one may think proof use strong method sn nk ct could prove elementari method present answer question trial appli elementari method nk ct success 5 extens catchthrow calculi given translat nd easi introduc secondord quantier four catchthrow calculi without loss nice properti strong normal sinc catchthrow calculi formul churchstyl variabl explicitli label type introduc termconstruct type abstractionappl usual let xa denot former ax latter type rule given follow 8introduct rule mark x may occur freeli also reduct rule xab 1 abx ad ad rule l k ct obtain secondord catchthrow calculu l k2 ct similarli obtain nk 2 ct calculi l k2 ct nk 2 ct enjoy nice properti subject reduct strong normal brie mention express calculi structur integ binari tree encod secondord quantier 6 dene function catchthrow mechan variou data type extend calculi instanc function multipli mention type follow int uufttuuf intlist wwfttwwf timesa b multipl two integ b dene usual int intlist iter type int intlist term int zb x x 62 fv b ifthenels express name reduc x 0 b otherwis easili seen function multipli comput one given introduct sinc represent free structur good comput 6 may consid anoth direct extens name may add induct data type 8 rst author alreadi propos add induct data type nj ct without loss sn calculu show higherord function use catchthrow mechan repres extend calculu howev fulli studi direct classic catchthrow calculi left futur work 6 conclud remark investig four catchthrow calculi nakano sato particular calculi correspond classic logic curryhoward isomorph dene nondeterminist variant parigot calculu prove strong normaliz variant gave faith translat catchthrow calculi variant corollari obtain strong normaliz four calculi also discuss extens brie recent fujita 4 studi exc callbynam variant de groot formul except mechan standard ml calculu subcalculu rstorder version calculu sinc catchthrow mechan except mechan essenti motiv similar main dierenc calculu nd 1 calculu con uent nondeterminist comput 2 use rstorder version actual implic use secondord version 3 calculu two sort variabl reminisc individu variabl tag variabl use one sort variabl thu directli abstract tag crolard 2 also studi con uent calculu catchthrow mechan sinc calculu translat parigot calculu similar fujita formul thu dier calculi studi paper extract algorithm content classic proof quit activ research area mani research area aim obtain con uent calculi classic logic howev classic logic said inher nondeterminist name classic proof may contain multipl comput mean therefor want repres mani comput mean possibl natur begin nondeterminist calculi approach design studi nondeterminist calculi rst studi con uent subcalculi believ catchthrow calculi present paper good basi approach barbanera berardi calculu 1 anoth nondeterminist calculu classic proof calculu could also good basi studi extract comput mean classic proof left futur work acknowledg would like express heart thank hiroshi nakano makoto tatsuta izumi takeuti help comment earlier work also thank kenetsu fujita point refer error anonym refere valuabl comment improv author support part grantinaid scientic research ministri educ scienc cultur japan 09780266 10143105 r proof type cambridg univers press classic catchthrow calculu tag abstract strong normaliz tr common lisp languag proof type formulaeastyp notion control intuitionist classic natur deduct system catch throw rule lambdamycalculu extract construct content classic logic via controllik reduct simpl calculu except handl classic brouwerheytingkolmogorov interpret ctr emmanuel beffara vincent dano disjunct normal form local except acm sigplan notic v38 n9 p203211 septemb