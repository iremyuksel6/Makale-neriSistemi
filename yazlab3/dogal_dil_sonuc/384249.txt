fast prioriti queue cach memori cach hierarchi preval today high perform processor taken account order design algorithm perform well practic paper advoc adapt extern memori algorithm purpos idea practic issu involv exemplifi engin fast prioriti queue suit extern memori cach memori base ikiway merg improv previou extern memori algorithm constant factor crucial transfer cach memori run cach hierarchi workstat algorithm least two time faster optim implement binari heap 4ari heap larg input b introduct mainstream model comput use algorithm design last half centuri 18 assum sequenti processor unit memori access cost howev mainstream comput sit desktop increasingli deviat model last decad 10 11 13 17 19 particular usual distinguish least four level memori hierarchi file multiport regist access parallel everi clockcycl firstlevel cach still access everi one two clockcycl parallel port achiev high throughput pipelin therefor instruct level parallel superscalar processor work best instruct use regist current firstlevel cach quit small 864kb order abl keep chip close execut unit secondlevel cach consider larger also order magnitud higher latenc offchip size mainli constrain high cost fast static ram main memori build high densiti low cost dynam ram includ overhead cach miss memori latenc translat logic virtual physic memori address main memori access two order magnitud slower first level cach hit machin separ cach data code disregard instruct read long program remain reason short although technolog detail like chang futur physic principl impli fast memori must small like expens slower memori live memori hierarchi talk sequenti algorithm larg input gener approach paper model one cach level main memori singl disk singl processor variant extern memori model 22 model assum intern memori size access extern memori transfer block size b use word pair cach line memori block cach intern memori main memori extern memori io cach fault synonym context indic otherwis formal limit compar extern memori cach fix replac strategi anoth paper show rel littl influenc algorithm kind consid nevertheless henceforth use term cach memori order make clear differ model despit farreach analog extern memori cach memori number addit differ note sinc speed gap cach main memori usual smaller gap main memori disk care also analyz work perform intern ratio main memori size first level cach size much larger disk space intern memori therefor prefer algorithm use cach econom possibl final also discuss remain level memori hierarchi inform order keep analysi focuss import aspect section 2 present basic algorithm sequenc heap data structur prioriti queue 1 algorithm analyz section 3 use extern memori model thetam k thetamb constant perform insert deletemin use i2rb log mo1 key comparison anoth paper show similar bound hold cach memori away associ cach k reduc ob 1a section 4 present refin take level memori hierarchi account ensur almost optim memori effici amort work perform oper depend current queue size rather total number oper section 5 discuss implement algorithm sever architectur compar result prioriti queue data structur previous found effici practic name binari heap 4ari heap relat work extern memori algorithm well establish branch algorithm eg 21 20 extern memori heap teuhola wegner 23 fish spear data structur 9 need thetab less io tradit prioriti queue like binari heap buffer search tree 1 first extern memori prioriti data structur repres total order set support insert element delet minim element queue reduc number io anoth factor thetalog lower bound oib log mb im io oper amort use fullfledg search tree implement prioriti queue may consid wast heaplik data structur brodal katajainen crauser et al fadel et al 3 7 8 directli gear prioriti queue achiev asymptot bound one 3 even per oper amort sens sequenc heap similar particular consid simplif reengin improv arrayheap 7 howev sequenc heap ioeffici factor three 1 3 7 8 need factor two less memori 1 7 8 2 algorithm merg k sort sequenc one sort sequenc kway merg io effici subroutin use sort extern 14 cach memori 16 basic idea sequenc heap adapt kway merg relat dynam problem prioriti queue let us start simpl case km insert take place size buffer fit fast memori data structur could consist k sort sequenc length use kway merg delet batch smallest element k sort sequenc next delet serv buffer constant time allow arbitrari mix insert delet maintain separ binari heap size hold recent insert element delet check whether smallest element come insert buffer buffer full sort result sequenc becom one sequenc kway merg point sequenc heap earlier data structur 3 7 8 almost ident differ relat question handl km element increas beyond sinc insert heap would fit fast memori arbitrarili increas k sinc eventu kway merg would start incur cach fault sequenc heap use approach make room merg k sequenc produc larger sequenc size km 3 7 question aris handl larger sequenc adopt approach use improv arrayheap 7 employ r merg group g hold k sequenc size mk igamma1 group g overflow sequenc merg result sequenc put group g i1 group equip group buffer size allow batch delet sequenc smallest element buffer delet batch size 0 store delet buffer fig 1 summar data structur enough inform explain delet work deletemin smallest element delet buffer insert buffer compar smaller one delet return empti delet buffer refil group buffer use rway merg kmerg kmerg kmerg rmerg insert heap mk buffer 3 group group buffer 1 mt group buffer 2 delet buffer fig 1 overview data structur sequenc heap refil group buffer less 0 element refil sequenc group group nonempti deletemin work correctli provid data structur fulfil heap prop erti ie element group buffer smaller element delet buffer turn element sort sequenc smaller element respect group buffer maintain invari main difficulti implement insert insert new element insert insert heap size reach element sort eg use merg sort heap sort result merg concaten delet buffer group buffer 1 smallest result element replac delet buffer group buffer 1 remain element form new sequenc length new sequenc final insert free slot group g 1 free slot initi g 1 empti merg sequenc singl sequenc size km put g 2 strategi use recurs necessari group gr overflow r increment new group creat sequenc move one group heap properti may violat therefor g 1 g empti group buffer 1 i1 merg put g 1 latter measur one differ improv array heap invari maintain merg new sequenc group buffer measur almost halv number requir io cach memori speed intern comput matter also crucial implement oper kway merg propos use loser tree variant select tree data structur describ knuth 14 section 541 k 0 nonempti sequenc consist binari tree k 0 leav leaf store pointer current element sequenc current key sequenc perform tournament winner pass tree key loser index leaf store inner node overal winner store addit node root use data structur smallest element identifi replac next element sequenc use dlog comparison less heap size k assum 7 8 would requir address calcul memori refer similar need binari heap noteworthi differ memori locat access loser tree predict case delet binari heap instruct schedul compil place access well data need thu avoid pipelin stall particular combin loop unrol 3 analysi start analysi number io term b paramet arbitrari sequenc insert deletemin oper insert deletemin continu number key comparison measur intern work discuss k 0 chosen extern memori cach memori respect adapt memori effici mani access rel small queue postpon section 4 need follow observ minimum interv tree empti oper sever place lemma 1 group g overflow everi mk proof complic slot group g 1 use invalid group buffer nevertheless group g 1 g contain k sequenc happen insert taken place particular sinc room insert insert buffer simpl upper bound number group need corollari 1 log k upsilon group suffic analyz number io base assumpt follow inform kept intern memori insert heap delet buffer merg buffer size group buffer 1 r loser tree data group gr grgamma1 assum kb unit memori suffic store block k sequenc current access loser tree inform correspond amount space share remain r gamma 2 group data merg r group buffer 2 theorem 1 log k io suffic perform sequenc insert deletemin sequenc heap proof let us first consid io perform element move follow canon data path first insert insert buffer written sequenc group g 1 batch manner ie charg 1b io insert element involv empti group arriv group gr empti oper involv one batch read one batch write ie charg 2r gamma 1b io tree empti oper eventu read group buffer r charg 1b io get charg 2rb io insert remain shown remain io contribut lower order term replac io done canon path element travel group grgamma1 2b io must charg write group buffer later read refil delet buffer howev 2b io save element move group gr pay charg element travel group buffer r gamma 2 addit save compar canon path also pay cost swap loser tree data group g latter cost 2kb divid among least remov one batch group buffer 2 becom invalid must merg group buffer put back group g 1 caus direct cost omb io must charg cost oimb io element thrown back oi step path delet buffer although element may move r group need charg ormb io small sinc mean shortcut origin taken element compar canon path miss remain overhead charg mk gamma 1k j gamma2 insert fill group g igamma1 sum group insert get addit charg similarli invalid group buffer 1 give charg o1k per insert need olog insert new sequenc loser tree data structur done tree 1 amort insert amort mk lemma 1 2 accept o1b io per oper would suffic swap insert buffer plu constant number buffer block one loser tree k sequenc buffer intern memori element move canon path get overal charg olog km overal get charg 2rbo1klogkm per insert estim number key comparison perform believ good measur intern work sinc effici implement prioriti queue comparison model number close number unpredict branch instruct wherea loop control branch usual well predict hardwar compil number key comparison also proport number memori access two type oper often largest impact execut time sinc sever limit instruct parallel superscalar processor order avoid notat overhead round also assum k power two divis mk rgamma1 gener bound would larger small addit term theorem 2 assumpt theorem 1 ilog dlog log 4 0 molog kk key comparison need averag case input log replac o1 proof insert insert buffer take log comparison worst o1 comparison averag everi deletemin oper requir comparison minimum insert buffer delet buffer remain comparison charg insert analog way proof theorem 1 sort insert buffer eg use merg sort take log comparison merg result delet buffer group buffer 1 take comparison insert sequenc loser tree take olog comparison empti group take r gamma 1 log k ork comparison per element element remov insert buffer take log comparison need count sinc save comparison similarli refil group buffer r alreadi account conserv estim group empti cost group gr degre imk comparison per element suffic use similar argument proof theorem 1 shown insert sequenc loser tree lead charg olog km comparison per insert invalid group buffer cost olog kk comparison per insert sum charg made yield bound proven extern memori one would choos anoth paper show k factor ob 1a ffi smaller away associ cach order limit number cach fault 1 ffi time number io perform extern memori algorithm requir togeth small size mani first level cach tlb 3 explain ranslat lookasid buffer store physic posit recent use virtual memori page may live quit small k observ main reason pursu simpl variant array heap describ 7 need singl merg group sequenc merg group would factor r larger howev refin memori manag sequenc heap implement memori effici way repres sequenc group singli link list memori page whenev page run empti push stack free page new page need alloc pop stack necessari stack maintain extern except singl buffer block use page size p extern sequenc sequenc heap r group n element occupi n kpr memori cell togeth measur describ keep number group small becom n kp log k nm page size particularli easi implement sinc also size group buffer insert buffer long guarante asymptot optim memori effici ie memori requir mani oper small queue let n denot queue size ith oper execut earlier algorithm 3 7 8 number io bound ii log k n certain class input ii log k n consider less log k im howev believ applic requir larg queue differ larg enough warrant signific constant factor overhead algorithm complic therefor chosen give detail analysi basic algorithm first outlin adapt yield refin asymptot bound similar 7 new sequenc insert group g free slot first look two sequenc g whose size sum less mk element found sequenc merg yield free slot merg cost charg deletemin caus sequenc get small g empti contain least mk 2 element io involv charg element insert g least size mk igamma1 4 similarli tidi shrink queue r group total size queue fall mk group gr insert result sequenc group grgamma1 free slot group grgamma1 merg two sequenc first regist instruct cach realist case r 4 group therefor instruct cach regist file like larg enough effici support fast rway merg routin refil delet buffer keep current key stream regist second level cach far analysi assum singl cach level still assum level first level cach second level cach may influenc first note group buffer loser tree group buffer like fit second level cach second level cach may also larg enough accommod group g 1 reduc cost 2b io per insert get interest use second level cach assum bandwidth suffici high bottleneck look input delet insert buffer rare eg sort choos size second level cach insert high local log cach line current access fit first level cach oper delet buffer group buffer use random access high bandwidth disk sequenc heap data structur view classic extern memori algorithm would simpli use main memori size measur section 5 indic larg binari heap insert buffer may slow match bandwidth fast parallel disk subsystem case better modifi sequenc heap ooptim cach main memori use special extern memori implement larger group may involv buffer disk block explicit asynchron io call perhap prefetch code random support parallel disk 2 also number io may reduc use larger k insid extern group degrad perform loser tree data structur much insert anoth heap level ie split high degre group sever low degre group connect togeth suffici larg level2 group buffer anoth merg data structur delet nonminim element perform maintain separ sequenc heap delet element deletemin smallest element main queue deletequeu coincid discard herebi insert delet cost one comparison charg delet cost one insert two deletemin note latter much cheaper insert memori overhead kept bound complet sort queue whenev size queue delet element exce fraction size main queue sort oper delet key discard result sort sequenc put group gr sequenc delet heap empti 5 implement experi implement sequenc heap portabl c templat class arbitrari keyvaluepair current sequenc implement singl array perform sequenc heap mainli stem effici implement kway merg use loser tree special routin 2way 3way 4way merg binari heap insert buffer import optim turn roughli order make live compil use sentinel ie dummi element end sequenc heap save special case test loop unrol 51 choos competitor author new code want demonstr use experimen talli great care must taken choos compet code use one best known algorithm least equal well tune chosen implicit binari heap align 4ari heap recent studi 15 two algorithm outperform pointer base data structur splay tree skew heap factor two although latter two perform best older studi 12 least need code insert buffer binari heap code perhap even care remain compon binari heap part code took care assembl code contain unnecessari memori access redund comput reason instruct schedul also use bottom heurist deletemin element first lift minpath root leaf leftmost element put freed leaf final bubbl note binari heap heurist perform log comparison insert plu deletemin averag close lower bound flat memori hard find comparison base algorithm perform significantli better averag case input small queue binari heap factor two faster straightforward nonrecurs adapt textbook formul use cormen leiserson rivest 5 align 4ari heap develop end use basic approach binari heap particular bottom heurist also use main differ data get align cach line complex index comput need sourc code avail electron httpwwwmpisbmpg desandersprogram 52 basic experi although program develop tune sparc processor sequenc heap show similar behavior recent architectur avail measur run code sparc mip alpha intel processor even turn singl paramet set work well machin 4 figur 2 3 4 5 respect show result measur use random valu maxim heap size n oper sequenc insert deletemin insert deletemin insert deletemin n execut normal amort execut time per insertdeleteminpair t6n divid log n sinc algorithm flat memori execut time c log n o1 constant c would expect curv hyperbol form converg 4 tune k perform improv around 10 possibl eg ultra pentiumii better tinsertlog bottom binari heap bottom align 4ari heap sequenc heap fig 2 perform sun ultra10 desktop workstat 300 mhz ultra processor 1stlevel cach use sun workshop c 42 option fast o4501501024 4096 16384 65536 2 tinsertlog bottom binari heap bottom align 4ari heap sequenc heap fig 3 perform 180 mhz mip r10000 processor compil cc r10000 tinsertlog bottom binari heap bottom align 4ari heap sequenc heap fig 4 perform 533 mhz decalpha21164 processor compil g o6501501024 4096 16384 65536 2 tinsertlog bottom binari heap bottom align 4ari heap sequenc heap fig 5 perform 300 mhz intel pentium ii processor compil g o6 constant larg n valu shown averag least 10 trial small input avoid problem due limit clock resolut order minim impact process virtual memori manag warmup run made measur program run almost unload machin sequenc heap show behavior one would expect flat memori cach fault rare influenc execut time much section 54 see decreas time per comparison quit strong input machin binari heap equal fast slightli faster sequenc heap small input heap still fit second level cach perform remain rather stabl even larger queue perform degrad acceler time per comparison grow linearli log n easi explain whenev queue size doubl anoth layer heap fit cach contribut constant number cach fault per deletemin sequenc heap 21 38 time faster binari heap consid differ larg enough consider practic interest furthermor care implement algorithm make unlik perform differ revers tune use differ compil 5 binari heap sequenc heap could slightli improv replac index arithmet arithmet address offset would save singl registertoregist shift instruct per comparison like littl effect superscalar machin furthermor satisfactori perform binari heap small input show larg input time spent memori access overhead code detail littl influenc 53 4ari heap measur figur 2 5 larg agre import observ lamarca ladner 15 sinc number cach fault halv compar binari heap 4ari heap robust behavior larg queue still sequenc heap anoth factor 25 29 faster larg heap sinc reduc number cach fault even howev rel perform binari heap 4ari heap seem complic issu 15 although main concern paper would like offer explan although bottom heurist improv binari heap 4ari heap binari heap profit much binari heap need less instead comparison 4ari heap concern instruct count 4ari 5 exampl older studi heap loser tree may look bad compar pointer base data structur compil gener integ divis oper halv index integ multipl array index heap save memori write instruct need complic index comput appar alpha highest clock speed machin consid save write instruct shorten critic path index comput done parallel slow memori access spill code machin balanc turn direct partic ular intel architectur lack necessari number regist compil gener larg number addit memori access even larg queue handicap never made confus effect jump execut time 4ari heap sparc n 2 20 noth like observ machin effect hard explain cach effect alon sinc input size alreadi well beyond size second level cach suspect problem virtual address translat also haunt binari heap earlier version 54 long oper sequenc worst case analysi predict certain perform degrad number insert much larger size heap n howev fig 6 seen contrari true random keys2060100 tinsertlog fig 6 perform sequenc heap use setup fig 2 use differ oper sequenc insert deletemin insert deletemin insert deletemin 16g essenti get heapsort overhead maintain useless group delet buffer fig 2 use famili instanc 33n heap grow shrink slowli almost two time faster n reason new element tend smaller old element smallest old element long remov therefor mani element never make group g 1 let alon group larger sequenc sinc work perform empti group work save similar local effect observ analyz fishspear data structur 9 binari heap 4ari heap properti even seem get slightli slower local effect work instanc come close worst case 6 discuss sequenc heap may current fastest avail data structur larg comparison base prioriti queue cach extern memori particularli true queue element small need delet arbitrari element decreas key implement approach particular kway merg loser tree also use speed sort algorithm cach memori case sequenc heap still look promis need experi encompass wider rang algorithm usag pattern decid algorithm best exampl monoton queue integ key radix heap look promis either simplifi averag case effici form known calendar queue 4 adapt extern memori radix heap 6 cach memori order reduc cach fault outlin algorithm adapt multipl level memori parallel disk share memori multiprocessor also possibl achiev moder speedup parallel eg one processor insert delet buffer one group refil group buffer processor collect work empti group acknowledg would like thank gerth brodal andrea crauser jyrki katajainen ulrich meyer valuabl suggest ulrich rude univers augsburg provid access alpha processor r buffer tree new techniqu optim ioalgorithm simpl random mergesort parallel disk calendar queue fast o1 prioriti queue implement simul event set problem introduct algorithm perform ledasm effici prioriti queue extern memori extern heap combin effect buffer prioriti queue algorithm comput architectur quantit ap proach empir comparison priorityqueu event set implementa tion 21264 superscalar alpha processor outoford execut art comput program sort search influenc cach perform heap influenc cach perform sort first draft report edvac tpie user manual refer extern memori algorithm algorithm parallel memori two level memori extern heapsort tr empir comparison priorityqueu eventset implement calendar queue fast 01 prioriti queue implement simul event set problem extern heapsort bottomupheapsort new variant heapsort beat averag quicksort italicnital small fishspear prioriti queue algorithm influenc cach perform heap simpl random mergesort parallel disk influenc cach perform sort worstcas externalmemori prioriti queue buffer tree access multipl sequenc set associ cach experiment studi prioriti queue extern memori extern memori algorithm ctr peter sander present data experi algorithm experiment algorithm algorithm design robust effici softwar springerverlag new york inc new york ny 2002 roman dementiev peter sander asynchron parallel disk sort proceed fifteenth annual acm symposium parallel algorithm architectur june 0709 2003 san diego california usa jame fix setassoci cach perform search tree proceed fourteenth annual acmsiam symposium discret algorithm januari 1214 2003 baltimor maryland joonsang park michael penner viktor k prasanna optim graph algorithm improv cach perform ieee transact parallel distribut system v15 n9 p769782 septemb 2004 bernard e moret david bader tandi warnow highperform algorithm engin comput phylogenet journal supercomput v22 n1 p99111 may 2002 gerth stlting brodal rolf fagerberg kristoff vinther engin cacheoblivi sort algorithm journal experiment algorithm jea 12 2007