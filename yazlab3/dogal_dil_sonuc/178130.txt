faster approxim algorithm unit capac concurr flow problem applic rout find spars cut paper describ new algorithm approxim solv concurr multicommod flow problem uniform capac algorithm much faster algorithm discov previous besid import problem right uniformcapac concurr flow problem mani interest applic leighton rao use uniformcapac concurr flow find approxim sparsest cut graph therebi approxim solv wide varieti graph problem includ minimum feedback arc set minimum cut linear arrang minimum area layout howev method appear impract requir solv larg linear program paper show method might practic give om2 log expectedtim random algorithm concurr flow problem medg graph raghavan thompson use uniformcapac concurr flow solv approxim channel width minim problem larg scale integr random algorithm okminnk mnlog nlog k determinist algorithm given problem channel width omegalog n k denot number wire rout nnode medg network b introduct multicommod flow problem involv ship sever differ commod respect sourc sink singl network total amount flow go edg limit capac amount commod wish ship call demand commod optim version problem concurr flow problem goal find maximum percentag z least z percent demand ship without violat capac constraint consid concurr flow problem unit capac observ case problem equival problem find flow disregard capac minim maximum total flow edg congest let n k respect number edg node commod input network paper give algorithm posit ffl find solut whose congest 1 time minimum congest algorithm significantli improv time requir find approxim optim solut one contribut paper introduct random techniqu use iter approxim algorithm techniqu enabl iter carri much quickli use known determinist method part motiv develop algorithm concurr flow deriv two import applic find sparsest cut find vlsi rout minim channel width leighton rao 11 show use solut unitcapac concurr flow problem find approxim sparsest cut graph consequ research develop polylogtimesoptim approxim algorithm wide varieti graph problem includ minimum area vlsi layout minimum cut linear arrang minimum feedback arc set 11 optim linear higherdimension arrang 5 minimum chordal fill 7 singleprocessor schedul 14 comput bottleneck method leighton rao solv unitcapac concurr flow problem commod unit demand appeal linear program techniqu show problem solv polynomi time new approxim algorithm greatli improv result run time theorem 11 fix ffl 0 1 fflfactor approxim unitcapac unitdemand concurr flow problem found random algorithm ok mm log expect time constant depend ffl applic result substanti reduc time requir leighton rao method theorem 12 olog nfactor approxim sparsest cut graph found random algorithm expect om 2 log time previou best run time 45 log n 18 obtain use linear program techniqu fast matrix multipl anoth applic approxim algorithm vlsi rout graph raghavan thompson 13 raghavan 12 consid problem rout twotermin net es sential wire graph approxim minim channel width ie maximum number net rout edg comput bottleneck algorithm solv unitcapac concurr flow problem algorithm requir better constant ffl approxim concurr flow problem fact algorithm theorem 11 fulli polynomi approxim algorithm ie run time depend polynomi ffl gamma1 algorithm type run time random fix ffl omk log n determinist fix ffl omkk log n polyn offl gamma3 mk log 2 n polyn offl gamma2 mkk log 2 n tabl 1 upper bound run time algorithm actual bound slightli better theorem 13 posit ffl 1 least invers polynomi n unitcapac concurr flow problem found random algorithm expect time offl determinist algorithm time applic algorithm theorem 13 signific improv time need solv raghavan thompson problem theorem 14 w min denot minimum achiev channel width w min omegagamma450 rout width w min p w min log n found random algorithm expect time ok 32 log n determinist algorithm time ok min fn kg log n log k algorithm compar favor previou work concurr flow problem formul linear program omk variabl om nk constraint see exampl 15 linear program use solv problem optim polynomi time kapoor gave method speed matrix invers involv karmarkar type algorithm multicommod flow problem combin techniqu vaidya new linear program algorithm use fast matrix multipl 18 yield time bound ok 35 n 3 p unitcapac concurr flow problem integ demand denot sum demand approxim problem shahrokhi matula 15 gave combinatori fulli polynomi approxim scheme unitcapac concurr flow problem call concurr flow problem uniform capac algorithm run onm 7 ffl gamma5 time approach solv concurr flow problem modif framework origin shahrokhi matula 15 idea use length function edg reflect congest iter rerout flow long congest path short less congest path approach differ shahrokhi matula sever way develop framework relax optim condit allow us measur congest local global level therebi give us freedom choos flow path rerout iter exploit freedom use faster random method choos flow path addit framework also allow us achiev greater improv result rerout tabl 1 give upper bound run time algorithm actual bound slightli better tabl given detail remaind paper note use variou combin techniqu obtain slightli better bound state theorem 11 13 earlier version paper appear 9 earlier version case capac demand uniform consid separ gener case capac assum uniform earlier version present fast algorithm first case factor ffl gamma1 slower one gener case version extend algorithm uniform demand case work gener case logarithm slowdown preliminari definit section defin concurr flow problem introduc notat give basic fact regard problem concurr flow variant multicommod flow start give formal definit latter multicommod flow problem problem ship sever differ commod respect sourc sink singl network obey capac constraint precis instanc multicommod flow problem consist undirect graph nonneg capac capvw everi edg vw 2 e specif k commod k specif commod consist sourcesink pair nonneg integ demand di denot maximum demand max total demand number node n number edg number differ sourc k notic k n notat conveni assum n graph g parallel edg edg node v w edg uniqu assumpt denot vw note vw wv denot edg flow f g node node defin collect path associ real valu let p denot collect path g let f p nonneg valu everi p p valu flow thu defin total flow deliv amount flow edg vw feasibl multicommod flow f g consist flow f valu di requir fvw capvw everi edg vw 2 e use denot total amount flow edg vw consid optim version multicommod flow problem call concurr flow problem first defin shahrokhi matula 15 problem object comput maximum possibl valu z feasibl multicommod flow demand z delta di everi 1 k call z throughput multicommod flow equival formul concurr flow problem comput maximum z feasibl flow demand di capac capvwz paper shall focu exclus special case unit capac edg capac equal problem find maximum throughput z reformul special case follow ignor capac find multicommod flow f satisfi demand minim jf ffvwg maximum total flow edg multicommod flow f satisfi demand di ffloptim jf j factor 1 ffl minimum possibl jf j approxim problem associ unitcapac concurr flow problem find ffloptim multicommod flow f shall assum implicitli throughout ffl least invers polynomi n 110 assumpt restrict cover practic everi case interest find ffloptim flow ffl 110 one find 110optim flow find ffloptim flow 1ffl greater polynomi n one run algorithm work arbitrarili small ffl howev run time slower time bound given need manipul number whose size exponenti input howev amount accuraci desir sensibl effici use polynomi time linear program algorithm solv problem exactli one defin analog problem direct graph algorithm correspond time bound easili extend direct case replac undirect edg direct arc path direct path henceforth concentr undirect case linear program dualiti give character optimum solut concurr flow problem let r nonneg length function node v w 2 v let dist v w denot length shortest path v w g respect length function path p shall use p denot length p shall use jj 1 denot vw2e vw sum length edg follow theorem special case linear program dualiti theorem see exampl 15 theorem 21 multicommod flow f satisfi demand di length function dist furthermor multicommod flow f minim jf j exist nonzero length function term equal optim complimentari slack condit given linear program reformul term condit edg path theorem 22 multicommod flow f minimum jf j exist nonzero length function 1 everi edg vw 2 e either 2 everi commod everi path goal algorithm solv approxim problem ie find multicommod flow f length function largest term jf jjj 1 1 within 1 ffl factor smallest term dist di case say f ffloptim note f ffloptim clearli f ffloptim fact multicommod flow f ffloptim exist length function f ffloptim 3 relax optim condit theorem 21 22 give two appar differ character exact optim goal find flow satisfi relax version theorem 21 order introduc relax version theorem 22 complimentari slack condit linear program show relax optim condit suffici show first last term 1 within henc flow f ffloptim notion relax optim analog notion ffloptim use goldberg tarjan context minimumcost flow problem 4 error paramet f multicommod flow length function throughout section shall use ffl 0 denot ffl say path p 2 p commod fflgood fflbad otherwis intuit flow path fflgood short either rel absolut sens ie either almost short shortest possibl small fraction jj 1 use notion defin follow relax optim condit respect flow f length function error paramet ffl r1 everi edg first condit say everi edg either length small fraction sum length edg almost satur second condit say amount flow fflbad path ie long path contribut small fraction sum f delta next two lemma show relax optim condit suffici impli ffl optim first show condit r1 impli first two term 1 close show two condit togeth impli first last term 1 close thu conclud relax optim condit suffici impli ffloptim lemma 31 suppos multicommod flow f length function satisfi relax optim condit r1 vw vw jf jvw two part first part sum term contribut edg satisfi jf j 1 part sum clearli vw fvwvw vw edg whose contribut count first part assumpt vw ffl 0 therefor sum term ffl 0 jf jjj 1 thu impli lemma theorem 32 suppos f ffl satisfi relax optim condit r1 r2 f ffloptim ie jf j factor 1 minimum possibl need estim ratio term inequ 1 theorem 21 lemma 31 estim ratio first two term shall use estim ratio first last term consid penultim term 1 break sum sum fflgood path sum fflbad path relax optim condit us upper bound ffl 0 sum fflbad path definit fflgood path give us follow bound sum fflgood path dist observ minfd kdig bound sum fflgood path dist dist observ exactli k commod last term sum exactli give dist combin bound sum fflbad fflgood path get dist middl equat theorem 21 give bound vw2e fvwvw term jf jjj 1 combin inequ rearrang term get dist combin fraction drop low order term get dist assumpt ffl 110 impli ffl 0 170 turn impli factor 1ffl 0 less 1 ffl combin bound inequ 1 complet proof next two section focu algorithm achiev relax optim condit rerout section describ procedur reduc core approxim algorithm prove bound run time given multicommod flow f procedur reduc modifi f either f becom ffloptim jf j reduc given target valu approxim algorithm present next two section repeatedli call procedur reduc decreas jf j factor 2 ffloptim solut found basic step algorithm choos flow path rerout flow path better path step close resembl basic step algorithm shahrokhi matula 15 main differ way choos path amount flow rerout iter key idea measur good current flow use notion ffloptim describ previou section given flow f valu ff determin later use length function defin reflect congest edg vw word length edg depend flow carri edg given input ffl algorithm reducef ffl oe ff jf j f ffloptim edg vw vw e fffvw call findpathf ffl find fflbad flow path p short path q endpoint p rerout oe unit flow p q return f figur 1 procedur reduc gradual updat f f defin formula becom ffloptim updat done choos fflbad flow path rerout flow path much shorter path respect recomput length function prove paramet ff definit length select relax optim condit r1 alway satisfi iter rerout flow gradual enforc relax optim condit r2 relax optim condit satisfi theorem 32 use infer f ffloptim simplic iof present shall assum valu length function e fffvw edg vw comput one step fvw repres singl comput word section 43 remov assumpt sho suffici comput approxim valu show time requir comput suffici good approxim chang asymptot run time algorithm procedur reduc see figur 1 take input multicommod flow f target valu error paramet ffl flow quantum oe commod requir flow path compris f carri flow integ multipl oe procedur repeatedli rerout unit flow fflbad path commod shortest path need technic granular condit oe small enough everi guarante approxim optim achiev rerout particular assum upon invoc reduc everi commod upon termin procedur output improv multicommod flow f either jf j less target valu f ffloptim recal assum ffl 110 remaind section analyz procedur reduc shown figur 1 first show throughout reduc f satisfi relax optim condit r1 second show granular condit satisfi number iter reduc small third give even smaller bound number iter case flow f offl optim upon invoc reduc bound use section 5 analyz fflscale algorithm present fourth describ effici implement procedur findpath 41 bound number iter reduc lemma 41 f multicommod flow ff 7 flow f length function relax optim condit r1 7 fv w edg vw 2 e let ffl 0 denot ffl 7 observ henc e fff vw use bound ff statement lemma conclud last term least 7m ffl thu vw ffl begin reduc ff set equal 7 long jf j valu ff suffici larg lemma 41 relax optim condit r1 satisfi lucki relax optim condit follow f ffloptim show r2 satisfi make signific progress like shahrokhi matula use jj 1 measur progress lemma 42 suppos oe satisfi granular condit rerout oe unit flow fflbad path commod shortest path endpoint decreas jj 1 fflbad path let q shortest edg whose length chang due rerout b decreas jj 1 also written granular condit definit ff assumpt ffl 110 impli 70 e x 140 x e gammax 140 x thu decreas least140 ffoe observ p give lower bound of140 ffoe p p fflbad must least140 ffoe ffl seen 7ffl impli 139ffl 0 141ffoe therefor first term domin second term thu third term give lower bound decreas jj 1 substitut valu ff use fact execut reduc jf j yield claim lemma follow theorem bound number iter reduc theorem 43 everi commod oe satisfi granular condit jf initi procedur reduc termin offl iter proof theorem 32 impli f satisfi relax optim condit ffloptim lemma 41 relax optim condit r1 maintain throughout iter fact f yet ffloptim impli condit r2 yet satisfi henc exist fflbad path findpath find singl rerout flow fflbad path commod shortest path result reduct jj 1 everi omax log iter reduc jj 1 least constant factor next bound number time jj 1 reduc constant factor let f 0 denot input multicommod flow everi edg vw f 0 vw jf 0 j henc first assign length edg valu jj 1 ffjf 0 j length everi edg remain least 1 jj 1 alway least therefor jj 1 reduc factor e ffjf 0 j time assumpt valu ff prove reduc termin claim number iter theorem 44 suppos input flow f offloptim oe satisfi granular condit initi procedur reduc termin omax iter denot input multicommod flow assumpt f 0 offloptim impli jf everi multicommod flow f therefor valu jj 1 never less e 1offl theorem 43 initi valu jj 1 ffjf 0 j number time jj 1 reduc constant factor offffljf log offffljf 0 choic ff theorem follow proof theorem 43 42 implement iter reduc shown reduc termin small number iter remain show iter carri quickli reduc consist three stepscomput length execut findpath rerout flow discuss comput length section 43 section discuss two step consid time taken procedur findpath give three implement procedur first give simpl determinist implement run ok log n n time sophist implement run time ok n log n final random implement run expect time algorithm use shortestpath algorithm fredman tarjan 3 run om n log n time determinist find bad flow path first comput everi sourc node length shortest path everi node v take ok mn log n time simplest implement comput length everi flow path p compar length length shortest path decid path fflbad could mani flow path consist n edg henc comput length take time decreas time requir findpath find fflbad path one exist without comput length mani path observ fflbad flow path commod longest flow path commod must fflbad thu instead look fflbad path p commod suffic find fflbad path direct graph obtain take flow path p treat path direct away order see fflbad path need comput length longest path direct graph facilit comput shall maintain direct flow graph acycl let g denot flow graph commod g acycl om time dynam program comput suffic comput longest path everi node suppos iter rerout flow fflbad path flow graph g must first updat flow graph g reflect chang second updat might introduc direct cycl g must elimin cycl flow use algorithm due sleator tarjan 16 implement process sleator tarjan gave simpl onm algorithm sophist om log n algorithm problem convert arbitrari flow acycl flow note elimin cycl decreas flow edg increas jj 1 thu bound number iter reduc still hold comput total time requir iter reduc follow order implement findpath must comput shortest path g longest path g everi commod time requir ok rerout must updat appropri flow graph elimin cycl elimin cycl take om log n time combin bound give ok n log nmk log n bound run time findpath fact improv possibl consid flow graph commod sourc flow quantum oe togeth let g voe direct graph obtain take union flow path treat path direct away v g voe acycl om time dynam program comput suffic comput longest path v everi node g voe concurr flow algorithm commod demand flow quantum limit differ flow graph consid want limit number differ demand decompos demand di log di demand sourc sink assum demand power 2 way number differ flow graph maintain k log max lemma 45 total time requir determinist implement iter reduc sume exponenti singl step ok n log n mlogn next give random implement findpath much faster ffl small implement seem simpl enough practic f ffloptim relax optim condit r2 satisfi thu fflbad path contribut least 7 fraction total sum therefor randomli choos flow path p probabl proport contribut sum least ffl 7 chanc select fflbad path furthermor show select candid fflbad path accord right probabl om time comput shortest path endpoint omn log n time enabl us determin whether p fflbad path thu implement findpath offl expect time contribut flow path p sum length p time flow must choos p probabl proport valu order avoid examin flow path explicitli use twostep procedur describ follow lemma lemma 46 choos edg vw probabl proport vwfvw select flow path among path edg vw probabl proport valu flow carri path probabl select given flow path p proport contribut sum select edg vw probabl fvwvwb edg vw select choos path consid commod path choos edg probabl proport vwfvw easili done om time order choos right probabl flow path go edg need data structur organ flow path edg maintain balanc binari tree one leaf flow path edg label flow valu flow path intern node binari tree label total flow valu descend leav number path polynomi n ffl gamma1 therefor use data structur randomli choos flow path given edg olog n time order maintain data structur time chang flow edg must updat binari tree edg cost olog n time one iter reduc flow chang edg therefor time updat log n per call findpath domin time comput singlesourc shortest path shown relax optim condit r2 satisfi probabl least ffl7 find fflbad path om log n time findpath continu pick path either fflbad path found 7ffl trial made observ given f yet ffloptim impli condit r2 yet satisfi probabl failur find fflbad path 7ffl trial bound 1e thu case reduc termin claim f ffloptim probabl least 1 gamma 1e comput length updat flow done log n time thu get follow bound lemma 47 one iter reduc implement randomli time ffl assum exponenti singl step random algorithm stand mont carlo nonzero probabl reduc erron claim termin ffloptim f make algorithm la vega never wrong sometim slow introduc determinist check findpath fail find fflbad path reduc comput sum dist requir precis compar jf jjj 1 determin whether f realli ffloptim loop resum time requir comput sum ok n k singlesourc shortest path comput requir probabl check must done time singl call reduc e total expect contribut run time reduc ok recal bound number iter reduc greater turn least k sinc iter carri least one shortest path comput addit time spent check asymptot increas bound run time reduc conclud section theorem summar run time reduc case particular interest bound run time comput multipli appropri time iter reduc appropri number iter reduc bound depend assumpt exponenti singl step subsect 43 shall show bound achiev without assumpt shall also give effici implement case ffl constant theorem 48 let f oe satisfi granular condit let hk let g follow tabl contain run time variou implement procedur reduc assum exponenti singl step random implement determinist implement polyn polyn f offlopt 43 implement detail section show get rid assumpt exponenti perform singl step also give effici implement procedur reduc case ffl fix 431 remov assumpt exponenti perform o1 time remov assumpt exponenti perform o1 time need two thing first show suffici work edgelength vw approxim actual length show comput approxim edgelength chang asymptot run time algorithm first step note proof lemma 42 never use fact rerout flow onto shortest path need rerout flow onto suffici short path precis easi convert proof lemma 42 proof follow claim lemma 49 suppos oe satisfi granular condit let p flow path commod let q path connect endpoint p length q ffl 0 p 2 greater length shortest path connect endpoint rerout unit flow path p q decreas jj 1 omegagamma oe show order comput length path precis given lemma need comput length edg reason small amount precis lemma 49 length path round error ffl 0 jf j path n edg suffic ensur edg round error 1 bound quantiti jf j maximum flow edg henc must least larg averag flow edg ie jf j vw fvwm everi unit flow contribut total flow least one edg henc combin previou equat get jf jd 1m jj 1 least big length longest edg ie jj 1 e ffjf j plug bound see suffic comput error ffl 0 edg posit length e ffjf j express e ffjf j ae 1 thu need comput ae error ffl 0 nm need comput ologffl gamma1 nm bit assumpt ffl invers polynomi n olog n bit use taylor seri expans e x comput one bit length function o1 time therefor comput length edg iter reduc need om log n time determinist implement reduc iter take least log n time time requir cycl cancel therefor time spent comput length domin run time iter approxim depend current valu jf j may chang iter crucial recomput length everi edg everi iter time om log n would domin run time random implement reduc recal random implement cycl cancel thu need find approxim need recomput everi iter choos one depend current jf j henc need updat edg flow actual chang proceed describ approxim depend rather jf j throughout reduc edg length e least one edg length e ff therefor jj 1 least e ff argument determinist case bit precis suffic throughout reduc first call reduc must spend time comput edg length subsequ iter need updat edg whose length chang sinc iter reduc expect take offl time comput shortest path findpath time updat edg domin time requir findpath appear time initi comput edg length may domin time spent one invoc reduc shall see section 5 whenev algorithm call reduc least omegagammast n iter iter expect take time comput shortest path findpath therefor time spent initi length domin run time reduc note describ random version findpath lemma 46 assum knew exact length howev use approxim length significantli chang path appar contribut sum henc significantli reduc probabl select bad path thu shown without assumpt reduc implement determinist time state theorem 48 although random version addit initi time algorithm paper initi time domin time spent iter reduc theorem 410 time requir determinist implement procedur reduc state theorem 48 hold without assumpt exponenti singl step time requir random implement increas addit factor offl log n without assumpt 432 improv fix ffl section show one reduc time per iter reduc case ffl constant first show use approxim length reduc time requir findpath use approxim shortestpath algorithm run om give improv implement detail iter reduc decreas time requir part reduc describ given length fflbad path p find path q endpoint q dist first discard edg length greater p never path shorter p p shortest path p fflbad path next remain graph comput shortest path use approxim edgelength 2n dvw 2n e thu give us dist approxim dist length actual shortest tpath n gamma 1 edg shortest path edg approxim length ffl 0 p actual length thu know dist sinc shortest path length integ multipl ffl 0 p 2n p use dial implement dijkstra algorithm 2 comput dist implement findpath approxim shortest path comput directli improv time requir determinist implement reduc random implement findpath approxim shortest path comput requir offl expect time order claim iter reduc implement amount time must handl two difficulti updat edg length updat edg tabl flow path flow rerout previous step took log n time domin time findpath reduc time findpath time step domin show carri step time first step show tabl precomput edg length updat constant time second step sketch threelevel data structur allow select random flow path edg time allow constanttim addit delet flow path say comput length e fffvw round fffvw nearest multipl fflc constant c introduc addit multipl error length edg henc addit multipl error 1 offlc path howev argument similar previou subsect still give us suffici precis approxim show round way small enough number possibl valu vw comput begin iter reduc comput length edg simpli look valu precomput tabl largest valu fffvw ever encount offl gamma1 log n sinc concern multipl fflc total offl gamma2 log n valu ever encount begin iter comput number precis olog n bit offl gamma2 log 2 n time comput number comput length edg comput fffvw truncat multipl fflc look valu vw tabl take o1 time thu constant ffl spend olog 2 n address problem maintain edg flow path go edg henceforth describ data structur associ singl edg first suppos flow path carri amount flow ie oe case keep pointer flow path array maintain array onequart empti easi randomli select flow path constant expect time one randomli choos index check whether correspond array entri pointer flow path select flow path tri anoth index one delet flow path array constant time one maintain list empti entri one also insert constant time array get full copi content new array twice size time requir copi amort time requir insert fill array array get empti copi content new array half size time requir copi amort time requir delet empti array see exampl 1 detail descript data structur consid gener case flow valu flow path may vari case use threelevel data structur top level path organ accord start node second level path common start node organ accord end node path start end node may assum belong commod henc carri amount flow thu path organ use array describ first level consist list list item specifi start node total flow flow path start node pointer secondlevel data structur organ flow path given start node secondlevel data structur consist list list item specifi end node total flow flow path end node given start node pointer thirdlevel data structur array contain flow path given start end node analyz time requir maintain data structur ad delet flow path take constant time choos random flow path right probabl accomplish time first randomli choos valu 0 total flow edg scan firstlevel list select appropri item base valu next scan secondlevel list point item select item secondlevel list two step take time final select entri thirdlevel array third level array flow oe thu accomplish o1 expect time scheme describ shown constant ffl three step procedur reduc implement om expect time thu yield follow theorem theorem 411 let f oe satisfi granular condit let hk let g constant ffl 0 procedur reduc implement random omhk oe determinist ohk oemlogn 5 concurr flow algorithm section give approxim algorithm concurr flow problem uniform capac describ two algorithm concurr scalingconcurr concurr simpler best ffl constant scalingconcurr gradual scale ffl right valu faster small ffl algorithm concurr see figur 2 consist sequenc call procedur reduc describ previou section initi flow construct rout commod singl flow path initi set oe call reduc divid flow quantum oe 2 everi commod need satisfi granular condit 3 call reduc modifi multicommod flow f either jf j decreas factor 2 f becom ffloptim procedur reduc set global flag indic whether conclud f ffloptim latter case algorithm termin return flow see olog call reduc suffic achiev ffloptim theorem 51 algorithm concurr find ffloptim multicommod flow log n expect time log n log n immedi initi jf j bound number phase need lower bound minimum valu jf j observ everi multicommod flow f total amount flow network everi unit flow contribut total flow concurrentg ffl fdi commod oe di creat simpl path rout di flow f ffloptim everi oe satisfi granular condit call reducef ffl 2 return f figur 2 procedur concurr least one edg henc therefor impli number iter main loop concurr olog theorem 43 48 procedur reduc invok singl iter concurr first spend om log n time initi edg length execut offl gamma1 minfdkdig iter throughout algorithm oe either equal di thetaffl 2 logmffl gamma1 everi first case min fd kdig ae oe second case min fd kdig logmffl thu total number iter loop reduc offl logmffl time spent initi edg length domin valu halv everi iter therefor total number call requir iter offl gamma1 k log n plu twice number requir last iter concurr follow 4 omegagamma total number iter loop reduc offl gamma1 k log n ffl gamma3 log n consid special case ffl constant use version reduc implement approxim shortest path comput appli bound theorem 411 combin proof similar theorem 51 get follow result theorem 52 constant ffl 0 ffloptim solut unitcapac concurr flow problem found omk log 2 n expect time random algorithm omk log max g log n time determinist algorithm ffl less constant use algorithm scalingconcurr shown figur 3 start larg ffl gradual scale ffl requir valu precis algorithm scalingconcurr start appli algorithm concurr concurr repeatedli divid ffl factor 2 call reduc initi call concurr f 1optim ie jf j twice minimum possibl valu therefor jf j decreas 2 everi subsequ call reduc return ffloptim multicommod flow current valu ffl concurr call reduc use largest flow quantum oe permit granular condit 3 f result flow 2 ffl ffl 0 everi oe satisfi granular condit call reducef ffl oe return f figur 3 procedur scalingconcurr theorem 53 algorithm scalingconcurr find ffloptim multicommod flow expect state theorem 52 call procedur concurr take okm log nm 2 log time return multicommod flow f 1 optim henc jf j twice minimum therefor everi subsequ call reduc return ffloptim multicommod flow f time requir one iter domin call reduc input flow f reduc 2ffloptim theorem 48 410 time requir random implement reduc offl seen max ok ffl gamma2 log valu ffl reduc factor two everi iter therefor total time requir iter twice time requir last iter last iter take ok prove claim consid implement concurr scalingconcurr determinist version reduc time requir findpath depend ffl claim time bound twice time requir last call reduc sinc log ffl gamma1 iter follow theorem theorem 54 ffloptim solut unitcapac concurr flow problem found determinist time okm log 2 nk log ffl log nk n log nmlog nmin fk k log max g 6 two applic section describ two applic unitcapac concurr flow algorithm first applic effici implement leighton rao sparsest cut approxim algorithm 11 second applic approxim minim channel width vlsi rout second problem consid raghavan thompson 13 raghavan 12 start review result leighton rao concern find approxim sparsest cut graph partit node graph g two set b associ cut set edg b ffi b denot number edg cut cut sparsest ffi bjajjbj minim leighton rao 11 gave olog napproxim algorithm find sparsest cut graph appli algorithm obtain polylog timesoptim approxim algorithm wide varieti npcomplet graph problem includ minimum feedback arc set minimum cut linear arrang minimum area layout leighton rao exploit follow connect sparsest cut concurr flow consid allpair multicommod flow g unit demand everi pair node feasibl flow f partit b node g total least jajjbj unit flow must cross cut b consequ one edg must carri least jajjbjffia b flow sparsest cut b leighton rao prove approxim maxflow mincut theorem allpair concurr flow problem show fact lower bound jf j olog n factor minimum valu approxim sparsestcut algorithm make use connect precis given nearli optim length function dual variabl show find partit ab within factor olog n minimum valu jf j henc valu sparsest cut 1 comput bottleneck method solv unitcapac concurr flow problem demand 1 everi pair node paper appeal fact concurr flow formul linear program henc solv polynomi time much effici approach use unitcapac approxim algorithm number commod requir 2 leighton 10 discov techniqu reduc number commod requir show graph edg connect sourcesink pair expand graph result flow problem suffic purpos find approxim sparsest cut call graph demand graph expand partit node set b jaj jbj number commod cross associ cut jaj therefor valu jf j smaller flow problem omegagamma jajffia b sinc jbj n2 follow njf j omegagamma jajjbjffia b smaller flow problem essenti simul origin allpair problem moreov leighton rao sparsestcut algorithm start length function smaller flow problem place allpair problem thu leighton idea allow one find approxim sparsestcut solv much smaller concurr flow problem one will toler small probabl error approxim one use randomli select sourcesink pair commod well known randomli select node pair high probabl result demand graph expand theorem 52 algorithm concurr take expect time om 2 log 2 find appropri solut smaller problem theorem 61 olog nfactor approxim sparsest cut graph found random algorithm om 2 log 2 time second applic discuss approxim minim channel width vlsi rout often vlsi design consist collect modul separ channel modul connect wire rout channel purpos regular channel uniform width desir minim width order minim total area vlsi circuit raghavan thompson 13 give approxim algorithm minim channel width model problem graph problem one must rout wire pair node graph g minim maximum number wire rout edg approxim solv problem first solv concurr flow problem commod demand 1 path need rout optim solut f opt fail algorithm also work edgeweight graph weight translat edg capac correspond concurr flow problem wire rout may consist path fraction flow howev valu jf opt j certainli lower bound minimum channel width raghavan thompson give random method convert fraction flow f opt integr flow increas channel width slightli result wire rout f achiev channel width jf opt j log n 5 w min w min log n w min minimum width fact constant implicit bound quit small later raghavan 12 show convers method made determinist comput bottleneck solv unitcapac concurr flow problem theorem 53 54 applic yield good algorithm w min n substanti better 2 case modifi version algorithm scalingconcurr directli yield integr f satisfi 5 although bigoh constant good 13 consid procedur scalingconcurr consist two part first procedur concurr call achiev 1 optim next scalingconcurr repeatedli call reduc reduc error paramet ffl factor two everi iter till requir accuraci achiev demand everi commod henc oe independ shall denot oe claim w omegagamma207 n oe initi 1 applic need never reduc consequ remain singl path flow per commod random convers method raghavan thompson becom unnecessari show path constitut rout width w min w min log n first suppos call concurr termin granular condit becom fals point jf j2 n assumpt w omegagamma54 n henc jf w min log n assum call concurr termin 1 optim flow proceed scalingconcurr termin granular condit becom fals point inequ 6 impli ffl flow f ffloptim integr jf ow min bound jf j w min w min log requir theorem 62 w min denot minimum possibl width w min omegagamma407 rout width w min log n found random algorithm expect time okm log n log k k 32 mn log n log n determinist algorithm time ok log kk n log nmk log n shown algorithm scalingconcurr find requir rout termin soon granular condit becom fals oe 1 analyz time requir everi throughout algorithm oe number call reduc concurr olog initi jf j k never get 1 1 therefor number iter loop reduc requir 2 case interst wmin olog n error term 5 domin wmin concurr ok log k next proceed scalingconcurr number iter olog k ffl reduc factor two iter ffl start 1 never get 1k iter call reduc turn result ok iter loop reduc time requir one iter loop determinist ok n log n mk log total time find good rout wire ok log kk n log expect time requir random implement reduc om log n n total expect time requir concurr omk log k log n call concurr ffl decreas factor two iter follow total expect time requir iter om log n log ffl gamma1 plu twice time last call reduc last call reduc ffl k log n time requir iter okm log n log log n time domin time requir concurr sinc w min omegagamma200 n impli k n acknowledg grate andrew goldberg tom leighton satish rao david shmoy pravin vaidya help discuss r introduct algorithm algorithm 360 shortest path forest topolog order fibonacci heap use improv network optim algorithm solv minimumcost flow problem success approxi mation approxim algorithm geometr embed plane applic parallel process problem fast algorithm convex quadrat program multicommod flow approxim multicommod flow approxim maxflow mincut theorem uniform multicommod flow problem applic approxim algorithm probabilist construct determinist algorithm approxim pack integ program provabl good rout graph regular array order problem approxim singleprocesssor schedul interv graph complet maximum concurr flow problem data structur dynam tree improv approxim algorithm concurr multicommod flow speed linear program use fast matrix multipl tr ctr suhwen chiou combinatori approxim algorithm concurr flow problem applic comput oper research v32 n4 p10071035 april 2005 xh jia dz du xd hu hj huang dy li optim placement wavelength convert wdm network parallel distribut comput system optic network recent advanc kluwer academ publish norwel 2001 mariechristin costa alain hertz michel mittaz bound heurist shortest capacit path problem journal heurist v8 n4 p449465 juli 2002 anil kamath omri palmon serg plotkin fast approxim algorithm minimum cost multicommod flow proceed sixth annual acmsiam symposium discret algorithm p493501 januari 2224 1995 san francisco california unit state georg karakosta faster approxim scheme fraction multicommod flow problem proceed thirteenth annual acmsiam symposium discret algorithm p166173 januari 0608 2002 san francisco california philip klein hsuehi lu effici approxim algorithm semidefinit program aris max cut color proceed twentyeighth annual acm symposium theori comput p338347 may 2224 1996 philadelphia pennsylvania unit state neal e young random round without solv linear program proceed sixth annual acmsiam symposium discret algorithm p170178 januari 2224 1995 san francisco california unit state david karger serg plotkin ad multipl cost constraint combinatori optim problem applic multicommod flow proceed twentyseventh annual acm symposium theori comput p1825 may 29june 01 1995 la vega nevada unit state matthew andrew kyomin jung alexand stolyar stabil maxweight rout schedul protocol dynam network critic load proceed thirtyninth annual acm symposium theori comput june 1113 2007 san diego california usa ashish goel monika r henzing serg plotkin onlin througputcompetit algorithm multicast rout admiss control proceed ninth annual acmsiam symposium discret algorithm p97106 januari 2527 1998 san francisco california unit state ashish goel monika r henzing serg plotkin onlin throughputcompetit algorithm multicast rout admiss control journal algorithm v55 n1 p120 april 2005 prabhakar raghavan eli upfal effici rout allopt network proceed twentysixth annual acm symposium theori comput p134143 may 2325 1994 montreal quebec canada anil kamath omri palmon serg plotkin rout admiss control gener topolog network poisson arriv proceed seventh annual acmsiam symposium discret algorithm p269278 januari 2830 1996 atlanta georgia unit state lisa fleischer fast approxim scheme fraction cover problem variabl upper bound proceed fifteenth annual acmsiam symposium discret algorithm januari 1114 2004 new orlean louisiana jame aspn yossi azar amo fiat serg plotkin orli waart onlin rout virtual circuit applic load balanc machin schedul journal acm jacm v44 n3 p486504 may 1997 tom leighton satish rao multicommod maxflow mincut theorem use design approxim algorithm journal acm jacm v46 n6 p787832 nov 1999 david r karger clifford stein new approach minimum cut problem journal acm jacm v43 n4 p601640 juli 1996