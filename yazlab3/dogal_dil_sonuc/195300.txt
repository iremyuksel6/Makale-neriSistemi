use special procedur specificationbas analysi reduc runtim cost modular manag tradeoff program structur program effici one difficult problem face softwar engin decompos program abstract simplifi construct mainten softwar result fewer error howev introduct abstract often introduc signific inefficienciesthi paper describ strategi elimin mani ineffici base upon provid altern implement abstract use inform contain formal specif allow compil choos appropri one strategi implement prototyp compil incorpor theorem prove technolog b introduct mani approach program emphas use specif interfac basic idea achiev separ concern client interfac look specif write code use inter need concern specifi behavior achiev implementor job provid implement satisfi specif effici context use practic often happen first implement prove unaccept ineffici must tune chang implement may necessit recompil client client sourc code chang unfortun often occur practic achiev desir effici requir chang inter support part advanc research project agenc depart defens monitor offic naval research research contract n0001492j1795 part nation scienc foundat grant 9115797ccr author address mit lab comput scienc 545 technolog squar cambridg 02139 internet fmtvguttagglcsmitedu appear proceed 1994 acmsigsoft foundat softwar engin confer mapdefin map dom ran r modifi ensur defin r imag alreadi defin chang imag r ran maplookup map dom modifi noth ensur undefin return nullran otherwis return imag figur 1 interfac map r nullran map figur 2 opportun optim map defin bet client code consid follow scenario suppos specif figur implement unsort list mainrang pair invari domain element appear maintain invari implement map defin must invoc search list find domain element defin alreadi client map code look like figur 2 run unnecessarili slowli time spent implement map defin check domain element listwhen call context guarante isnt one convent solut problem extend interfac ad map defineuniqu specifi figur 3 depend upon context call client call either map defin map defineuniqu depend upon whether requir claus map defineuniqu satisfi howev unfortun ramif solv problem way 1 unhappi client wrote code appear figur chang code 2 client notifi encourag look code mapdefineuniqu map dom ran r requir undefin modifi ensur defin r imag figur 3 addit interfac map 3 new opportun bug creat client may call map defineuniqu invari fact satisfi gener procedur nontrivi requir claus avoid possibl 4 solut may appli level abstract suppos exampl map use repres graph map defin call within implement procedur graph addnod call map defin replac one map defineuniqu perhap done node ad new might lead chang graph abstract ad procedur addnewnod etc 5 chang difficult back suppos exampl implement map chang binari tree longer anyth gain call map defineuniqu instead map defin unless one will revisit client code yet interfac maintain better approach origin problem chang implement map defin automat take advantag inform avail call context illustr figur 4 leav client code untouch avoid problem list unfortun rais problem 1 effici gain implement cant runtim test decid case therefor compil must abl decid whether guard true 2 order compil know safe use implement doesnt test membership must abl deduc compil time actual paramet map deduc context call implement map lookup map defin ran creat well beyond capabl contemporari compil paper present approach deal two problem basic idea allow compil take advantag inform contain perhap incomplet formal specif becom possibl superior analysi program text analysi make possibl evalu compil time guard special procedur implement spi one figur 4 turn allow one write client program simpl effici remaind paper deal three question ffl signific opportun improv program perform use spi address question section 2 report analysi legaci code mapdefin map dom ran r pair p p null insertpairmd r return special undefin figur 4 dual implement map defin ffl one go build compil take advantag opportun address question describ section 3 built prototyp implement spi compil section 6 discuss extent implement realiz potenti opportun discuss section 2 ffl much kind work programm take advantag opportun discuss section 4 estim potenti benefit spi examin two exist program neither wrote tri measur much mere introduc spi might improv perform purpos made unrealist assumpt compil would detect opportun use spi section 6 shall see one come surprisingli close satisfi assumpt two program studi perform differ task written differ program languag one program acunifi comput unifi substitut term contain associativecommut oper 22 8000 line comment clu code program sim simul objectori databas 7 7000 line comment c code program key attribut common although care design algorithm effici neither highli tune perform codelevel thu room improv also program wellstructur make good use data abstract made rel easi read understand program 1 profil program identifi hot spot 2 introduc spi speedup hot spot 3 measur speedup assumpt compil would detect opportun use spi reduc time spent hot spot acunifi ad spi three procedur shown figur 5 procedur oper abstract data type spi setinsert avoid check see whether e alreadi repres unsort array without duplic spi mappinginsert similar discuss setelem e elem special e dom r ran signal exist special defin return assignmentvarv signal empti duplic special env contain duplic var figur 5 spi acunifi v variabl signal exist special v defin figur propag spi acunifi introduct spi assignmentcr avoid check see whether env contain duplic var figur 6 contain signatur procedur special propag spi mappinginsert substitut repres mappingvariableterm thu implement substitutionstor call mappinginsert acunifi make substitutiona separ data type maintain invari substitut enforc map procedur figur 5 figur 6 call total 14 call site 14 site nine could safe optim five could optim nine site reduc run time 14 write spi ad neglig amount sourc codeseven line sim ad two spi procedur shown figur 7 oper return refer element dynamicarray userdefin abstract oper caus runtim assert failur index within current array bound first spi elimin low bound check second spi elimin high low bound check gener third spi elimin high bound check would use spi unnecessari hot spot sim optim illustr one common use spisremov unnecessari error check use spi close relat work done 9 17 elimin check mandat sourc languag key differ spi allow compil remov check particular programmersuppli abstract hot spot sim invok oper 12 call site ten requir bound check two requir low bound check unnecessari check elimin run time reduc 14 note sim good exampl bad idea disabl error check condit two check prevent program clobber memori class dynamicarray public element operatorint index const special index low bound special index low bound index high bound figur 7 spi sim intset e int requir modifi ensur e figur 8 speckl procedur specif base integ base integerset figur 9 speckl data type specif section 2 indic signific opportun use spi reduc need trade abstract effici next question address feasibl exploit opportun central problem go build compil detect context spi use subsidiari problem design program languag incorpor formal specif spi relat annot come grip problem built prototyp compil dialect clu 14 call speckl prototyp speckl compil psc incorpor primit autom theorem prove technolog identifi opportun use spi gener code speckl retain clu featur includ static type side effect data abstract garbagecollect heap iter except combin side effect pointer heapalloc data structur requir psc handl alias challeng problem optim compil specif languag portion speckl build larch famili specif languag 10 borrow heavili larchclu languag 21 procedur specif consist pre postcondit written styliz fashion figur 8 specif procedur insert int intset empti requir claus indic precondit vacuou true postcondit intlist e int gener implement repmemb e return end repinsertlast e special implement special repinsertlast e figur 10 dual implement insert combin modifi claus state visibl side effect ensur claus state upon return valu union feg valu call function use pre postcondit eg defin separ languag call larch share languag lsl lsl provid syntax semant specifi function sort first order multisort predic logic speckl also facil write data type speci ficat consist two primari part first part declar whether object type mutabl immut immut object valu throughout program execut wherea mutabl object modifi differ valu differ time declar type immut simplifi analysi code use object type primarili alias issu immut object base claus specifi lsl sort use model valu object type figur 9 contain part specif int intset specif incorpor program languag straightforward add construct express spi speckl allow user suppli multipl implement procedur first implement gener oneit must work correctli call context critic sinc gener one count compil discharg guard special implement sound compil need safe default implement fall back special implement follow gener one prefix special claus claus suppli guard condit written syntax specif lan guag compil must discharg substitut special implement gener one figur show multipl implement procedur insert figur 8 might written final compon need build compil formal model reason program model includ formal program state set proof rule sketch model detail descript model use psc contain 20 model procedur implement repres control flow graph cfg six kind node assign procedur call iter call branch merg loop edg cfg associ program state repres state program control edg program state contain usual kind inform program store program state repres use logic theori avail reason point comput theori built part specif data type use code reason valu program state edg cfg use small set proof rule one six kind node similar hoar floyd rule 4 12 procedur specif come play proof rule procedur call node use specif call procedur defin program state call term program state call interprocedur analysi base propag inform specif procedur say p invok anoth procedur say p1 compil use inform specif p1 optim p use inform deriv code implement p1 optim p organ psc base directli proof rule first psc build cfg use proof rule assign procedur call iter call branch node psc construct logic system edg cfg next use logic system edg tri discharg guard spi step psc use proof rule merg loop node perform autom proofbycas proofbyinduct final psc choos implement associ first guard abl discharg guard discharg choos gener implement reason guard done use equat condit term rewrit earli version psc invok lp 5 theorem prove system prove unsatisfactori current version psc intern theorem prove technolog great deal code borrow lp modifi make suitabl noninteract applic theorem prove experi build use psc leav littl doubt technic feasibl build spi compil difficult question whether benefit compil suffici larg rel effort requir use one effort fall two class ffl suppli program document might normal provid ie specif key interfac abstract function implement data abstract represent modul invari ffl look problem specif well code debug tune perform evalu costbenefit tradeoff import keep mind suppli better qualiti program document sever advantag beyond facilit use spi moreov discuss amount specif requir use spi less suggest good softwar engin practic contrast mani suggest suppli abstract function invari use 8 inform practic usual provid spi compil reli specif bug specif lead optim chang behavior code program run may exhibit behavior explain mere examin code similarli program may exhibit perform explain mere examin code sinc current debug tool design work spi compil bug hard find 41 suppli specif invari abstract function inform found formal specif procedur case speckl iter use help discharg guard spi usual complet specif inform psc actual need minim effort involv use psc design speckl support partial specif procedur iter partial specif weaker pre postcondit intend specif 1 extrem case specif omit entir often part procedur specif need discharg guard spi modifi claus enabl compil approxim omit modifi claus speckl requir data type specifi type mutabl object may contain valu type exampl type set mutabl queue object would specifi contain queue psc use contain claus bound type object reachabl procedur argument turn bound object procedur may modifi test util partial specif deliber wrote weakest partial specif need detect optim acunifi partial specif work well specif necessari 11 roughli 300 procedur acunifi total wrote 69 line specif speckl 139 line small fraction 8000 line comment sourc code furthermor mani lsl specif gener sort integ map sequenc set probabl consid part theorem prove librari partial specif work well two reason first reason modular optim hot spot procedur p compil need procedur specif p procedur call p program decompos mani small procedur fanout call graph small small number procedur specif need optim second reason partial specif work well contain claus modifi claus omit psc could still deduc use approxim use contain claus acunifi psc deduc seven modifi claus essenti four optim addit specif psc sometim need invari abstract function program often reli invari constrain valu data access group procedur psc perform interprocedur analysi may need invari discharg guard spi 1 purpos detect spi distinct partial intend specif unnecessari howev optim perform psc distinct necessari sound abstract function 2 13 map valu use repres abstract type valu abstract type suppos p procedur interfac data type psc use abstract function two way one translat inform precondit p abstract level use ps specif represent level use ps implement make inform avail discharg guard spi ps implement way psc use abstract function propag spi ps implement techniqu explain 20 acunifi psc use abstract function substitut automat propag spi mappinginsert caller substitutionstor thu psc abl optim caller substitutionstor question want explor littl inform need psc perform desir optim therefor provid abstract function invari need enabl optim acunifi psc need represent invari implement map partit tree solut data type abstract function map substitut total requir three line state represent invari seven line state abstract function 42 debug perform tune program compil use spi compil may exhibit behavior perform understood mere examin code mean programm must consid code specif debug perform tune code specif inconsist spi compil may perform unsound optim one way avoid problem detect compil time place code specif may inconsist undecid problem mani occas inconsist found rel easili 3 rel easi exampl flag place formal paramet modifi mutat mutat necessarili violat specif sideeffect may later undon may invis caller good place look bug anoth possibl compil gener programm suppli code check guard special implement debug mode code execut detect place inappropri spi chosen similar assert check suppli anna 15 final compil could direct select turn optim use pinpoint optim trigger chang behavior tune perform first use convent techniqu eg profil local problem identifi code region includ call spi examin output compil see implement chosen one expect need understand experi suggest common caus psc fail choos appropri special implemen abstract function analog reific vdm literatur tation compil limit theorem prove capabl particular sometim fail deduc appropri consequ underli lsl specif one way circumv problem would provid mechan would allow programm insert assert code reluct howev sinc fear wish think often lead insert incorrect assert sounder approach use add implic lemma deduc axiom lsl specif identifi use implic use lp examin logic system point psc fail choos appropri special easi us understand psc lp well other would sure difficulti part solut problem reduc need implic use better theorem prove technolog eg incorpor lp anoth part provid diagnost help user identifi miss implic challeng provid diagnost contain necessari inform concis easi understand spi one varieti techniqu improv program speed introduc specialpurpos code anoth approach inlin procedur call inform call context avail perform tradit optim constant fold essenc form partial evalu spi inlin complementari approach inlin good perform lowlevel optim elimin common subexpress locat differ procedur bodi spi hand good higherlevel optim check whether newli alloc element object member previous exist set object speckl first languag allow user defin optim 11 hisgen present unimpl design strategi base transform rule rather specif defin optim implementor describ transform perform compil transform rule may precondit express use applic sideeffect free function play role analog lsl function thu transform languag suffici power express special procedur fact transform languag express speckl main problem transform rule strategi lack modular appli transform rule compil must reorder program match pattern rule problem commut one procedur call anoth compil must gener reli commut transform rule suppli user maxim compil abil perform transform user must consid pair procedur contrast speckl use modifi claus one per procedureto determin whether procedur call interfer optim common use special procedur elimin runtim check mani focuss elimin check oper primit sourc languag eg array bound check nil check pointer derefer overflow assign supertyp subtyp etc special procedur gener use elimin runtim check primit sourc languag 18 site describ techniqu prove program written languag like algol 60 termin without runtim error requir prove properti suffici elimin runtim check array refer numer oper assign supertyp subtyp etc languag pointer problem alias simpler speckl site simul techniqu manual sever exampl 6 german develop tool verifi absenc runtim error arithmet overflow invalid array indic user write formal specif procedur entri exit assert decor code suffici strong assert verifi discharg assert plu absenc runtim error german work focus defin pascal formal express assert suffici preclud runtim error describ strategi use discharg assert 16 mchugh examin static check gypsi deriv pascal gypsi program environ verifi softwar program typic contain entri exit assert mchugh compil gener optim conjectur discharg ut interact prover 2 result elimin code support exceptionsi broad categori runtim check mchugh describ strategi use prove conjectur 9 gupta reduc overhead array bound check elimin redund check occur code fragment ai ai1 move check loop strategi use reli program languag semant array extend userdefin type current greg nelson david detlef studi way elimin array bound check nil check runtim check modula3 17 6 statu conclus extend program languag clu 14 includ spi use framework outlin section 3 built prototyp compil languag psc identifi sound optim appli addit perform optim base special procedur psc take advantag inform provid specif perform enhanc global common subexpress elimin code motion loop dead code elimin 1 aspect work report 19 20 psc use acunifi program way describ section 2 abl optim nine possibl call result perform improv 14 compil procedur contain nine call site took 105 second dec alpha run 150 mhz unaccept slow psc could easili sped consider clu unusu program languag mani featur eg garbag collect except handl iter found imper program languag help us better understand gener util spi recent began look appli idea context c discuss section 2 seem plenti opportun appli spi context yet implement compil c plu spi therefor sure mani opportun optim identifi section 2 realiz practic compil estim translat relev section sim speckl fed psc psc identifi 14 22 possibl optim improv perform 9 miss optim would brought overal improv 14 psc took 109 second compil procedur contain 22 call site mani year us work like think foundat softwar engin concentr understand creat program appropri function devot rel littl attent understand achiev appropri perform unfortun sinc much complex use program caus desir achiev good perform paper present mechan potenti greatli reduc need trade simplic effici experi convinc us spi use write code clear effici remain seen much effort typic programm must expend realiz advantag acknowledg kathi yelick sanjay ghemawat provid acunifi sim program steve garland help us integr theorem prove psc gener provid help throughout work jim horn provid sound advic sever occas dorothi curti maintain pclu system use implement psc r ut interact prover tool use specif check code assign mean program guid lp verifi absenc common runtim error comput program disk manag objectori databas program methodolog collect articl member ifip wg2 fresh look optim array bound check languag tool formal specif optim userdefin abstract data type program transform approach axiomat basi comput pro gram proof correct data represen tation clu refer manual anna refer manual toward gener effici code verifi program extend static check prove comput program termin cleanli specif make program run faster exploit specif improv program perform gener approach equat uni ficat tr clu refer manual compil principl techniqu tool fresh look optim array bound check languag tool formal specif exploit specif improv program perform lclint axiomat basi comput program specif make program run faster gener approach equat unif twotier approach specifi program toward gener effici code verifi program optim userdefin abstract data type ctr dawson r engler incorpor applic semant control compil proceed confer domainspecif languag confer domainspecif languag dsl 1997 p99 octob 1517 1997 santa barbara california lee lin michael ernst improv adapt multimod system via program steer acm sigsoft softwar engin note v29 n4 juli 2004 dawson r engler interfac compil step toward compil program interfac languag ieee transact softwar engin v25 n3 p387400 may 1999 g griswold richard wolski scott b baden stephen j fink scott r kohn program languag requir next millennium acm comput survey csur v28 n4e dec 1996