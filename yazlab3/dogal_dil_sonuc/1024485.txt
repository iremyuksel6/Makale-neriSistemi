type constraint logic program present prescript type system parametr polymorph subtyp constraint logic program aim type system detect program error static introduc type disciplin constraint logic program modul maintain capabl perform usual coercion constraint domain type metaprogram predic thank exibl subtyp properti subject reduct express consist prescript type system wrt execut model program welltyp deriv start welltyp goal welltyp properti prove wrt abstract execut model constraint program proce accumul constraint wrt enrich execut model type constraint substitut describ implement system type check type infer report experiment result type check isoprolog constraint librari sicstu prolog prolog program b introduct class clpx constraint logic program languag introduc jaar lassez jaar lassez 1987 gener innov featur introduc colmerau prolog ii colmerau 1984 colmerau name comput prolog structur herbrand term inequ constraint coroutin inherit prolog tradit clpx program untyp usual structur interest x howev quit complex combin basic structur may includ integ arithmet real arithmet boolean list herbrand term innit term etc implicit coercion constraint domain like prolog iv colmerau 1996 even earli clpr system jaar lassez 1987 alreadi combin herbrand term arithmet express nonsymmetr way arithmet express may appear herbrand function symbol eg list way around framework mani sort logic jaar lassez 1987 adequ repres type system underli combin forc herbrand function symbol francoi fage emmanuel coqueri uniqu type eg real herbrand term wherea herbrand function use polymorph eg f1 ff1 list constructor list list number 3 type system mycroftokeef mycroft okeef 1984 lakshman reddi 1991 hill topor 1992 adapt logic program rst type system parametr polymorph introduc dama milner function program languag ml system type rst order term type variabl insid type like list express type paramet program dene data structur type list use polymorph homogen list element type type system prolog implement system godel hill lloyd 1994 mercuri somogyi et al 1996 exampl exibl parametr polymorph howev far insuci handl properli coercion constraint domain eg boolean natur number list herbrand term support metaprogram facil logic program metapred functorxfn callg setofxgl semant ground type repres set express subtyp make type system express exibl allow express inclus among set paper investig use subtyp express coercion constraint domain type metaprogram predi cate idea allow subtyp relat like list term atom like functorx jl f n welltyp type declar functor term atom int pred although rst argument list similarli type pred pred freez term pred pred setof pred list pred absenc subtyp relat list 6 pred eect rais type error call predic appli list hand subtyp relat pred term make coercion possibl goal term type system subtyp logic program languag propos descript type system ie purpos describ success set program requir type predic upper approxim denot hand prescript type system type syntact object dene user express intend use function predic symbol program note distinct descript prescript type system orthogon distinct type check type infer possibl approach work consid prescript type system logic program subtyp beierl 1995 dietrich hagl 1988 hanu 1992 hill topor 1992 yardeni et al 1992 smolka 1988 system howev subtyp relat parametr type constructor dierent ariti like list term allow thu use type metaprogram predic design purpos system typic meyer 1996 possess ad hoc mechan type metapred make quit dicult use object propos simpl type system allow uniform treatment prescript type issu constraint logic program prescript type system properti subject reduct express type constraint logic program 3 consist type system wrt execut model program well type deriv start welltyp goal welltyp wellknown result polymorph type system without subtyp mycroft okeef 1984 lakshman reddi 1991 hill topor 1992 subtyp ad pictur absenc xed data ow logic program make obtent similar result problemat beierl beierl 1995 show exist princip type subtyp relat basic type provid type infer algorithm howev beierl also hanu hanu 1992 claim subject reduct system propos gener type kept runtim hanu 1992 yardeni et al 1992 mode introduc restrict data ow dietrich hagl 1988 smau et al 2000 somogyi et al 1996 paper abstract particular structur requir clp scheme studi prescript type system clp program independ specic constraint domain x section 2 present type system includ parametr polymorph subtyp relat type constructor dierent ariti quit gener type structur poset suprema show two subject reduct result one rel abstract execut model constraint program proce accumul constraint proof subject reduct hold independ comput domain assumpt type predic satis denit gener principl lakshman reddi 1991 second subject reduct result rel concret execut model clp substitut step show second form necessari keep runtim type constraint variabl insid welltyp program queri section 3 describ type check algorithm show system subtyp inequ gener type checker leftlinear acycl section 4 present linear time algorithm solv leftlinear acycl system subtyp inequ describ cubic time algorithm pottier pottier 2000a solv gener system inequ addit assumpt type form lattic section 5 present type infer algorithm infer type variabl predic program claus section 6 describ implement avail coqueri 2000 solv subtyp inequ done interfac wallac constrainthandl librari pottier 2000b section 7 report experiment result use implement type check isoprolog librari sicstu prolog includ constraint program librari prolog program type constraint logic program section describ type system logic deriv type judgment clp program 4 francoi fage emmanuel coqueri 21 type type system consid base structur partial order term call poterm use repres type parametr polymorph subtyp polymorph poterm gener rstorder term de nition subsumpt order base function symbol come addit instanti preorder base variabl poterm similar ordersort featur term term aitkaci nasr 1986 smolka 1988 aitkaci et al 1997 nd conveni adopt term syntax match posit instead record syntax match name denot static type set type set term form denumer set u type variabl also call paramet denot nite set constructor k symbol k 2 k ariti 0 associ write km basic type type constructor ariti 0 assum k contain basic type pred type type form k distinct paramet set type variabl type denot v set ground type g set type contain variabl write denot type obtain replac occurr write denot type strictli contain type subexpress size type dene number occurr constructor paramet denot size qualifi kind subtyp allow intuit type subtyp type mean term also term subtyp relat design certain nice algebra properti state proposit assum order type constructor km k 2 k set fk 0 j k k 0 g maximum moreov assum pair km k 0 0 inject map associ kk whenev k k 0 k 00 assumpt mean move hierarchi type constructor ariti decreas hierarchi need lattic poset suprema order type constructor extend covari subtyp order type denot also dene least relat satisfi follow rule par paramet 1 0 contravari type constructor could dene subtyp rule similar rule constr order relat revers argument like eg 0 premis rule argument 0 contravari type constructor consid paper therefor int f loat listint listf loat listf loat 6 type constraint logic program 5 streamoralia atomorlist stream atom lista charact claus byte int float tflag streamcreationopt streamproperti teofactionortyp teofact ttype pred fig 1 part type structur isoprolog listint also listf loat 6 list subtyp order includ instanti preorder intuit ground type repres set express subtyp order ground type correspond set inclus parametr type directli support interpret paramet denot unkown type type structur given gure 21 repres part type use type check isoprolog omit type subtyp atom associ type type special valu option type list parametr type use isoprolog parametr type use type prolog librari array assoc heap etc type substitut idempot map paramet type ident almost everywher applic type substitut dene obviou way proposit 21 type substitut proof structur induct proposit 22 size size proof 6 francoi fage emmanuel coqueri structur induct assumpt k 2 k set fk 0 j k k 0 g maximum togeth ariti decreas assumpt entail exist maximum supertyp type proposit 23 type set f j g maximum denot max proof structur induct mean everi connect compon type root exampl structur like b c b c violat hypothesi b common supertyp serv root connect compon hand assumpt assum impli exist least upper bound type upper bound supquasilattic hypothesi smolka 1989 proposit 24 type max proof structur induct note possibl forget type paramet subtyp relat list term may provid solut inequ form list eg howev proposit 25 inequ form solut inequ form solut proof type size size henc prop 22 6 solut second proposit prove contraposit suppos solut say denit maximum prop 23 henc prop 24 rule subtyp 6 max therefor 62 v max sinc otherwis would contain max strict subexpress imposs 22 welltyp program clp program built denumer set v variabl nite set f function symbol given ariti constant function ariti 0 nite set p program predic constraint predic symbol given ariti contain equal constraint queri q nite sequenc type constraint logic program 7 constraint atom program claus express note q atom form program predic q queri type scheme express form 8 set paramet type assum function symbol f 2 f declar type scheme form 8 ariti f type similarli assum predic symbol p 2 p declar type scheme form 8 pred n ariti p declar type equal constraint symbol 8u u upr notat conveni quantier type scheme result type pred predic omit type declar declar type scheme indic write assum fresh renam paramet occurr f p throughout paper assum k f p xed mean declar type program syntact detail insignic result variabl type map nite subset v written g type system dene welltyp term atom claus rel variabl type u type rule given tabl 1 rule basic consist rule mycroft okeef plu subsumpt rule note sake simplic constraint distinguish atom system substitut atom type substitut head head renam substitut claus queri ua head tabl 1 type system object say term welltyp exist variabl type u 8 francoi fage emmanuel coqueri type u otherwis term illtyp likewis atom etc program welltyp claus welltyp distinct rule head atom express usual denit gener principl lakshman reddi 1991 state type dene occurr predic ie left claus must equival upto renam assign type predic rule head use deriv type head claus thu allow use substitut variabl renam declar type predic exampl predic member type polymorph ie member listpr denit contain special fact like member1 1 would forc type member int listintpr satisfi denitionalgener condit follow proposit show express claus head welltyp variabl type u remain welltyp instanc u proposit 26 variabl type u type judgement r head claus type subtitut u r u r proof induct height deriv tree u r 23 subject reduct wrt csld resolut subject reduct properti evalu rule transform welltyp express anoth welltyp express evalu rule constraint logic program csldresolut recal evalu rule conveni distinguish queri q constraint part c sequenc denot conjunct sequenc atom use notat make distinct given constraint domain x xe interpret constraint queri c 0 jb csldresolv queri cja renam apart program claus constraint c theorem 21 subject reduct csld resolut let p welltyp clpx program q welltyp queri ie u q queri variabl type u q 0 csldresolv q exist variabl type u 0 u 0 q 0 queri proof let us assum without loss gener q 0 csldresolv q program claus pt djb thu q welltyp u cjp queri program well type constraint logic program 9 exist variabl type u 00 renam apart u u 00 pt djb claus pred type declar predic p sinc u ps atom substitut let u proposit 26 u 00 djb queri thu remain shown u henc proposit 26 u 00 therefor u conclud worth note previou result would hold without denit gener condit express rule head exampl two constant pred dene non denit gener claus pa queri pb well type resolv illtyp b upper bound 24 subject reduct wrt substitut csld reduct note csld fact abstract oper reduct may perform also substitut step note instead keep equal constraint clp scheme constraint handl modulo logic equival jaar lassez 1987 clear diagram reduct howev previou subject reduct result express consist type wrt horizont reduct step wrt abstract execut model accumul constraint may hold concret oper constraint solv substitut exampl subtyp relat int term pred term type declar pred intpr program px queri true although queri obtain substitut ptrue illtyp order establish subject reduct substitut step consist semant equival program one need consid type execut model type constraint variabl check runtim exampl int constraint true unsatis queri francoi fage emmanuel coqueri thu reject compiletim check satis type constraint denit 21 given constraint system domain x type constraint system 2 x dene ad type constraint ie express form term type basic type interpret distinguish subset x type constructor map subset x satisfi subtyp relat type declar function predic symbol type exist valuat variabl free paramet 2 type constraint system compos type constraint constraint x satis exist valuat satis constraint system lemma 21 type constraint system proof valuat x 2 denit 22 tclp claus resp queri associ welltyp program resp queri type environ u claus resp queri augment type constraint u theorem 22 subject reduct substitut let p tclp program associ welltyp clpx program q tclp queri u q queri variabl type u q 0 csld resolv q variabl type u 0 associ type constraint q 0 queri furthermor q 0 contain equal constraint queri proof subject reduct csld resolut follow theorem 21 tclp program special case welltyp clp program furthermor one easili check type constraint q 0 come type constraint q resolv tclp claus give exactli type environ u 0 construct proof previou theorem thu u queri let constraint resolv q 0 let constraint part q 0 togeth lemma 21 therefor immedi type rule replac x deriv u 0 q 0 queri complet deriv deriv get deriv u queri eect type constraint tclp program prevent deriv illtyp queri substitut step addit queri true px reject compiletim unsatis constraint similarli tclp program claus unsatis type constraint reject compiletim type constraint logic program 11 note smau et al 2000 anoth result subject reduct substitut shown without addit type constraint restrict context mode logic program 3 type check system describ rule tabl 1 nondeterminist sinc rule sub use anywher type deriv one obtain determinist type checker direct syntax type program simpli replac rule sub variant rule func atom head subtyp relat premis lead follow type system tabl 2 substitut atom type substitut head renam substitut claus queri ua head tabl 2 type system second form proposit 31 program well type origin system well type new one proof clearli program typabl new system typabl origin one one replac everi occurr func atom rule respect follow deriv francoi fage emmanuel coqueri head convers program typabl origin system typabl second one note 2 proof induct type deriv origin system rule var queri claus remain rule atom head similar rule func thu show properti term u rst system u second system 0 let us consid three possibl case either proof termin applic var rule applic func rule applic sub rule rst case trivial rule var system second case accord func rule u induct hypothesi term 1 n also type check n second system 0 appli func rule 0 third case accord sub rule u allow us deduc u induct hypothesi type check u second system sinc 0 0 type check construct substitut need rule func atom head type check done solv system subtyp inequ collect along deriv type judgement paramet type environ ie paramet type variabl howev scope substitut act paramet renam declar function predic symbol thu look type substitut restrict domain sake simplic ever instead deal formal domain type substitut shall simpli assum paramet type variabl replac new constant check satis subtyp inequ avoid unsound instanti let collect subtyp inequ impos type rule atom head deriv let us dene size system inequ number symbol size system inequ associ type program onvd v size type declar type constraint logic program 13 variabl program n size program size type declar function predic symbol type system determinist proposit 32 wellform program typabl system inequ collect along deriv satis worth note system inequ collect way type check fact particular form denit 31 system inequ leftlinear type variabl one occurr left system acycl exist rank function type variabl r u n 2 r r proposit 33 system inequ gener type check algorithm acycl leftlinear proof type variabl type clp variabl renam con stant type variabl occur introduc rule atom head come renam apart type declar function predic symbol thu associ type variabl rank h dene height introduct node deriv tree ie maxim distanc node leav rule func atom head height h post inequ form rank variabl h rank variabl h 1 system thu acycl type variabl left paramet come result type function declar eg nil list result type type variabl result type distinct renam apart henc variabl occur type left uniqu occurr system system thu trivial leftlinear note allow contravari type constructor previou proposit would hold linear time algorithm solv acycl leftlinear system given next section 4 subtyp inequ satis subtyp inequ ssi problem problem determin whether system subtyp relat 1 n 1 ssi problem confus semiun problem dene instanti preorder intead subtyp order 9 undecid semiun shown kfouri et al 1989 14 francoi fage emmanuel coqueri solut ie whether exist substitut 0 hold denit 41 solut inequ 0 substitut 0 maxim solut solut solut 0 exist substitut 8 2 v 0 ssi problem deepli studi function program com muniti due lack result gener case special instanc ssi problem identi along sever axe form type basic type constructor type covari case paper contravari structur type disjoint union lattic tiuryn 1992 quasi lattic smolka 1989 ncrown tiuryn 1992 poset suprema case partial order frey 1997 form type constraint section show type constraint gener type check algorithm solv linear time quit gener structur type type constraint gener type infer algorithm solv cubic time addit assumpt type form lattic 41 acycl leftlinear case show satis acycl leftlinear subtyp inequ decid linear time admit maxim solut gener type structur poset suprema section present algorithm proce simplic subtyp inequ introduc equat paramet type say system solv form contain equat form dierent occurr substitut associ system solv form trivial maxim solut show follow simplic rule comput solv form satis acycl leftlinear system type constraint logic program 15 k k 0 62 v 62 v l l r 2 62 v max lemma 41 rule termin step n sum size term lefthand side inequ proof suce remark rule strictli decreas sum size term lefthand side inequ triv varleft one decomp least one varright size one easili check rule preserv leftlinear well acycl system moreov lemma 42 rule preserv satis system well maxim solut one exist proof rule decomp triv preserv solut denit subtyp order rule varleft replac paramet upper bound system leftlinear comput maxim solut thu preserv maxim solut system one exist rule varright replac paramet occurr lefthand side inequ henc upper bound maximum type lower bound comput maxim solut thu preserv also maxim solut system one exist theorem 41 let acycl leftlinear system let 0 normal form solv form case 0 maxim solut proof consid normal form 0 0 contain non variabl pair 0 inequ irreduc decomp 0 solut henc unsatis lemma 42 similarli 0 solut contain inequ prop 25 inequ 2 v max 6 prop 25 case irreduc acycl 0 contain inequ henc 0 contain equal solv form substitut associ 0 maxim solut francoi fage emmanuel coqueri 42 gener case absenc subtyp relat type constructor dierent ariti check consist gener subtyp inequ nite type shown frey frey 1997 pspacecomplet arbitrari poset gener fuh mishra algorithm open problem whether techniqu use frey prove consist arbitrari poset gener case subtyp relat type constructor dierent ariti assum howev subtyp relat lattic shown pottier pottier 2000a satis subtyp inequ check cubic time structur innit regular tree ie recurs type amadio cardelli 1993 note recurs type admit solut equat form list name type listlist present pottier algorithm set simplic rule show acycl system solv subtyp constraint innit type equival solv nite type assum structur type constructor k lattic type maintain previou assumpt decreas ariti except nari type constructor also assum greatest lower bound introduc new paramet similarli k 00 rang kk 00 note loss gener assumpt lattic type constructor alway complet introduc glb lub constructor right number paramet consid system subtyp inequ paramet type form type repres form introduc new paramet inequ paramet type repres sake present assum initi system solv rst complet introduc new variabl non empti subset v 0 ad inequ variabl 2 also assum system complet ad inequ variabl given system set variabl dene variabl f2v0 j92 2g similarli simplic rule follow type constraint logic program 17 62 6 k k 0 g l k 00 6 k 0 6 f g k l k 00 k rule tran comput transit closur inequ paramet mainli respons cubic time complex rule clash check consist lower upper bound paramet rule dec decompos type three simpl rule fact sucient check satis system pottier 2000a rule glb lub make explicit greatest least solut system comput greatest lower bound upper bound paramet least upper bound lower bound remark algorithm appli initi system contain uniqu inequ form 0 paramet algorithm maintain uniqu upper lower bound paramet note lb resp ub lower resp upper bound system irreduc form proposit 41 rule termin proof termin rule clash trivial rule let us consid complex measur system coupl integ e order lexicograph order e entropi system number v 2 n francoi fage emmanuel coqueri v number paramet system n number inequ paramet temperatur system sum height constructor right depth constructor left height resp depth constructor length longest path constructor resp k show rule increas temperatur system rule either decreas e rule tran chang decreas e 1 rule dec chang decreas e least 1 rule glb either decreas k 00 6 k 0 decreas e otherwis similarli rule lub henc algorithm termin theorem 42 pottier 2000a system inequ satis innit regular tree simplic rule gener fals case identi cation paramet upper bound ub resp lower bound lb provid maximum resp minimum solut furthermor one show set acycl system covari constructor type solv subtyp constraint innit type equival solv nite type theorem 43 acycl system inequ satis nite type simplic rule gener fals case ident paramet upper bound resp lower bound provid maximum resp proof sucient remark simplic rule preserv acycl system acycl system ident paramet bound creat nite solut corollari 41 lattic structur without acycl system inequ satis nite type simplic rule gener fals paramet 5 type infer usual prescript type system type reconstruct algorithm use omit type declar program still check typabl program possibl infer omit type lakshman reddi 1991 describ algorithm infer type variabl predic assum type declar function symbol 51 type infer variabl type variabl clp claus queri infer introduc unknown type variabl type collect subtyp type constraint logic program 19 equal along deriv type judgement like type check algorithm easi check system subtyp inequ thu collect still acycl unknown type clp variabl appear left posit system howev leftlinear clp variabl one occurr claus queri second algorithm previou section thu use infer type variabl clp claus queri 52 type infer predic type predic infer well assumpt predic use monomorph insid mutual recurs denit lakshman reddi 1991 mean insid group mutual recurs claus occurr even bodi claus predic dene claus must type rule head instead rule atom reason restrict similar one done infer type mutual recurs function ml avoid solv semiun problem ie given system type substitut exist substitut st prove undecid kfouri et al 1989 note ssi obtain collect subtyp inequ deriv type judgement still acycl unknown type predic appear righthand side inequ second algorithm previou section thu use also infer type predic clp program assumpt structur type lattic without one consequ acycl system howev maximum type predic alway inde type system predic alway type maxim permiss gener structur poset suprema unless unknown type predic compar type belong dierent connect compon case predic typabl substitut unknown type root connect compon alway solut case obvious inform type infer strategi infer two type predic minimum type predic heurist type type infer algorithm proce follow firstli minimum type predic obtain comput minimum solut ssi associ type complet denit predic minimum type ith argument predic type unknown type associ ith argument predic ssi minimum type lower bound possibl type predic secondli heurist type comput type parametr comput two step francoi fage emmanuel coqueri first heurist upper type comput predic heurist upper type ith argument predic obtain collect upper type fubx1 ubxn g variabl fx 1 occur ith posit predic denin claus greatest lower bound type variabl argument set ident creat cycl heurist type comput infer possibl parametr type ssi associ heurist upper type candid parametr type paramet bound ssi associ heurist upper type candid check iter replac new constant identifi paramet new constant one bound although tediou one easili check condit impos de nition heurist type creat sound type heurist type thu provid correct type declar type check program 6 implement type system 61 wallac librari solv subtyp inequ current implement use wallac librari fpottier pottier 2000b solv subtyp inequ type infer type check case set type constructor k thu lattic describ section 4 note type system requir condit could ariti decreas order relat k requir type infer algorithm element distinguish type term stand prolog term type consid valid type empti type note wallac librari author constrain type scheme like exampl oat express result type function type argument sake simplic consid constrain type scheme paper 62 type checker type checker rst read prolog le deduc le contain type inform load one le prolog le sourc plu one le modul use usemodulesomemodul sicstu prolog system load type le build structur type constructor type checker impos give type clp variabl claus type constraint logic program 21 queri instead type variabl infer describ section 5 environ u built type unknown variabl subtyp inequ system collect appli rule type system step wallac use solv type constraint one diculti appear check denit gener condit type error must rais denit predic use argument head claus term whose type subtyp instanc declar type 0 argument renam wallac abl make dierenc subtyp instanc renam type 0 follow consider allow us work around diculti subtyp renam 0 instanc 0 0 0 must exist instanc 0 0 check denit gener thu replac paramet appear declar type head predic constructor appear program term 6 constructor 6 6 term rule atom appli use transform type rule head appli well origin type 63 type infer predic describ section 5 two type infer predic minimum type lower bound possibl type predic heurist type may parametr type infer display user inform print type use type automat program noninteract manner choos heurist bound sinc permiss type 7 experiment result 71 detect program error show small catalog kind program error detect type checker 711 invers argument predic function error detect exampl variabl occur two posit incompat type exampl 71 consid follow claus argument length predic revers 22 francoi fage emmanuel coqueri usual declar pred pred rule atom variabl l3 must type list int type hierarchi use type smaller list int subtyp inequ premis rule atom thu unsatis type error rais note exampl motiv discard type would detect variabl sinc empti type could alway infer type variabl 712 misus predic function error detect term type appear argument predic functor expect argument type 0 6 0 substitut exampl 72 consid follow claus declar int integ divis pred tri use oat 35 int expect rule atom appli kind error detect also insid call foreign predic prolog interfac c program languag exampl exampl 73 consid declar predic p dene c use sicstu c interfac declar interpret type declar pred call program p314 rais type error sinc argument f loat predic expect int type constraint logic program 23 713 wrong predic denit wrt declar type error detect two way correspond two preced kind error two follow exampl predic p declar type pred exampl 74 let p dene p term use argument p requir p accept argument type atom list atom list 6 int rule atom appli exampl 75 let p dene pred case infer type x must smaller list use rule atom x use length smaller int use rule head type common subtyp error rais 714 violat denit gener condit exampl 76 p1 pred although argument p list type listint instanc renam list int 6 error also detect variabl head claus exampl 77 pred variabl x must type f loat common subtyp error rais francoi fage emmanuel coqueri 72 type check program test system rst tri 20 librari sicstu prolog around predic type check implement clpfd written complet prolog use lot metapred contain around 170 predi cate test done use type declar around 100 builtin iso prolog predic builtin sicstu predic type error obtain librari came overload function symbol exampl function 2 use code pair well code arithmet oper number anoth exampl overload come option happen term common two set option type 1 2 case enough creat subtyp 1 2 tell common term type also skip type check particular declar mode declar use type system exampl 78 mode p q declar type anoth type structur mode declar type structur one predic sinc predic clearli overload declar 73 type infer predic said section 63 infer interv type predic bound interv may oer interest inform exampl 79 appendhead tail list head rest appendtail list rest append list list minimum type listbottom listbottom listbottom pred heurist infer type lista lista lista pred exampl 710 sumlist sum sum sumlisthead tail sum0 sum sum1 headsum0 sumlisttail sum1 sum minimum type listbottom bottom bottom pred heurist infer type listfloat float float pred sometim heurist infer permiss type particular case overload arithmet predic express alway type float int type constraint logic program 25 exampl 711 length0 lengthtailr lengthtail l r l1 minimum type listbottom int pred heurist infer type lista float pred heurist may also infer type restrict exampl 712 islist minimum type listbottom pred heurist infer type lista pred typic exampl maximum type pred fact intend type exampl clearli justifi heurist approach type infer predic prescript type system final interest f latten predic illustr remark exibl type system exampl 713 pred pred 74 benchmark follow tabl sum evalu result rst column indic type check prolog program le second column indic number predic dene le rst maximum number atom claus complet connect compon third column indic time second type check program type declar function predic symbol fourth column indic cpu infer type predic type declar function symbol last column indic percentag predic infer type exactli intend type last test le anoth implement clpfd top prolog use lot metaprogram predic 26 francoi fage emmanuel coqueri file predic type check type infer exact type assocpl bdbpl 101 2727 2356 4110 64 charsiopl 15 77 127 221 33 clpbpl 59 2077 2435 182732 na clpq 396 39160 35512 403437 na clpr 439 39160 30445 395841 na jasperpl listspl randompl 11 socketspl ugraphspl 87 1224 4821 27422 67 clpfdpl 163 2071 2435 5965 na tabl 3 benchmark algorithm use solv system subtyp inequ type check type infer dierenc comput time come handl complet connect compon denit type infer enc wherea type check claus type check one one particular clpr clpq larg mutual recurs claus librari array low percentag exact match infer type intend type simpli due type indic oat instead int error librari also due type arithmet express oat sometim use equal predic creat type term argument instead restrict type librari clpfd nite domain variabl type type int similarli librari clpr variabl real type type oat one consequ type checker allow coercion nite domain variabl real constraint variabl make coercion work practic one modic clpr librari necessari 8 conclus type constraint logic program check program error static retain exibl requir preserv metaprogram facil type constraint logic program 27 logic program usual coercion constraint program challeng conduct design type system present paper experi librari sicstu prolog shown type system simpl exibl enough accept larg varieti constraint logic program main diculti locat con ict overload predic function ad hoc polymorph could resolv consid disjunct formula type demoen et al 1999 exampl given also show type system use enough detect program error invers argument predic unintend use predic price pay exibl type system may regard permiss intuit illtyp queri may reject type system analyz defect term subject reduct properti type system particular shown addit type constraint variabl welltyp program queri suce state subject reduct wrt csld resolut substitut step eect reject larger set claus queri check satis constraint type constraint compiletim lattic assumpt type structur due implement wallac subtyp constraint may regard also demand case alreadi relax assumpt reject bottom element structur type nevertheless decid subtyp constraint gener assumpt interest open problem particular whether method frey frey 1997 extend cover subtyp relat type constructor dierent ariti requir approach open question final worth note result present limit logic program languag relev variou constraint program languag main diculti type check constraint variabl express commun dierent constraint domain acknowledg would like acknowledg fruit discuss francoi pottier didier remi jan smau alexandr frey work also grate refere peer review r login logic program languag builtin inherit subtyp recurs type type inferenc polymorph ordersort logic program equat inequalit httppauillac polymorph type system subtyp prolog page 7993 ganzing satisfi subtyp inequ polynomi space type infer subtyp logic program type speci semant type logic program pfen type prolog semant reconstruct mycroftokeef type system type check type inferenc logic program subtyp parametr polymorph polymorph type system prolog type logic program use mode ensur subject reduct type logic program subtyp logic program polymorph ordersort type logic program polymorph ordersort type subtyp inequ pfen tr ctr adam kiezun michael ernst frank tip robert fuhrer refactor parameter java class proceed 29th intern confer softwar engin p437446 may 2026 2007 wodzimierz drabent jan mauszyski paw pietrzak use parametr set constraint locat error clp program theori practic logic program v2 n45 p549610 juli 2002