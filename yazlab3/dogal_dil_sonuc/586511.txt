unifi approach goaldirect evalu goaldirect evalu embodi icon snobol built notion backtrack gener success result therefor alway someth challeng specifi implement articl address challeng use comput monad partial evaluationw consid subset icon specifi monad semant list monad consid spectrum monad also fit bill relat exampl deriv continu monad church encod list monad result semant coincid gudeman continu semant iconw compil icon program special interpret ie use first futamura project use typedirect partial evalu variou back end includ runtim code gener gener ml code c code ocaml byte code bindingtim analysi partial evalu continuationbas interpret automat give rise c program coincid result proebst optim compil b introduct goaldirect languag combin express yield multipl result backtrack result gener one time express either succeed gener result fail express fail control pass previou express gener next result control pass back origin express order tri whether succeed time goaldirect program specifi order subexpress retri thu provid programm succint power controlflow mechan wellknown goaldirect languag icon 11 backtrack languag featur complic semant impl mentat gudeman 13 give continu semant goaldirect languag continu also use implement languag control structur similar goaldirect evalu prolog 3 15 30 proebst townsend implementor icon compil java observ continu compil ecient code 1 14 nevertheless dismiss notori dicult stand target languag directli support 23 p38 instead compil base translat scheme propos proebst 22 base fourport model use describ control flow prolog 2 icon express translat flowchart languag condit direct indirect jump use templat subsequ optim amongst thing reorder code perform branch chain necessari produc compact code refer implement icon 12 compil icon byte code byte code execut interpret control control flow keep stack express frame articl present unifi approach goaldirect evalu 1 consid spectrum semant small goaldirect languag relat deriv semant gudeman 13 instanti one gener semant base comput monad 21 unifi approach enabl us show equival dierent semant simpli systemat furthermor abl show strong conceptu link dierent semant continu semant deriv semant base list stream result churchencod list stream respect 2 link semant implement semanticsdirect compil use partial evalu 5 17 particular bindingtim analysi guid us extract templat special interpret templat similar proebst partial evalu give rise similar flowchart program demonstr templat good ideathey intrins semant icon provabl deriv rest paper structur follow section 2 first describ syntax monad semant small subset icon instanti semant variou monad relat result semant present equival proof two section 3 describ semant direct compil goaldirect languag section 4 conclud 2 semant subset icon intuit explan goaldirect evalu given term list listmanipul function consequ introduc subset icon treat paper defin monad semant term list monad show also stream monad two dierent continu monad use give exampl prove equival result monad use monad morphism 21 subset icon program languag consid follow subset icon intuit icon term either fail succe valu succe subsequ resum case either succeed fail process end express fail inform succe valu succe sum subexpress e 1 e 2 call succe valu e 1 subsequ resumpt yield rest integ valu e 2 point succe valu e 2 larger valu produc result produc result e 3 gener nest exampl icon term 4 5 7 gener result express 4 5 4 6 4 7 concaten result function languag scheme ml haskel achiev eect icon term use function map concat exampl defin fun ml evalu concat map 6 4 5 6 7 list integ produc icon term 4 5 7 22 monad semant comput monad introduc structur denot semant 21 basic idea parameter semant monad mani languag ex tension ad store except carri simpli instanti semant suitabl monad correspond join figur 1 monad oper type standard monad oper unit join l join l l special oper sequenc empti empti l empti l append l figur 2 list monad proof semant aris instanti dierent monad conduct modular way use concept monad morphism 28 monad also use structur function program 29 term program languag monad describ unari type constructor three oper unit map join type display figur 1 oper socal monad law hold section 24 give denot semant goaldirect languag describ section 21 anticip semanticsdirect compil partial evalu describ semant term ml eect defin interpret semant int parameter monad repres sequenc valu type xjoin els append unit figur 3 monad semant subset icon 23 monad sequenc order handl sequenc structur need addit three gener monad oper display figur 1 add three oper empti append empti stand empti sequenc empti discrimin function given sequenc two addit input return first input sequenc empti return second input otherwis append append two sequenc straightforward instanc monad sequenc list monad l display figur 2 list join sometim also call flatten ml concat 24 monad semant monad semant goaldirect languag describ section 21 given figur 3 explain semant term list monad liter interpret express yield exactli one result consequ map singleton list use unit semant given term bind2 function type int int int list type function bind2 l list list list ie take two list contain valu type function map list valu type eect definit bind2 l f xs ys 1 map f x ys x xs 2 flatten result list list step found exampl end section 21 eect goaldirect evalu achiev ml use list 25 spectrum semant follow describ four possibl instanti semant given figur 3 semant correspond directli interpret thu creat four dierent interpret 251 listbas interpret instanti semant list monad figur 2 yield listbas interpret eager languag ml listbas interpret alway comput result behavior may desir situat first result interest matter whether exist result consid exampl condit examin whether given express yield least one result fail altern use lazi 252 streambas interpret implement list monad figur 2 lazi languag result monad finit lazi list correspond interpret gener one result time eager languag eect achiev explicitli implement data type stream ie finit list built lazili thunk use delay comput definit correspond monad oper straightforward 253 continuationbas interpret gudeman 13 give continuationbas semant goaldirect languag deriv semant instanti monad semant continu monad c defin figur 4 typeconstructor c continu monad defin r r r call answer type continu conceptu link list monad continu monad answer type list list made church encod 4 higherord represent list propos hugh 16 hugh observ construct partial appli concaten function ys xs ys rather list xs list append constant time result represent empti list correspond function append ele ment ie ident wherea function append singl element standard monad oper unit join special oper sequenc empti c empti c xs ys append c figur 4 continu monad repres partial appli con function con churchencod data type mean abstract selector function case con result represent list type inde correspond c answer type notic nil con list represent yield empti c unit c respect similarli remain monad oper correspond usual list oper figur 5 display definit oper inlin result express reduc 254 interpret explicit success failur continu tailrecurs implement continuationbas interpret icon use explicit success failur continu result interpret icon express type int first argument success continu second argument failur continu note success continu take failur continu second argument failur continu determin resumpt behavior icon term success continu may later appli c els figur 5 continu semant failur continu gener result correspond continu monad c 2 standard monad oper continu monad display figur 4 sequenc oper empti empti c 2 xs ys append continu monad figur 4 conceptu link list monad present continu monad link stream monad church encod data type stream x fact second compon stream thunk suggest one give selector function type int 1 1 1 result type end x xs int choos result type selector function yield type continu monad answer type interpret defin semant start point semanticsdirect compil describ section 3 figur 6 display definit monad oper inlin result express reduc basic monad oper c 2 c semant base c 2 c dier definit leq handl jto c 2 els figur semant success failur continu 26 correct far relat variou semant present section 25 con ceptual four dierent interpret present section 25 creat instanti one parameter semant dierent monad formal correspond proof conduct modular way build concept monad morphism 28 n two monad h n monad morphism preserv monad oper 1 ie follow lemma show semant result two dierent monad instanti relat defin monad morphism two sequenc monad question n monad sequenc specifi section 23 h monad morphism n everi icon express e strengthen definit monad morphism somewhat consid sequenc preserv monomorph also preserv monad oper specif monad sequenc proof induct structur e lemma eect shown induct use lemma 2 show listbas interpret section 251 continuationbas interpret section 253 alway yield compar result proposit 3 let show c l defin show unit l x xs empti l show express e proof show 1 h l c defin unit c x h xs monad morphism l c 2 function show h ident function list proposit follow immedi lemma 2 27 conclus take intuit listbas semant subset icon start point defin streambas semant two continu semant init semant defin instanti monad semant list monad semant defin stream monad two dierent continu monad respect modular monad semant allow us relat semant relat correspond monad conceptu formal best knowledg conceptu link listbas monad continu monad via church encod observ known continu compil ecient code rel easili 1 14 follow section show partial evalu su cient gener ecient code continu semant deriv section 254 3 semanticsdirect compil goal partial evalu special sourc program two argument fix static argument result residu program must yield result appli dy namic argument origin program appli static dynam argument ie p interest partial evalu due use semanticsdirect com pilat sourc program p interpret static argument term domain p p compil version repres implement languag p often possibl implement interpret function languag base denot semant start point function interpret implement denot semant figur 6 sourc languag interpret shown figur 7 section 31 present icon interpret written ml section 31 32 33 use typedirect partial evalu special interpret icon term yield ml code c code ocaml byte code output partialevalu techniqu could appli yield essenti result structur struct datatyp icon icon plu icon icon leq icon icon icon icon icon figur 7 abstract syntax icon term 31 typedirect partial evalu use typedirect partial evalu compil icon program ml standard exercis semanticsdirect compil use typedirect partial evalu 9 typedirect partial evalu approach olin special higherord program 8 use normal function map valu trivial special program dp text target program input typedirect partial evalu bindingtim separ program static dynam primit separ implement ml sourc program conveni wrap functor parameter structur dynam primit functor instanti evalu primit run sourc program residu primit special sourc program 311 special icon term use typedirect partial evalu case dynam primit oper addit add integ comparison leq fixedpoint oper fix condit function cond quot function qint lift static integ dynam domain signatur primit shown figur 8 residu primit let partial evalu produc function gener ml program meaning variabl name 8 parameter interpret shown figur 9 main function eval take icon term two continu re re yield result type re intend special interpret static icon term keep continu paramet k f dynam consequ residu program parameter two continu continu also consid static residu program would simpli list gener integ signatur type tunit type tint type tbool type re val qint int tint val add tint tint tint re val fix tint re tint re tint re figur 8 signatur primit oper output typedirect partial evalu text residu program residu program long betaeta normal form contain beta redex fulli etaexpand respect type exampl 4 follow result special interpret respect icon 4 7 fix fn loop0 fn i0 cond leq i0 qint 7 fn loop0 add i0 qint 1 qint struct fun loop pfix fn walk pcond pleq j fn walk padd pqint 1 fun select pcond pleq j fn k j f f fun sum fun eval lit eval toe1 eval e1 fn eval e2 fn j loop eval pluse1 eval e1 fn eval e2 fn j sum eval leqe1 eval e1 fn eval e2 fn j select eval ife1 e2 eval e1 fn fn eval e2 k f fn eval e3 k f figur 9 parameter interpret 312 avoid code duplic result special interpret figur 9 may exponenti larg due continu paramet k duplic claus exampl special interpret icon term 100 yield follow residu program context cond leq qint 1 qint 2 code duplic wellknown problem partial evalu 17 equal wellknown solut bind continu residu program use introduc new primit save two argument k g appli g two copi continu k signatur re val save succ succ succ re re final claus interpret modifi save continu paramet proce follow fun eval lit eval ife1 e2 save k fn k0 k1 eval e1 fn fn eval e2 k0 f fn eval e3 k1 f special new interpret icon term yield follow residu program context add100 occur save fn v0 fn resume0 k add qint 100 v0 fn resume0 fn k00 k10 cond leq qint 1 qint 2 two copi continu paramet k bound k0 0 k1 0 continu use twice bodi second lambda order prevent code duplic pass one copi continu paramet actual enough translat c introduc section 32 use two dierent name variabl case k00 k10 determin ifbranch insid continu appli 32 gener c program residu program long betaeta normal form type tint tunit re re tunit re re impos restrict residu program must take two argument success continu re failur continu re must produc valu type re also consid type primit may occur residu program see valu type re result appli success continu k integ n function type tunit re appli failur continu f appli primit cond boolean two function type tunit re appli primit fix function two argument loop n re tint integ insid function pass fix appli function loop n integ appli primit save two argument first function two argument vn tint resumen tunit re second function pair argument k 0 type tint tunit re re insid first function pass save appli function resumen insid second function pass save appli one function n integ function type tunit re similar analysi appli valu type tint aris evalu integ n variabl variabl vn appli add two argument type tint result observ residu program special icon interpret use typedirect partial evalu restrict grammar figur 10 restrict variabl loop n vn resum n must occur insid function bind express use contextfre grammar problem develop express grammar ml datatyp use datatyp repres output typedirect partial evalu thu essenti use type system ml theorem prover show follow lemma lemma 5 residu program gener appli typedirect partial evalu interpret figur 9 gener grammar figur 10 idea gener grammar residu program studi eg malmkjr 20 use runtim special tempo gener code templat 6 f cond e fn fn fix fn loop n fn e loop n e save fn vn fn resumen resum n vn add e e leq e e figur 10 grammar residu program simpl structur output program allow view program flowchart languag choos c concret exampl languag figur 11 12 show translat residu program c program translat replac function call jump except call resum n occur result compil ifstat name function uniqu determin correspond label jump jump resum n end two dierent place correspond two copi continu use boolean variabl gate n distinguish two possibl destin call loop n kn pass argument name formal paramet known n vn respect therefor argument pass assign variabl jump translat condit new label l must gener entir translat term must wrap context defin label succ fail correspond initi continu statement follow label succ allow jump resum translat figur 11 12 gener c program success print produc integ one one lemma eect translat residu ml program c semant preserv would requir give semant c subset ml present figur 10 show equival exampl 6 consid icon 4 7 exampl 4 translat follow c program loop0 i0 7 goto l0 goto fail goto succ succ printfd valu goto resum goto succ resum f cond e fn fn e e goto l l fix fn loop n fn e goto loop save fn vn fn resumen succn resumen goto resum 0 gate goto resum figur translat residu program c statement qint figur 12 translat residu program c express resum goto loop0 succ printfd valu goto resum c target program correspond target program proebst optim templatebas compil 22 eect automat gener flowchart program denot icon term 33 gener byte code previou two section develop two compil icon term one gener ml program one gener flowchart program section unifi two compos first compil third author automat runtim code gener system ocaml 25 compos second compil handwritten compil flow chart ocaml byte code 331 runtim code gener ocaml runtim code gener ocaml work deforest composit tradit typedirect partial evalu compil ocaml byte code deforest standard improv runtim code gener 6 19 26 remov need manipul text residu program special time result instead gener ml term runtim code gener allow typedirect partial evalu directli gener execut ocaml byte code special icon interpret figur 9 icon 7 use runtim code gener yield residu program 110 bytecod instruct function implement closur call implement tailcal compil residu ml program use ocaml compil yield 90 bytecod instruct 332 compil flow chart ocaml byte code modifi translat figur 11 12 produc ocaml bytecod instruct instead c program result embed icon ocaml use 4 7 yield 36 bytecod instruct function implement label block call implement assign argument pass follow jump style target code promot steel first compil scheme 27 34 conclus translat continuationbas denot semant interpret written ml use typedirect partial evalu enabl standard semanticsdirect compil icon term ml compil residu program c yield flowchart program correspond produc proebst icon compil 22 4 conclus issu observ list monad provid kind backtrack embodi icon specifi semant icon parameter monad consid altern monad proven also provid fit semant icon inlin continu monad particular yield gudeman continu semant 13 use partial evalu special interpret respect icon program therebi compil program use first futamura project use combin typedirect partial evalu code gener either ml c ocaml byte code gener code c particular yield result similar proebst compil 22 gudeman 13 show continu semant also deal addit control structur state expect diculti scale codegener accordingli monad list hand oer enough structur deal eg state possibl ever creat rich enough monad combin list monad monad state monad 10 18 observ tradit partial evalu gener success continu avoid code duplic proebst present problemat compil also studi result defunction continu la reynold 24 obtain stackbas specif correspond runtim architectur acknowledg thank due anonym refere comment andrzej filinski discuss work support esprit work group appsem httpwwwmdchalmerssecsresearch semanticsappsem r compil continu understand control prolog program implement prolog function program calculi lambdaconvers tutori note partial evalua tion gener approach runtim special applic c repres layer monad icon program lan guag implement icon program languag denot semant goaldirect languag repres control presenc firstclass continu prolog featur function settingaxiom implement revers partial evalu automat program gener combin monad optim ml runtim code gener abstract interpret partialevalu algo rithm comput lambdacalculu monad simpl translat goaldirect evalu new implement icon languag definit interpret higherord program languag phd thesi two price one compos partial evalu compil steel jr comprehend monad monad function program easi implement pil prolog lisp tr novel represent list applic function revers implement icon program languag comput lambdacalculu monad repres control presenc firstclass continu denot semant goaldirect languag compil continu partial evalu automat program gener tutori note partial evalu optim ml runtim code gener gener approach runtim special applic c repres layer monad icon programmng languag definit interpret higherord program languag typedirect partial evalu semanticsbas compil combin monad monad function program ctr mitchel wand dale vaillancourt relat model backtrack acm sigplan notic v39 n9 septemb 2004 dariusz biernacki olivi danvi chungchieh static dynam extent delimit continu scienc comput program v60 n3 p274297 may 2006