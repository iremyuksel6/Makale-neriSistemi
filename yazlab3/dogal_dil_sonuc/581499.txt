tagless stage interpret type languag multistag program languag provid conveni notat explicitli stage program stage definit interpret domain specif languag one way deriv implement readabl effici untyp set stage interpret remov complet layer interpret overhead like partial evalu type set howev hindleymiln type system allow us exploit type inform languag interpret practic mean slowdown cost factor three morprevi type special tag elimin appli problem paper propos altern approach name express definit interpret depend type program languag report experi issu aris write interpret design languag demonstr sound combin stage depend type gener sens formal languag call metad prove type safeti formal metad extend shao saha trifonov papaspyr h languag multilevel set build h allow us demonstr type safeti set type languag contain calculu induct construct without repeat work need establish sound system b introduct recent year substanti effort invest develop theori tool rapid implement domain specif languag dsl 4 22 40 47 45 23 dsl formal provid user notat appropri specif famili task promis approach implement domain specif languag write definit interpret 42 dsl metalanguag stage interpret either manual ad explicit stage annot multistag program 55 30 45 50 appli automat bindingtim analysi offlin partial evalu 25 result either step stage interpret stage interpret essenti translat subjectlanguag dsl targetlanguag 1 alreadi compil targetlanguag approach yield simpl compil dsl addit perform benefit compil inter preter compil obtain process often retain close syntact connect origin interpret inspir greater confid correct paper concern subtl costli problem aris subject metalanguag static type particular metalanguag type gener need introduc univers datatyp repres valu uniformli see 48 detail discuss univers datatyp mean perform tag untag oper run time subjectlanguag un type would write ml interpret scheme check realli necessari subjectlanguag also static type would write ml interpret ml extra tag realli need necessari static type check interpret interpret stage inherit 29 weak gener program contain superflu tag untag oper earli estim cost tag suggest produc 26 time slowdown smlnj system 54 extens studi metaocaml system show slowdown due tag high 10 time 21 remov tag overhead inher use univers type one recent propos possibl tag elimin 54 53 26 transform design remov superflu tag postprocess phase scheme dsl implement divid three distinct stage rather tradit two extra stage tag elimin distinctli differ tradit partial evalu special stage essenc tag elimin allow us type check subject pro stage multistag languag usual impli metalanguag targetlanguag languag gram transform check superflu tag simpli eras interpret semant equival interfac ad around interpret tag elim inat howev static guarante tag eras must run tag elimin runtim multistag languag paper studi altern approach provid guarante fact user never introduc tag first place type system metalanguag strong enough avoid need follow describ detail superflu tag problem 11 untyp interpret begin review one write simpl interpret untyp languag 2 notat parsimoni use ml syntax disregard type interpret small lambda languag defin follow datatyp int v string l string exp exp exp fun eval e case e l se fn v eval e ext env v fe eval f env eval e env provid simpl implement subject program repres datatyp exp function eval evalu exp environ env bind free variabl term valu implement suffer sever perform limita tion particular abl inspect result interpret eval lxv x env0 would find equival term comput correct result contain unexpand recurs call eval problem aris callbi valu callbynam languag one main reason call layer interpret overhead degrad perform fortun problem elimin use stage annot 48 12 untyp stage interpret stage annot partit program stage bracket surround express lift next stage build code escap drop surround express previou stage splice alreadi construct code build larger piec code appear within bracket stage annot chang evalu order program even evalu lambda abstract forc unfold eval function codegener time thu ad stage annot eval function chang behavior achiev desir oper semant case e 2 discuss issu prove adequaci represent correct implement interpret beyond scope paper exampl done found elsewher 54 l se fn v eval e ext env fe eval f env eval e env comput applic eval lxv x env0 directli yield term fn v v leftov recurs call eval multistag languag come run annot allow us execut code fragment stage interpret therefor view userdirect way reflect subject program meta program hand type safe way compil metalanguag 13 hindleymiln stage interpret program languag haskel ml use hindleymiln type system eval function stage unstag welltyp 48 branch case statement differ type type reconcil within hindleymiln system circumv problem use univers type univers type type rich enough encod valu type appear result function like eval case includ function well integ valu typic definit univers type exampl might int f v v interpret rewritten welltyp program fun unf fun eval e case e l se f fn v eval e ext env v fe unf eval f env eval e env comput eval lxv x env0 get back valu untyp eval stage version eval comput eval lxv x env0 yield 14 problem superflu tag unfortun result still contain tag f may seem like minor issu small program like one effect larger program profus tag untag oper tag would inde necessari subject languag untyp know subjectlanguag static type exampl simplytyp lambda calcu lu tag untag oper realli need benchmark indic tag add 23 time overhead 54 sometim larg 310 time 21 number approach deal prob lem none approach howev guarante time write stage interpret tag elimin runtim even tag elimin guarante elimin tag particular exampl requir separ metatheoret proof subject languag obtain guarante 54 contribut paper propos altern solut superflu tag problem solut base use depend type multistag languag work inspir work write depend type interpret cayenn 2 illustr viabil combin depend type stage design implement prototyp languag call metad use languag vehicl investig issu aris take approach built compil interpret begin end metad also report issu aris tri develop depend type program languag oppos type theori featur basic stage oper depend type help avoid redund type annot depend type induct famili depend datatyp separ valu type ensur decid type check treatment equal represent type use equalitytypelik mechan technic contribut paper formal multistag languag prove safeti sophist depend type system capit recent work shao saha trifonov papaspyr system 44 turn build number recent work type intermedi languag 20 7 59 43 9 57 44 16 organ paper section 2 show take motiv exampl turn tagless stage interpret depend type set first present syntax semant simpl type languag show implement direct fashion metad first part write unstag interpret similar done cayenn 2 simplifi presenc depend datatyp metad see relat work key observ interpret need defin type deriv rather express depend type datatyp need repres type deriv accur next show interpret easili stage step exactli untyp hindleymiln set section 3 point address basic practic problem aris implement interpret depend type program languag first show construct type judgment consum tagless inter preter review import clear separ comput languag type languag motiv need represent type effect code tagless stage interpret section 4 present formal core subset metad formal proof type safeti origin work use system type comput languag includ basic effect nontermin 44 paper develop multistag comput languag show essenti techniqu use verifi sound key technic modif need addit level type judgment address evalu type binder section 5 discuss relat work section 6 outlin direct futur work conclud extend version paper avail onlin technic report 36 stage interpret section show exampl discuss introduct redevelop depend type set begin consid definit syntax semant simpli type version subject languag 21 subjectlanguag syntax semant figur 1 defin syntax type system semant exampl subject languag shall call sl simplic develop use de bruijn indic variabl binder semant defin type sl map intend mean exampl mean type n set natur number mean arrow type function space furthermor map mean type assign g product set denot finit number type assign note semant program defin type judgment map element mean type standard way defin semant type languag 56 18 39 implement next section direct codif definit 22 interpret metad interpret sl simpli implement definit figur 1 begin defin datatyp use interpret basic type type environ sl defin datatyp metad use altern notat sml haskel datatyp definit exampl defin set natur number instead write datatyp write induct induct notat conveni defin depend datatyp wish defin new type new kind mean type type type express type assign repres follow induct induct induct 1 definit mean defin new type implement type judgment sl need depend type datatyp index three paramet type assign env express exp type typ defin datatyp shown figur 2 3 constructor datatyp correspond one rule type system object languag exampl consid rule lambda abstract lam figur 1 basic idea use judgment type principl 19 view type rule constant combin judgment combin take hypothesi judgment return conclus judgment case rule requir environ g two type 0 bodi e lambda abstract judgment gt return judgment rule codifi directli follow constructor je1 el t1 s2 arrowt t1 t2 definit j see differ tradit datatyp definit induct datatyp constructor depend type argument rang type j index differ indic variabl return 3 practic reason discuss next section datatyp legal metad use section explain basic idea discuss need socal represent type figur 1 semant sl induct figur 2 type judgment j without represent type type constructor depend datatyp provid inform valu 221 interpret type judgment defin judgment readi implement terpret note howev type result interpret judgment depend interpret sl type depend captur interpret function typev figur 3 present implement interpret type typev map type assign meta type envev interpret judgment eval function eval defin case analysi type judg ment comput function significantli differ one present section 12 differ includ addit type annot case analysi type judg ment importantli write requir use tag result valu type system allow us specifi return type function typev tag longer need help us discrimin type valu get back runtim type system tell us static 23 stage interpret metad figur 4 show stage version eval hindleymiln type stage complic depend type stage interpret eval return valu type code typev note type valu assign also chang see envev figur 4 rather carri runtim valu sl carri piec code repres valu variabl assign execut program produc tagless code fragment interest even though eval function never perform tag un tag interpret overhead travers input still consider judgement must deconstruct eval run time may requir even work deconstruct tag valu stage overhead perform first stage overheadfre term gener execut later stage stage violat prevent standard way metad type system see technic report 36 stage construct davi 10 addit crossstag persist 55 refer reader refer detail natur stage violat ad run construct along line previou work 51 30 consid turn address practic question uniqu depend type set includ abovement judgement construct 3 practic concern build type judgment amount implement either typecheck type infer languag interpret anoth practic concern type depend valu lead either undecid unsound type check happen valu contain diverg sideeffect comput section discuss concern address context metad 31 construct type judgment requir user dsl suppli type judgment program interpret like accept although depend situat user abl use implement suppli plain text subject pro gram therefor implement need includ least type check function function take represent type annot program produc appropri type judgment exist might even want implement type infer requir type annot input figur 4 present function typecheck function use illustr number featur metad type result 4 typecheck depend sum jest mean result typecheck consist sl type type judgment prove argument express particular type given type assign sinc judgment built subjudg case strong depend sum elimin construct need deconstruct 4 pure comput effect whatsoev set result typecheck option typ j est sinc particular term given typecheck may welltyp function given paper omit option save space reli incomplet case express instead case natt nat arrowt t1 t1 typev t1 typev t2 case e empty unit ext e2 envev e2 typev case j jn e1 n1 n1 jv e1 t1 2rho jw e1 t1 t2 j1 eval e1 1rho ev t1 j1 jl ee1 et1 et2 es2 ej1 fn ja e s1 s2 t1 t2 j1 j2 eval e rho s1 arrowt t1 t2 j1 eval e rho s2 t1 j2 figur 3 depend type tagless interpret without represent type case e empty unit ext e2 envev e2 code typev case j jn e1 n1 jv e1 t1 2rho jw e1 t1 t2 j1 eval e1 1rho ev t1 j1 jl ee1 et1 et2 es2 ej1 fn vtypev et1 eval ext ee1 et1 rho es2 et2 ej1 ja e s1 s2 t1 t2 j1 j2 eval e rho s1 arrowt t1 t2 j1 eval e rho s2 t1 j2 case ev nn case nn z case e ext ee t2 n case e ext e2 t2 case x rx typj2 typecheck e2 ev n el targ s2 case x rt typ j2 typecheck ext e targ s2 ea s1 s2 case x1 rt1 typj1 case x2 rt2 typj2 case rt1 arrowt tdom tcod cast assert rt2tdomjestdom j2 end typecheck e s1 typecheck e s2 case x case t1 natt eval empty natt j arrowt t2 t3 z typecheck empty figur 4 stage tagless interpret function typecheck without represent type result recurs call typecheck case construct applic judgment illustr interest point build judgment express ea s1 s2 involv first comput judgment subterm s1 s2 judgment assign type arrowt tdom tcod rt2 respect expr sion howev definit induct famili j order build larger applic judgment tdom rt2 must sl type ie typ valu must equal introduc two languag construct metad express sort constraint valu first express form assert introduc equal judgment id e1 e2 valu equal type 5 elimin construct use cast express e2 type tv1 tv2 e1 equal judgment type id v1 v2 type checker allow use leibniz style equal prove cast correct sinc e1 equal judgment state v1 v2 equal oper express assert e1e2 evalu two subexpress compar equal inde equal comput proce howev two valu equal program rais except termin cast construct make sure equal judgment introduc assert evalu runtim equal check succe simpli proce evalu argument express altern use assertcast includ equal judgment type part type judgment build equal proof part typecheck function 6 approach possibl prove verbos omit paper assertcast howev serv conveni program shortcut reliev user effort formal equal type level manipul equal type 32 represent type combin effect depend type requir care ex ampl typecheck function partial mani input term well type sl input typecheck would caus runtim pattern match failur equal assert except would like metad continu sideeffect nontermin except time depend type languag perform comput type check determin equal type allow effect comput leak comput done type check risk nontermin even unsound typecheck time goal often describ preserv phase distinct compil time runtim 5 basic approach deal problem allow type depend type valu disallow kind depend howev would allow us express type check function produc term whose type depend 5 featur restrict ground type whose valu shown equal runtim 6 due space limit omit approach defin altern typecheck function accompani technic report 36 valu argument standard solut introduc mechan allow limit kind depend valu type limit depend use socal singleton represent type 60 7 9 57 basic idea allow biject ground term valu type world rewrit interpret type depend runtim valu may introduc effect typecheck phase comput type check phase guarante complet effectfre runtim valu forc represent type reflect world valu valu induct kind metad special type constructor r use express kind depend exampl defin induct kind nat induct note definit exactli one type nat except classifi 2 instead 1 definit encount introduc constructor type also possibl use special type constructor r write rss z refer type uniqu inhabit also call rep ss z figur 5 present implement represent type introduc restrict type system requir us turn definit exp env typ definit kind chang one charact definit term kind use gener recurs defin interpret therefor use special primit recurs construct provid type languag defin interpreta tion judgment howev remain type type index type valu part definit judgment interpret function chang need chang judgment case natur number augment represent valu number constructor jn becom definit eval chang accordingli modifi eval use helper function convert represent natur type natur number 7 definit typecheck function requir substanti chang figur 5 particular function requir carri case analysi type 20 7 59 43 9 purpos metad provid special case construct tycas x cn xn en pattern cn xn match valu x type k k induct kind provid represent valu type rx pattern match induct kind perform without presenc correspond runtim valu appropri represent type insid bodi case en express rep xn provid represent valu part induct constructor xn bound 4 formal develop section report main technic result type safeti formal core subset metad result show multistag program construct safe use even integr sophist depend type system follow approach use develop tl build comput languag l h use type languag integr formal 7 practic see fundament reason distinguish two identifi howev requir addit special support syntact sugar particular represent type induct induct induct induct induct induct primrec typ nat fn c 1 fn 1 c fun cast n rn z zero cast case j jn e1 n1 rn1 cast n1 rn1 jv e1 t1 2rho jw e1 t1 t2 j1 eval e1 1rho ev t1 j1 jl ee1 et1 et2 es2 ej1 fn ja e s1 s2 t1 t2 j1 j2 eval e rho s1 arrowt t1 t2 j1 eval e rho s2 t1 j2 tycas rs ev n tycas n rep n z tycas e ext ee t2 n tycas e ext e2 t2 case x rx typj2 1 j2 jw e2 rx t2 n 2 j2 typecheck e2 rep e2 ev n rep ev n el targ s2 case x typecheck ext e targ rep ext e targ s2 rep s2 ea s1 s2 case x1 t1 typj1 case x2 t2 typj2 tycas t1 1 j1 arrowt tdom tcod cast assert t2tdomjestdomj2 end typecheck e rep e s1 rep s1 typecheck e rep e s2 rep s2 figur 5 tagless interpret represent type metad induct w figur 6 definit type l h type express cast e 0 figur 7 syntax l h cast figur 8 type system l h framework gave us signific practic advantag formal develop l h import metatheoret properti type languag use tl alreadi proven 44 sinc chang anyth type languag result eg churchross properti type languag decid equal type term easili reus proof base comput languag lh 44 tri make differ two languag small possibl result proof type safeti l h similar type safeti proof lh abl reus certain lemmata techniqu develop lh proof detail proof type safeti l h present extend technic report 36 figur 6 defin l h comput type first step need integr l h framework syntax comput languag l h given figur 7 languag l h contain recurs stage construct contain two predefin represent type natur boolean construct lh provid propag proof inform branch analog tycas construct metad full implement induct datatyp style metad left futur work sinc arbitrari depend type prohibit l h use univers existenti quantif express depend valu type kind exampl ident function natur express l h follow l h also formal assertcast construct requir extend languag comput type equal judgment type similarli add appropri construct syntax l h abl defin smallstep semant stage lan guag defin syntax l h term levelindex famili express valu 48 type judgment fig ure 8 well type assign l h also appropri extend level annot 55 levelannot erasur function j n use convert l h type assign form requir type judgment tl44 interfac allow us reus origin type judgment due lack space show definit smallstep semant l h togeth proof relev theorem includ companion technic report 36 list import theorem proof structur induct e n 2e n examin case type judgment proof case possibl reduct e e 0 7 proof use subject reduct lemma 2 progress lemma 1 lemma follow wright felleisen syntact techniqu 58 5 relat work barendregt 3 good highlevel introduct theori depend type system number refer strictli termin function program depend type theori literatur 32 31 6 cayenn depend type program languag 1 essenc direct combin depend type theori potenti nontermin recurs fact use implement unstag interpret similar one discuss paper 2 work present extend work done cayenn three respect first cayenn allow type depend valu thu ensur type check termi nate second cayenn support depend datatyp like jest write interpret involv use separ proof object encod inform carri jest mostli thread program number paramet pass metad cayenn implement eval function use depend datatyp metad allow direct analog standard definit semant type judgment rather raw term third cayenn provid explicit support stage essenti compon achiev perform result achiev use tagless stage interpret xi pfen studi number differ practic approach introduc depend type program languag 59 60 work concentr limit express depend type thu limit constraint need solv presburg arithmet problem singleton type seem first use xi context dml 60 idea later use number work develop idea represent type intension type analysi logic framework 19 37 use depend type basi proof system relat work logic framework alon suffici purpos interest comput program languag effect nontermin recent work shao saha trifonov papaspyr gener framework safe integr comput base languag rich depend type system without lose decid sound typecheck dybjer extens studi semant induct set famili 11 12 13 14 16 simultan induct recurs definit 15 use former type level also use valu level jest coq proof assist provid fairli extens support kind definit 17 34 35 futur interest explor integr second techniqu program languag one interest problem whether selfinterpret possibl given program languag possibl simplytyp languag 54 clear howev done depend type languag 38 explor problem interest futur work final stage type infer 46 also use mean obtain program without tag techniqu discuss paper probabl closest spirit tag elimin fact multistag set tag elimin appli runtim noth nonstandard type analysi key differ stage type infer system code type use reflect type inform type inform determin dynam type check impor tantli success failur stage type infer depend whether valu code type undergon simplifica tion easi return valu tell us runtim languag whether dynam infer succeed tag elimin hand work code explicit static type addit use care craft fallback plan projectionembed pair runtim tag elimin guarante alway denot semant certainli oper semant independ test code analyz simplif may done subject program 54 6 conclus futur work paper shown depend type program languag use express stage interpret complet circumv need runtim tag untag oper associ univers datatyp highlight two key practic issu aris tri develop stage interpret depend type languag first need function build represent type judgment interpret function defin second need represent type avoid pollut type languag impur term comput languag demonstr stage construct depend type safe combin formal languag multistag comput languag type shao saha trifonov papaspi rou system allow us prove type safeti fairli straightforward manner without duplic work done system practic concern use depend type write interpret system decid type infer view highlyvalu featur type languag find annot burden simpl trick implement enough avoid need redund annot carri work develop deeper appreci subtleti involv depend type program implement type checker depend type languag current implement prototyp system made avail onlin 27 next step studi integr depend type languag practic implement multistag program metaocaml 28 also found lot opportun context depend type languag would like explor futur exampl includ syntact lightersupport represent type formal simpl trick use implement help allevi need redund type annot also interest explor use depend type reflect resourc need gener program 8 24 52 r exercis depend type welltyp inter preter lambda calculi type littl languag phase distinct type theori type theori program flexibl type analysi resourc bound certifica tion intension polymorph typeerasur semant modal analysi stage comput induct defin set martinlof set theori induct set famili martin lof type theori settheoret semant induct set famili martinlof type theori settheoret semant induct famili gener formul simultan inductiverecurs definit type theori finit axiomat induct inductiverecurs definit tutori recurs type coq semant program languag framework defin logic compil polymorph use intent type analysi practic implement tag elimin build domain specif embed languag modular domain specif languag tool prove correct reactiv system use size type partial evalu automat program gener jonesoptim special strongli type languag metaocaml compil inherit limit ideal metaml simpler program construct set ori exampl program martinlof type theori oregon graduat institut technic report induct definit system coq rule properti induct definit system coq rule properti emir pasal logic program lf logic frame work leap languag eval polymorph basic categori theori comput scientist microlanguag oper system specializa tion definit interpret higherord program languag definit interpret higherord program languag nikolao pa paspyr benaissa emir pasal peyton jone transform librari data structur sound reduct semant untyp cbn multistag comput direct function program realtim applic tag elimin type specialis typeindex effect tag elimin jonesoptim semant program languag fulli reflex intension type analysi syntact approach type sound elimin array bound check depend type depend type practic program tr basic categori theori comput scientist logic program lf logic framework induct set famili martinlomyampersandumlf type theori settheoret semant semant program languag partial evalu automat program gener syntact approach type sound compil polymorph use intension type analysi typebas compil standard ml modal analysi stage comput prove correct reactiv system use size type build domainspecif embed languag multistag program explicit annot dynam type stage type infer elimin array bound check depend type intension polymorph typeerasur semant depend type practic program flexibl type analysi resourc bound certif sound reduct semant untyp cbn mutlistag comput theori metaml nontriv extend abstract dsl implement use stage monad fulli reflex intension type analysi type system certifi binari principl program languag semant applic implement program gener tag elimin jonesoptim jonesoptim special strongli type languag induct definit system coq rule properti multistag program direct function program realtim applic ideal metaml inherit limit definit interpret higherord program languag program construct set theori modular domain specif languag tool multistag program ctr chiyan chen hongwei xi implement type program transform acm sigplan notic v38 n10 p2028 octob jason eckhardt roumen kaiabachev emir pasal kedar swadi walid taha implicitli heterogen multistag program new gener comput v25 n3 p305336 januari 2007 manuel fhndrich michael carbin jame r laru reflect program gener pattern proceed 5th intern confer gener program compon engin octob 2226 2006 portland oregon usa adam chlipala certifi typepreserv compil lambda calculu assembl languag acm sigplan notic v42 n6 june 2007 seth fogarti emir pasal jeremi siek walid taha concoqt index type proceed 2007 acm sigplan symposium partial evalu semanticsbas program manipul januari 1516 2007 nice franc oleg kiselyov chungchieh lightweight static capabl electron note theoret comput scienc entc v174 n7 p79104 june 2007 chiyan chen rui shi hongwei xi implement type program transform fundamenta informatica v69 n12 p103121 januari 2006 oleg kiselyov kedar n swadi walid taha methodolog gener verifi combinatori circuit proceed 4th acm intern confer embed softwar septemb 2729 2004 pisa itali sheard languag futur acm sigplan notic v39 n12 decemb 2004 edwin bradi kevin hammond verifi stage interpret verifi compil proceed 5th intern confer gener program compon engin octob 2226 2006 portland oregon usa jim grundi tom melham john oleari reflect function languag hardwar design theorem prove journal function program v16 n2 p157196 march 2006 walid taha michael florentin nielsen environ classifi acm sigplan notic v38 n1 p2637 januari