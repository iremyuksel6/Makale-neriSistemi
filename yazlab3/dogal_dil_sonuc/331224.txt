univers construct larg object abstractw present lockfre waitfre univers construct implement larg share object previou univers construct requir process copi entir object state impract larg object previou attempt address problem requir programm explicitli fragment larg object smaller manag piec pay particular attent piec copi contrast construct design larg shield programm fragment furthermor mani object construct result lower copi overhead previou one fragment achiev construct use loadlink storecondit valid oper larg multiword share variabl present construct show oper effici implement similar oneword primit b introduct paper extend recent research univers lockfre waitfre construct share object 3 4 construct use implement object lockfre waitfre manner thu use basi gener methodolog construct highlyconcurr object unfortun gener often come price specif space time overhead excess mani object particular sourc ineffici previou univers construct requir process copi entir object state impract larg object paper address shortcom present univers construct use implement larg object low space overhead take start point lockfre waitfre univers construct present herlihi 4 construct oper implement use retri loop herlihi lockfre univers construct processs retri loop consist follow step first share object pointer read use loadlink opera tion privat copi object made desir oper perform privat copi final storecondit sc oper execut attempt swing share object pointer point privat copi sc oper may fail case step repeat algorithm waitfre sc loop iter may fail ensur termin herlihi waitfre construct employ help mechan wherebi process attempt help process perform pend oper togeth mechan ensur work support part nsf contract ccr 9216421 young investig award us armi research offic grant number daaho49510323 process repeatedli unsuccess swing share object pointer eventu help anoth process fact two loop iter herlihi point construct perform poorli use implement larg object overcom problem present lockfre construct larg object fragment block link pointer construct oper implement block must access modifi copi herlihi lockfre approach implement larg object suffer three short come first requir fragment left programm determin base semant implement object programm must also explicitli determin copi done second herlihi approach difficult appli waitfre implement particular directli combin help mechan waitfre construct small object result excess space overhead third herlihi largeobject techniqu reduc copi overhead long chain link block avoid consid exampl larg share queue fragment linear sequenc block ie link list replac last block actual requir replac everi block sequenc particular link new last block requir pointer previou block chang thu nexttolast block must replac repeat argument follow everi block must replac approach implement larg object also base upon idea fragment object block howev differ herlihi arraybas rather pointerbas ie view larg object long array fragment block unlik herlihi approach fragment approach visibl user also copi overhead approach often much lower herlihi approach exampl implement share queue constant copi overhead construct similar herlihi oper perform use retri loop howev herlihi construct employ singl share object pointer need manag collect pointer one block array deal problem employ sc valid vl oper access larg share variabl contain block pointer larg variabl store across sever memori word 1 first part paper show effici implement use usual singleword sc vl primit present two implement one may return special valu indic subsequ sc fail call weakll anoth usual semant implement sc wword variabl take ow time vl take constant time first implement simpler second weakll return consist multiword valu case interfer concurr sc also weakll use avoid unnecessari work univers algorithm point perform privat updat subsequ sc certain fail reason use weakll univers construct waitfre univers construct first construct incorpor techniqu implement larg object construct impos upper bound number privat block process may bound assum larg enough accommod singl oper bound affect manner process may help one anoth specif process attempt help mani process simultan run risk use privat space avail abl solv problem process help mani process possibl oper choos process help way process 1 multiword oper consid access singl variabl span multipl word thu multiword oper consid 1 2 5 6 access multipl variabl store separ word multiword oper consid admit simpler effici implement consid 1 2 5 6 share initi initi valu implement variabl v privat initi proc long weak llvar r wordtyp return 0n 1 curr llx 2 ri buf curr pid curr tag 3 vlx return n 4 els return x pid fi proc long sc val return boolean 4 5 buf p ji val return sc x p j figur 1 wword weakll sc use 1word vl sc wword vl implement valid x eventu help enough space avail process help one process time call parallel help otherwis sever round help must perform possibl sever process call serial help tradeoff serial parallel help one time versu space remaind paper organ follow section 2 present implement sc vl oper larg variabl discuss present lockfre waitfre univers construct preliminari perform result section 3 end paper conclud remark section 4 due space limit defer detail proof full paper 2 sc larg variabl section implement vl sc oper wword variabl v use standard oneword vl sc oper 2 first present implement support weakll oper describ previou section present implement support oper usual semant latter implement guarante return correct valu v even subsequ sc oper fail unfortun guarante come cost higher space overhead complic implement mani applic howev oper suffic particular lockfre waitfre univers construct includ sc use pair way sc fail none comput sinc preced effect object use weakll avoid unnecessari comput 21 weakll vl sc oper larg variabl begin describ implement weakll vl sc shown figur 1 3 long weak long sc procedur implement weakll sc oper wword variabl v valu v store buffer share variabl x indic buffer contain current valu v current valu valu written assum sc oper fail spurious shown 1 sc oper fail spurious effici implement use sc oper might fail spurious 3 privat variabl figur assum retain valu procedur call v recent success sc oper initi valu v preced success sc vl oper v implement simpli valid x sc oper v achiev write wword variabl store buffer use oneword sc oper x make buffer current ensur sc oper overwrit content current buffer sc oper process p altern two buffer buf p 0 buf p 1 process p perform weakll oper v three step first execut oneword oper x determin buffer contain current valu second read content buffer third perform vl x check whether buffer still current vl succe buffer modifi ps read valu read p buffer safe return vl fail weakll reread x order determin id last process perform success sc process id return call process whose id return wit fail weakll see section 32 wit fail provid use state inform held execut weakll note vl line 3 fail buffer read p longer current henc subsequ sc p fail implement yield follow result theorem 1 weakll vl sc oper wword variabl implement use vl sc oper oneword variabl time complex ow o1 ow respect space complex onw 2 22 vl sc oper larg variabl show implement sc usual semant although oper implement suffici construct use larg sc might requir oper alway return correct valu v complic fact w word v access atom implement vl sc oper wword variabl v shown figur 2 like previou implement one employ share variabl x along set buffer also share array tag use buffer manag buffer manag differ describ previou subsect sever respect first process p 4n instead two anoth differ buffer contain inform specif old valu v new valu v two control bit control bit use detect concurr readwrit conflict bit togeth tag array employ ensur return correct valu despit interfer figur show two procedur long long sc implement sc oper v respect vl v perform simpli valid x long procedur similar long weak procedur except event vl x fail work requir order determin correct return valu buffer manag scheme employ guarante follow two properti buffer modifi process read buffer ii process concurr read buffer written process obtain correct valu either old field new field buffer full paper prove properti formal describ implement shown figur 2 detail pay particular attent ii describ long procedur focu code execut event vl x fail code distinguish long long weak procedur previou subsect process p execut long share initi initi valu l privat var val1 initi tag 0 last tag sucess sc proc long return wordtyp 1 curr llx 2 val1 buf curr pid curr tag new 3 vlx return val1 els 4 curr 5 ap curr 7 bit buf curr pid curr tag b 8 val2 buf curr pid curr tag old 9 buf curr pid curr tag return val2 els return val1 proc long sc newval wordtyp 10 read aj 11 select diff flast n tag readg flast n tag selectedg flast tag success sc dg 12 vlx return fals fi 13 bit buf p diff c 14 buf p diff c bit 15 buf p diff old val1 17 buf p diff new newval return sc x p diff figur 2 wword sc use 1word vl sc wword vl trivial implement valid x procedur vl x fail p might read corrupt valu buffer due concurr write order obtain correct return valu p read x ascertain current buffer read entir content buffer new b old c field within buffer written revers order read long procedur thu properti ps read cross one concurr write anoth process compar valu read b c field p determin whether cross point occur p read old field new field base comparison p choos correct return valu essenc formal proof requir establish properti ii describ long sc procedur focu buffer select mechan buffer select procedur simpli updat old new b c field buffer explain primari purpos buffer select mechan ensur properti hold time process p execut long sc read tag valu written ar process r line 10 tag valu read process turn n sc oper v p read tag process process p select buffer sc choos new tag line 11 new tag select differ last n tag read p differ last n tag select p differ last tag use success sc p last three condit ensur p overwrit current buffer first two condit ensur properti hold explain tag select first howev explain select mechan ensur properti observ process qs vl x line read one ps proc read tagv deleteread els deleteselect dequeueread q last q enqueueselect proc store tagv deleteselect enqueuelast dequeuelast q enqueueselect proc select tag return dequeueselect q enqueueselect return figur 3 pseudocod implement oper tag queue buffer buf p v line 6 9 q write p v aq line 5 p select modifi buf p v process q read buf p v p select buf p v next n sc oper thu p select buf p v p read aq line 10 long p v remain aq among last n tag read p henc p select buf p v modifi therefor properti hold conclud subsect describ tag select line 11 effici implement accomplish process maintain three local queue last select read queue record last n tag read last queue record last tag success written use sc x tag resid select queue new tag select tag queue maintain mean read tag store tag select tag procedur shown figur 3 procedur enqueu dequeu denot normal queue oper deleteq v remov tag v q modifi q v q x 2 q hold iff tag x queue q process p select tag line 11 figur 2 call select tag select tag move front tag ps select queue back return tag tag subsequ written x success sc oper line 18 p call store tag move tag select queue last queue tag previous last queue remov read queue return select queue process p read tag p v line 10 call read tag record tag read p v alreadi read queue read tag simpli move p v end read queue p v alreadi read queue enqueu read queue remov select queue necessari final tag front read queue remov longer one last n tag read tag also last tag written x return select queue read queue alway contain last n tag read last queue alway contain last tag success written x thu tag select select tag certainli last tag success written x among last n tag read full paper show maintain total 4n tag ensur tag select also one last n tag select requir maintain static index tabl allow tag locat constant time repres queue doublylink list queue oper describ implement constant time thu follow result theorem 2 vl sc oper wword variabl implement use vl sc oper oneword variabl time complex ow o1 ow respect space complex 2 w 2 block bank pointer current block process ps replac pointer process ps replac last object block mem array made sword block figur 4 implement mem array larg object construct 3 larg object construct section present lockfre waitfre univers construct larg object begin brief overview previou construct due herlihi 4 herlihi present lockfre waitfre univers construct small object well lockfre construct larg object 4 describ section 1 oper herlihi smallobject construct copi entir object sever disadvantag larg object herlihi largeobject construct implement object fragment block link pointer modif amount copi perform oper often reduc copi block affect oper howev fragment signific amount creativ work part sequenti object design often requir advantag herlihi largeobject construct realiz also approach provid advantag common object queue describ section 1 final herlihi present waitfre construct larg object lockfre waitfre univers construct larg object design overcom problem construct describ next section 31 32 respect section 33 present perform result compar construct herlihi 31 lockfre univers construct larg object lockfre construct shown figur 5 construct implement object store array unlik herlihi smallobject construct array actual store contigu locat share memori instead provid illus contigu array fact partit block oper replac block modifi thu avoid copi whole object describ code figur 5 first explain illus contigu array provid figur 4 show array mem divid b block word memori word mem 0 mem gamma 1 store first block word mem store second block bank pointer one block array maintain order record block current part array order chang content array oper make copi block chang attempt updat bank pointer instal new share pointer array block array copi block initi kth block initi valu privat var oldlst copi initi return wordtyp return blk ptr addr div saddr mod blkidx addr div index address dirti blkidx havent chang block dirti blkidx record block chang memcpyblk copi dirtycnt blk ptr blkidx sizeof old block new oldlst dirtycnt ptr blkidx dirtycnt ptr blkidx copi dirtycnt dirtycnt new block record old block prepar next one ptr blkidx addr mod val write new valu proc lf opop optyp par paramtyp true loop oper succe 1 long weak llbank object pointer dirti fals od dirtycnt copi yet 2 ret perform oper object 3 dirtycnt unnecessari sc 4 long sc bank ptr oper success reclaim old block 0 dirtycnt gamma 1 copi oldlst od return ret od figur 5 lockfre implement larg object pointer chang block pointer left unchang achiev use weakll sc oper larg variabl present section 21 4 figur 4 process p prepar modifi word last block other thu bank pointer written p current bank except last pointer point ps new last block oper process p access word array say mem x block current contain mem x must identifi ps oper modifi mem x p must replac block order hide detail identifi block replac modifi block address translat recordkeep necessari work perform special read write procedur call sequenti oper order read write mem array result construct complet transpar sequenti object design exampl instead write mem 1 mem 10 design would write write1 read10 howev discuss section 4 preprocessor could use provid complet transpar turn attent code figur 5 figur bank b word share variabl treat array b pointer actual indic blk array point block word togeth b block point bank make implement array mem assum upper bound number block modifi oper therefor addit b 4 extra paramet ad procedur section 21 explicitli indic share variabl updat block requir object copi block need per process give total block block store blk array although block blk nt blk nt initi array block blk pt blk p process ps initi copi block role block fix particular p replac set array block copi block result success sc p reclaim replac array block copi block thu copi block one process may becom block array later becom copi block anoth process process p perform lockfre oper call lf op procedur loop lf op procedur repeat sc line 3 succe iter process p first read bank local variabl ptr use bword weakll recal section 21 weakll return process identifi f0 n gamma 1g follow sc guarante fail case point attempt appli ps oper loop restart otherwis p record dirti array block yet modifi oper initi dirtycnt counter zero next p call op procedur provid paramet lf op op procedur perform sequenti oper read write element mem array read write perform invok read write procedur shown figur 5 read procedur simpli comput block current contain word access return valu appropri offset within block write procedur perform write word mem comput index blkidx block contain word written alreadi done write procedur record block dirti ie modifi copi content old block one ps copi block copi block link ps ptr array make block part ps version mem array displac old block record oldlst possibl reclaim later final appropri word new block modifi contain valu pass write procedur bank modifi anoth process ps weakll object contain ps version mem array point ps ptr array correct result appli ps oper therefor ps sc success instal copi object ps oper appli sc p reclaim displac block record oldlst replac copi block use perform oper hand anoth process modifi bank ps weakll sc ps sc fail case process complet oper implement lockfre conclud subsect one complic bear mention bank variabl modifi anoth process ps sequenti oper execut possibl p read inconsist valu mem array observ result p instal corrupt version object ps subsequ sc fail howev risk ps sequenti oper might caus error divis zero rang error read inconsist state object problem solv ensur bank invalid control return directli read procedur lf op procedur without return sequenti oper unix longjmp command use purpos detail omit figur 5 full paper prove follow theorem 3 suppos sequenti object obj implement array b sword block oper modifi block worstcas time complex c obj implement lockfre manner space overhead 5 onb nt contentionfre time complex ob interest compar complex figur herlihi lockfre 5 space overhead mean space complex beyond requir sequenti object construct consid implement queue store head tail pointer actual array indic pointer design block enqueu dequeu perform construct copi two block block contain head tail pointer updat block contain array slot point pointer space overhead case onb ns small compar ob size queue contentionfre time complex ob ob greater time sequenti enqueu dequeu contrast mention section 1 process herlihi construct must actual copi entir queue even use largeobject techniqu thu space overhead least n time worstcas queue length nb also contentionfre time complex sinceomegagamma bs time requir copi entir queue worst case implement balanc tree construct requir space overhead logb local block howev pay logarithm time cost perform oper whose sequenti counterpart modifi logarithm number array slot contrast herlihi construct entail logarithm time cost copi almost everi oper whenev block modifi chain block pointer must updat block block contain root tree 32 waitfre construct larg object waitfre construct larg object shown figur 6 lockfre construct present previou subsect construct use read write procedur figur 5 provid illus contigu array princip differ lockfre waitfre construct process waitfre construct help order ensur oper process eventu complet enabl process perform oper least one process togeth process p 2t privat copi block recal maximum number block modifi singl oper help mechan use waitfre largeobject construct similar use herlihi waitfre smallobject construct sever respect enabl process perform other oper process q begin announc oper paramet anc q line 11 figur 6 also process store suffici inform object allow help process detect oper complet determin return valu oper inform also ensur oper help subsequ reappli also sever differ help mechan herlihi first herlihi construct time process perform oper also perform pend oper process howev construct restrict amount privat copi space might prevent process simultan perform pend oper process therefor construct process help mani process oper order ensur process eventu help help counter ad share variabl bank use lockfre construct help field indic process help next time process p perform oper p help mani process possibl start process store help field achiev help process privat copi block remain accommod anoth oper line 22 24 recal write procedur figur 5 increment dirtycnt whenev new block modifi process p updat help field next process success perform oper start help p stop help mechan also differ herlihi way process detect complet oper herlihi construct complet detect mean appli copi boolean end share announc array block oper return valu last ret block updat process initi privat var oldlst copi match done bit loop boolean applyop initi 1 match anc q bit 2 ret rbq appli 6 match 3 applyop anc q op 4 applypar anc q par 5 ret rbq val applyopapplypar appli match proc return block return 0n 7 tmp long weak llbank ptr 8 tmp 6 n 9 return last tmp els 10 return ptr ret proc wf opop optyp par paramtyp announc oper 12 b done return block fals 13 done ret bpcopi 6 bit loop updat succe oper help 14 long weak llbank object pointer 15 0 dirti fals od dirtycnt modifi yet old return block instal new one 17 memcpyret rb ret oldrb sizeof privat copi return block appli oper 19 ret rbjappli 20 ret rbjcopi appli oper 22 dirtycnt suffici space remain 24 tri tri ptr help loop true fi 25 last p ptr help rb tri return block modifi oper success reclaim old block copi oldlst od 28 ret rbpcopi rb done bit copi bit next time current recent return block 30 return ret bpval get return valu oper figur waitfre implement larg object collect toggl bit one process store current version object attempt appli oper process p first announc new toggl bit valu anoth process help p copi bit valu current version object detect complet oper p test whether bit valu store current version object match bit valu previous announc access current version object p first read share object pointer read buffer point pointer order avoid race condit result oper return incorrect valu herlihi construct requir sequenc read perform twice race condit aris p attempt access current buffer ps access anoth process subsequ reclaim buffer privat updat dereferenc object pointer check toggl bit second time p ensur first buffer access reclaim ps oper alreadi appli process reclaim buffer help process oper therefor ensur ps oper appli construct guarante process help process p might reread share object pointer read toggl bit mani time ensur oper appli therefor use differ mechan explain determin whether oper appli enabl process detect oper appli determin return valu oper use set return block n block ret 0 ret n time one block current indic new ret field bank variabl process own one return block current return block contain process q return valu qs recent oper along two bit appli copi bit use q detect oper complet roughli speak appli bit indic qs oper appli object copi bit indic anoth oper complet sinc qs oper appli interpret bit determin anc qbit exampl qs oper appli iff qs appli bit current return block equal anc qbit see two bit need detect whether qs oper complet consid scenario figur 7 figur process p perform two oper first ps sc success p replac ret 5 ret 3 current return block line 26 ps first oper q start oper howev q start oper late help p ps execut line 26 q read bank line 7 determin ret 5 current return block p start second oper p previous replac ret 5 current return block ret 5 ps privat copi ps second oper use ret 5 record oper help p execut line 6 chang qs appli bit indic appli qs oper note stage qs oper appli ps privat object copi p yet perform sc howev q read appli bit ret 5 previous determin current ret block line 13 q incorrectli conclud oper appli object termin prematur similarli possibl q detect copi bit return block ret b equal anc qbit sc make ret b current howev qs copi bit updat appli bit success instal part current return block follow process must previous appli qs oper thu q termin correctli case see line 13 remain describ process q determin return block contain current state qs oper suffici q perform weakll bank read ret field weakll guarante return valu bank success 14 26 14 6 ancqbit ret5qappli figur 7 process q prematur detect appli bit equal anc qbit sc oper interfer case weakll return id wit process perform success sc bank weakll oper prepar possibl process p record return block use last p line 25 attempt make block current line 26 q detect interfer success sc q use last entri wit process determin return block read last entri contain index return block current qs weakll oper block subsequ written current copi recent current return block content still valid waitfre construct give rise follow result theorem 4 suppos sequenti object obj whose return valu r word implement array b sword block oper modifi block worstcas time complex c 2t obj implement waitfre manner space overhead onnr worstcas time complex odn minn bmt ceb nr 33 perform comparison subsect describ result preliminari experi compar perform herlihi lockfre construct larg object two construct 32processor ksr1 multiprocessor result one set experi shown figur 8 experi sc primit implement use nativ ksr lock processor perform 1000 enqueu 1000 dequeu share queue test construct chose b number block size block approxim squar root total object size also chose queue oper access two word waitfre construct chose suffici guarante process help least one oper fact two consecut enqueu dequeu oper usual access choos suffici ensur process often help process time perform oper choic result low space overhead compar requir herlihi construct expect lockfre waitfre construct significantli outperform herlihi construct queue size grow oper herlihi construct copi entir object copi small part object interest note waitfre construct outperform lockfre one 6 shown success oper guarante advanc help pointer minn bmt c thu process ps sc fail dn minn bmt ce time ps oper help consid bound note mani object r small constant also queue c constant balanc tree c logarithm size object time forenqueu anddequeu queue size comparison larg object construct share queue lockfre waitfre herlihylockfre herlihylockfreebackoff figur 8 perform experi ksr believ cost recopi block event sc fail domin cost help also interest note exponenti backoff significantli improv perform herlihi lockfre construct stand contrast herlihi experi small object exponenti backoff play import role improv perform believ perform herlihi larg object construct domin copi content point deliber chosen queue show advantag construct herlihi full paper also present implement skew heap object consid herlihi expect construct still outperform herlihi albeit less dramat copi logarithm number block sequenti oper herlihi whenev block near bottom tree modifi conclud remark construct improv space time effici lockfre waitfre implement larg object also contrast similar previou construct requir programm determin object fragment object copi howev requir programm use special read write function instead assign statement use convent program nonetheless demonstr figur 9 result code close ordinari sequenti implement construct could made complet seamless provid compil preprocessor automat translat assign mem call read write function applic construct could improv addit dynam memori alloc mechan would provid conveni interfac object balanc tree natur repres node dynam alloc releas wellknown techniqu implement dynam memori manag array techniqu could appli directli sequenti object programm could provid subroutin librari sever issu aris design librari first dynam memori alloc pro int dequeu int item readhead readtail return empti return item int enqueueitem int item int newtail int newtail newtail readhead newtail head return full return full return success return success figur 9 c code use queue oper comment show usual enqueu code cedur must modifi small number array block advantag construct preserv second fragment complic implement alloc releas procedur complic make procedur quit ineffici even caus alloc procedur incorrectli report insuffici memori avail problem significantli reduc size alloc request fix advanc mani object restrict consequ exampl node tree typic size final construct allow parallel execut oper even oper access disjoint set block would like extend construct allow parallel execut possibl exampl share queue implement enqueu oper might unnecessarili interfer dequeu oper 1 address similar concern implement waitfre oper multipl object acknowledg would like thank lar nyland help perform studi section 33 r univers construct multiobject oper method implement lockfre share data structur waitfre synchron methodolog implement highli concurr data object disjointaccessparallel implement strong share memori primit softwar transact memori tr ctr mage michael high perform dynam lockfre hash tabl listbas set proceed fourteenth annual acm symposium parallel algorithm architectur august 1013 2002 winnipeg manitoba canada mark moir lazi pay use lazi synchron mechan improv nonblock construct proceed nineteenth annual acm symposium principl distribut comput p6170 juli 1619 2000 portland oregon unit state mage michael safe memori reclam dynam lockfre object use atom read write proceed twentyfirst annual symposium principl distribut comput juli 2124 2002 monterey california simon doherti mauric herlihi victor luchangco mark moir bring practic lockfre synchron 64bit applic proceed twentythird annual acm symposium principl distribut comput juli 2528 2004 st john newfoundland canada yuhjzer joung asynchron group mutual exclus distribut comput v13 n4 p189206 novemb 2000 mauric herlihi victor luchangco paul martin mark moir nonblock memori manag support dynamics data structur acm transact comput system toc v23 n2 p146196 may 2005 hagit attiya eyal dagan improv implement binari univers oper journal acm jacm v48 n5 p10131037 septemb 2001