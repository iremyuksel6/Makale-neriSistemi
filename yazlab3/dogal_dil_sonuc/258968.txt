type specialis imper languag extend type specialis comput lambda calculu firstclass refer result specialis use specialis selfinterpret type comput lambda calculu optim furthermor specialis perform oper refer specialis time possibl b introduct far import program specialis techniqu partial evalu partial evalu program transform program part input static part transform new program partial evalu perform oper enough data avail reconstruct rest interpret oper valu partial evalu oper valu symbol valu code valu combin code valu partial evalu appear two variant onlin offlin onlin partial evalu specialis decis taken inspect symbol valu wherea offlin variant specialis decis taken actual run specialis decis commun specialis mean twolevel annot program annot introduc hand mean bindingtim anal ysi specialis case interpret twolevel program type specialis extens offlin partial evalu specialis express collect nonstandard type rule type infer rule specifi transform express e type via specialis judgement gamma code part dynam part result appli transfor mation 0 play role symbol valu partial evalu may contain valu static support belgian nation fund scientif research nfwo work done visit chalmer work done visit chalmer appear proceed icfp97 part use static comput dynam part treat blackbox set specialis correspond build proof specialis judgement advantag partial evalu symbol valu residu type propag via type unif 1 combin rich languag residu type superior valu propag strategi type unif enabl hugh achiev optim specialis selfinterpret type lambda calculu feat achiev standard partial eval uation optim specialis context mean specialis interpret respect term yield term ffconvers problem presenc univers type selfinterpret standard partial evalu abl get rid tag untag oper univers type work serv two purpos first show type specialis modular respect addit new type constructor refer comput sec ond show type specialis restrict pure function languag also appli specialis oper comput effect perform oper refer specialis time languag like ml formal extend type specialis extens moggi comput metalanguag ml firstclass refer demonstr use extens instanti store monad result type specialis oe ml ml extend mlstyle oper refer distinguish featur specialis fact perform oper refer static special achiev optim specialis selfinterpret oe ml also yield satisfactori result interest problem describ overview reader unfamiliar type speciali sation start short type specialis primer inform found hugh origin paper introduc languag oe ml extens moggi comput lambda calculu firstclass refer first step toward full specialis state specialis rule treatment dynam refer oper appli specialis self interpret oe ml achiev optim specialis second step add specialis rule static refer appli specialis interpret lazi function languag implement lazi use updat inform found section closur next discuss extens state thread state new postprocess rule final assess work respect partial evalu consid relat work conclud type specialis primer type specialis form program specialis type play central role rather say one term specialis anoth term say sourc term type specialis residu term type e carri inform control specialisa tion particular bindingtim type former come static dynam variant mark dynam one underlin usual residu type suffici refin carri static inform mean static valu need appear residu term exam ple static integ constant specialis dummi val residu type record integ dummi valu repres residu type inform enough specialis express use static valu appropri exampl lift oper convert static integ dynam one specialis constant valu given residu type argument welltyped sourc term check specialis welltyped residu term check construct specialis thu specialis embodi residu typecheck unif typecheck propag static inform specialis exampl specialis dynam function applic yield unif assign x residu type 3 suffici inform perform static addit specialis lift 4 type specialis propag static inform effect partial evalu modifi exampl slightli specialis sinc unif assign x residu type 3 enabl static addit perform allow f assign residu type 3 4 enabl lift specialis constant done even though f dynam function whose call may unfold convent partial evalu allow dynam function return static result sinc deriv static valu reduc express normal form dynam function applic must reduc type specialis inher monovari modifi exampl longer specialis f would need assign 3 int 4 int residu type polyvari easili ad via new sourc type poli constructor poli selector spec express poli e specialis tupl specialis e spec e specialis select tupl rewrit exampl poli xlift x1 spec f 3 spec f 4 int specialis f residu type 3 int residu type inform enough enabl spec choos right version call convers type inform spec enough enabl poli decid version creat altern could chang f exampl static function note applic longer line static function unfold specialis exampl call f replac specialis bodi cours two specialis differ order unfold static function applic specialis repres static function closur static part closur bound variabl name bodi residu type free variabl make residu type static dynam part tupl becom residu term residu type static function say noth type argument result function freeli appli differ static argument differ call exampl f free variabl residu term empti tupl dummi valu result specialis exampl reveal static comput leav undesir residu dummi valu specialis pro gram optim specialis must remov static comput complet fortun dummi valu remov postprocess phase call void erasur complet static express yield residu type singl element exampl 3 4 3 4 3 theta 4 express safe replac dummi valu ffl type void use isomorph elimin void compon void paramet cours letbound variabl void type void erasur often simplifi residu program drastic exampl last two specialis becom optim specialis type interpret demand specialis univers type interpret poli e j spec e term poli type poli poli figur 1 twolevel sourc languag 1 e 0 figur 2 basic specialis rule use repres valu appropri exampl interpret calculu integ might use type data repres valu exampl static sum type constructor encod type interpret valu must known static therefor emb static constructor residu type rather residu term exampl residu type record fact num constructor appli need appear residu term case express static sum simplifi one branch given residu type inspect ex pression neither runtim type tag runtim tag check need appear residu program interpret oe ml specialis optim given cours partial evalu also implement static sum type keep track constructor static specialis interpret optim need abl return valu static sum type dynam function type specialis deriv static inform type infer problem partial evalu use reduct imposs figur give syntax twolevel type system larg fragment metalanguag essenti twolevel version simplytyp calculu full languag also includ sum product omit allow type recurs special syntax point wish emphasis type freeli form accord syntax given wellformed condit argument result dynam function type must dynam neither side condit type rule requir exampl variabl bound dynam let dynam type extra condit essenti part twolevel calculi need make partial evalu possibl key advantag type specialis condit drop standard semant metalanguag usual semant callbynam calculu static dynam construct distinguish poli e spec e semant e annot control specialis affect mean origin program type specialis specifi quit simpli via specialis rule let us infer judgement form context gamma tell us specialis variabl via sequenc entri select figur 3 comput metalanguag specialis rule appear figur omit rule static function littl complic express compar rule static dynam let express differ static let un fold dynam one precis static inform bound variabl x avail case contrast partial evalu variabl bound dynam let must dynam specialis rule complic implement usual type infer rule syntaxdirect descript implement beyond scope paper found 3 metalanguag effect languag effect invari harder treat formal pure function languag one reason evalu order suddenli becom import even construct pure subset ad refer unrestrict assign metalanguag would therefor chang semant everi construct potenti invalid specialis rule present avoid chosen work moggi comput metalanguag ml explicitli distinguish valu type comput effect deliv result type latter assign comput type trivial comput ef fect creat unit oper j result comput inspect use mlet x e1 e2 combin comput e1 e2 sequenc bind x valu e1 deliv evalu e2 extens syntax typesystem metalanguag shown figur e1 e2 comput effect type error write e1 e2 instead must write mlet x1 e1 mlet x2 e2 j x1 make evalu order explicit similarli pass result e1 function f must write mlet x e1 f x make explicit e1 evalu call write f e1 instead would comput e1 first would pass entir comput paramet f invok later f pleasur think valu type suspend comput invok mlet mani differ kind effect repres moggi framework depend type oper j mlet interpret repres side effect store exampl interpet comput function store beforehand result store afterward mlet x e1 note translat pass store e1 produc e2 x scope e2 oper creat assign refer interpret suitabl function comput type interpret j mlet call monad provid satisfi socal monad law mlet x e mlet x mlet e1 e2 mlet e1 mlet x e2 e3 third law must occur free e3 haskel provid imper oper exactli way cours imper languag distinguish comput explicitli howev well known calculu implicit effect simpli translat sever differ way ml translat make differ evalu order explicit extend callbyvalu translat map say ml algol program metalanguag thu claim type specialis also applic languag simpli map intermedi form make evalu order explicit first moggi languag conserv extens calculu mean pure subset remain unchang isomorph void remain true function type effect must comput type side repres suspend com putat big advantag us type specialis void erasur rule pure metalanguag remain valid effect ad need defin new rule new construct specialis rule j mlet given yet depend kind effect interest note oper come static dynam version inde interest static dynam effect sinc kind may use one comput need one comput type therefor one version monad oper specialis oper state approach specialis imper oper three step first consid situat oper defer run time alreadi enough achiev optim specialis self interpret sec move consid static effect final section show combin figur 4 oper dynam refer residu type 1 e 0 figur 5 specialis rule dynam state two requir us factoris monad static state transform second monad specialis manipul static state 41 specialis dynam state shall extend metalanguag oper cre ate inspect updat dynam refer addit syntax type rule given figur ref creat refer read content assign cours three oper comput type assumpt monad oper dynam specialis rule turn rather straightforward see fig monad oper simpli specialis subexpress reconstruct selv spite simplic still possibl achiev interest result sinc dynam refer contain static inform residu type propag rest comput via unif exampl specialis mlet r ref 2 mlet x j lift yield mlet r ref ffl mlet x j 3 int static valu 2 present runtim preserv residu type r ref 2 r dereferenc know static result 2 even though r dynam see specialis express refer r still exist residu program useless content void type final phase type specialis void erasur extend remov refer oper thu transform term j 3 assum read write oper refer test refer equal also avail eras void refer would correct sinc residu type dynam refer includ residu type valu contain valu assign must static part exampl valu assign r 2 dynam refer contain partial static valu static part must assign dynam part vari exampl refer type ref univ univ defin sec creat mlet r ref num lift 2 could later assign num lift 3 num lift 4 valu residu type num int could assign valu form fun f residu program would contain refer int would assign untag valu 2 3 4 want refer contain mani differ static valu oblig use static refer situat compar differ static dynam function dynam function specialis one static argument wherea static function unfold appli number data data case e case eval env e 1 case eval env e case eval env e1 case eval upd env v e2 case eval env e e 1 case eval env e1 eval iwrong figur selfinterpret optim specialis 42 optim specialis specialis alreadi capabl optim specialis show give selfinterpret metalanguag figur interpret recurs see specialis rule recurs sinc interpret languag type repres valu static sum type express type univ specialis residu type exampl num int fun num int us type valu repres type tag known specialis time correspond tag test simplifi away specialis consequ interpret specialis welltyp program suppli illtyp input lead failur residu type infer refer need write self interpret use refer interpret model refer interpret program refer assign valu one type caus interpret languag welltyp specialis valu assign static part specialis interpret term obtain essenti term result ffconvers oper interpret give rise residu code mark dynam lift interpret constant monad oper mlet j inspect clear case eval specialis copi second argument provid true recurs call exampl case constant contain one lift gener residu constant case express contain one dynam gener residu express two case break pattern rf gener addit mlet j howev alway remov postprocessor appli monad law case rf residu code alway mlet r ref e j r second monad law equal ref e case residu code form mlet z e1 e2 j ffl sinc z type void equival mlet z e1 e2 j z equal e1 e2 second monad law postprocessor perform simplif specialis interpret therefor optim fact postprocessor may simplifi addit dex accur specialis interpret term obtain reduct origin term claim specialis still consid optim would unreason refus specialis sometim perform simplif optim requir 43 specialis static state dynam refer creat updat runtim consequ know content special isat insist content static part know specialis time exampl express mlet r ref 2 mlet z r 3 r would caus specialis error sinc r use ref 2 ref 3 residu type could avoid error make refer content dynam mlet r ref lift 2 mlet z r lift 3 r specialis succe sinc r residu type ref int hand use simplif perform constrast static refer creat updat specialis specialis keep track content static state may freeli assign residu type 1 s0 e 0 figur 7 specialis rule static state valu differ residu type differ time exampl rewritten use static refer mlet r ref 2 mlet z r 3 r specialis succe produc section shall consid specialis languag static refer new oper type analog dynam refer figur differ omit underlin specialis dynam state abl treat monad oper black box effect defer runtim specialis need know anyth treat static effect longer case let us therefor say explicitli comput type state comput repres function static state tupl content exist static refer actual build tupl pair let us defin littl syntact sugar valu type also obviou translat pattern match combin project sourc program static state implicit residu program repres explicitli tupl pass explicitli residu comput encount problem residu type static state tupl type whose compon residu type content refer comput may modifi residu type thu residu pro gram comput may modifi content state type residu comput type form oe residu type state beforehand oe 0 type afterward type monad mean express residu program term monad oper howev st much common monad exampl give sensibl definit mlet monad law hold call quasimonad 2 specialis rule static refer given figur rule j mlet gener code pass state around explicitli notic rule mlet residu type propag static inform store e1 e2 via share variabl oe 1 creat static refer third rule enlarg static store one element static refer may well dynam content becom part residu static store static inform need new refer locat refer introduc new form residu type loc repres ith locat dereferenc assign oper gener function access modifi residu store appropri notic residu type record precis static content everi refer oper last three rule appli unless shape static store known last two either appli unless address static locat also known specialis inform propag context unif consid specialis error possibl determin size static store specialis exampl suppos specialis term mlet x ref lift 2 mlet ref 3 mlet z x lift 4 j x initi empti static store result appli 2 quit differ steel pseudomonad 1 s0 e 0 figur 8 specialis rule mix state specialis rule s3 x s3 s0 x z void type remov void eras also delet void compon tupl result void erasur case s3 s3 use postprocessor contract trivial firedex actual paramet variabl sinc specialis rule introduc mani final result postprocess static oper store remov result program pass around dynam valu held residu program gener approach pure function pass around dynam compon static store explicitli altern approach consid store dynam compon dynam store instead thu everi static refer dynam content would associ refer residu program hold dynam part content rememb static refer hold valu differ residu type differ time ex ampl refer type ref univ could hold num n fun f differ occas singl residu refer hold dynam part n f differ type could perhap associ static refer tupl refer residu program one type valu assign derefer oper would cours know static associ residu refer held current dynam part content refer creation would awkward one correspond residu refer would uninitialis problem probabl solubl feel approach present consider simpler 44 specialis mix state know specialis static dynam state separ rel straightforward specialis togeth trick separ monad two part static part manipul explicitli specialis dynam part treat black box therefor interpret monad type monad type use residu program previou section residu comput may chang type static state type form specif rule modifi produc term type modifi rule dynam refer oper pass static store unchang modifi rule static refer oper construct trivial 0 comput use j modifi rule given figur 45 specialis lazi interpret demonstr capabl specialis specialis lazi interpret term lazi implement use updat closur applic abstract pass refer closur evalu reduc argument weakhead normal form perform updat refer cell provid bound number closur creat refer oper perform static figur show interpret specialis interpret term xxx1 2 yield residu type st hi hvl num inti num int output store contain vl num int constructor vl tell us correspond closur evalu specialis time constructor num also manipul specialis time mean elimin tag untag residu pro gram remain store run time integ residu term simplic see section let f b result program although bit awkward expect structur f correspond abstract b argument 1 2 build closur closur b take store return result addit f take closurederefer taken place specialis time appli closur itselfth closur sole element store result applic comput taken apart monad let perform addit tupl result updat store applic store may seem strang perfectli admiss recurs type int result void erasur delimit effect type specialis abl among thing deriv static inform result dynam condit exampl b num lift tell us static result tag num cours possibl residu program well type two branch must residu type arm condit comput impli must leav static store state awkward meet restrict mean refer creat one branch exactli correspond refer must creat assign content static part partial evalu imper languag handl problem forbid modif static store arm dynam condit make static store much less use solut problem support stack disciplin static store introduc store prompt e caus specialis dealloc static refer creat e specialis complet see fig use store prompt arm dynam condit arm refer previou static store creat use local refer without caus residu type mismatch cours store prompt use local refer escap enclos express explain oper static store specialis size store known specialis rule propag static store oper oper initi size store known size deriv subsequ oper cours intend initi store empti far gloss specifi fact reason want specifi size store consid function tmlet r ref 1 mlet v liftv use static store intern comput 1 function type intm int specialis without know size static store point call seem unfortun sinc doesnt refer nonloc refer moreov function call two point differ static store would need make polyvari construct two differ specialis even though doesnt access differ store would case even insert store prompt function definit solut run comput function bodi new empti static store defin two new oper differ treatment dynam store see fig runm e turn comput effect one without comput perspect run e complet new static dy namic store e neither access modifi enclos store state thread residu type involv monad residu code must includ effect delimit runm runm e run e type new empti static store thread dynam store e access modifi nonloc dynam refer residu type still dynam store ensur refer neither escap runm e import outsid analog runm e static refer gloss problem appli launchburi peyton joness solut relat problem specialis rule runm e see fig appli residu quasimonad e empti initi static state run result dynam comput discard final static state result valu residu type 0 rule runm e also appli residu quasimonad empti static state final state oe 0 di card contrast runm result express might still induc effect runtim reason thread result comput dynam comput thread specialis initi exampl two way mlet v mlet v data data data case e case v mlet case b ap mlet ref bl 0 mlet b cl mlet c eval env e2 vl c case f pl eval env e1 mlet b eval env e2 case case b eval iwrong figur 9 lazi interpret figur 10 type specialis rule store prompt specialis combin firstclass function static refer due dussart thiemann convent partial evalu dynam function static argument consequ alway specialis bodi dynam express empti static store runm essenti simul behaviour effect delimit runm runm rather blunt instrument ideal would like abl specialis comput know content static refer actual refer likewis would like abl invok specialis differ static store provid refer actual use content requir polymorph residu program want invok residu function store differ residu type gener polymorph program type specialis far open problem must solv better treatment static store possibl 6 postprocess remark oe ml pure languag sens isomorph like void still valid therefor techniqu void erasur lambda calculu still valid 61 void erasur void eras follow one simpl principl replac everi express whose type denot singleton set ffl apart standard situat involv product sum function type describ hugh two addit type constructor consid ref keep refer type ref void make sens unless equal oper refer eras absenc oper howev type void denot comput return void comput may well affect dynam state eras sinc regard ref void useless replac figur 11 type rule store delimit figur 12 specialis rule store delimit oper process appropri monad unit process remov oper dynam state residu oper static state express explicit store pass simplif rule standard type suffic simplifi 62 monad simplif residu program written monad style contain lot redund monad let unit expr sion partli due action preced void erasur express present ideal target appli three monad law moggi prove ml sound complet respect monad mod el specif model use state transform therefor applic monad law safe sens duplic discard reorder comput type x void applic rule drop let e 0 entir type x void case let postprocessor unfold let gener use simplic term form appear quit often appli preced transform final simplif discard trivial comput wrap runm runm j e e 63 simplif due explicit storepass style residu program contain mani trivial firedex like xe x convert letexpress appli simplif outlin seriou fi reduct perform explicit represent store tupl introduc lot extran tupl tupl oper elimin via ariti rais phase final explicit storepass introduc mani jredex top comput affect static store therefor void eras also perform jreduct assess type specialis enhanc partial evalu inform propag unif enabl sideway inform exchang sourc program execut tree wherea partial evalu restrict path execut tree consequ residu program construct bottomup manner rather program fragment construct demanddriven order prescrib flow inform much power type specialisaton stem refin type languag use type languag abl express singl element type play role symbol valu partial static valu standard partial evalu contrast partial evalu twolevel type disciplin type specialis impos wellformed condit like abstract dynam argument result must also dynam anoth instanc fact dynam refer may hold static valu liber uniqu type specialis key optim specialis result type function languag report hugh initi work allow inform static tag commun dynam function howev wellformed condit heart tradit bindingtim analysi bindingtim analys construct least static assign wellform type term dynam input forc comput dynam also via wellformed condit static type assign alway best lead strongest specialis type specialis contrast check twolevel program welltyp infer best assign twolevel type onelevel program absenc wellformed constraint mani oper made static mean exampl interpret paper chose make univ static sum type type tag would remov specialis consequ interpret specialis welltyp program interpret type languag chosen make univ dynam sum instead type tag would remain residu program would abl specialis interpret arbitrari program interpret accept untyp languag neither altern obvious better believ choic made autom analysi assign bindingtim interpret essenti way specifi static semant interpret languag creativ activ furthermor type specialis also perform program analysi residu program construct residu program exampl shown hugh work construct firstifi twolevel interpret type lambda calculu type special perform closur analysi construct recurs residu type fli 8 relat work 81 type constructor specialis hugh introduc type specialis simplytyp lambda calculu product sum current work conserv extens moggi comput metalanguag type specialis embodi constructor specialis extend higherord languag hagiya iino consid weaker variant constructor specialis call data type specialis lisplik languag set extens standard partial evalu framework consist extend bindingtim analysi specialis express nonstandard interpret construct residu program composit manner bechet give account similiar techniqu gear toward type languag constructor specialis type specialis construct residu program order 82 partial evalu partial evalu tradit imper languag like fortran c pascal modula2 perform side effect special time howev none incur problem inher higherord control flow face problem deal pointer similar problem firstclass refer present work type specialis deal satisfactorili languag higherord control flow firstclass refer partial evalu higherord function languag quit common attempt handl side effect follow approach bondorf danvi defer side effect like oper refer assign global variabl io run time recent approach perform partial evalu imper program static oper refer moura consel lawal show use schism partial evalu pure scheme poy variant bindingtim analysisto specialis program c languag transform sophist variant storepass style approach avoid construct new program analys new partial evalu techniqu imper program dussart thiemann construct offlin partial evalu simplytyp lambda calculu firstclass refer system tradit monovari bindingtim analysi ensur error special time bindingtim analysi base effect system system automat contrast type specialis work manual annot program 9 conclus type specialis adapt seamlessli specialis imper languag unif give us necessari power achiev optim specialis version moggi comput metalanguag firstclass refer use comput metalanguag oe ml turn big win first add rule new construct languag type special exist rule chang contrast special dussart thiemann everi special rule chang order thread state comput second specialis complet independ evalu order sequenc monad oper fix remain part program special without commit specif evalu order third conjectur monad approach allow modular extens cater ex ception nondetermin etc acknowledg thank anonym review mad toft valuabl comment r program analysi special c program languag partial evalu numer program fortran remov valu encod use altern valu partial evalu stronglytyp languag automat autoproject higher order recurs equat automat autoproject recurs equat global variabl abstract data type effici analysi realist offlin partial evalu practic aspect special algollik program tour schism gener approach runtim special applic c partial evalu polyvari constructor special partial evalu higherord languag state build interpret transform stratifi monad bind time analysi data type special function program languag comput architectur type specialis partial evalu automat program gener stronglytyp selfapplic partial evalu modular denot semant compil construct ml partial evalu use setbas analysi techniqu partial evalu imper languag constructor special comput lambdacalculu mon ad bridg gap function imper languag automat onlin partial evalu tr comput lambdacalculu monad ariti raiser use program special techniqu partial evalu imper languag automat autoproject recurs equat global variabl abstract data type stronglytyp selfapplic partial evalu automat onlin partial evalu twolevel function languag automat autoproject higher order recurs equat partial evalu automat program gener partial evalu semanticsbas program manipul constructor special gener account continuationpass style build interpret compos monad lazi function state thread polyvari constructor specialis state haskel gener approach runtim special applic c function program languag comput architectur partial evalu remov valu encod use altern valu partial evalu stronglytyp languag handwrit program gener gener practic aspect special algollik program type specialis lambdacalculu new paradigm partial evalu base type infer ctr john hugh type special acm comput survey csur v30 n3e sept 1998 john hatcliff foundat partial evalu function program comput effect acm comput survey csur v30 n3e sept 1998 kedar swadi walid taha oleg kiselyov emir pasal monad approach avoid code duplic stage memoiz function proceed 2006 acm sigplan symposium partial evalu semanticsbas program manipul januari 0910 2006 charleston south carolina gill barth john hatcliff morten hein b srensen cp translat applic cube beyond higherord symbol comput v12 n2 p125170 septemb 1999