ioeffici dynam planar point locat present ioeffici dynam data structur point locat gener planar subdivis structur use oinbi disk block size ibi store subdivis size ini queri answer ologinfibiinfsup2supini io worstcas insert delet perform ologinfibiinfsup2supini ologinfibiinfini io amort respect part data structur base extern version socal logarithm method allow effici dynam static externalmemori data structur certain characterist anoth import part structur extern data structur vertic rayshoot among line segment plane endpoint ibi line develop use extern version dynam fraction cascad believ method could prove help develop dynam extern memori data structur b introduct planar point locat dene follow given planar subdivis n vertic ie decomposit plane polygon region induc straightlin planar graph preprocess data structur arbitrari queri point p face contain p report quickli problem aris sever applic includ graphic spatial databas geograph inform system planar subdivis aris mani applic massiv intern memori must resid disk instanc io commun bottleneck instead cpu run time work date especi allow edg vertic chang dynam focus minim cpu run time assumpt subdivis ts main extend abstract version paper present sixteenth annual acm symposium comput geometri socg00 support part nation scienc foundat ess grant eia9870734 ri grant eia9972879 career grant ccr9984099 email largecsdukeedu z part work done visit duke univers email janmathunimuensterd memori 7 11 12 17 20 24 result known ioecient point locat subdivis store extern memori 1 5 14 18 27 paper develop rst space ioecient dynam data structur planar point locat gener subdivis previous structur known case monoton 1 subdivis 1 11 previou result intern memori edelsbrunn et al 16 propos optim data structur point locat monoton subdivis space preprocess time olog 2 n queri time arbitrari planar subdivis either preprocess time space requir increas log 2 n see eg 20 24 allow edg vertic chang dynam two linearspac structur known gener subdivis one cheng janardan 11 answer queri olog 2 support updat olog 2 n time baumgarten et al 7 support queri olog 2 n log 2 log 2 n time worstcas insert olog 2 n log 2 log 2 n time amort delet olog 2 structur store edg subdivis interv tree 15 construct xproject rst suggest 17 use structur answer vertic rayshoot queri queri point p nd rst edg hit ray eman p ydirect answer vertic rayshoot queri face contain p found olog 2 n time 23 summari known result found recent survey 25 paper interest problem dynam maintain planar subdivis disk number io oper io use perform queri updat minim consid problem standard twolevel io model propos aggarw vitter 2 model n denot number element problem instanc number element tting intern memori b number element per disk block n 2 b 2 io oper read write disk block extern memori comput done element present intern memori measur perform number io use solv problem amount space disk block use aggarw vitter 2 consid sort relat problem io model prove sort requir nb log mb nb io note assumpt b onb log b n search set n order element requir log b n io io ecient algorithm data structur develop numer problemsse recent survey sampl result 3 28 previou result point locat extern memori either static batch dynam goodrich et al 18 design static data structur use onb space store monoton subdivis queri answer optim olog b n io also develop structur answer batch k pointloc queri optim kb log mb n io arg et al 5 extend batch result gener subdivis see also 14 arg et al 4 olin dynam set sequenc queri updat given advanc queri answer sequenc oper perform vahrenhold hinrich 27 consid problem practic assumpt input data known dynam structur recent propos agarw et al 1 restrict monoton subdivis linearspac onb 1 polygon call monoton direct line direct 2 intersect polygon connect interv planar subdivis monoton face monoton xed direct sometim assum b m2 simplic make realist assumpt main memori capabl hold b 2 element techniqu develop paper work without assumpt disk block structur support queri olog 2 io worst case updat perform olog 2 12 result paper present rst provabl ioecient dynam data structur point locat gener planar subdivis structur use optim onb disk block store queri answer olog 2 io worstcas insert delet perform olog 2 part data structur base new extern version socal logarithm method 9 allow ecient dynam static externalmemori data structur certain characterist precis assum static externalmemori data structur extern orderdecompos 4 problem p construct onb log b n io queri answer olog kq io delet perform olog k method use construct linearspac dynam data structur 0 p answer queri olog kq 1 io support insert delet olog 2 anoth import part structur data structur vertic rayshoot among line segment plane endpoint line develop use new extern version dynam fraction cascad 10 21 direct use fraction cascad line segment data structur complic fact segment compar accord abovebelow relat ie one total order exist set segment plane believ idea use data structur independ interest prove help develop extern memori line segment data structur remaind paper organ follow section 2 review static version structur agarw et al 1 work gener subdivis also discuss structur modi support delet made semidynam section 3 discuss gener dynam techniqu show use obtain dynam point locat structur support queri olog 3 io section 4 show improv bound olog 2 use extern version dynam fraction cascad follow concentr answer vertic rayshoot queri among edg planar subdivis intern memori face contain queri point p easili found olog b n io rayshoot queri answer simplifi present assum wlog vertic distinct xcoordin make frequent use btree 19 btree object store leav level intern node except possibl root b children paper b 2 b c constant 0 c 1 node store o1 block tree height olog b c normal btree 8 13 structur case call structur btree unless 3 gener 2b b 2 insert bound olog b n log mb nb gener structur construct onb log mb nb io assum 2b made dynam insert delet bound olog b n log mb nb olog specic state otherwis assum leaf contain b object tree use onb disk block total sinc tree height olog b n search perform olog b n io insert delet also perform olog b n io use olog b n split fuse oper node rootleaf path 19 basic idea static version structur agarw et al 1 similar one use sever main memori structur 7 11 17 set edgesseg store twolevel tree structur rst level interv treeher extern interv tree 6on xproject base interv tree btree xcoordin endpoint segment segment store secondari structur associ node node v associ vertic slab v root associ whole plane interior node v v partit vertic slab separ vertic line call slab boundari dash line figur 1 slab contain number vertic slab associ ith child v segment store highest node v intersect slab boundari associ v let v set segment store v leaf z store segment whose endpoint lie interior slab z number segment store leaf ob henc occupi o1 block let v intern node let segment v suppos left endpoint lie slab l right endpoint lie slab r associ v call subseg l left subseg r right subseg portion lie call middl subsegmentse also figur 1 let r denot set middl subseg segment v 1 b let l denot set left resp right subseg lie store follow secondari structur v multislab structur set middl segment r ii 1 b follow structur left structur segment l right structur segment r segment v thu store three secondari structur multislab structur left structur right structur exampl segment figur 1 store multislab structur left structur 1 1 right structur 4 4 secondari structur construct use linear space node v requir oj v jb disk block turn mean overal data structur requir onb disk block r figur 1 node base tree left subseg slab 1 right subseg slab 4 middl subseg span 2 3 b answer queri ray eman point p ydirect nd rst segment hit search along path length olog b n root leaf z z contain p intern node v visit queri procedur comput rst segment v hit particular rst search nd rst segment r hit next nd vertic slab contain p search nd rst segment l r respect hit refer figur 1 b rst segment z hit comput test segment z explicitli queri answer choos lowest segment among olog b n segment found way base idea due cheng jarnadan 11 agarw et al 1 show left right structur implement ecient lemma 1 agarw et al 1 set k disjoint segment whose right left endpoint lie singl vertic line store data structur use okb block vertic rayshoot queri answer olog b k io updat perform olog b k io structur construct okb log b k io agarw et al 1 also show multislab structur implement queri answer olog b n io left right structur support gener updat agarw et al 1 manag make multislab structur dynam monoton subdivis discuss structur show easili modi support delet gener subdivis set k disjoint segment endpoint vertic line store data structur use okb block vertic rayshoot queri answer olog b k io delet perform olog b k io structur construct okb log b k io lemma 1 2 impli structur agarw et al 1 answer queri io structur construct onb log b n io first base tree construct sort endpoint segment use onb log mb onb log b n io build tree bottomup use addit onb io next segment sort left xcoordin distribut intern node onb log b n io visit node levelbylevel scan sort list level final secondari structur node construct onb log b n io total lemma 1 2 use onb log b n io construct algorithm delet also support delet segment search nd node v store sinc multislab structur left right structur support delet olog b n io lemma 1 2 delet olog b n io final use global rebuild 22 maintain olog b n height base tree delet endpoint leav rebal sinc space queri perform remain asymptot long delet perform need rebal immedi instead simpli rebuild structur n2 updat use onb log b n io olog b nb io amort per delet thu follow theorem 1 set n disjoint segment store data structur use onb disk block vertic rayshoot queri answer olog 2 io delet perform olog b n io amort structur construct io describ multislab structur design 1 detail prove lemma 2 order need dene partial order nonintersect segment denit 1 segment plane segment plane exist vertic line l intersect intersect l intersect l note two segment incompar intersect vertic line segment sort problem problem extend partial order total order lemma 3 arg et al 5 set n disjoint segment sort accord partial order onb log mb io consid set r k disjoint segment whose endpoint lie vertic line b b1 b let vertic slab bound b b i1 r henc also subset r 0 r cross sort accord easili answer rayshoot queri olog b n io use btree r 0 howev aord build btree segment cross slab sinc could result segment store time therefor segment store singl multislab structur follow first btree construct sort sequenc segment r node v 2 let r v denot subsequ r store subtre root v guid process queri certain segment r v store intern node v specic let w b denot children intern node v 1 b dene ij maxim segment rw accord intersect vertic slab j segment rw intersect j ij unden less store v o1 block note segment store one rootleaf path btree requir okb disk block construct bottomup okb io assum r v sort accord order nd rst segment hit queri ray follow path root leaf z r z contain rst segment hit node v visit procedur follow p lie interior slab r let bg denit ij ensur lr rst lowest segment e v hit contain rst segment r hit therefor visit w l next total queri answer olog b n io one way think btree b slab store structur answer queri slab r set e v node v dene btree segment intersect r main problem make dynam insert new segment may chang total order segment r consider 1 special featur monoton subdivis 26 use limit chang delet segment hand chang sort sequenc segment r still sort sequenc delet make easi perform delet ecient delet store leaf z rst nd cross maxim segment j z delet z travers path z root exchang relev segment j rst node encount ij dene requir olog b n io delet may result leav store ob segment space queri perform remain asymptot long delet perform n2 delet simpli rebuild structur use onb log b n io olog b nb io amort per delet prove lemma 2 3 dynam use logarithm method section discuss gener method transform static externalmemori data structur certain characterist ecient dynam structur method extern version logarithm method 9 see also 22 also discuss method use make semidynam point locat structur describ previou section fulli dynam logarithm method work broad class socal decompos search problem rst dene bentley 9 previous consid extern set arg et al 4 denit 2 arg et al 4 let p search problem let px v denot answer p respect set object v queri x p call externaldecompos partit ab v queri x px v comput o1 addit io given px appropri form vertic ray shoot problem externaldecompos fact alreadi use section 2 solv problem solv olog b n disjoint segment subset return appropri segment bentley 9 describ gener method make static data structur decompos problem dynam main idea partit set object v log 2 n subset v exponenti increas size 2 build static structur subset queri perform queri combin answer insert perform nding rst empti discard structur j j build new object object v j j make logarithm method ioecient need decreas number subset log b n turn mean increas size v b howev contain enough object build turn build static structur ioecient enough resolv problem make modi version method work extern memori consid static structur externaldecompos problem p construct set v n object onb log mb n io answer queri olog kq io also assum support delet olog k io partit v log b n set v jv construct extern memori static data structur v refer figur 2 answer queri simpli queri combin result use log kq io insert handl nding rst structur discard structur j j build new object structur use io way chosen know mean least b 1 object move lower index structur j divid construct cost object themv b bv 2 figur 2 logarithm method structur contain jv object note 1 contain enough object build j1 size b j1 pay olog mb nb io sinc object never move higher lower index structur charg olog b n time n insert thu amort cost insert olog b n log mb nb io note key make method work factor b lost charg construct structur size b object oset b factor win construct bound order support delet ecient maintain separ btree c object v object c store inform structur contain object note add extra olog 2 io insert bound sinc need updat entri c ob object move j j insert delet given object rst use c determin structur store object olog b n io found perform delet olog k io final order guarante number structur remain olog b n also perform global rebuild 22 structur half object delet collect object discard data structur build new log b n structur use onb log mb nb io add o1b log mb io amort delet cost theorem 2 let p externaldecompos problem set v size n let linearspac static structur p construct onb log mb nb io queri answer olog kq io delet perform olog k io exist linearspac dynam data structur 0 p answer queri olog kq 1 io support insert delet olog b n log mb nb olog io amort respect note use b 2 assumpt proof theorem 2 theorem hold 2b easi see b 2 static structur construct onb log b n io insert bound becom olog 2 use method semidynam structur describ section 2 theorem 1 immedi obtain follow theorem 3 set n disjoint segment store data structur use onb disk block vertic rayshoot queri answer olog 3 io insert delet perform olog 2 b n olog b n io amort respect improv dynam structur previou section obtain structur answer vertic rayshoot queri olog 3 use logarithm method full semidynam structur section 2 result could also obtain altern way insert segment structur section 2 search base tree olog b n io nd node v store sinc left right structur alreadi support insert almost thing need consid insert segment multislab structur also need consid insert endpoint base tree agarw et al 1 show use weightbalanc btree 6 insert endpoint base tree handl amort mean appli logarithm method multislab structur lemma 2 obtain olog 2 queri insert structur obtain result theorem 3 section show design modi multislab structur queri answer olog b n io lead improv overal olog 2 queri bound consid multislab structur store set r n disjoint segment whose endpoint lie b1 previous let b vertic slab bound b b i1 like logarithm method divid r log b n disjoint subset r size less n store r data structur main idea use obtain olog b n queri bound similar fraction cascad 10 iter start set b segment sampl i1 use segment avoid olog b n io cost search i1 answer queri sinc two segment plane alway compar denit 1 fraction cascad directli applic problem normal appli fraction cascad would sampl uniformli sort sequenc segment r i1 intuit know rst segment b b hit vertic ray make possibl nd rst segment r r i1 hit ecient mani segment could b r sort sequenc segment r i1 unfortun case sinc mani segment incompar b r could two segment sort order problem aris even sampl segment uniformli slab j follow show overcom problem inde sampl segment uniformli slab addit design i1 segment r i1 two known sampl segment l 1 l 2 j search ecient o1 io key obtain result store segment l 1 l 2 cross j togeth secondari structur one complic segment cross mani slab care store segment mani secondari structur would make delet segment ineci help exposit follow refer origin segment r red segment segment b sampl i1 store blue segment also refer origin segment b i1 green segment g i1 blue segment b store pointer correspond green segment g i1 rest section organ follow section 41 rst discuss sampl segment b jr section 42 describ show construct use linear space given r section 43 show answer vertic ray shoot queri olog b n io overal section 44 discuss perform insert delet olog 2 b n olog b n io respect thu obtain follow lemma 4 set r n disjoint segment endpoint vertic line store data structur use onb block vertic rayshoot queri answer io segment insert delet olog 2 respect construct onb log b n io discuss lead main result theorem 4 exist data structur use onb block store planar subdivis size n vertic rayshoot queri answer olog 2 worst case insert delet perform olog 2 respect 41 sampl segment given k k log b n disjoint set r 1 red segment jr j n sampl blue b green g i1 segment iter start sort sequenc segment r sort sequenc segment v cross slab j consid construct set segment g j slab j sampl everi th segment v j cut sampl segment slab boundari segment sampl v j subseg j insert g j set green segment g i1 sampl r i1 consist sampl segment g 1 say two segment consecut j g 2 successor g 1 j consecut sort list segment g j build i1 r i1 b i1 also includ segment g i1 b consist copi segment g i1 segment augment pointer ident segment g i1 sinc sampl everi segment slab induct prove size b bound thu jr given red blue segment set r b green blue segment g b 1 easili comput ioecient follow start rst comput sort segment r use algorithm arg et al 5 done use scan v collect segment g j slab j cut slab boundari simpli maintain counter count mani segment span given slab encount output relev segment sort list total use sampl segment r b overal use k b log b n k io construct blue green segment set b g lemma 5 given red segment r 1 blue green segment construct k b log b n k io 42 construct describ structur build segment r note later describ delet segment delet origin red segment blue green segment possibl produc mean number red segment green segment sampl slab becom much smaller originalp segment structur consist structur main structur red blue green segment r sampl structur u ij green segment g j main structur twolevel structur base structur bari tree sort sequenc segment r leaf contain b 3 segment segment also store secondari structur intern node pair consecut green segment less 2 segment cross slab j g 1 g 2 store minim common ancestor v leav contain g 1 segment assign v sever time one copi actual store g 1 g 2 also store pointer v copi segment secondari structur contain pointer leaf store final green segment j also store minim rst blue segment cross j number segment store intern node v bound ob 3 segment store v consecut green segment pair consecut green segment j store segment v store dierent b children v number intern node b 3 b total number segment store secondari structur ob 3 node v intern leaf two secondari structur r v b v store red blue segment respect structur implement multislab structur section 2 use lemma 2 mean use linear space vertic rayshoot queri answer delet perform olog b 2b 3 io addit r v b v v also contain index block v contain inform mani red segment store v green segment store segment v given segment r b g sort order construct ioecient follow first construct use b io levelbylevel bottomup manner next segment leav scan sort order mcag comput consecut pair green segment slab maintain last encount green segment slab comput relev minim common ancestor search tree use olog b io encount new green segment time also comput minim blue segment directli green segment total use ojg io next scan leav construct list red blue segment mark intern node need store note mention earlier one copi given segment assign node sort list onb log mb io obtain node v segment store r v b v final r v b v well v construct ob 3 node v lemma 2 b io total thu use b log b n io construct consid two consecut segment nonredund r contain least one red segment cross j g 1 g 2 dene lowest nonredund segment green segment g j lowest nonredund green segment j g note g lowest nonredund segment natur partit sort sequenc green segment j thu also sort sequenc endpoint one boundari j refer figur 3 delet red segment r may result two partit merg nonredund nonredund find figur 3 six green segment slab j three red segment cross j two green segment nonredund partit segment endpoint induc lowest nonredund segment relationship indic rightmost endpoint b find red segment immedi p given green segment g i1 immedi p rmcag 0 g rmcag 00 g 000 queri sampl structur u ij maintain lowest nonredund segment green segment implement use interv unionfind structur findg return lowest nonredund segment g uniong merg partit contain g partit partit ie partit contain successor g 0 2 g findg j section 45 show interv unionfind structur k element implement initi use ok log b k io union oper free amort find oper take o1 io construct sampl structur u ij b log b n io follow rst produc list green segment g nonredund segment mark scan list sort segment r collect green segment main memori keep track last green segment seen b process red segment r simpli mark green segment slab cross r scan sort list green segment slab j produc onb log mb io sort list final produc u ij slab j turn rst initi interv unionfind structur green segment j perform union oper correspond redund segment number green segment b take lemma 6 given r sort order construct b log b n io 43 answer vertic rayshoot queri consid queri p slab j nd rst segment hit ray eman p rst load 1 mainmemori determin rst red segment r 1 2 r 1 rst blue segment repeatedli use pointer blue segment b green segment g i1 i1 comput rst segment r comput blue segment b i1 consid green segment g 0 j immedi g i1 queri bmcag 0 g i1 rst blue segment hit segment exist return minim blue segment g i1 store g i1 similarli comput red segment r i1 rst queri rmcag 0 g i1 red segment found perform findg i1 u ij determin lowest nonredund green segment g 00 j queri rmcag 00 g 000 000 successor g 00 j obtain r i1 refer figur 3 b queri procedur spend o1 io use olog b n io total rayshoot externaldecompos easili answer queri anoth olog b n io r 1 log b n found lemma 7 vertic rayshoot queri among n segment 1 log b n answer olog b n io 44 perform updat insert basic handl gener logarithm method nd rst structur build new red segment r j structur blue segment b use unlik logarithm method also need rebuild structur j j start segment set r io rst produc sampl segment b j j discuss section 41 lemma 5 build j j discuss section 42 lemma 6 previous argu least red segment move lower index structur j charg rebuild cost segment obtain olog 2 amort insert bound delet segment handl follow rst determin structur well leaf l main structur contain next delet rw node w path root l way segment assign secondari structur store secondari structur delet rw also decrement relev counter w count number red segment pair consecut green segment store segment w use counter determin green segment g becom redund result delet green segment becom redund perform uniong relev sampl structur u ij logarithm method also perform global rebuild half origin segment delet relev structur leaf l locat olog b n io queri one endpoint use separ btree discuss section 3 delet rw updat w olog b n node w path l root also perform olog b n io total discuss earlier charg cost union oper construct note howev worst case perform log b n oper final global rebuild add anoth olog b n io amort delet cost insert delet olog 2 amort respect 45 ioecient interv unionfind structur consid k order element initi x consid singleton set findx union oper use join neighbor set x find return maxim element set consecut element formal x j set x join set element x l findx l set element xm findxm findx q findx j g interv unionfind structur implement ioecient straightforward way use height one tree initi store n element consecut disk element contain pointer root contain copi element findx maintain element x point find find oper perform o1 io root element store consecut disk structur occupi onb block union oper implement combin two consecut set element updat element 2 point root 1 updat pointer smallest set element store consecut disk accomplish o1 io root pointer element chang log 2 n time overal cost u union oper bound ou io u n obtain follow lemma 9 interv unionfind structur n element implement use onb disk block find perform o1 io u union oper perform log b n io total 5 conclus open problem paper present linear space ioecient dynam data structur point locat gener planar subdivis import part data structur base new extern version logarithm method 9 well new extern version dynam fraction cascad 10 21 sever challeng problem remain open one exampl queri andor insert bound improv olog b n note improv would also lead improv intern memori structur anoth exampl develop higherdimension structur acknowledg rst author would like thank pankaj agarw mani inspir point locat discuss r inputoutput complex sort relat problem extern memori data structur theori practic io ecient algorithm multidimension batch search problem optim dynam interv manag extern memori dynam point locat gener subdivis organ mainten larg order index decompos search problem fraction cascad new result dynam planar point locat ubiquit btree random externalmemori algorithm geometr problem new approach rectangl intersect spaceoptim solut gener region locat new data structur repres sort list optim search planar subdivis design dynam data structur rang search set line segment planar point locat use persist search tree point locat dynam mainten planar digraph planar point locat larg data set seek seek extern memori algorithm data structur deal massiv data tr planar point locat use persist search tree optim point locat monoton subdivis inputoutput complex sort relat problem new result dynam planar point locat dynam point locat gener subdivis unifi approach dynam point locat ray shoot shortest path planar map point locat ioeffici dynam point locat monoton planar subdivis theori practic ioeffici algorithm multidimension batch search problem rang search set line segment ubiquit btree extern memori algorithm data structur design dynam data structur externalmemori algorithm process line segment geograph inform system extend abstract extern memori data structur planar point locat larg data set optim extern memori interv manag ctr lar arg mark de berg herman j haverkort ke yi prioriti rtree practic effici worstcas optim rtree proceed 2004 acm sigmod intern confer manag data june 1318 2004 pari franc pankaj k agarw lar arg ke yi optim dynam interv stabbingmax data structur proceed sixteenth annual acmsiam symposium discret algorithm januari 2325 2005 vancouv british columbia lar arg mark de berg herman haverkort cacheoblivi rtree proceed twentyfirst annual symposium comput geometri june 0608 2005 pisa itali