data structur circular string analysi visual csdawg circular string obtain make simpl modif compact symmetr direct acycl word graph csdawg linear string propos data structur contain extran vertic consequ avoid disadvantag previou method use method algorithm make use csdawg linear string extend circular string trivial modif extend algorithm continu time space complex moreov extens take form postprocess preprocess step simpl add system built linear string particularli objectori languag b introduct circular string data type use repres number object circular genom polygon close curv research molecular biolog involv identif recur pattern data hypothes caus andor effect 1 2 research pattern recognit comput vision involv detect similar within object object 3 detect pattern visual tediou prone error 4 model propos allevi problem model consist identifi recur pattern string highlight ident pattern color 4 also list number queri model would support 5 effici mostli optim algorithm propos queri linear string algorithm perform oper travers symmetr compact direct acycl word graph scdawg 6 linear string scdawg use repres string set string evolv string data structur posit tree suffix tree direct acycl word graph etc 7 8 9 10 one approach extend techniqu circular string arbitrarili break circular string point becom linear string techniqu linear string may appli howev disadvantag signific pattern circular string may lost pattern broken linear string inde would defeat purpos repres object circular string 3 defin polygon structur graph extens suffix tree circular string howev suffix tree power scdawg use solv problem scdawg solv paper defin scdawg circular string algorithm 5 6 make use scdawg linear string extend circular string minor modif extend algorithm continu effici time space complex extens take form postprocess preprocess step simpl add system built linear string particularli object orient languag e c c figur 1 circular string section 2 contain definit section 3 describ scdawg linear string section 4 describ extens circular string section 5 deal comput occurr display entiti section 6 introduc notion conflict section 7 list queri implement section 6 also explain algorithm implement queri linear string modifi work circular string final section 8 mention applic visual analysi circular string let denot circular string size n consist charact fix alphabet sigma constant size figur 1 show exampl circular string size 8 shall repres circular string linear string enclos angl bracket distinguish linear string linear string obtain travers circular string clockwis order list element travers start point travers chosen arbitrarili consequ n equival represent exampl could repres abcdabc bcdabcea etc character relationship circular string linear string defin function linear circular linear map circular string linear string onemani map circular string gener map one linear string exampl dabcg assum purpos paper linear arbitrarili choos one linear string conveni assum choos represent obtain remov angl bracket linearizeabcd abcd circular map linear string circular string manyon function repres invers linear use lower case letter repres circular string upper case letter repres linear string lower case letter say use repres particular circular string correspond upper case letter assum linear singl charact occur th posit denot respect substr denot ij j substr denot ij j exampl use symbol fl denot either circular string linear string exampl predecessor predflij substr fl ij fl defin linear successor succflij substr fl ij fl defin fl linear fl circular immedi context contextflij substr fl ij fl order pair predecessor predfl ff successor succfl ff set pattern ff string fl defin predfl g succfl g immedi context set contextflff pattern ff fl set g exampl string figur 1 succ pattern occur fl said maxim iff occurr preced charact follow charact pattern ff length n fl maxim iff jpredfl ffj 2 jsuccfl ffj 2 necessarili true pattern length greater equal n exampl maxim sinc neither preced follow charact jpred pattern said display entiti display fl iff maxim occur least twice fl note fl repres circular string pattern arbitrarili long rest discuss assum display entiti circular string length less n 3 scdawg linear string scdawg correspond string direct acycl graph defin set vertic v set rs label direct edg call right extens edg set label direct edg ls call left extens le edg vertex v repres substr specif v consist sourc repres empti word sink repres vertex correspond display entiti let dev denot string repres vertex v v ffl v defin implic imp ff string ff smallest superword ff fdevj v ffl v sg superword exist otherwis imp ff exist edg v 1 v obtain follow letter x sigma imp dev 1 x exist equal edg v 1 v 2 label xfl fi empti string edg known prefix extens edg le edg v 1 v obtain follow letter x sigma imp xdev 1 exist equal dev 2 gabcd de e de c abc bc de gabcd fabcgabcd gabcd fabcgabcd cde sink abc c sourc figur 2 scdawg edg shown le edg v 1 v 2 label flx fi empti string edg known suffix extens edg figur 2 show v sr correspond cde c display entiti two edg vertex repres abc correspond g impsabcd consequ edg incid sink edg correspond letter alphabet impsabcx exist x ffl fg notic number edg vertex v equal jsucc dev f1gj number le edg equal jpred dev f1gj exampl number right edg leav vertex correspond 1 space requir scd time need construct 7 6 defin scdawg data structur singl string extend repres set string 6 4 extens circular string section 41 present construct definit scdawg circular string section 42 analyz complex algorithm section 41 construct scdawg circular string section 43 identifi prove properti scdawg 41 scdawg circular string notion scdawg may extend circular string scdawg circular string defin construct algorithm figur 3 scdawg circular string obtain first construct scdawg linear string linear bit associ edg rt indic whether prefix extens edg similarli bit associ le edg lt identifi suffix extens edg two pointer suffix pointer prefix pointer associ vertex v v suffix prefix pointer point vertex w v dew largest suffix prefix dev repres vertex v suffix prefix pointer revers suffix prefix extens edg deriv figur 4 show scdt cabcbab broken edg vertex c vertex abc suffix extens edg solid edg vertex ab vertex abc prefix extens edg next step 2 suffix prefix redund vertic scdt identifi suffix prefix redund vertex vertex v satisfi follow properti v exactli one outgo le edg vertex said redund either prefix redund suffix redund figur 4 vertex c prefix redund vertex ab suffix redund vertic figur redund particular vertex repres redund even though one one le edg n fact step 2 fact identifi redund vertic establish later vertic scdt process revers topolog order step 3 redund algorithm step1 construct scdt fidentifi suffix redund verticesg v 6 sourc begin v exactli one outgo edg mark v suffix redund els exit step 2a fidentifi prefix redund verticesg fsimilar step 2 ag step3 v sourc begin case v suffix redund prefix redund processsuffixredundantv prefix redund suffix redund processprefixredundantv suffix redund prefix redund processbothredundantv redund fdo noth figur 3 algorithm construct scdawg circular string tss c cabcbab cabcbab cabcb abcbab c bab cabcb c c ab cabc abcbab bab ab c c ab c abc ab figur 4 scdt tcabcbabcabcbab procedur processsuffixredundantv 1 elimin left extens edg leav v least two 2 exactli one right extens edg e leav v let vertex lead w let label right extens edg xfl delet edg 3 right edg incid v updat point w label modifi repres concaten origin label xfl 4 left edg incid v updat point w label modifi howev suffix extens edg bit indic reset edg longer suffix extens edg 5 delet v figur 5 algorithm process vertex suffix redund vertic elimin vertex elimin edg incid tofrom redirect relabel describ figur 5 10 result graph cscd set vertic cscd denot cv set right left edg denot cr cl figur 11 show cscd notic vertic c ab elimin two incom edg c three incom edg ab figur 4 point abc ul ur ur ul u u figur procedur processprefixredundantv 1 elimin right extens edg leav v least two 2 exactli one left extens edg e leav v let vertex lead w let label left extens edg flx delet edg 3 left edg incid v updat point w label modifi repres concaten flx origin label 4 right edg incid v updat point w label modifi howev prefix extens edg bit indic reset edg longer prefix extens edg 5 delet v figur 7 algorithm process vertex prefix redund ul ur ur ul u u figur 8 v prefix redund procedur processbothredundantv 1 exactli one right extens edg e 1 leav v let vertex lead w 1 let label edg xfl delet edg 2 exactli one left extens edg e 2 leav v let vertex lead w 2 let label edg flx delet edg fwe establish later w 1 w 2 fact vertexg 3 right edg incid v updat point w 1 label modifi repres concaten xfl edg prefix edg bit indic reset 4 similarli left edg incid v updat point w 2 label modifi repres concaten flx edg suffix extens edg bit indic reset 5 delet v figur 9 algorithm process vertex prefix suffix redund e l l l fiy e r l r xfl e l l l ul ur ur ul u u figur 10 v suffix prefix redund lemma 1 everi substr ij length n exist substr lm ij contextt proof case case subcas context subcas subcas possibl sinc length corollari 1 everi pattern ff length n context ff contextt ff corollari 2 everi pattern ff length n pred ff predt ff succ ff substr 6 1 substr lm ij pred l proof result follow definit predt choos lm length ij greater n lm assum wrap around pred l corollari 3 everi pattern ff length n predt theorem 1 everi pattern ff length less n pred proof corollari 2 pred ff predt ff pred ff f1g predt ff f1g henc pred ff predt ff f1g sinc pred ff contain cabc ab tss sourc abcbab cabcb cabcbab cabcbab bab c c c abc abc abc figur 11 scdawg 1 corollari 3 pred ff predt ff f1g pred f1g proof succ theorem 2 vertex v jdevj n v non redund iff dev display entiti proof suppos ff display entiti jpred ffj 2 jsucc ffj 2 theorem 1 jpredt 2 ff display entiti correspond vertex v least two le two edg leav henc v redund next suppos non redund vertex v scdt dev sinc v redund jpredt 2 theorem 1 jpred ffj 2 jsucc ffj 2 ff display entiti scorollari 4 redund vertex v display entiti lemma 3 vertex v v exactli one le edg dev suffix prefix b vertex v dev jdevj n suffix prefix one le edg vertex w dew suffix prefix dev suffix prefix redund proof suppos dev suffix 1 element succt dev 2 v least two edg contradict henc dev must suffix b sinc dew suffix dev successor dev must also successor dew dev least two edg w must least two edg suffix redund 2 show step 2a algorithm identifi suffix redund vertic suffici examin vertic correspond suffix lemma 3a step 2a follow chain suffix pointer start sink vertex chain repres display entiti length n one edg mark suffix redund travers chain termin either sourc reach vertex one edg encount lemma 3b similarli step 2b identifi prefix redund vertic v 42 complex analysi worst case travers vertic scdt spend o1 time number vertic bound 6 step 2 take time step 3 travers scdt vertex process edg process twice incom edg vertex current process edg vertex current process step 3 take time note scdt edg 43 properti cscd defin implic imp ff string ff respect cscd smallest superword fifffl ff repres vertex cv exist substr fi 1 fffl 1 length least common suffix less minjfij length least common prefix lcpfl less minjflj jfl 1 j superword exist otherwis imp ff exist addit condit refer uniqu condit impos imp ff guarante impt ff definit scdt smallest set superword display entiti abc superword display entiti abc superword element r de abc must one element r jlcsb abc neither babcaa cabcaa sinc jlcsaaaa aaj abcaaaa lemma 4 let v suffix prefix redund vertex scdint scdint repres intermedi configur scdt cscd statement step 3 algorithm let le edg incid w 1 w 2 respect dew 1 redund w proof case 1 jdew 1 nil w 1 prefix redund sinc jdew 1 j n occurr dev except prefix preced similarli must form fi 3 ydevxfl 1 sinc letter preced dev similarli dew 2 must form fi 2 ydevxfl 3 show fi assum case sinc jdew 1 redund least 2 must exist display entiti fi ydevxfl fi largest common suffix fi 3 fi 2 fl largest common prefix fl 1 fl 3 fi dev dev dev dev642 figur 12 illustr proof prefixsuffix redund invari imp ydev contradict statement made case 2 jdew 1 j n nil otherwis w 2 suffix redund dew 2 x letter follow dev argument similar case 1 show sinc jdew 2 j must prefix fl 3 fi 1 suffix fi 2 contradict henc case 2 exist case 3 jdew 2 j n similar case 2 case 4 jdew 2 j n figur 12 show case occur prefixsuffix redund invari figur assum jdew 1 dev prefix dew 1 jdevj n2 divid n howev prefixsuffix redund invari shown true case two copi shown figur first copi shade occurr n dev ff 2m ff vertic ff ff ff ff ff ff ff ff ff figur 13 scdff 2m extens dew 1 second shade occurr n1 n jdevj extens dew 1 sinc shade region string repres next assum without loss gener fi call smallest repetit assumpt occurr ff 1 jffj jffj1 2jffj gamma 1ff1 2n argument similar one figur 12 contradict smallest repetit assumpt take form figur 13 vertex repres ff exactli one le one edg shown remain display entiti subword ff 2 size less jffj argument ident one figur 12 contradict smallest repetit assumpt vertic repres display entiti repres box figur 13 none vertic box edg incid vertic repres display entiti g particular edg vertic box incid vertic repres display entiti length greater n 2m process algorithm incom edg vertic correspond ff ff 2 scdff 2m incid vertex correspond cscdff 2m follow prefix suffix redund vertex scdff 2m process step 3 algorithm edg incid w 1 w 2 least n dew 1 properti p1 p2 p3 state theorem 3 properti ensur algorithm 5 extend circular string consist sourc sink v cv sourc sink follow true jdevj n iff dev display entiti b jdevj n dev display entiti exist edg correspond letter x sigma vertex v 1 cv vertex exist equal dev 2 dev 2 label edg xfl edg prefix extens edg 3 similar p2 le edg theorem 3 cscd satisfi p1 p2 p3 proof properti p1 establish knowledg scdt contain display entiti algorithm elimin display entiti length less n display entiti corollari 4 p2 p3 prove induct induct hypothesi let u subset u remain vertex set u v process step 3 algorithm let ru set edg incid vertic u edg r ffl ru vertex u w label xfl imp condit hold le edg ii vertex u u edg correspond letter x succt incid vertex u condit hold le edg u definit r cv establish edg incid correct vertic label correct ii establish cr complet p2 hold similarli p3 hold induct base u fg ru lu empti appli ii establish definit scdt induct step consid vertex v v ffl v process step 3 algorithm let u 0 u 0 denot u u respect v process must show ii hold u 0 u 0 sinc vertic process revers topolog order edg v incid vertic u therefor element ru lu must satisfi case 1 v redund u 0 sinc v elimin must show true incom edg v addit ru lu ie r u 0 fincom right edg vg l u 0 fincom left edg vg let e edg label xfl u v definit scdt smallest superword deux fdewjw ffl v g sinc cv sg true sinc v ffl cv symmetr argument made incom le edg v letter alphabet le edg correspond first last charact label sinc edg ad delet redirect label edg unchang vertex rele edg correspond letter alphabet prior process vertex v ii hold induct hypothesi case 2 v redund u 0 sinc v elimin subcas v suffix redund definit v consist singl edg e vertex w u let label xfl induct hypothesi imp first establish ii dev prefix dew imp dev 6 dev v redund imp dev must correspond vertex one edg v incid sinc edg correspond element pred dev succ dev ii singl edg incid w repres imp devx left edg v incid vertic repres imp x dev 2 definit imp dev none vertic possibl repres imp dev instanc imp x dev imp dev string imp x j dev 6 j would invalid definit imp dev must dew howev true must show nil therefor dev prefix dew occurr dev follow x jpredt 2 argument similar one previou paragraph show imp devx exist ru 0 edg vg fincom edg vg lu 0 edg vg fincom le edg vg ii appli edg delet ru lu need prove ii incom edg v let e r edg incid v vertex ur label yfl 1 must redirect imp deu r hold impt deu r dev smallest superword deu r fdeaj ffl v g imp deu r smallest superword deu r satisfi uniqu condit fdeaj ffl cv sg fdeaj ffl v g sinc v imp deu r smallest superword dev satisfi uniqu condit fdeaj ffl cv sg imp deu r xfl updat edg e r incid w label yfl 1 xfl obtain step 3 algorithm concaten continu prefix extens edg e r satisfi let e l le edg incid v ul z use argument use e r imp zdeu l redirect w label remain unchang clearli e l longer suffix edg even fi notic ii continu satisfi edg correspond vertex u 0 continu associ charact particular label r continu begin label l continu end z edg continu leav vertex particular e r continu leav ur e l continu leav ul subcas b v prefix redund symmetr subcas subcas c v prefix suffix redund v one edg e 1 vertex w 1 cv let label 1 also v one le edg e 2 vertex w 2 induct hypothesi dew 1 imp condit lemma 4 satisfi sinc w 1 w 2 redund otherwis would elimin thu dew 1 imp dev either imp devx imp ydev express equal dew imp proof ii satisfi similar subcas note howev incom prefixsuffix extens edg v longer remain prefixsuffix extens edg xfl fiy nil 2 comput occurr display entiti procedur linearoccurrencess v figur 14 base outlin 6 report end posit occurr dev v ffl v linear string howev invok linearoccurrencest v v ffl cv immedi yield occurr dev section 51 present modif obtain occurr display entiti section 52 show modif correct time complex optim 51 algorithm auxiliari boolean array reported1n use conjunct cscd initi element array set fals procedur circoccurrencess v figur 15 comput end posit dev v ffl cv linearoccurrencest v line 1 necessarili comput occurr dev sinc execut cscd scdt note also occurr dev end posit n ident occurr end posit n occurr correspond occurr dev report occurr singl correspond occurr dev must eventu report line 47 transform occurr l necessari repres valu 1 n occurr alreadi list ad list occurr correspond element report set true occurr list duplic line 812 occurr comput element report reset fals line 1415 report subsequ reus comput occurr display entiti exampl figur 11 linearoccurrencest v v repres abc report end posit occurr abc ie 4 8 11 line 2 12 transform list end posit abc ie 1 4 correspond 61 24 respect figur show dev dew dex hypothet string figur show fragment scdawg v suffix redund scdt singl edg incid w edg x v x redund construct edg x v scdt becom edg x w cscd procedur linearoccurrencest x x cscd fail yield rightmost occurr dex sinc occurr neither subword dew procedur linearoccurrencessstr vvertex fobtain occurr dev v ffl v sg procedur occurrencesslinear string vvertex iinteg begin dev suffix edg e v scd begin let w vertex e incid figur 14 obtain occurr display entiti linear string procedur circoccurrencesscircular string vvertex fv vertex cscdsg 2 report occurr l dev 6 els 8 reportedk 9 begin add k final list occurr 14 occurr l dev figur 15 obtain occurr display entiti circular string dev dew figur exampl string suffix next section show circoccurrencess x comput occurr dex spite fact linearoccurrencest v comput occurr dex 52 proof correct substr assum ij suffix defin immedi right extens irescdt ij ij scdt occurr igammajfijjjflj1 display entiti substr assum ij suffix defin immedi right extens irecscdst ij ij cscd occurr igammajfijjjflj1 display entiti figur 16 occurr dev correspond suffix howev repres valid substr ff figur 17 fragment scdawg correspond figur 16 iredawg ire occurr said right retriev rr scdt iff one follow true rr scdt similarli occurr said right retriev rr iff one follow true rr cscd defin occurr ij rr cscd irecscdst ij repres substr iiirecscd ij valid substr rr cscd exampl figur 16 2ngammajdexffj12ngammajffj rr scdt rr cscd notic substr iff lemma 5 k 1 ire substr proof assum exist pair substr assum ire defin symmetri occurr repres display entiti say dev definit ire n appli argument repeatedli prove lemma 2 lemma 6 rr occurr dev v v cv scdt cscd exactli occurr dev obtain linearoccurrencest v proof follow definit rr occurr 2 corollari 5 occurr pattern dev v ffl v obtain linearoccurrencest v lemma 7 occurr dev v ffl cv jdevj n obtain proof follow corollari 5 construct cscd right edg vertic repres display entiti size n modifi rr cscd proof assum lemma fals exist occurr ij dev rr cscd clearli j 6 2n otherwis ij would rr cscd let last denot smallest valu k ire k cscd ij substr last 1 must exist sinc ij rr let last j last denot ire last cscd ij let z vertex cv last j last correspond case 1 last last 2n consid string 1j last length greater n two occurr string would display entiti length n ij last predecessor ii dez maxim occurr follow letter vertex correspond display entiti would elimin algorithm sinc length would n 1j last would rr cscd lemma 7 must exist one occurr string repres ij last string proper suffix dez mean one occurr preced charact two occurr string lead contradict case 2 last 2n proof similar one case 1 2 lemma 9 least one two occurr ij injn dev ffl cv rr cscd proof assum lemma fals let last smallest valu k either substr let last cscd ij q last cscd injn case 1 ire last cscd ij substr ire last cscd injn substr ie rr cscd sinc q j q satisfi condit lemma 8 case 2 ire last cscd ij substr ire last cscd injn substr symmetr case 1 case 3 ire last cscd ij substr ire last cscd injn substr 5 shown caus contradict argument similar one lemma 8 2 theorem 4 procedur circoccurrencessv correctli obtain occurr dev show linearoccurrencest v comput rr occurr dev cscd lemma 8 9 show occurr dev least one correspond occurr rr cscd circoccurr comput occurr transform repres occurr remov duplic output list occurr dev 2 theorem 5 procedur circoccurr optim proof procedur circoccurrencess v take ojocct vj time jocct vj number occurr dev loop take ojocct vj time number occurr dev complex ojocc vj jocc vj size output algorithm optim 2 6 comput conflict effici 4 defin concept conflict explain import analysi visual string formal subword conflict two display entiti 1 2 exist iff 1 substr 2 ii prefixsuffix conflict two display entiti 1 2 exist iff exist substr p sm occur p string sm known intersect conflict conflict said occur 1 2 respect sm 4 also identifi number problem relat comput conflict linear string 5 present effici algorithm problem list next section algorithm typic involv sophist travers oper scdawg linear string extens scdawg circular string make possibl use algorithm solv correspond problem circular string minor modif outlin conceptu two kind travers algorithm 5 perform scdawg correspond linear string travers display entiti string travers vertex travers specif repres display entiti string ii incident travers travers vertex travers display entiti perform function exampl includ vertic travers linearoccurrencest v travers type cscd requir travers vertic repres display entiti size greater equal n may achiev simpli disabl edg cscd leav vertex repres display entiti size less n incid vertex repres display entiti size greater equal n travers type ii howev may requir travers vertic repres display entiti size greater equal n achiev associ bit edg set 1 repres edg vertex whose display entiti size less n vertex whose display entiti size greater equal n otherwis set 0 type travers check bit type ii travers ignor final call linearoccurr replac call circoccurr 7 queri section list queri system visual analysi circular string would support 5 contain algorithm queri linear string previou section show algorithm could modifi support queri size restrict queri experiment data show random string contain larg number display entiti whose length small applic small display entiti uninterest henc use list display entiti whose length greater integ k similarli use report exactli conflict conflict display entiti length greater k give rise follow problem 1 list occurr display entiti whose length greater k 2 comput prefix suffix conflict involv display entiti length greater k 3 comput subword conflict involv display entiti length greater k altern formul problem also seek achiev goal outlin base report conflict whose size greater k size conflict defin overlap conflict defin string common conflict display entiti overlap subword conflict subword display entiti overlap prefixsuffix conflict intersect size conflict length overlap formul problem particularli relev conflict interest display entiti also ensur conflict display entiti report size greater k follow problem 4 obtain prefixsuffix conflict size greater integ k 5 obtain subword conflict size greater integ k pattern restrict queri queri use applic fact two pattern conflict import number locat conflict follow problem aris result list pair display entiti subword conflict list triplet display entiti 1 2 dm prefix suffix conflict 1 2 respect dm 6 size restrict 5 7 size restrict 4 statist queri queri use conclus drawn data base statist fact 10 pair display entiti 1 2 involv subword conflict 1 subword 2 obtain number occurr 1 occur subword 2 number occurr 1 11 pair display entiti 1 2 involv prefixsuffix conflict number occurr 1 prefixsuffix conflict number occurr 1 greater statist determin threshold follow could said confid presenc 1 impli presenc 2 applic circular string may use repres circular genom 1 g4 oex174 detect analysi pattern genom help provid insight evolut structur function organ 1 analyz g4 oex174 linear construct scdawg work improv upon 1 analyz circular string without risk loss pattern ii extend analysi visual techniqu 5 linear string circular string circular string form chain code also use repres close curv comput vision 11 object figur 18a repres chain code follow 1 arbitrarili choos pixel curv pass diagram start pixel chain code represent object 1 2 mark arrow 2 travers curv clockwis direct move one pixel next direct move record accord convent shown figur 18b object 1 2 repres 1122102243244666666666 666666661122002242242446 respect alphabet f0 1 2 3 4 5 6 7g fix constant size 8 therefor satisfi condit section 2 may use visual techniqu 5 compar two object exampl method would show object 1 2 share segment s1 s2 figur 18c correspond 0224 2446666666661122 respect inform common segment would also avail techniqu paper make possibl detect pattern irrespect start pixel chosen two object circular string may also use repres polygon comput graphic comput geometri 3 figur 19 show polygon repres follow altern sequenc line angl bfiaffeffeffcficfiefiaffeffeffcficfibffcffdffcff ff denot 90 degre angl fi 270 degre angl techniqu paper would point instanc self similar polygon affeffeffcf note howev method work effici number line angl use repres polygon must small fix 9 conclus paper defin scdawg circular string shown use solv problem visual analysi pattern circular string expect also use string match applic involv circular string import featur scdawg circular string easi implement use correspond techniqu scdawg linear string alreadi avail c b start posit object 2 start posit object 16420 chain code represent direct figur repres close curv circular string e c c c c c c e e figur 19 repres polygon circular string acknowledg grate professor gerhard ritter point applic circular string represent close curv r sequenc landscap match protein sequenc use color intrasequ homolog display method detect structur polygon string visual comput display conflict string visual complet invert file effici text retriev analysi smallest automaton recogn subword text effici onlin construct correct posit tree spaceeconom suffix tree construct algorithm effici eleg subword tree construct process 2nd edit tr digit imag process 2nd ed complet invert file effici text retriev analysi match protein sequenc use color intrasequ homolog display comput graphic principl practic 2nd ed model techniqu visual label discret object spaceeconom suffix tree construct algorithm ctr p mehta sahni comput display conflict string visual ieee transact comput v43 n3 p350361 march 1994