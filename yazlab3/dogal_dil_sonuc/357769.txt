optim hardwarealgorithm sort use fixeds parallel sort devic abstractw present hardwarealgorithm sort n element use either psorter sort network fix io size p strictli enforc conflictfre memori access best knowledg first realist design achiev optim time perform run theta fracn log np log p time rang n result complet resolv problem design implement timeoptim algorithm sort n element use psorter importantli howev result show order achiev optim time perform need sort network depth olog2 p exampl batcher classic biton sort network b introduct recent advanc vlsi made possibl implement algorithmstructur chip build block highperform comput system sinc sort one fundament comput problem make sens endow generalpurpos comput system specialpurpos parallel sort devic invok whenev servic need articl address problem sort n element use sort devic io size p n arbitrari p fix sort devic use either psorter sort network fix io size p assum input well partial result resid sever constantport memori modul addit achiev timeoptim crucial sort without memori access conflict reallif applic number n element sort much larger fix size p sort devic accommod situat sort devic must use repeatedli order sort input follow natur question aris one schedul memori access call sort devic order achiev best possibl sort perform clearli question find appropri answer power sort devic fulli util psorter sort devic capabl sort p element constant time comput model p sorter exist exampl known p element sort o1 time p theta p reconfigur work support onr grant n000149710526 nsf grant ccr9522093 ecs9626215 louisiana grant leqsf199699rda16 depart comput scienc old dominion univers norfolk va 235290162 usa z istituto di elaborazion dellinformazion cnr pisa 56126 itali x depart comput scienc univers texa dalla richardson richardson mesh 3 7 8 beigel gill 2 show task sort n element n p n log n log p call psorter present algorithm achiev bound howev algorithm assum p input psorter fetch unit time irrespect locat memori sinc gener address pattern operand psorter oper irregular appear algorithm 2 realist achiev time complex theta n log n log p unless one solv constant time address problem inher access p input psorter scatter output back memori spite result 2 pose interest open problem name design implement theta n log n log p time sort algorithm use psorter consid algorithm sort n element use psorter ofn p time clear algorithm also sort n element use sort network io size p ofn p time main reason task sort p element use network requir odt proport depth dt maximum number node path input output network thu psorter oper replac naiv individu applic time requir sort becom odt delta fn p elimin odt slowdown factor network must use pipelin fashion turn pipelin requir suffici parallel psorter oper identifi exploit recent olariu pinotti zheng 9 introduc simpl restrict design row merg model show model n element sort theta log n time use either psorter sort network io size p achiev better sort perform new algorithmstructur architectur must design involv devis sort algorithm suitabl hardwar implement time architectur algorithm execut directli algorithmarchitectur combin commonli refer hardwarealgorithm major contribut articl present first realist hardwarealgorithm design sort arbitrari number input element use fixeds sort devic optim time strictli enforc conflictfre memori access introduc parallel sort architectur special design implement care design algorithm compon architectur includ parallel sort devic set randomaccess memori modul set convent regist control unit architectur simpl feasibl vlsi realiz show architectur model n element sort theta n log n log p time use either psorter sort network fix io size p depth olog 2 p conjunct theoret work 2 result complet resolv problem design implement time optim algorithm sort n element use psorter importantli howev result show order achiev optim sort perform psorter realli necessari need sort network depth olog 2 p exampl batcher classic biton sort network see exceedingli import sinc known implement psorter requir power process element wherea batcher biton sort network use simpl compar architectur assumpt section describ architectur framework within specifi optim sort algorithm use fixeds sort devic consid sequenti sort algorithm adequ case consequ assum assumpt impli address purpos need least 2 log p bit 1 reader conveni figur 1 depict design 9 keep figur simpl control signal line shown basic architectur assumpt sort model includ r r r r r r r r r memori modul ar ar ar ar ar ar ar ar ar sort devic control unit figur 1 propos architectur data memori organ p independ constantport memori modul word assum length w bit w 2 log p assum n input element distribut evenli arbitrarili among p memori modul word address memori modul refer memori row memori modul randomli address address regist ar associ adder regist ar load word read memori modul row address broadcast cu see ii set data regist r 1 p capabl store w refer word store regist r compos word sinc consist three field ffl element field w bit store element ffl long auxiliari field log p bit ffl short auxiliari field 05 log p bit 1 remaind articl logarithm assum base 2 field arrang element field left long auxiliari field left short auxiliari field field regist r load independ memori modul ith output sort devic broadcast cu output regist r connect ith input sort devic cu memori modul assum ffl constant time p element data regist load address regist store p modul address address regist ffl bit field regist r 1 p setreset 0s constant time ffl field data regist r 1 p compar particular valu individu field set special valu depend outcom comparison moreov parallel compareandset oper take constant time iii sort devic fix io size p form psorter sort network depth olog 2 p assum sort devic provid data path width w 15 log p bit input output sort devic use sort compos word combin element auxiliari field case sort network use sort devic assum sort network oper pipelin fashion iv control unit cu short consist control processor capabl perform simpl arithmet logic oper control memori use store control program well control data cu gener control signal sort devic regist memori access cu broadcast address element memori modul andor data regist read element data regist assum oper take constant time describ minimum hardwar requir architectur model case sort network use sort devic one use halfpipelin scheme input network provid group row next group suppli output previou group obtain depth sort network sort network oper full capac one may add addit set address resp data regist one set address resp data regist use read oper order set use write oper oper perform concurr let us estim vlsi area design use hardwar data memori sort devic cu word model ie assum word length w constant exclud area taken cu highperform comput system one processor assign task control parallel sort subsystem clearli extra area use address data regist amount op exceed vlsi area implement psorter sort network io size p includ vlsi area run data memori address bu width log n bit control signal line data memori sort devic sinc need architectur involv data memori sort devic point architectur p memori modul involv total n p 2 word control circuitri requir least omegagamma01 flog p log n area sinc oper perform control processor simpl assum take constant area length control memori word least log n length data memori address becom appar algorithm requir n data memori consequ control memori word length olog n control program simpl take constant memori howev n use control inform store data memori 3 extend columnsort algorithm section present extens well known columnsort algorithm 5 extend column algorithm implement architectur model invok repeatedli sort larg number element two known version columnsort 5 6 one involv eight step seven provid extens 8step columnsort 7step version map well architectur columnsort design sort columnmajor order matrix r row column classic columnsort contain 8 step oddnumb step involv sort column matrix independ evennumb step permut element matrix variou way permut step 2 pick element columnmajor order lay rowmajor order permut step 4 revers step 2 permut step 6 amount b rc shift element column permut step 8 revers permut step 6 8step columnsort work assumpt r 5 leighton pose open problem extend rang applic columnsort without chang algorithm drastic provid extens show one addit sort step necessari suffici complet sort case r ss gamma 1 extens seen trade one addit sort step larger rang applic algorithm figur 2 step step applic extend columnsort algorithm first eight step correspond classic 8step columnsort figur 2 show matrix r row column condit r satisfi first eight step exampl correspond 8step columnsort algorithm produc sort matrix ad one step step 9 element column sort obtain extend columnsort algorithm assum matrix r row column number 0 r gamma 1 0 gamma 1 respect argument reli part follow wellknown gem comput scienc mention knuth 4 proposit 1 let matrix whose row sort sort column row remain sort follow result prove 5 lemma 1 element x end posit j end step 3 x rank least follow result mention without proof 5 lemma 2 element x end posit j end step 3 rank si proof interest determin lower bound number element known larger equal x purpos note sinc end step 3 element x posit known larger equal x among known smaller equal gamma j element column end step 1 remain must smaller equal element column end step 1 consequ x known smaller equal least rs element follow rank x si sj claim 2 later refer choos r lemma 3 element x end column c end step 4 correct posit x sort matrix one pair column 1 proof consid gener element x end posit j end step 3 permut specif step 4 guarante x move step 4 posit correspond sort matrix element rank si j gener correct posit x howev shall prove x close correct posit follow sens x column c end step 4 sort matrix x must one pair column 1 recal virtu lemma 1 2 combin x rank smaller si larger si sj moreov simpl algebra manipul show consid element z rank si respect number n z element matrix lie z sort order 2 observ equat 4 impli z must lie adjac column sort matrix saw end step 4 x lie posit correspond element rank sort matrix confirm x lie somewher z assum x lie column c end step 4 thu correct posit x one column c gamma 1 c case z column x one column c c column x 2 lemma 4 row sort end step 4 proof consid arbitrari column k 0 k gamma 1 end step 3 permut specifi step 4 guarante first r element column k appear posit k ks k2 column 0 next group r element appear posit k ks k2 sinc column sort end step 3 follow row k ks sort end step 4 sinc k arbitrari conclus follow 2 lemma 5 element x bottom half column c end step 5 correct posit sort matrix one column c c 1 proof lemma 3 know correct posit x one pair column 1 thu prove claim need show x column c gamma 1 purpos begin observ proposit 1 lemma 4 combin row column sort end step 5 suppos element x end row b rc end step 5 x belong column c gamma 1 sort matrix element matrix column c belong row 0 must belong column c gamma 1 lemma 3 element alreadi column 0 must belong column 0 sort matrix thu least addit element must belong column c gamma 1 contradict 2 perfectli similar way one prove follow result lemma 6 element top half column c end step 5 correct posit sort matrix one column c gamma 1 c suppos find end step 8 8step columnsort lemma 7 everi item x column c end step 8 must column c sort matrix proof begin show element column c column proceed induct c basi trivial element column 0 lie column left assum 5 true column less c word element end one column end step 8 lie column left need prove statement also hold column c see must case consid first element u lie bottom half column c end step 8 end step 5 u must either bottom half column c top half column c 1 u belong bottom half column c lemma 6 must belong column c c 1 sort matrix u belong top half column c must belong column c c 1 sort matrix therefor either case u belong column c gamma 1 next consid element v lie top half column c end step 8 v belong element bottom half column c gamma 1 well element occur v column c must belong column c gamma 1 induct hypothesi element lie column end step 8 lie column c gamma 2 lemma 5 6 combin element lie top half column c gamma 1 belong column c reach contradict column must contain r element thu 5 must hold prove element column belong column left symmetr argument show element belong column immedi right complet proof 2 lemma 7 one sort step complet task thu obtain 9step columnsort trade addit sort step larger rang r versu theorem 1 extend 9step columnsort algorithm correctli sort r theta matrix r ss gamma 1 4 basic algorithm section show sort rowmajor order use architectur model enforc conflictfre memori access result algorithm refer basic algorithm turn first step stone design timeoptim sort algorithm basic algorithm implement extend columnsort discuss section 3 present focu effici use gener sort devic io size p mind shall keep track follow two paramet becom key ingredi evalu run time algorithm ffl number call sort devic ffl amount time requir data movement task involv sort assum sort rowmajor order element memori row case 2 perfectli similar assum without loss gener input place order memori row integ 0 sort element place memori row b 2 rang overlap step 1 sort row independ step consist follow loop read ith memori row sort nondecreas order use sort devic result sort sequenc parallel store x j ith word memori modul j endfor endfor 2 call sort devic op 1 data movement involv sort step 2 permut row permut specif step 2 columnsort prescrib pick element memori row lay column column illustr consid case initi element distribut featur follow matrix end step 2 permut matrix read care examin permut matrix reveal consecut element memori row end memori modul eg element 1 2 3 occur memori modul 1 therefor order achiev desir permut without memoryaccess conflict one devis differ way pick element variou memori row purpos find conveni view element x store memori modul order tripl hx rowx modulexi rowx modulex stand ident memori row memori modul respect contain x let rowxjmodulex denot binari number obtain concaten binari represent rowx modulex detail spell follow procedur procedur begin parallel read th word memori modul j endfor use sort devic sort p element nondecreas order rowxjmodulex result sort sequenc parallel store x j th word memori modul j endfor endfor clearli procedur involv p 1 iter iter p word read one memori modul sort written back memori one word per modul read write memori access conflict would seem though memori modul requir arithmet unit comput address word access iter fact point arithmet capabl requir specif use p 1 memori row store offset use memori access oper exampl offset begin step 2 address regist contain 1 first iter entri first row offset matrix ad content address regist guarante correct word memori modul access illustr refer 7 note offset first row indic word involv read oper found address memori modul 1 address memori modul 3 key observ understand happen iter column offset matrix 7 entri first row avail subsequ element column gener modulo 2 arithmet architectur comput perform adder associ address regist turn observ impli fact offset matrix need store entri gener fli yet anoth import point note order tripl hx rowx modulexi compos word three field compos word sort use combin two field name rowx modulex clearli modulex log p bit seem order repres rowx need log n bit actual replac rowx address offset contain offset matrix discuss sinc entri matrix integ larger p 1 logp bit suffici therefor concaten rowxjmodulex involv 15 log p bit discuss clear step 2 requir p 1 2 call sort devic time spent data movement oper involv sort bound op 1 step 3 step 1 step 4 permut step 2 perform revers permut set word store row step 5 step 1 step shift row shall permut element slightli differ way specifi columnsort howev easi verifi element suppos end given row inde end desir row sinc step 7 sort row order element place row step 6 immateri permut step 6 best illustr consid particular exampl specif permut specifi step 6 columnsort involv three row shown 6 permut bit differ assum p 1 consecut input row store memori start memori row 1 addit assum memori row avail us content immateri denot motiv anchor observ step 7 sort memori row element row sort step 9 consequ row sort step 7 row 1 detail follow procedur row shift begin sigma pupsilon parallel read ith word memori modul j store gamma 1th word memori modul j endfor endfor import note implement step 6 involv sort howev op 1 time spent data movement oper involv sort step 7 step 1 step 8 simpli revers data movement step 6 step 9 step 1 summar prove follow result theorem 2 set p 3 element store p 1 memori row sort rowmajor order without memoryaccess conflict 7p 1 2 call sort devic io size p op 1 data movement involv sort essenti way one prove follow companion result theorem 2 theorem 3 task sort rowmajor order set mp element store memori row perform without memoryaccess conflict 7m call sort devic io size p om time data movement oper involv sort remaind section present import applic basic algorithm suppos wish merg two sort sequenc algorithm merg b reli follow technic result lemma 8 assum n 2 e b b n 2 c1 let sequenc obtain merg e n element sequenc strictli larger element sequenc proof begin show 1 ne strictli larger element e assumpt n 2 e b b n 2 c1 guarante claim fals element strictli larger element c k evalu posit element c k sort sequenc c observ b nc element c come known larger equal therefor strictli larger c k consequ n even b nc element c larger c k impli k b nc contradict hand n odd ne b nc1 assumpt b n 2 e larger therefor strictli larger c k case least ne element c strictli larger c k follow contradict c k belong e next claim c larger element e sinc c sort statement fals c b k k k b nc1 notic element c come b smaller equal b k therefor strictli smaller c follow contradict c belong complet proof lemma 2 mirror argument prove follow companion result lemma 8 lemma 9 assum n sequenc obtain merg element sequenc 2 c strictli larger element sequenc worth note lemma 8 9 combin show given two sort sequenc size n task merg handl follow begin split two sequenc two sequenc size n element first one strictli larger element second one separ avail remain done sort two sequenc independ noteworthi featur approach fit extrem well architectur 2 consid sort sequenc store memori row store memori row 1 goal merg two sequenc store result sort sequenc memori row r r 1 detail follow procedur merg two group begin mp use basic algorithm sort b 1 nonincreas order c mp c store result memori row r els use basic algorithm sort 1 nonincreas order c mp c store result memori row r copi memori row r row r copi memori row r gamma memori row r b endfor odd copi leftmost pe element row r leftmost pe posit row r copi rightmost b pc element row r rightmost b pc posit row r endif endif odd copi leftmost pe element memori row r c leftmost pe posit row r copi rightmost b pc element row r c rightmost b pc posit row r endif copi memori row r c copi memori row r c endfor use basic algorithm sort memori row r r nondecreas use basic algorithm sort memori row r nondecreas order obviou procedur merg two group implement directli architectur model one point worth discuss howev specif task sort sequenc nonincreas order perform architectur follow sign element sort flip result sequenc sort nondecreas order final sign flip back origin valu correct procedur follow lemma 8 9 moreov procedur requir three call basic algorithm consid task sort collect 2mp memori row partit input two subgroup consecut memori row use basic algorithm sort group done complet sort use procedur merg two group thu follow result theorem 4 task sort 2mp 2 element store 2m memori row perform five call basic algorithm om time data movement oper involv sort 2 5 effici multiway merg algorithm consid collect 1 sequenc size p assum store topdown order 1 consecut memori row multiway merg problem sort sequenc rowmajor order goal section propos effici algorithm multiway merg multiway merg problem show implement architectur procedur multiway mergeam size p output result sort sequenc store rowmajor order mp igamma2 contigu memori row g step 1 select sampl size mp igamma2 2 retain everi pth element sequenc j 1 j move dmp igamma4 discuss step 2 one call sort devic els one call basic algorithm els frecurs multiway merg sg endif igamma22 sort version step 3 partit p igamma2 contain 2mp element discuss move element bucket without memori access conflict step 4 sort bucket individu use basic algorithm procedur merg two group step 5 coalesc sort bucket desir sort sequenc 2 notic sampl store one memori row remaind section devot detail implement procedur architectur 51 implement step 1 step 2 conveni view matrix size mp igamma2 2 theta p tth element memori row j denot aj element aj p term leader memori row j goal step 1 extract sampl retain leader everi memori row along ident k subsequ k leader belong context k refer sequenc index two disjoint group dmp igamma4 consecut memori row set asid store sampl correspond set sequenc indic remaind subsect view memori row alloc two matric size dmp igamma4 p intent end step 1 sx ix store yth leader sequenc index respect see step 1 implement without memori access conflict notic memori row leader extract store memori modul p gener memori row j cu interchang temporarili element aj p aj dj p interchang undon end step 1 next dmp igamma4 parallel read oper perform follow two parallel write oper jth parallel read oper pick kth word memori modul k 1 k p p element store jth memori row alloc second parallel write oper store sequenc indic p element jth memori row alloc thu step 1 implement omp igamma2 data movement call sort devic sampl process continu recurs level reach procedur multiway merg invok either case correspond sampl set store one memori row sort one call sort devic 4 case sampl set store memori row sort one call basic algorithm sinc oper sort one row direct discuss way basic algorithm oper context conceptu process sort sampl benefit view one sort concaten sjk sampl element k sequenc index recal describ section 2 design assum sort devic provid data path size w 15 log p input output impli step 1 3 5 7 9 extend columnsort execut directli sort row r correspond row r cu load two parallel read oper element field short auxiliari field data regist r j 1 j p sr j ir j long auxiliari field 0 let rj k rj element sequenc index store regist r j let rj jk rj denot concaten next content data regist suppli input sort devic let receiv r j sort rj 0 k rj 0 store respect element short auxiliari field r j two parallel write oper cu store element field short auxiliari field regist r j 1 j p sr j ir j respect step 2 4 6 8 basic algorithm perform permut implement step 6 8 involv sort case data movement involv sampl element correspond sequenc indic perform two companion phase specif view sampl set correspond sequenc index set two matric permut perform step 2 4 basic algorithm involv data movement oper sort data movement oper step similar step 6 8 detail recal sort oper step 2 4 basic algorithm perform concaten two auxiliari field store rel row number column number element henc perform two companion sort phase one permut sampl element permut sequenc indic clearli implement time complex easi confirm end step 2 procedur multiway merg sampl set sort rowmajor order furthermor view matric ix sequenc index sampl element sx let sort version equat 8 use step 3 partit element bucket order leader row need learn rank 8 next goal associ everi memori row rank task carri two stage first stage use sequenc index rank cu assign row number row everi row either exact row number extract step 1 case leader sever row equal row achiev possibl reassign leader row detail first stage spell procedur assign row number present conveni use matrix represent oper easili implement use address word correspond sx initi contain sequenc indic sampl procedur termin ix contain row correspond procedur assign row number begin r k row number first memori row store sequenc k endfor 2 e endfor endfor second stage cu assign rank memori row row contain ix oper perform matrix represent easili implement use address word correspond sx ix sinc readwrit oper use procedur describ total time spent oper bound omp igamma2 52 implement step 3 step 4 rank leader known readi partit bucket first object construct collect bucket follow condit satisfi b1 everi element belong exactli one bucket b2 bucket contain 2mp element b3 everi j 1 strictli larger element b j present bucket partit scheme need definit let mp igamma22 8 memori row leader b said regular respect bucket b j j notic equat 9 guarante everi memori row regular respect exactli one bucket ident bucket determin cu constant time convers respect bucket exactli regular memori row memori row r leader b sequenc k 1 k term special respect bucket b stand leader preced memori row k let memori row leader b regular respect bucket respect j import note equat 10 impli memori row whose leader b special respect bucket conceptu bucket partit scheme consist two stage first stage associ regular special row respect gener bucket 2 obtain set c j candid element second stage assign element bucket way actual element assign bucket b j form subset candid set c j specif element x memori row regular respect bucket b j assign b j one condit satisfi j gamma1m j gamma1m x jm whenev j element assign bucket virtu 11 12 longer elig assign bucket remaind assign process consid element x assign bucket respect memori row regular element x assign exactli one bucket respect memori row contain x special assum memori row contain x special respect bucket smallest index 1 n lx one equat 11 12 hold j n place j x assign bucket b jn next result show bucket defin satisfi condit b1b3 condit b1 b2 b3 proof clearli assign scheme guarante everi element get assign bucket element get assign one bucket thu condit b1 verifi notic 9 10 combin everi j 1 2 candid set c j respect bucket b j contain 2m memori row therefor 2mp element moreov indic element actual assign bucket b j subset c j prove b2 final equat 11 12 guarante element x belong bucket b j strictli larger element bucket b k k thu condit b3 hold well 2 worth note preced definit bucket work perfectli well even input element ident fact element distinct one defin bucket simpler way moreov case distinct element step 13 procedur multiway merg simplifi present implement detail assign element bucket write denot everi j 1 2 order pair j gamma1m jm jth bound pair notic equat 11 12 amount test whether given element lie bound pair b2 bucket contain 2mp element motiv us set asid 2m memori row bucket b j alloc first memori row element assign b j come regular memori row respect b j alloc last memori row element assign bucket b j resid special memori row respect b j addit find conveni initi content 2m memori row alloc b j 1s import note regular memori row respect bucket b j natur order 1 order correspond leader clarifi last point recal 9 leader belong bucket b j j gamma1m1 j accordingli memori row whose leader j gamma1m1 first regular row respect b j memori row whose leader j gamma1m2 second regular row respect b j similarli fact sequenc k sort guarante may contain one special memori row respect bucket b j case special row exist term kth special memori row respect b j distinguish other order move element bucket cu scan memori row one one suppos current memori row scan row r sequenc k assum leader row r b leader row r gamma 1 use equat 9 cu establish row r regular respect bucket b j similarli previou memori row regular respect bucket case row r first row k j 0 set 1 next element memori row r read element field data regist cu broadcast regist bound pair j gamma1m jm use compareandset regist store short auxiliari field 1 correspond element assign bucket b j virtu 11 12 0 otherwis say element x data regist mark valu short auxiliari field otherwis x unmark clearli everi element x mark end first broadcast assign bucket parallel write oper cu copi mark element correspond word row alloc bucket b j done use compareandset mark element data regist set 1 short auxiliari field clear cu broadcast data regist increas order bound pair bucket us follow process specif bucket b j 0 receiv bound pair data regist determin whether valu x store element field satisfi 11 12 j 0 place j mark x accordingli parallel write oper cu copi mark element correspond word next avail memori row alloc bucket b j next use compareandset mark element data regist set 1 short auxiliari field clear process repeat remain bucket respect row r special reader fail note process row r complet element move bucket assign moreov 9 10 altogeth mp igamma2 regular row mp igamma2 special row total time involv assign element bucket bound omp igamma2 call sort devic summari step 3 implement omp igamma2 data movement call sort devic step 4 bucket sort independ bucket p 1 memori row sort one call basic algorithm otherwis bucket partit two halv sort one call basic algorithm final two sort halv merg use procedur group theorem 4 task sort bucket individu perform omp igamma2 call sort devic omp igamma2 data movement involv sort 53 implement step 5 motiv need process specif step 5 note sort bucket individu step 4 may number 1s bucket refer element empti memori row consist entir empti element term empti row memori row term impur partli empti clear bucket may one impur row memori row contain empti element refer pure task coalesc nonempti element bucket mp igamma2 consecut memori row refer compact easi discuss assum sort bucket store consecut row nonempti row b 2 follow nonempti row b 1 nonempti row b 3 follow nonempti row b 2 assum empti row remov compact process consist three phase phase 1 let c row sequenc obtain concaten nonempti row b j obtain step 4 multiway merg increas order indic partit sequenc c subsequ x c j contain p 1 consecut row c except last subsequ c x may contain fewer row clearli x 2mp igamma3 2 use basic algorithm sort subsequ independ let sort subsequ correspond c c 0 empti row elimin futur consider let row sequenc obtain concaten row c 0 increas order indic partit sequenc subsequ j contain p 1consecut row except last subsequ may contain fewer row use basic algorithm sort subsequ independ let sort subsequ correspond 0 empti row elimin let e row sequenc obtain concaten row 0 increas order indic lemma 11 preced row everi impur row except last row e pure row proof notic follow fact except last row everi row either contain least p 1nonempti element contain fewer p 1 nonempti element preced row must pure row row c contain least one nonempti element impur row gener one two condit c j contain fewer p nonempti element contain one row impur row nonempti element come p 1 impur row c j b c j contain p nonempti element c 0 contain one impur row preced row pure row lemma directli follow fact 2 phase 2 phase comput set paramet use next phase let w total number nonempti row e assum row e locat row 1 row w everi j 1 stand number nonempti element impur memori row c j first subtask phase 2 determin igamma2 consid gener impur row c j determin n j cu read entir row c j data regist r 1 everi k 1 k p c j th word memori modul k read regist r k long auxiliari field data regist r k set k use compareandset featur cu instruct regist r k reset auxiliari field gamma1 element hold 1 ie empti next data regist load sort devic sort increas order long auxiliari field easi confirm sort largest valu k j precis posit rightmost nonempti element memori row c j therefor cu set consequ task comput number call sort devic op igamma2 readwrit oper involv sort number avail cu comput prefix sum oe cours involv addit perform cu omp igamma2 call sort devic let e mod g defin phase 3 construct row group g consecut row follow ff kgamma2 0 row start row e k els row kp 1 start row e k end row e k row kp 1 end row e g row w note e k e k1 may share two row lemma 11 contain least p1p2element last two row contain least p element g perform follow oper sort use basic algorithm b replac fi smallest element 1s c sort use basic algorithm ff k 0 k g elimin last row e g perform b c let k row group obtain e k let f row sequenc obtain concaten row increas order indic f compact c set select element row 1s done o1 time compareandset oper exampl set leftmost element row 1s carri follow read row r cu broadcast r r compar set content 1 modifi row written back memori array base lemma 10 easi verifi element f sort order step 5 implement omp igamma2 call sort devic omp igamma2 data movement involv sort 54 complex analysi correct multiway merg algorithm obviou turn complex specif interest assess total amount data movement involv sort requir procedur multiway merg specif let jmp stand time spent data movement task involv use sort devic take o1 time case take om time refer theorem 3 final 4 previou discuss show step 1 step 3 step 4 step 5 requir omp igamma2 recurs jmp igamma2 time thu obtain follow recurr system easi confirm p 4 solut recurr satisfi jmp similar analysi repeat show total number call sort devic io size perform procedur multiway merg merg sequenc 2 bound omp igamma2 summar discuss state follow import result theorem 5 procedur multiway merg perform task merg quenc size p 2 architectur use omp igamma2 call sort devic io size p omp igamma2 data movement involv sort 6 sort algorithm basic algorithm multiway merg dispos posit present detail sort algorithm use sort devic fix io size p input set sigma n item store evenli possibl p memori modul dummi element valu 1 ad necessari ensur memori modul contain n e element dummi element remov sort goal show use architecturealgorithm combin input sort n log n log p time data space assum p 16 along 1 impli log equat 13 import analysi section discuss focu case sort network io size p depth olog 2 p use sort devic 3 natur candid network batcher classic biton sort network 1 shall tacitli assum recal virtu 1 4 turn equat 14 guarante log n log p 1 point note 14 15 combin guarante log 2 16 write observ 14 reason becom clear later pad sigma appropri number 1 element way n 0 stand length result sequenc sigma 0 import note 14 17 19 combin guarante suggest number memori row use sort algorithm bound n show inde case sort algorithm consist iter order guarante overal run time n log n log p ensur iter perform n see shortli sort network use follow three context sort individu memori row 3 turn complex claim hold sort devic use instead psorter ii sort individu group consist consecut memori row iii sort individu group consist 2m consecut memori row effici implement use simpl pipelin memori row sort input sort network one initi overhead olog 2 p time subsequ time unit produc sort memori row clearli total sort time bound olog effici implement ii use interleav pipelin let g gm group wish sort interleav pipelin begin run step 1 basic algorithm pipelin fashion group g 1 group g 2 word step 1 basic algorithm perform group use simpl pipelin perfectli similar fashion simpl pipelin use carri step 2 basic algorithm group g 1 strategi use remain step basic algorithm requir use sort devic consequ total amount time need sort group use interleav pipelin bound olog effici implement iii reli extend interleav pipelin let g gm group want sort recal theorem 4 state sort group 2m consecut memori row requir five call basic algorithm extend interleav pipelin consist five interleav pipelin step correspond one five call basic algorithm thu task sort group perform olog time discuss iter sort algorithm detail iter 1 input partit n 0 group involv p 1 memori row use interleav pipelin group sort individu discuss run time iter 1 bound olog iter 1 input iter k collect n 0 ksort sequenc size p store consecut memori row output iter k collect n 0 1sort sequenc size p store p consecut memori row partit sort sequenc n 0 consecut sequenc proceed sort group gk j call multiway merg 1 k refer call multiway merg 1 k call first level observ sinc n altogeth n way merg call first one group step 1 multiway merg call first level extract sampl 2 k j 1 k consist p 1 sort sequenc size p store consecut memori row turn everi j 1 j n sampl 2 k j sort invok multiway merg 2 k refer multiway merg call second level step 1 multiway merg call second level extract sampl 3 k j everi u 1 2 c multiway merg call level u form multiway merg step 2 call multiway merg u k multiway merg call level u1 form multiway merg u1 k let r ku denot total number row sampl u k j level u clearli r p u 13 r ku qp r even 2 recurs call multiway merg end level b k gamma1c last call form note depend whether k odd proceed demonstr take k1 time show total time requir five step multiway merg call level u bound ku consid particular level u step 1 multiway merg call level u perform sampl u k j increas order j sampl u1 k extract one clearli total time oper ku perform step 3 multiway merg call level u increas order j partit bucket sampl u k use correspond u1 k j lemma 10 sampl bucket bucket contain 2p 3 element discuss subsect 52 task move element u k j bucket carri op use sort devic thu total time partit sampl u k multiway merg call level u bound n 0 step 4 multiway merg call level u sort bucket involv element u k j obtain step 3 perform step 4 multiway merg call level u increas order j use extend interleav pipelin 2 sort bucket u k j altogeth n 0 2u1bucket u k js thu total time sort bucket bound total time sort bucket multiway merg call level u ku step 5 multiway merg call level u three phase discuss subsect 53 oper phase 1 phase 3 involv sort devic carri use interleav pipelin oper phase 2 involv sort devic carri use simpl pipelin clearli time complex step 5 multiway merg call level u bound olog evalu time need perform step 2 multiway merg call level u first consid call level b k gamma1c multiway merg b 1 sampl extract step 1 call p element odd use simpl pipelin sort sampl b k use interleav pipelin 2 sort sampl b k either case time requir bound n 0 n 0 thu total time step 1 5 multiway merg call level b k gamma1c kb next time perform step 2 multiway merg call level u induct deriv ku use claim total time step 1 3 4 5 multiway merg call level u ku hypothesi step 2 multiway merg call level turn prove total time requir multiway merg call level u bound ku shown time requir multiway merg call level u iter k ku conclud total time perform iter k k1 n iter 2 n input element sort end iter assum algorithm termin iter input iter gamma 1 collect sort sequenc 2 sequenc size p 2 store p tgamma2 consecut row complet sort need merg q sequenc desir sort sequenc task perform call multiway mergesigma detail implement multiway mergesigma use sort network sort devic analysi involv almost iter 2 iter differ paramet use interleav pipelin 2 use step multiway merg iter 2 gamma 2 correspond step multiway merg iter use interleav pipelin similarli extend interleav pipelin 2 use step multiway merg iter 2 gamma 2 correspond step multiway merg iter use extend interleav pipelin q multiway merg call level b tgamma1c multiway merg b odd 4 recurs stop b tgamma1cth level sampl set b obtain step 1 multiway merg call level b tgamma1c qp 1 odd qp element even let r tgamma1u total number memori row simpl induct conclud multiway merg call level u 1 take tgamma1u time run time iter run time multiway merg call first level take tgamma11 shown iter multiway merg implement time n conclud run time sort algorithm n log n log p sinc psorter abstract sort network io size p depth o1 time complex stand sort devic use psorter work data memori iter simpli sampl size multiway merg call level u p time sampl size multiway merg call level u1 sinc work data memori one iter reus anoth iter total data memori requir sort algorithm remain summar previou discuss prove main result work theorem 6 use simpl architectur set n item store n memori row sort rowmajor order without memori access conflict n log n log p time data space use either psorter sort network io size p depth olog 2 p sort devic r sort n object ksorter optim sort algorithm reconfigur mesh art comput program tight bound complex parallel sort introduct parallel algorithm architectur array sort o1 time reconfigur mesh size n sort n number n sort n item use sort network fix io size tr ctr classifi matric separ row column ieee transact parallel distribut system v15 n7 p654665 juli 2004 giusepp campobello marco russo scalabl vlsi speedarea tunabl sort network journal system architectur euromicro journal v52 n10 p589602 octob 2006 brian grattan greg stitt frank vahid codesignextend applic proceed tenth intern symposium hardwaresoftwar codesign may 0608 2002 est park colorado