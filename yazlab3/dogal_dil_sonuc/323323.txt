leadingon predict concurr posit correct abstractthi paper describ design leadingon predict lop logic floatingpoint addit exact determin shift amount normal adder result leadingon predict techniqu calcul number lead zero result parallel addit howev predict might error one bit previou scheme correct error result delay increas design present incorpor concurr posit correct logic oper parallel lop detect presenc error produc correct shift amount describ error detect part overal lop perform estim delay complex compar previou scheme b introduct leadingon predict use floatingpoint adder elimin delay determin leadingon posit adder output critic path determin need perform normal result sinc latenc floatingpoint addit signific mani applic predict might practic import direct way perform normal illustr figur 1a result comput leadingon detector lod 1 count code number lead zero result left shift howev procedur slow sinc necessari wait result comput determin shift amount altern shown figur 1b normal shift determin parallel significand addit leadingon predictor anticip amount shift normal operand result addit obtain normal shift perform sinc shift alreadi determin approach use recent floatingpoint unit design commerci processor 3 7 8 9 11 18 19 describ basic scheme develop leadingon predictor give posit possibl error one bit second step consist detect correct error step increas overal delay avoid delay increas propos correct procedur detect error parallel 1 lod also call lzd lead zero detector 2 lop also call lza lead zero anticip lod input input b result result input input b significand adder sub shift code b adder sub significand shift code figur 1 magnitud addit normal floatingpoint adder unit determin posit correct perform concurr first stage shifter evalu comparison present show plausibl achiev specif implement singl datapath doubl datapath case 11 previou work sever lop recent propos literatur 4 17 19 briefli discuss lop describ 19 gener structur shown figur 2a describ detail section 2 preencod examin pair bit operand produc string zero one lead one posit correspond lead one addit result string use lod produc encod leadingon posit characterist preencod result leadingon posit might error one bit therefor necessari correct error addit one bit left shift call compens shift perform basic normal shift compens shift increas delay floatingpoint addit design 19 perform case align step operand compar swap result subtract alway posit simplifi implement adder lop howev use case floatingpoint adder doubl datapath explain section 5 b b b compens shift normal lod adder p preencod adder lod preencod p adder detect tree c shift lod p correct preencod normal shift carri select correct shift normal shift carri figur 2 lop architectur without concurr correct b concurr correct base carri check c concurr correct base parallel detect tree 4 lop concurr posit correct base carri check de scribe gener structur shown figur 2b design part multiplyaddfus maf unit 5 9 previou scheme lop possibl wrong predict one posit perform correct carri adder go anticip leadingon posit check posit correct accord carri valu correct done last stage normal shift therefor principl correct increas delay howev show section 5 carri detect slow introduc addit delay floatingpoint addit similar scheme propos 17 12 contribut main contribut paper propos evalu method perform correct one posit error basic lop normal shift without produc delay degrad achiev detect error condit concurr basic lop therefor significand adder describ develop detect correct scheme systemat way sinc descript much common descript basic lop also includ latter propos lop oper gener case output adder posit neg version case operand adder previous compar result subtract alway posit describ 1 approach figur 2c basic lop similar 19 extend case output adder posit neg base locat bit pattern produc leadingon binari code posit mean binari tree moreov includ anoth preencod tree detect occurr error basic lop output tree use correct output lod correct shift perform sinc detect correct perform last stage normal shift delay addit increas sinc almost floatingpoint processor 6 10 13 use ieee standard 15 consid case signandmagnitud represent operand paper organ follow section 2 structur lop present differ modul lop describ leadingon posit encod section 3 concurr posit correct section 4 section 5 design evalu compar lop final section 6 effect floatingpoint addit latenc discuss gener structur give overview structur leadingon predictor propos follow section consid individu modul state introduct two significand signandmagnitud lop applic effect oper subtract shown figur 1b lop predict posit leadingon result parallel subtract significand lop oper significand align denot 0 b 0 signific bit oper perform magnitud adder ja gamma bj 3 develop lop gener case either 3 note consid posit align significand consid sign floatingpoint operand correct normal concurr correct leadingon encod string symbol n symbol string 0s 1s n bit detect vlog n bit correct modul coars b adder normal figur 3 gener structur propos lop b contrast simplifi lop consid b propos 19 ad concurr correct 1 extens necessari lop describ 19 1 suitabl floatingpoint adder operand swap obtain alway posit result case effect subtract discuss section 5 effect singledatapath floatingpoint adder compar parallel align shift contrast lop propos incorpor also floatingpoint adder swap operand depend expon differ case result effect subtract may neg expon equal shown figur 3 lop divid two main part encod leadingon posit correct posit moreov part compos follow compon encod ffl preencod modul provid string zero one defin leadingon posit lead one immateri rest string ffl encod tree also call leadingon detector lod encod posit mostsignific 1 drive shifter normal addi tion bit v indic result 0 correct ffl preencod modul provid string symbol use determin whether correct need indic figur 3 signific common preencod modul ffl detect tree determin whether posit indic encod tree correct increment one ffl correct modul perform correct necessari parallel oper barrel shifter section 3 4 describ two part correspond modul tree 3 posit encod 31 preencod modul indic figur 3 modul produc string zero one first step product string perform radix2 signeddigit subtract significand obtain oper done bit slice without carri propag clariti gamma1 repres 1 consid string w determin posit lead one malli determin posit requir convers signeddigit represent convent binari represent howev see convers actual requir simplifi discuss consid separ case w notat use throughout paper follow x denot arbitrari substr 0 k 1 k 1 k denot string k 0s 1s 1s respect k 0 altern situat locat lead one describ diagram figur 4 last level diagram indic possibl combin w radix 2 signeddigit nonredund binari represent togeth locat leadingon sinc w 0 first digit w differ 0 equal 1 therefor top diagram show w string 0 k 1x substr x two situat identifi follow s1 digit w follow first 1 either 0 1 case lead one locat posit k 2 shown consid two case see 1 digit follow first 1 1 clearli convers w convent represent 1 posit k1 sinc borrow produc neg x absorb 1 posit k 2 situat lead one posit identifi substr 2 digit follow first 1 0 two possibl exist respect x name ffl x posit zero posit lead one k 1 sinc borrow x ffl x neg posit lead one borrow produc x problem situat possibl detect inspect digit w sinc depend number zero 1 consequ assum posit k1 correct later lead 1 posit identifi substr 0 ae ae ae ae ae ae ae ae ae z z z z z z z z z z 0kj 0 ae ae ae ae ae ae ae ae ae z z z z z z z z z z 0k omega omega omega omega omega omega omega omega omega omega omega posit neg zerok 0xomega omega omega omega omega omega omega omega omega omega omega posit neg zerok correct correct assum posit pattern 1 assum posit pattern 11 figur 4 bit pattern w 0 tabl 1 leadingon posit w 0 bit pattern leadingon posit substr first 10fposit zerog first first 0 last 1 string k 0fposit zerog last 1 string k first 0 last correct need summari s1 lead one posit identifi substr s2 first 1 w follow string 1s string 1s length j posit lead 1 depend similar situat s1 consequ use approach assum posit k correct later lead one posit identifi substr discuss summar tabl 1 combin s1 s2 case leadingon posit determin substr case analysi extend determin lead one posit w 0 achiev exchang role 1 1 w 0 case therefor leadingon posit identifi follow substr case case lead one encod tree provid signal indic situat therefor immateri encod 311 string identifi leadingon posit produc string zero one first one leadingon call string correspond bit f obtain combin substr describ simplifi descript f valu digit w equal 1 0 1 call respect bit posit input operand follow function defin notat substr ffl w 0 ffl figur 5a 5b show exampl comput f po f neg accord equat 2 3 would possibl use string f po f neg encod posit lead one separ lod choos sign known howev effici combin string singl lod 4 simplest way combin would two express howev produc incorrect result instanc 1 f neg signal leadingon posit correct posit w exampl given figur 5c abovement problem use also w igamma1 substr ore produc combin f figur 4 see substr w w identifi lead one w similarli substr w w identifi posit w consequ extend express e contrast discuss section 4 use two separ string detect pattern correct b w w f c fpo b fneg combin f b w w figur 5 comput intermedi encod similarli neg string combin equat obtain transform e exampl calcul string f given figur 5d note case postpon descript implement modul discuss also preencod concurr correct sinc modul share compon figur design 8bit lod tree implement b logic structur 4bit lod block 32 encod tree string f obtain posit lead one f encod mean lod tree 14 19 figur 6a show structur 8bit lod follow scheme notat describ 14 bit v lod block indic 1 group bit consider block p encod rel posit 1 exampl figur 6b show logic structur 4 bit lod block block lod4 tree note logic structur lod8 block similar multiplex 2 bit input 3 bit output rel posit 1 insid group obtain concaten depend 1 block v 0 v 1 respect final p encod posit lead one case obtain final indic shift n bit perform 4 concurr posit correct explain section 3 posit lead one predict input operand one bit error follow pattern w 1 tree tree posit preencod logic correct neg correct g g posit encod neg encod concurr correct present pattern present pattern present pattern neg posit figur 7 detect correct pattern 2 case posit correct ad 1 encod calcul tree therefor concurr posit correct two step 1 detect necessari correct 2 correct posit encod first step carri parallel leadingon encod second one normal shift 41 detect figur 7 show gener scheme detect correct pattern explain detect perform two modul preencod modul detect tree preencod logic two differ string obtain g p use detect presenc posit correct pattern case w detect neg correct pattern case w 0 done posit encod previou section possibl combin string one tree detect type pattern howev found complic substanti tree opt use two differ tree g p process posit tree g n neg tree describ modul tabl 2 relat w g p b g n otherwis z otherwis z 411 preencod modul preencod use w string obtain two new encod construct carri detect g p detect posit correct pattern g n detect neg one case necessari distinguish digit valu 1 1 therefor digit string g p g n take valu fgamma1 0 1g simplifi notat use n z p 1 0 1 respect specif posit case detect two pattern w construct string g p detect pattern similarli g n detect pattern let us consid g need detect pattern consist lead one follow zero termin 1 follow ffl use f p string describ express 2 section 3 give us lead one follow zero ffl combin w give us posit 1 result relat substr w digit g p shown tabl 2a note substr w n g p set accord previou discuss case interpret n interpret perform posit detect tree figur 8 indic pattern w correspond string g p seen g p pattern z k pz q n case correct need correct need c correct need f figur 8 pattern string g p w 0 case similar way preencod g n obtain tabl 2b show relat w digit g n 412 implement preencod modul implement express f g p g n name ffl f ffl g p ffl g n implement shown figur 9 413 detect tree detect one two pattern correct present binari tree use input tree intermedi encod g howev singl tree use detect posit pattern pz k n neg one nz k p number valu node tree would larg result complex slow hardwar implement therefor propos use two differ tree one detect posit pattern posit tree detect neg pattern neg tree shown figur 7 two tree oper parallel one pattern present correspond tree detect posit tree posit tree receiv input string g p detect pattern z k pz q nx present node tree five possibl valu z p n u repres figur 9 implement preencod logic follow substr indic pattern detect u indic string incompat pattern node tree receiv input output two node preced level produc combin valu figur 10a illustr node differ level combin tabl 3a show function tabl node tree left input node repres first column tabl right input first row output result combin left p right n valu valu set combin right input result tabl 3 node function posit tree b neg tree z u u u u u u z u u u u u u sinc string found mostsignific digit string leastsignific digit effect figur 10b show exampl detect pattern case pattern z 5 pz 8 n x present string result posit correct valu note first digit differ z g p n examin neg w string posit tree valu obtain output last level tree n simpl implement encod five valu four variabl assign code 0000 valu u encod logic equat input right input respect neg tree neg tree obtain exchang role p n posit tree receiv input g n string node function shown tabl 3b similarli posit detect tree posit w string process final valu obtain p string g p leastsignific digit node node level level z p z n n z z z z z z z z z left right z z z z z z z p z z z z z string detect mostsignific digit figur 10 binari tree detect correct pattern implement hardwar implement node posit tree equat 7 neg tree shown figur 11 42 correct normal shift last step lop propos correct leadingon posit correct done increment one shift amount done 19 reduc delay shifter conveni decod shift amount parallel adder suffici time moreov implement constraint shifter one stage shown figur 12 stage organ coarsest finest last one perform shift one sever contigu posit say 0 k f binari posit indic figur perform correct last stage shifter modifi shift 0 posit neglig effect delay last stage notic select correct nocorrect made parallel previou stage shifter z p n z figur hardwar implement tree node 5 evalu comparison section lop architectur propos evalu term delay critic path ad hardwar complex compar implement two scheme discuss section 11 name lop without concurr correct lop concurr correct base carri check 51 evalu evalu lop carri time analysi architectur critic path addit normal shift bit calcul moreov estim addit hardwar need concurr correct time analysi estim delay differ block architectur use unit delay simpl gate 2input nand delay summar tabl 4a estim obtain 19 thorough comparison perform lop describ 19 4 delay preencod logic f g p g n calcul accord hardwar implement propos figur 9 comput delay lod detect tree consid tree six level first level decod decod ls bit decod partial shift f leadingon posit ms bit unnorm b first stage shifter shifter second stage last stage shifter normal b correct correct tree detect shift partial shift partial shift figur 12 concurr correct leadingon posit lod compos gate delay remain level determin 2input multiplex howev level 3 4 5 6 control input multiplex known advanc input obtain previou level 14 therefor delay level estim 2 nand result total delay lod 12 nand delay level detect tree determin twolevel nand nand network see figur 11 note z output load 7 gate howev load slowest path node output 1 gate therefor load z affect global delay node consid normal shift carri two stage coars shift fine shift oper three bit shift amount consequ shifter implement 8input multiplex moreov buffer need control input shifter due heavi load line figur 13a show gener structur delay parallel path adder lop shifter note slowest path goe adder tabl 4 delay basic compon lop b gate count lop buffer 3 2input mux 3 preencod f 6 preencod g p g n 4 detect tree 12 shift correct 3 adder coars shifter 5 fine shifter 5 valu obtain 19 element gate preencod f 650 preencod g p g n 320 detect tree 1000 shift decod correct 34 nand wherea path preencod f lod tree almost delay 33 nand path detect tree lower delay point concurr correct critic path hardwar compon evalu hardwar complex concurr correct includ compon lop estim includ activ compon gate interconnect tabl 4b summar total count logic gate bit gate count preencod logic f g p g n obtain implement shown figur 9 count logic f includ gate except gate exclus comput g p g n therefor bit consid 12 gate devot comput f 6 comput g p g n said lod detect tree compos dlog 2 n number bit significand lod differ modul level tree thu modul except first level compos gate 2input multiplex howev number bit multiplex input depend level 54 bit total number 2input multiplex 49 modul first level multiplex number gate level coars select adder adder c preencod adder detect correct carri preencod lod coars control line buffer comp coars lod preencod lod correct adder fine buf detect tree g f buf26lodcoarse5 dec shift corr adder f buf26lod coars fine5 shift compbuf dec shift adder fine coars f6prefix tree7 finecarri 22 7corr buf select carri dec coars buf dec c figur 13 gener structur critic path delay lop concurr correct base detect tree b lop without concurr correct c lop concurr correct base carri check detect tree deriv implement figur 11 includ also gate count shift decod shift correct 52 comparison section compar lop architectur concurr correct two lop altern lop without concurr correct lop correct scheme base util addit carri use estim modul delay number gate three scheme main characterist follow 1 lop without concurr correct figur 13b extens one describ 19 case output adder either posit neg sinc lod determin posit leadingon within error one bit compens shift includ normal perform estim delay compens shifter 2 nand addit delay buffer requir shift control correspond delay diagram shown figur 13b 2 lop concurr correct base carri figur 13c discuss 4 17 error leadingon posit detect check carri correspond posit therefor scheme carri adder calcul explicitli correspond carri select accord output lod accomplish select prefer lod output consist string 1s follow 0s therefor lod implement prefix tree carri select perform set 2input gate follow gate characterist lod output delay fine decod larger scheme howev critic path note carri select shift correct done parallel coars shifter conveni reduc much possibl delay fine shift accomplish done 4 coars shifter hexadecim figur 13c show correspond time diagram tabl 5 summar critic path three scheme show estim lop concurr correct present result reduct 13 estim number gate lop two scheme compar given tabl 6 total gate count three lop summar tabl 7 lop concurr correct present larger number gate almost doubl gate count lop without concurr correct approxim 10 larger gate count lop concurr correct tabl 5 comparison critic path delay lop without lop concurr lop concurr correct correct base carri critic path delay 34 nand improv 13 13 tabl gate count lop without concurr correct b lop concurr correct base carri check element gate preencod f 650 coars shift decod 40 fine shift decod 120 compens shift 160 element gate preencod f 650 prefix tree 1100 carri select 110 coars shift decod 40 fine shift decod 120 correct base carri check howev gate count small part number gate floatingpoint adder 53 actual implement put perspect comparison estim present briefli summar actual lop implement recent describ literatur 19 implement floatingpoint adder use lop without concurr correct present includ compens shifter normal floatingpoint adder fabric 05 cmo process technolog tripl metal interconnect main differ respect lop without concurr correct describ section 52 come fact 19 result subtract alway posit preencod logic simplifi delay lop 8 ns time devot compens shifter 1 ns therefor conclud incorpor concurr correct base detect tree consequ elimin compens shifter delay tabl 7 gate count concurr correct lop gate lop detect tree 2260 lop without concurr correct 1200 lop carri check 2050 lop could improv 7 ns 5 9 implement ibm rs6000 floatingpoint unit 1 cmo technolog use triplelevel metal describ incorpor floatingpoint multiplyaddfus unit use lop concurr correct base carri check lod design accommod partialdecod scheme use shifter normal shift accomplish two stage first stage produc hexadecim shift second stage fine shift 0123 lod calcul hexadecim posit leadingon string 1s follow 0s necessari decod binari posit leadingon configur use kind lop comparison lop design detail 4 leadingon posit anticip carriedout digitwis input data process block 4 bit provid shift signal block shift signal constitut coars shift obtain shift signal prefix tree use receiv input gener g input 1 propag p one input 1 zero z input 0 signal also use adder output tree specifi leadingon posit insid group four bit signal use control shifter select carri 6 floatingpoint addit latenc reduct consid effect propos concurr correct overal latenc floatingpoint addit depend delay part adder pipelin implement processor cycl time consid separ effect singledatapath doubledatapath implement latenc reduct singledatapath floatingpoint adder figur 14a show block diagram singledatapath floatingpoint adder use lop without concurr posit correct 10 13 adder pipelin five stage done 19 significand addit perform one complement signif signif exp exp stage mux mux muxexpon differ correct concurr detect concurr without sign exp diff exp diff adder adder one comp one comp 1bit shift msb 1bit shift sign bit msb bit invert msb sign bit shift correct control sign addsub right bit invert control mux output align incr exp compens control bit invert output align mux figur 14 singl datapath floatingpoint adder without comparison includ concurr round b reduc latenc singl datapath floatingpoint adder without comparison concurr round lop concurr correct form 5 way result neg recomplement consist bit invers altern compound adder could use 2 16 fourth stage perfom round normal adder result note invert recompl result also includ stage shown figur oper perform two parallel path 19 one invers massiv left shift 1bit shift round possibl 1 valu comput significand adder neg whe expon differ zero case full normal left shift may need round requir consequ bit invert oper parallel round logic 2 hand expon differ larger zero two situat occur ffl two mostsignific bit adder result zero occur expon differ one zero case analyz separ normal left shift one bit need result exact round requir mux select output shift modul addit result ffl least one two mostsignific bit adder result one situat occur expon differ note normal adder result includ situat maximum normal shift one normal result round limit normal shift carri 1bit shift modul mux select output round modul result case effect addit round alway requir never normal left shift howev significand overflow occur need one bit rightshift normal right shift also carri 1bit shift modul figur adder lop concurr correct similar except compens shifter expon increment fifth stage elimin might permit merg two last stage shown figur 14b note merg might possibl without concurr correct delay compens shifter expon increment similar scheme latenc reduct obtain singl datapath floatingpoint adder comparison 6 19 case compar includ second stage assur case effect subtract smaller operand subtract larger one therefor result alway posit latenc reduct obtain kind adder analyz 1 round additionsubtraction0 signif exp signif exp expon differ sign bit lop without correct concurr effect subtract round 1bit shift msb msb far close exp diff effect oper eff add sign exp diff control addsub sign control shift eff sub adder compound bit 1bit shift bit invert right bit invert compound adder align 1bit shift exp incr control mux output align exp incr shift compens figur 15 latenc doubl datapath floatingpoint adder latenc reduct doubledatapath floatingpoint adder figur 15 show doubledatapath architectur 11 12 far datapath comput effect subtract expon differ larger one well effect addit hand effect subtract expon differ equal smaller one comput close datapath pipelin adder four stage deriv transform pipelin singl datapath floatingpoint adder without comparison figur 14 consid compon delay specifi 19 section 5 path additionsubtract combin round compound adder 2 11 16 adder comput select one perform round moreov close datapath use perform two complement result bitwis invers 11 16 array half adder includ compound adder far datapath comput requir round infin significand overflow howev 2 describ modif replac array right shift operand one posit effect addit way result either normal one lead zero situat subtract consequ round perform way addit subtract shift operand implement right shifter parallel 1bit shifter modif reduc delay sinc elimin de array half adder far datapath assur posit result adder smaller operand complement effect subtract way result convers elimin moreov path fulllength normal requir sinc maximum left shift result one bit respect close datapath case equal expon result neg align right shift result exact round necessari case expon differ equal one maximum align shift one bit complet align shifter requir hand case may requir fulllength normal shift therefor lop need close datapath note datapath effect oper alway subtract bit invert smaller operand includ insid compound adder sinc case effect subtract operand equal expon result neg neg result convert sign andmagnitud represent convert result form bitinvert output b compound adder way result convers reduc bitwis invers output compound adder sinc 1bit align shift 1bit normal shift small delay implement shorter critic path singl datapath case figur 14 determin influenc lop concurr correct latenc analyz total delay two path use lop without concurr correct see expect elimin compens shifter close datapath reduc total delay path describ flexibl pipelin two path sever stage latenc reduc consid block close far path see path almost modul signif exp signif exp expon differ compound adder four level adder compound sign bit msb exp diff effect oper control mux far close sign exp diff eff sub concurr lop detect control addsub sign eff add control shift shift corr bit 1bit shift bit invert 1bit shift shift right compound adder two level exp incr mux 1bit shift output align bit invert figur doubl datapath floatingpoint adder reduc latenc close expon differ operand swap 1bit right shifter align compound adder bit invert normal left shifter compens shifter mux output align far expon differ operand swap align right shifter bit verter compound adder 1bit left shifternorm mux output align differ two datapath compens shift close datapath consequ concurr correct use compens shift elimin path delay allow pipelin four stage smaller stage delay might even possibl obtain three stage pipelin shown figur 16 7 conclus present leadingon predict lop algorithm implement obtain exact predict normal shift floatingpoint adder predict permit reduc delay adder sinc lop oper parallel adder normal shift known result significand addit lop algorithm present gener sinc oper adder result posit neg predict lead one posit error one bit approach includ logic necessari concurr detect predict wrong correct normal shift permit elimin compens shifter requir adder lop includ concurr shift correc tion although concurr correct increas number gate requir lop increas signific sinc lop small portion overal floatingpoint adder detect correct logic oper parallel lop signific adder introduc addit delay adder improv perform respect lop concurr correct base check carri significand adder logic necessari carri check introduc addit delay estim delay signific addit normal shifter reduc approxim 13 use lop algorithm respect lop without concurr correct lop concurr correct base carri check improv use reduc latenc pipelin floatingpoint adder shown latenc singl datapath adder reduc five four cycl maintain critic path delay similarli latenc doubl datapath floatingpoint adder reduc four three cycl r round floatingpoint addit use compound adder ultrasparc next gener superscalar 64bit sparc design ibm risc system6000 floatingpoint execut unit snap project design floatingpoint arithmet unit variabl latenc pipelin floatingpoint adder algorithm novel design lead zero detector cir cuit comparison logic synthesi comput architectur improv algorithm highspe floatingpoint addit design implement snap float point adder tr ctr r v k pillai alkhalili j alkhalili shah low power approach float point adder design dsp applic journal vlsi signal process system v27 n3 p195213 march 1 2001 chi huang xinyu wu jinmei lai chengshou sun gang li design high speed doubl precis float point adder use macro modul proceed 2005 confer asia south pacif design autom januari 1821 2005 shanghai china khalid h abe raymond e siferd cmo vlsi implement lowpow logarithm convert ieee transact comput v52 n11 p14211433 novemb