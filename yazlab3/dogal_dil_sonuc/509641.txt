scalabl marksweep garbag collector largescal sharedmemori machin work describ implement marksweep garbag collector gc sharedmemori machin report perform simpl parallel collector processor cooper travers object global share heap collector stop applic program collect assum uniform access cost locat share heap implement base boehmdemersweis conserv gc boehm gc experi done ultra enterpris 10000 ultra sparc processor 250 mhz 64 processor wrote two applic bh nbodi problem solver cki context free grammar parser parallel extens cthrough experi observ load balanc key achiev scalabl naiv collector without load redistribut hardli exhibit speedup fourfold speedup 64 processor perform improv dynam load balanc exchang object scan processor still observ straightforward implement sever limit perform first larg object becom sourc signific load imbal unit load redistribut singl object perform improv split larg object small piec push onto mark stack next processor spend signific amount time uselessli serial method termin detect use share counter problem suddenli appear processor implement nonseri method termin detect idl time elimin perform improv care implement achiev averag speedup 280 bh 286 cki 64 processor b introduct sharedmemori architectur attract platform implement generalpurpos parallel program languag support irregular pointerbas data structur 4 20 recent progress scalabl sharedmemori technolog also make architectur attract highperform massiv parallel comput one import issu yet address implement generalpurpos parallel program languag scalabl garbag collect gc techniqu sharedheap previou work gc sharedmemori machin concurr gc 6 10 17 mean collector dedic processor run concurr applic program perform collect parallel focu shorten paus time applic overlap collect applic differ processor larg number processor howev collector may abl catch alloc speed applic achiev scalabl parallel collect paper describ implement parallel marksweep gc largescal 64 processor multiprogram sharedmemori multiprocessor present result empir studi perform algorithm least conceptu simpl alloc request collect applic program stop processor dedic collect despit simplic achiev scalabl turn challeng task empir studi found number factor sever limit scalabl appear number processor becom larg show elimin factor demonstr speedup collect implement collector extend boehmdemersweis conserv garbag collect librari boehm gc 2 3 two system 64processor ultra enterpris 10000 16processor origin 2000 heart extens dynam task redistribut exchang content mark stack ie data live yet examin collector present achiev 1428fold speedup ultra enterpris 10000 37 63fold speedup origin 2000 rest paper organ follow chapter 2 compar approach previou work chapter 3 briefli summar boehm gc collector base chapter 4 describ parallel mark algorithm solut perform limit factor chapter 5 describ experiment condit chapter 6 show experiment result conclud chapter 7 chapter 2 previou work previou publish work gc sharedmemori machin dealt concurr gc 6 10 17 one processor perform collect time focu work scalabl largescal mediumscal sharedmemori machin shorten paus time overlap gc applic util multiprocessor gc parallel collector may fail finish singl collect cycl applic exhaust heap figur 21 occur largescal machin amount live data larg cumul speed alloc correspondingli high therefor much interest parallel garbag collector singl collect perform cooper processor sever system use type collector 7 16 believ mani unpublish work rel publish perform result knowledg present paper first publish work examin scalabl parallel collector real largescal multiprogram sharedmemori machin previou public report preliminari measur uzuhara construct parallel mark sweep collector symmetr multiprocessor 22 amount free space share heap becom smaller threshold processor start collect processor continu applic execut collector processor cooper mark reachabl object dynam load balanc use global task pool sweep heap time memori region reus gc time time applic pe concurr gc parallel gc approach figur 21 differ concurr gc approach one dedic processor perform gc collect cycl becom longer proport number processor join applic worker approach advantag concurr gc prevent singl collect cycl becom longer largescal machin ichiyoshi morita propos parallel copi gc share heap 11 assum heap divid sever local heap singl share heap processor collect local heap individu collect sharedheap done cooper asynchron collect live data share heap call fromspac collect copi anoth space call tospac processor initi copi data reachabl local heap tospac processor copi data reachabl local heap resum applic processor work new sharedheap ie tospac collector much simpler uzuhara collector ichiyoshi morita collector simpli synchron processor collect processor dedic collect reachabl object mark although ichiyoshi morita mention explicitli believ potenti advantag method lower suscept load imbal collect idl time would appear collector effect fill applic perform measur chapter 6 show good speedup maximum configur 64 processor indic urgent need consid use applic fill idl time prefer method interfer spmdstyle applic global synchron frequent 1 uzuhara method ichiyoshi morita method may interact badli applic exhibit long mark cycl applic util processor taura also reach similar conclus distributedmemori machin 21 collector algorithm similar imai tick parallel copi collector 12 studi processor perform copi task cooper memori object one share heap copi processor dynam load balanc 1 global synchron occur even program languag provid explicit barrier synchron primit implicitli occur mani place reduct termin detect achiev exchang memori page scan tospac among proce sor speedup calcul simul assum processor becom idl load imbalanceth simul overlook sourc perform degrad factor spintim lock acquisit show chapter 6 factor becom quit signific especi largescal multiprogram environ chapter 3 boehmdemersweis conserv gc librari boehmdemersweis conserv gc librari boehm gc marksweep gc librari c c interfac applic simpl simpli replac call malloc call gc malloc collector automat reclaim memori longer use applic lack precis knowledg type word memori conserv gc necessarili marksweep collector move data boehm gc support parallel program use solari thread current focu seem support parallel program minimum implement effort serial alloc request gc parallel 31 sequenti marksweep algorithm marksweep collector work find garbag object unreach root set machin regist stack global variabl via pointer path free object tell whether object live reachabl garbag object mark bit show 0 unmark collect cycl mention boehm gc maintain mark bit section 32 collect cycl consist two phase mark phase collector travers object reachabl root set recurs set mark mark bit 1 mark mark object recurs boehm gc use data structur call mark stack shown section 33 sweep phase collector scan mark bit free object whose mark bit still unmark sweep method heavili depend free object manag describ aspect relev sweep phase section 34 32 heap block mark bitmap boehm gc manag heap unit 4kb block call heap block object singl heap block must size wordalign block separ header record heap block header alloc contain inform block size object also kept header mark bitmap object block singl bit alloc word 32 bit experiment environ thu mark bitmap 128byte length j th bit th byte mark bitmap describ state object begin blockaddr blockaddr start address correspond heap block put differ word mark bitmap describ state consecut word correspond heap block may contain multipl small object therefor parallel gc algorithm visit mark object must explicitli done atom otherwis two processor simultan mark object share common word mark bitmap either may mark properli 33 mark stack boehm gc maintain mark task perform vector call mark stack keep track object mark may directli point unmark object entri repres two word ffl begin address object ffl size object figur 31 show mark process pseudo code iter pop entri mark stack scan specifi object 1 possibl push new entri onto precis specifi object larg 4 kb collector scan first 4 kb keep rest stack push root regist stack global variabl onto mark stack mark stack empti f size f oi pointer noth els mark bit oi mark noth els f mark bit pushoi mark stack figur 31 mark process mark stack mark stack mark phase finish mark stack becom empti 34 sweep sweep phase boehm gc free garbag object actual instead distinguish empti heap block heap block boehm gc examin mark bitmap heap block heap heap block contain mark object link list call reclaim list prepar futur alloc request 2 heap block found empti link list call list heap block sort address adjac one coalesc form larg contigu block heap block free list examin alloc serv reclaim list 2 system free garbag object nonempti heap block program request object proper size lazi sweep order find garbag object heap block mark bitmap preserv next collect chapter 4 parallel gc algorithm collector support parallel program consist sever unix process assum process fork initi program ad applic dynam interfac applic program origin boehm gc provid gc malloc return pointer share memori acquir mmap system call could altern support solari thread choic arbitrari somewhat histor simpli thought privat global variabl make implement simpler claim one better 41 basic algorithm 411 parallel mark processor local mark stack gc invok applic process suspend send signal signal deliv everi processor start mark local root push object onto local mark stack object mark correspond word mark bitmap lock mark bit read purpos lock twofold one ensur live object mark exactli atom set appropri mark bit word reachabl object mark mark phase finish naiv parallel mark hardli result recogniz speedup object mark pe2 object mark pe1 pe1 root pe2 root heap figur 41 simpl algorithm node share tree mark one processor imbal mark task among processor load imbal signific larg data structur share among processor small number extern visibl object exampl signific imbal observ larg tree share among processor root object case root node tree mark one processor intern node figur 41 improv mark perform collector perform dynam load balanc exchang entri store mark stack 412 dynam load balanc mark besid local mark stack processor maintain addit data structur name stealabl mark queue task entri mark stack exchang 42 mark processor period check stealabl mark queue empti processor move entri local mark stack task mark stack lock stealabl mark queue figur 42 dynam load balanc method task exchang stealabl mark queue except entri point local root process local processor stealabl mark queue processor becom idl ie mark stack becom empti tri obtain task stealabl mark queue processor examin stealabl mark queue first processor find nonempti queue find one steal half entri 1 queue store mark stack sever processor may becom idl simultan testandst oper must acquir lock queue mark phase termin mark stack stealabl mark queue becom empti termin detect use global counter maintain number empti stack empti queue counter updat whenev processor becom idl obtain task 1 queue n entri n odd number n 12 entri stolen 413 parallel sweep parallel algorithm processor share singl heap block free list processor maintain local reclaim list sweep phase processor examin part heap link empti heap block heap block free list nonempti one local reclaim list sinc processor local reclaim list insert block reclaim list straightforward insert block heap block free list howev far difficult heap block free list share block must sort address adjac block must coalesc reduc content overhead share list make unit work distribut sweep phase larger singl heap block perform task local possibl processor acquir larg number 64 current implement contigu heap block time process local empti block local sort coalesc within block acquir time accumul local list call partial heap block free list processor repeat process block examin final list empti block accumul partial heap block free list chain togeth form global heap block free list possibl coalesc block joint sweep phase finish restart applic 42 perform limit factor solut basic mark algorithm describ previou section exhibit accept speedup smallscal system eg approxim fourfold speedup eight processor see chapter 6 howev sever factor sever limit speedup basic form never yield 12fold speedup list factor describ address turn load imbal larg object often found larg object becam sourc signific load imbal recal smallest unit task distribut singl entri stealabl mark queue repres singl object memori still larg often found processor busi scan larg object processor idl behavior promin applic use mani stack larg array one parallel applic input data singl 800kb array caus signific load imbal basic algorithm unusu processor idl entir second half mark phase address problem split larg object object larger 512 byte small 512byte piec push onto mark stack experi describ later refer optim slo split larg object delay test mark bitmap observ case processor consum signific amount time acquir lock mark bit simpl way guarante singl object mark lock correspond mark bit precis word contain mark bit read ever may unnecessarili delay processor read mark bit object know object alreadi mark improv sequenc replac lockandtest oper optimist synchron test mark bit first quit bit alreadi set otherwis calcul new bitmap word write new bitmap origin locat locat origin read bitmap oper done atom compareswap instruct sparc architectur loadlink storecondit instruct mip architectur retri locat overwritten anoth processor oper elimin useless lock acquisit mark bit alreadi set refer optim mo mark optimist synchron experi anoth advantag algorithm nonblock algorithm 8 18 19 henc suffer untim preemption major problem basic algorithm howev lock word bitmap everi time check object mark caus content even absenc preemption confirm testandlockandtest sequenc check mark bit lock work equal well though block algorithm serial termin detect number processor becom larg found gc speed suddenli drop reveal processor spent signific amount time acquir lock global counter maintain number empti mark stack empti stealabl mark queue updat counter time stack queue becam empti task thrown empti stack queue serial updat oper counter introduc long critic path collector implement anoth termin detect method two flag maintain processor one tell whether mark stack processor current empti tell whether stealabl mark queue processor current empti sinc processor maintain flag locat differ flag processor set flag clear flag done without lock termin detect scan flag turn guarante atom detect process maintain addit global flag detectioninterrupt set collector recov idl state detect processor clear detectioninterrupt flag scan flag find nonempti queue final check detect interrupt flag queue empti retri process interrupt processor must take care order updat flag lest termin detect mistak exampl processor steal task processor b need chang flag follow order 1 stack empti flag clear 2 detectioninterrupt flag set 3 queue empti flag b set refer optim nsb nonseri barrier chapter 5 experiment condit implement collector two system ultra enterpris 10000 origin 2000 former uniform memori access uma architectur latter nonuniform memori access numa architectur implement base sourc code boehm gc version 410 use four applic written c bh nbodi problem solver cki context free life game simul rna program predict rna secondari structur 51 ultra enterpris 10000 ultra enterpris 10000 symmetr multiprocessor sixtyfour 250 mhz ultra processor processor memori connect crossbar interconnect whose bandwidth 107 gb l2 cach block size 64 byte 52 origin 2000 origin 2000 distribut share memori machin machin use experi sixteen 195 mhz r10000 processor system consist eight modul two processor memori modul modul connect hypercub interconnect whose bandwidth 25 gb memori bandwidth modul 078 gb l2 cach block size 128 byte default configur memori page whose size 16 kb place node processor access page first therefor processor desir page local touch page initi phase program use two physic memori alloc polici experi local alloc la heap block correspond mark bitmap local processor alloc heap block first roundrobin rr home node heap block determin address rather alloc block heap block local processor p processor home mark bitmap determin rule 53 applic use follow four applic written c bh cki parallel ap plicat wrote enterpris version applic parallel extens c 14 extens allow programm creat user level thread dynam runtim implicitli use fork system call begin program sinc extens work origin wrote applic origin use fork system call explicitli life rna sequenti applic even sequenti applic util parallel collect facil bh simul motion n particl use barneshut algorithm 1 time step bh make tree whose leav correspond particl calcul acceler speed locat particl use tree experi simul 10000 particl 50 time step cki take sentenc written natur languag syntax rule languag input output possibl pars tree sentenc cki calcul nontermin symbol substr input sentenc bottomup experi given 256 sentenc consist 10 word life solv conway game life simul cell squar board cell either two state state cell determin state adjac cell previou time step program take list contain cell initi state number initi cell 5685 experi simul 150 time step rna predict secondari structur rna sequenc input data set stack region stack region posit energi set stack region call feasibl pair element fulfil certain condit problem find feasibl subset given stack region whose total energi smaller threshold size input stack region 119 experi 54 evalu framework ideal speedup collector measur use variou number processor appli algorithm snapshot heap difficult howev reproduc snapshot multipl time indeterminaci applic program amount data larg simpli dump entir imag heap even dump feasibl would still difficult continu dump imag differ number processor thu feasibl approach formul amount work need finish collect given heap snapshot calcul fast work process occurr collect gener accept estim workload mark given heap configur amount live object equival number word scan collector howev ignor fact load word differ depend whether pointer densiti pointer live data may differ one collect anoth given word heap boehm gc first perform simpl test rule nonpoint examin word elabor measur speedup accur defin workload w collect 4 x 4 5 x 5 number mark object x 2 number time scan alreadi mark object x 3 number time scan nonpoint x 4 number empti heap block x 5 number nonempti block 1 x n total processor gc speed defin elaps time collect gc speedup n processor ratio n processor singl processor measur singl processor elimin overhead parallel constant determin preliminari experi determin 3 exampl creat 1000word object contain nonpoint measur time scan object ran measur sever time use shortest time took 20 us scan 1000word object enterpris 10000 mean 0020 us per word result let 0020 constant determin similarli intent preliminari experi measur time workload without cach miss experi constant set 1 016 3 4 20 5 13 enterpris 10000 1 013 3 4 20 5 13 origin 2000 1 mark workload deriv x1 x2 x3 sweep workload x4 x5 chapter 6 experiment result 61 speedup gc figur 61616 show perform gc use four applic two system measur sever version collector sequenti refer origin boehm gc simpl refer algorithm processor simpli mark object reachabl root processor without task distribut basic refer basic algorithm describ section 41 follow three version refer one implement one optim describ section 42 noxxx stand version implement optim xxx full fulli optim version measur addit version origin 2000 fullla full take differ physic memori alloc polici fullla take local alloc polici version roundrobin polici applic execut four time configur invok collect 40 time tabl show averag perform invoc use almost processor machin occasion observ invoc perform distinguish wors usual one typic time wors usual one frequenc unusu bad invoc everi five invoc use processor yet determin reason invoc might effect process purpos studi exclud case figur 6164 68611 compar three version name simpl basic full graph show simpl exhibit recogniz speedup applic figur 6164 show basic enterpris 10000 perform reason certain point scale beyond except rna see differ basic full satur point basic depend applic basic cki reach peak 32 processor bh reach satur point 8 processor peak life 48 processor full achiev 28fold speedup bh cki 14fold speedup life rna 64 processor 16processor origin 2000 differ basic full littl except bh perform problem basic howev appear number processor becom larg observ enterpris 10000 thu full would signific larger system full achiev 3763fold speedup processor 62 effect optim figur 6567 show optim affect scalabl enterpris 10000 especi bh cki remov particular optim yield sizabl degrad perform larg number processor without improv termin detect nonseri barrier nsb neither bh cki achiev 17fold speedup without nsb life scale 48 processor sensit optim differ among applic split larg object slo mark optimist synchron mo signific impact bh applic slo import larg object applic bh use singl array name particl hold particl data whose size 800 kb experi larg array becam bottleneck omit slo optim phenomenon note origin 2000 figur 612 indic gener mo signific effect object big refer count object caus mani content collector tri visit experi reveal array particl sourc problem one collect cycl observ 70000 pointer array caus signific content big refer count produc stack user thread bh implement comput forc particl parallel thread refer respons particl although refer direct distinct address exampl ith thread refer particlesi regard pointer singl object particl mo optim effect allevi content case improv perform observ signific impact nsb optim gc speed three applica tion see rna even 64 processor although reason differ understood well gener nsb import collector tend becom idl frequent collector often updat idl coun ter implement nsb rna frequenc task shortag may low investig whether hypothesi case futur 63 effect physic memori alloc polici figur 613616 compar two memori placement polici local alloc la roundrobin rr origin 2000 describ section 52 full adopt rr polici fullla la see easili collect speed rr significantli faster la three applic bh cki rna adopt la polici gc speed improv eight processor fulli analyz conjectur mainli due imbal amount alloc physic page among node la polici access object mark bitmap mark phase contend node alloc mani page actual bh signific memori imbal one processor construct tree particl object rna natur alloc one processor rna sequenti program 1 investig case life also sequenti program 64 discuss optim perform seen section 61 gc speed fulli optim version alway get faster number processor increas applic consider differ gc speed instanc 28fold speedup bh cki 14fold life rna enterpris 10000 order tri find caus differ examin processor spend time mark phase 2 figur 617620 show breakdown figur say biggest problem life load imbal processor spend signific amount time idl perform improv may possibl refin load balanc method hand current specifi reason rel bad perform rna processor busi 90 mark phase collect cycl sweep phase five ten time shorter mark phase therefor focu mark phase sequenti sequenti code without overhead parallel simpl parallel load balanc done basic load balanc done optim slo split larg object done optim mo mark optimist synchron done optim nsb nonseri barrier done optim slo split larg object done full optim done fullla origin 2000 full physic memori alloc polici local alloc tabl 61 descript label follow graph except fullla physic memori alloc polici origin 2000 roundrobin number processor speedup full basic simpl linear figur 61 averag gc speedup bh enterpris 10000 number processor speedup full basic simpl linear figur 62 averag gc speedup cki enterpris 10000 number processor speedup full basic simpl linear figur 63 averag gc speedup life enterpris 10000 number processor speedup full basic simpl linear figur 64 averag gc speedup rna enterpris 10000 number processor speedup full linear figur 65 effect optim bh enterpris 10000 number processor speedup full linear figur 66 effect optim cki enterpris 10000 number processor speedup full linear figur 67 effect optim life enterpris 10000 bh origin 20002610 number processor speedup full basic simpl linear figur 68 averag gc speedup bh origin 2000 cki origin 20002610 number processor speedup full basic simpl linear figur 69 averag gc speedup cki origin 2000 life origin 20002610 number processor speedup full basic simpl linear figur 610 averag gc speedup life origin 2000 rna origin 20002610 number processor speedup full basic simpl linear figur 611 averag gc speedup rna origin 2000 bh origin 20002610 number processor speedup full linear figur 612 effect optim bh origin 2000 bh origin 20002610 number processor speedup full fullla linear figur 613 effect physic memori alloc polici bh origin 2000 cki origin 20002610 number processor speedup full fullla linear figur 614 effect physic memori alloc polici cki origin 2000 life origin 20002610 number processor speedup full fullla linear figur 615 effect physic memori alloc polici life origin 2000 rna origin 20002610 number processor speedup full fullla linear figur 616 effect physic memori alloc polici rna origin 2000 bh enterpris 10000 0 20 40 80 100 number processor busi lock balanc idl figur 617 breakdown mark phase bh enterpris 10000 show busi wait lock move task idl cki enterpris 10000 0 20 40 80 100 number processor busi lock balanc idl figur 618 breakdown mark phase cki enterpris 10000 life enterpris 10000 0 20 40 80 100 number processor busi lock balanc idl figur 619 breakdown mark phase life enterpris 10000 rna enterpris 10000 0 20 40 80 100 number processor busi lock balanc idl figur 620 breakdown mark phase rna enterpris 10000 chapter 7 conclus construct highli scalabl parallel marksweep garbag collector sharedmemori machin implement evalu done two system ultra enterpris 10000 symmetr sharedmemori machin 64 processor origin 2000 distribut sharedmemori machin 16 processor collector perform dynam load balanc exchang object mark stack experi largescal machin found number factor sever limit scalabl present follow solut 1 unit load balanc singl object larg object divid degrad util processor split larg object small part push onto mark stack enabl better load balanc 2 observ processor spent signific time lock acquisit mark bit bh useless lock acquisit elimin use optimist synchron instead lockandtest oper 3 especi 32 processor processor wast signific amount time serial oper use termin detect global counter implement nonseri method use local flag without lock long critic path elimin origin 2000 must pay attent physic page placement default polici place physic page node first touch gc speed scalabl improv perform distribut physic page round robin fashion conjectur default polici caus imbal access traffic node sinc node much physic page alloc node access highlyload node tend contend henc latenc remot access accordingli increas enough tool conclud use solut achiev 14 28fold speedup 64processor enterpris 10000 37 63fold speedup 16processor origin 2000 chapter 8 futur work would like improv gc perform section 64 seen collector applic still spend signific amout time idl investig improv load balanc method instead use buffer commun stealabl mark queue steal task victim mark stack directli may enabl faster load distribut also notic explain rel bad perform rna load imbal alon may due number cach miss includ busi figur 620 captur number cach miss use perform counter recent processor equip use r10000 counter proc file system origin 2000 construct simpl tool use ultra sparc counter enterpris 10000 tool plan examin often processor meet cach miss section 63 mention obtain better perform rr roundrobin physic memori alloc polici la local alloc polici far focu discuss speed gc alon matter complic take account local applic program la polici may advantag memori region tend access alloc ideal situat would access applic local collect task balanc well r hirarch log n forcecalcul algorithm space effici conserv garbag collect garbag collect uncoop environ concurr garbag collect c concurr gener garbag collector multithread implement ml languag concurr symbol computa tion methodolog implement highli concurr data ob ject concurr copi garbag collector languag distinguish immut data sharedmemori parallel extens klic garbag collect evalu parallel copi garbag collect sharedmemori multiprocessor garbag collect sgi origin ccnuma highli scalabl server garbag collect multischem preliminari version concurr replic garbag collect remark methodolog implement highli concurr data object methodolog implement highli concurr data object effect garbag collect strategi parallel program languag larg scale distributedmemori machin parallel garbag collect sharedmemori multiprocessor uniprocessor garbag collect techniqu tr multilisp languag concurr symbol comput garbag collect uncoop environ garbag collect multischem space effici conserv garbag collect concurr copi garbag collector languag distinguish immut data concurr gener garbag collector multithread implement ml methodolog implement highli concurr data object concurr replic garbag collect remark methodolog implement highli concurr data note myampersandldquoa methodolog implement highli concurr data objectsmyampersandrdquo garbag collect effect garbag collect strategi parallel program languag larg scale distributedmemori machin lockfre garbag collect multiprocessor evalu parallel copi garbag collect sharedmemori multiprocessor uniprocessor garbag collect techniqu iccac dialect high perform parallel comput ctr guy e blelloch perri cheng bound time space multiprocessor garbag collect acm sigplan notic v34 n5 p104117 may 1999 guy e blelloch perri cheng bound time space multiprocessor garbag collect acm sigplan notic v39 n4 april 2004 david siegwart martin hirzel improv local parallel hierarch copi gc proceed 2006 intern symposium memori manag june 1011 2006 ottawa ontario canada toshio endo kenjiro taura reduc paus time conserv collector acm sigplan notic v38 n2 supplement februari h gao j f groot w h hesselink lockfre parallel concurr garbag collect marksweep scienc comput program v64 n3 p341374 februari 2007 david detlef christin flood steve heller toni printezi garbagefirst garbag collect proceed 4th intern symposium memori manag octob 2425 2004 vancouv bc canada yoav ossia ori benyitzhak irit goft elliot k kolodn victor leikehman avi owshanko parallel increment concurr gc server acm sigplan notic v37 n5 may 2002 katherin barabash ori benyitzhak irit goft elliot k kolodn victor leikehman yoav ossia avi owshanko erez petrank parallel increment mostli concurr garbag collector server acm transact program languag system topla v27 n6 p10971146 novemb 2005 yossi levanoni erez petrank onthefli referencecount garbag collector java acm transact program languag system topla v28 n1 p169 januari 2006 yossi levanoni erez petrank onthefli refer count garbag collector java acm sigplan notic v36 n11 p367380 11012001 guy e blelloch perri cheng bound time space multiprocessor garbag collect acm sigplan notic v39 n4 april 2004