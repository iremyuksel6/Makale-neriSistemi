approach phrase select offlin data compress recent sever offlin data compress scheme publish expend larg amount comput resourc encod file decod file quickli compressor work identifi phrase input data store data seri pointer phrase paper explor applic algorithm comput repeat substr within string phrase select offlin data compressor use approach obtain compress similar best known offlin compressor genet data poor result gener text seem howev altern approach base select repeat substr feasibl b introduct data store cd dvd static databas compress often decompress mani time given scenario compress scheme aord spend sever hour comput time make multipl pass input consum mani megabyt ram compress process order make compress represent small possibl decompress howev fast memori ecient compress scheme said oin one way meet demand fast decod high compress level identifi suitabl phrase book input data store seri pointer entri phrase book exampl figur 1 show simpl string much wood woodchuck chuck woodchuck could chuck wood compress use three differ phrase book rst represent favour phrase appear frequent string henc space charact form phrase second represent look includ space charact start end word form phrase third greedili choos longest repeat phrase similar strategi employ compressor base lz77 scheme 1977 gzip winzip pkzip nal le phrase book seri pointer must store dicult tell inspect exampl three phrase book yield best compress phrase book represent 1 contain 27 charact 26 pointer phrase book represent two three charact copyright c 2001 australian comput societi inc paper appear twentyfifth australasian comput scienc confer acsc2002 melbourn australia confer research practic inform technolog vol 4 michael oudshoorn ed reproduct academ notfor prot purpos permit provid text includ phrase book signicantli less pointer unfortun variabl involv choos phrase book much complic mere number pointer number charact phrase book assum sort statist coder exampl human code arithmet code use actual encod pointer phrase book frequenc distribut self entropi two compon better indic tness phrase book particular exampl cost zeroord human code charact phrase book pointer data portion shown last row figur 1 indic rst phrase book lead smallest represent 21 byte even calcul approxim nal compress level obtain code natur necessari inform describ human code employ prelud includ estim oin compress use phrase book new idea rubin 1976 storer szymanski 1982 nevillman witten 1994 increas avail cheap power comput comput intens techniqu viabl encod order improv compress level construct good phrase book task identifi best possibl phrase book input shown npcomplet storer szymanski 1982 use heurist lot machin power compress level superior altern techniqu achiev data set nevillman witten introduc approach induc context free text use grammar rule describ phrase book compress nevillman witten 1994 larsson moat cannan william explor use repeat pair charact order build phrase book emphasi small larg data set respect larsson moat 2000 describ ecient algorithm nding long repeat substr place phrase book bentley mcilroy 1999 paper expand work apostolico lonardi recent introduc offlin compressor apostolico lonardi 2000 calcul measur compress gain possibl nonoverlap substr string high gain factor indic substr chosen phrase phrase book good compress would result similarli low gain score substr indic particular substr chosen phrase phrase book compress algorithm use offlin outlin figur 2 represent 1 represent 2 represent 3 much 1 much 1 much 1 wood 3 could 3 c 3 2 woodchuck 4 ould 4 could 4 chuck 5 5 5 woodchuck 4 chuck 6 could 3 c 3 wood 3 chuck 5 huck 7 chuck 6 wood 2 8 chuck 6 wood 2 chuck 6 ould 4 5 c 3 wood 3 wood 2 chuck 6 9could 4chuck 6wood 3 phrase 12 pointer 9 4 8 total figur 1 string much wood could wood chuck chuck woodchuck could chuck wood repres three possibl phrase book rst occurr phrase shown gray case number order rst occurr nal three row show cost human encod phrase book pointer byte allud exampl calcul exact gain compress given substr dicult task commenc encod way know mani phrase end phrase book probabl distribut charact phrase book pointer data compon accordingli apostolico lonardi experi three approxim gain formul use simpl approach achiev excel level compress genet sequenc competit compress level gener data apostolico lonardi 2000 detail result found wwwcspurdueeduhomessteloofflin implement offlin reli sux tree data structur trie hold possibl sux string ukkonen 1995 refer therein acknowledg howev sux tree larg slow data structur task paper introduc altern approach perform compress use offlin algorithm base string process algorithm nding repeat substr string focus repeat substr rather sux string hypothesis time taken perform gain calcul string manipul use offlin approach signicantli reduc section 2 describ crochemor algorithm crochemor 1981 nding repeat substr input string compress calcul gain possibl nonoverlap substr input string compress choos substr highest gain factor add phrase book step 3 remov occurr chosen substr string store pointer origin phrase occurr step 4 recalcul gain measur substr input string cover chosen phrase step 5 still posit gain factor repeat step 2 remain uncov string output phrase book list pointer repres input string figur 2 basic algorithm employ offlin within string explain use select phrase oin compress scheme crush section 3 describ experiment result compress level time crush offlin final section 4 discuss result implic crush compressor consist two stage rst analys input string use crochemor algorithm gener two dimension array c store inform substr given length data structur travers calcul gain measur substr occur leftmost uncompress posit input string highest gain substr chosen phrase book note approach deviat offlin algorithm make local choic leftmost uncov posit rather global choic possibl uncov posit remain string two stage explain detail follow two subsect summaris figur 3 21 stage 1string analysi crochemor algorithm crochemor 1981 nd ing repeat substr input string begin group posit string charact singl class class rene subclass get repeat substr length two turn class rene get substr length three exampl consid input string b b b b posit form initi class string length one b rst stage accomplish time n number charact input string assum alphabet charact string drawn index exam ple ascii next stage algorithm split class class repres start posit substr length two rst class split class aa ab class b split class ba b end string symbol ab aa ba b use nave approach stage accomplish n time simpli check charact follow posit class exampl order rene class would necessari check posit case f3 8 11g must form class aa form class ab process renement continu ignor class contain singl posit must repres substr repeat rene ment possibl ab aa ba aba aab baa abaa aaba baab abaab baaba abaaba nave approach renement adopt stage total run time 2 could level requir n time crochemor oer two insight allow time reduc log n crochemor 1981 rst necessari refer back origin string order rene class renement achiev respect class level order member class level l rene class level must share charact l1st posit nave approach check charact directli class member howev member class share l 1st char acter length l sux must also ident exampl substr aba b next posit share three charact sux bab substr length share sux length l posit plu one must appear anoth class level l exampl substr aba occur posit substr baa occur posit take account overlap two charact sux aba two charact prex baa deduc string abaa must occur posit precis happen rene class aba f1 4 6 9g level 3 check posit f2 5 7 10g fall class level 3 deduc string form class level 4 case 2 7 10 inhabit class baa f1 6 9g form class level 4 similarli f5g class level 3 f4g form class level 4 observ alon reduc run time algorithm use conjunct observ class need rene level run time come consid exampl rene 9g level 3 class level 4 mani class level three need inspect order perform renement discuss class must prex ba overlap sux aba inspect renement took place level 2 produc level 3 see class split 2 class level 3 name f5g precis two class need consid rene 9g turn mean use one perform renement aba f1 4 6 9g remain posit must fall class level 4 case either rene f1 4 6 9g use f5g get class f4g remain class f1 6 9g rene f1 4 6 9g use f2 7 10g get class f1 6 9g remain class f4g obvious choos smallest class rene leav largest class left process requir precis approach adopt crochemor algorithm stage small class rene observ class level l rene two class level l 1 longest smallest class greater half size parent class charact string appear small class olog 2 n time henc involv renement olog n time see n charact overal run time crochemor algorithm log n brief descript intuit behind crochemor algorithm hide complex intric detail requir achiev fast memori ecient implement algorithm implement use paper oper space store list class level renement discard list previou level constant factor quit high space bound current implement requir 44n byte memori 22 stage iiphras select order use result crochemor algorithm phrase select current implement crush store class inform level deriv memori conserv encod primari aim crush simpl array n integ use hold circular list class member level formal element cli array c pointer next member class contain posit level l nal class member point back rst member exampl crochemor algorithm c would number level restrict k paramet crush total space requir c okn array c exist phrase select begin unlik offlin crush make phrase select set substr begin leftmost uncov posit overlap alreadi cover posit offlin compressor howev consid possibl nonoverlap substr phrase choic crush choos phrase p highest gain measur g p set possibl substr g p 0 charact uncov posit skip left nal stage process nal stage simpli treat uncov charact singl letter phrase innit store singl letter phrase book uncov occurr pointer report comput g p cost store occurr phrase zeroord charact model less cost store singl copi seri pointer copi gave best result experi accordingli crush use similar gain measur let h cost bit store singl charact input string use simpl charact base model statist coder exampl human code arithmet code h would around 2 3 bit ascii code quantiti h estim preliminari scan data record probabl charact set shannon lower bound compress level shannon 1948 approach adopt crush let f p frequenc phrase p occur text l p number charact phrase p cost store f p copi phrase uncompress text approxim hf p l p bit phrase p chosen phrase book one copi requir cost approxim hl p bit phrase plu h bit store either length phrase termin symbol phrase phrase book apart phrase book copi p also necessari store f p pointer phrase cost pointer new phrase estim dlog 2 number phrase alreadi phrase book 2000 accur estim pointer cost amount cost binari code pointer current phrase book cours crush continu p number phrase increas net effect slowli make cost ad phrase expens total gain compress phrase p includ phrase book therefor uncompress represent phrase book entri cost pointer cost figur 3 show pseudo code complet algorithm use crush step 1 2 simpli run crochemor algorithm creat c array step 4 perform phrase select step 5 nish skip posit posit gain step 4 process time requir crush domin travers c list step 432 possibl substr may k 1 entir pointer chain item must travers order calcul frequenc substr step 46 also see chain pointer relat select phrase travers second time record pointer mark posit cover note step 432 46 must also exclud self overlap posit consider implement crush describ implement offlin download wwwcspurdueeduhomessteloofflin run purdu corpu purdu 2001 tabl 1 show compress speed result achiev use pentium iii 800mhz cpu 640mb ram primari cach run linux c code compil use gcc version egcs29166 full optimis phrase crush limit charact length valu report tabl 1 use gain formula nal term ad order bia phrase select toward singl char reduc number phrase chosen initi experi show crush use gain measur state previou section aggress phrase select problem discuss compress valu assum human coder use code phrase book pointer list preludecost code includ code number codeword small less 100 case prelud size neglig eect nal compress level tabl show compress result competit le corpu unusu given local rather global approach phrase select one obviou failur crush nd good phrase le spor 2x le spor repeat twice exampl shortcom local choic approach adopt spor 2x le le purdu corpu consist 258 2 block 14 line genet data shown figur 4 le offlin rst choos upstream sequenc 800 1n highest gain phrase proce choos 200 phrase length 800 charact maximum allow occur four less time crush hand must rst deal charact select phrase upstream sequenc 800 1n fact crush determin upstream sequenc 800 1n rst decent phrase leav preced charact encod singleton amongst crush phrase choic le phrase upstream sequenc 800 1 upstream sequenc 800 1 upstream sequenc 800 1 3 upstream sequenc 800 1 4 upstream sequenc 800 1 9 upstream sequenc 800 1 7 upstream sequenc 800 1 8 upstream sequenc 800 1 5 upstream sequenc 800 1 6 upstream sequenc 800 1 clearli could improv crush get line 2222 le locat block offlin design second best phrase block alreadi cover earlier choic smaller phrase avail choic crush similar problem occur gener text ran crush small text le calgari calgari 2001 canterburi canterburi 2001 input string compress k maximum length phrase consid phrase book level one class crochemor algorithm algorithm level k store level c array cki point next member class contain posit level k step 3 set posit uncov step 4 uncov posit step 41 let smallest uncov posit step 42 let j minsmallest cover posit k step 43 level 2 k j step 431 set f 0 step 432 posit c list root cki k posit fcc1 ck1g uncov set f f 1 step 433 set g k hfk hk step 44 find step 45 gm 0 record posit skip mark cover goto step 4 step 46 posit c list root cmi step 461 k posit fcc1 ck1g uncov record pointer posit c new phrase posit fc c cover step 5 posit record skip step 45 step 51 singl charact posit phrase add phrase book step 52 record pointer phrase posit output phrase book list pointer phrase book figur 3 algorithm use crush file size bzip2 offlin crush offlin crush name byte bpc bpc bpc sec sec spor earlyii 25008 2894 2782 2217 62 11 spor earlyi 31039 1882 1835 2222 85 19 helden cgn 32871 2319 2264 2219 98 21 spor middl 54325 2281 2176 2196 213 90 helden 112507 2261 2116 2227 750 585 spor 222453 2218 1953 2195 2785 2912 400k 399615 2249 2136 2275 9897 10348 spor 2x 444906 1531 0148 2194 11337 10467 tabl 1 compress time result purdu corpu corpora compress result abysm averag around four bit per charact tabl also show run time purdu corpu low anticip run time calgari canterburi corpora except fast hardli surpris given poor compress result reason low run time gener text short phrase initi chosen cover much input string subsequ process need look remain substr tabl 2 show breakdown run time purdu corpu gener use gprof soft ware prole code indic far major time spent count frequenc phrase step 432 figur 3 string process portion crush crochemor algorithm extrem fast paper report simpl attempt appli crochemor algorithm nding repeat substr phrase select oin data compr file step 1 step 432 2 spor earlyii 2 78 spor earlyi 2 82 helden cgn 2 85 spor middl 1 91 helden 0 96 spor 0 98 400k 0 99 tabl 2 percentag run time taken crochemor algorithm step 1 2 frequenc count step 432 crush purdu corpu sion follow model apostolico lonardi greedili choos phrase stage maximis approxim compress gain expect phrase includ phrase book global approach phrase select howev triall local approach shown work well string cover algorithm yang 2000 rts2 rts2 upstream sequenc 800 1 gtaatggttcatttctttaatagccttccatgactcttctaagttgagtttatcatcagg tagtaaggatgcacttttcgatgtactatgagactggtccgcacttaaaaggcctttaga tttcgaagaccacctcctcgtacgtgtattgtagaagggtctctaggtttatacctccaa tgtcctgtactttgaaaactggaaaaactccgctagttgaaattaatatcaaatggaaaa gtcagtatcatcattcttttcttgacaagtcctaaaaagagcgaaaacacagggttgttt gattgtagaaaatcacagcg mek1 mek1 upstream sequenc 800 1 acagaaagaagaagagcgga ndj1 ndj1 upstream sequenc 800 1 gtacggcccattctgtggaggtggtactgaagcaggttgaggagaggcatgatgggggtt figur 4 begin le spor 2x string process portion compressor base crochemor algorithm crochemor 1981 fast subsequ process stage limit poor data structur sever techniqu oer hope improv run time crush rst replac pointer chain data structur store result crochemor algorithm later process altern structur recent smyth tang shown repeat substr inform requir crush store n space array smyth tang 2001 structur play role sux tree gener directli crochemor algorithm henc store repeat substr overhead construct minim increas run time rst stage crush use array signicantli reduc memori requir crush speed process repeat substr inform importantli allow frequenc phrase calcul e cientli major bottleneck shown tabl 2 typic 90 time spent calcul phrase frequenc current implement anoth avenu resourc save altern implement crochemor algorithm futur version softwar make use new arraybas implement crochemor algorithm baghdadi et al 2001 practic run much faster standard implement reduc space requir 44n 12n byte one nal avenu worth explor context recent algorithm due smyth tang 2001 calcul repeat substr nonex tendibl left right current crochemor algorithm suppli set substr nonextend right run crochemor algorithm revers string collat result run string set candid string phrase book reduc time util remain string enhanc anticip substanti improv compress result approach implement major point deviat approach apostolico lonardi phrase choic crush consid phrase start leftmost uncov posit input stringa local approach clearli major contribut factor poor compress level gener text examin phrase choic made crush offlin exampl progc calgari corpu show mani good phrase select offlin unavail crush partial cover earlier phrase choic inde crush choos four phrase singl charact henc poor compress result reason introduct 2f p l p term gain calcul formula bias gain toward singl charact limit earli select short phrase occur frequent phrase whose select prevent use longer match later process downsid cours extrem dicult infrequ long phrase chosen le purdu corpu h typic around 25 bit per charact phrase length 800 select must occur least 6 time wherea spor 2x offlin routin choos phrase length 800 frequenc less 6 interest note local approach howev still gave good compress major purdu corpu reason crush perform well purdu corpu rather text gener high gain phrase purdu corpu occur toward start data le allow earli select crush unlik gener text high gain substr never consid possibl phrase candid part phrase cover earlier local choic implement global approach use current pointer chain data structur crush would prohibit expens tree data structur smyth tang 2001 incor porat howev global approach may becom feasibl option compress result purdu corpu indic global approach would improv compress perform gener data anoth techniqu intend incorpor crush accur gain measur gener repeat substr inform fast appropri data structur store inform aord spend time estim gain phrase approxim base self entropi pointer phrase book represent lead improv compress level wide rang data also iter approach make multipl pass data improv gain estim worth investig avenu explor allow phrase overlap phrase allow overlap data section compress le longer simpl sequenti list pointer phrase phrase book pointer must also pair indic much phrase repres overlap previou text human code similar use store informa tion fast decod guarante least one bit per pointer must ad nal le therefor maintain compress level nonoverlap implement averag size pointer must reduc one bit reduct pointer size would occur suitabl chang frequenc distribut pointer occur overlap allow larg reduct number pointer preliminari experi allow phrase overlap purdu corpu seem indic allow overlap beneci acknowledg thank lu yang yang 2000 make avail code kcover algorithm f franek make avail code ecient implement crochemor algo rithm thank also anonym refere help comment r fast spaceeci approach substr nement data compress use long common string calgari corpu canterburi corpu optim algorithm comput repetit word crochemor algorithm revisit compress induct hierarch grammar purdu corpu experi text mathemat theori commun mathemat theori commun comput repeat use space log n time onlin construct sux tree comput kcover string univers algorithm sequenti data compr sion tr data compress via textual substitut experi text file compress generalpurpos compress effici retriev data compress use long common string ctr frantiek frank jan holub william f smyth xiangdong xiao comput quasi suffix array journal automata languag combinator v8 n4 p593606 april