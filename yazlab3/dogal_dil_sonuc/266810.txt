framework balanc control flow predic predic execut promis architectur featur exploit instructionlevel parallel presenc control flow compil predic execut involv convert program control flow condit predic instruct process known ifconvers order effect appli ifconvers one must address two major issu ifconvert ifconvers appli compil use predic represent effect larg amount code ifconvert ifconvers perform earli compil procedur hand final code gener processor predic execut requir delic balanc control flow predic achiev effici execut appropri balanc tightli coupl schedul decis detail processor characterist paper present effect compil framework allow compil maxim benefit predic compil represent delay final balanc control flow predic schedul time b introduct perform modern processor becom highli depend abil execut multipl instruct per cy cle order realiz perform potenti processor demand increas level instructionlevel parallel ilp expos program one major challeng increas avail ilp overcom limit impos branch instruct ilp limit branch sever reason first branch impos control depend often sequenti execut surround instruct second uncertainti branch outcom forc compil hardwar schedul make conserv decis branch predict along specul execut gener employ overcom limit 12 howev branch mispredict take away signific portion potenti perform gain third tradit techniqu facilit exploit ilp along singl trajectori control abil concurr execut instruct multipl trajectori offer potenti increas ilp larg amount final branch often interfer complic aggress compil transform optim schedul predic model instruct execut condit sole determin branch characterist allow predic form basi mani techniqu deal branch effect compil execut code provid benefit compil represent ilp processor architectur featur predic represent compil naddress program represent instruct guard boolean sourc operand whose valu determin whether instruct execut nullifi guard boolean sourc operand refer predic valu predic regist manipul predefin set predic defin instruct use predic guard instruct execut reduc even complet elimin need branch control depend instruct control depend branch predic use condit branch branch legal remov process replac branch appropri predic comput guard known ifconvers 34 predic represent provid effici use model compil optim schedul remov branch code transform contain control depend complex control flow transform instead perform predic domain tradit straightlin code optim way predic represent allow schedul among branch perform domain without control depend remov control depend increas schedul scope afford new freedom schedul 5 predic execut architectur model support direct execut predic represent 678 respect convent instruct set architectur new featur addit boolean sourc operand guard instruct set compar instruct use comput predic predic execut benefit directli advantag compil use predic representa tion addit remov branch yield perform benefit execut code notabl remov branch mispredict penalti particular remov frequent mispredict branch yield larg perform gain 91011 predic execut also provid effici mechan compil overlap execut multipl control path hardwar manner processor perform may increas exploit ilp across multipl program path anoth subtl benefit predic execut allow height reduct along singl program path 12 support predic execut introduc two compil issu ifconvert compil procedur ifconvers appli first question address ifconvert specif branch remov via ifconvers tradit full ifconvers led posit result compil numer applic 13 howev nonnumer applic select ifconvers essenti achiev perform gain 14 ifconvers work remov branch combin multipl path control singl path condit instruct howev two path overlap result path exhibit increas constraint origin path one import constraint resourc path combin togeth must share processor resourc compil respons manag avail resourc make ifconvers decis appropri stop point may identifi ifconvers result increas execut time path involv discuss next section problem decid ifconvert complic mani factor one resourc consumpt second question must address appli ifconvers compil procedur broadest level ifconvers may appli earli backend compil procedur delay occur conjunct schedul appli ifconvers earli enabl full use predic represent compil facilit ilp optim schedul addit complex control flow transform may recast data depend domain make practic profit exampl transform includ branch reorder control height reduct 12 branch combin 15 hand delay ifconvers late possibl make answer first question much practi cal sinc mani ifconvers decis tightli coupl schedul knowledg processor characteri tic appli ifconvers schedul time natur choic also appli ifconvers schedul allevi need make entir compil backend cogniz predic represent effect compil strategi predic execut must address question ifconvers purpos paper present flexibl framework ifconvers ilp compil framework enabl compil extract full benefit predic represent appli aggress ifconvers earli compil pro cedur novel mechan call partial revers ifconvers oper schedul time facilit balanc amount control flow predic present gener code base characterist target processor remaind paper organ follow section 2 detail compil issu challeng associ compil predic execut section 3 introduc propos compil framework facilit take full advantag predic represent well achiev effici balanc branch predic final code essenti compon framework partial revers ifconvers describ detail section 4 effect framework context prototyp compil ilp processor present section 5 final paper conclud section 6 compil challeng effect use predic execut provid difficult challeng ilp compil predic offer potenti larg perform gain effici util howev imbal predic control flow gener code lead dramat perform loss baselin compil support predic execut assum paper hyperblock framework hyperblock issu associ form qualiti hyperblock first summar section remaind section focus approach form hyperblock earli compil procedur use heurist techniqu use expos predic represent throughout backend optim schedul pro cess howev approach sever inher weak solv weak motiv framework present paper 21 background hyperblock structur creat facilit optim schedul predic architectur 14 hyperblock set predic basic block control may enter top may exit one locat hyperblock form appli tail duplic ifconvers set care select path inclus path hyperblock done consid profit profit determin four piec inform resourc util depend height hazard presenc execut frequenc one gain insight effect hyperblock format heurist understand characterist lead perform loss common caus poor hyperblock format excess resourc consumpt resourc requir overlap execut multipl path union resourc requir individu path consid ifconvert simpl ifthenels statement result resourc consumpt hyperblock combin resourc requir separ execut els path path alon consum almost processor resourc result hyperblock would requir substanti resourc processor avail result hyperblock format result signific slowdown path cours calcul account benefit gain ifconvers import point resourc oversubscript potenti negat benefit hyperblock format even degrad perform poor hyperblock may also form care consid depend height ifconvers hyperblock contain multipl path complet constitu path complet therefor overal height hyperblock maximum origin path depend height consid ifconvers simpl ifthen els statement path height two els path height four height result hyperblock maximum path four result path potenti slow two time compil must weigh neg potenti posit effect ifconvers determin whether hyperblock profit form anoth way poor hyperblock may form inclus path hazard hazard instruct set instruct hinder effici optim schedul control path two common hazard subroutin call unknown side effect store instruct littl alia inform hazard degrad perform forc compil make conserv decis order ensur correct reason inclus control path hazard hyperblock gener reduc compil effect entir hyperblock path contain hazard execut frequenc use measur path import also provid insight branch behavior inform use weigh tradeoff made combin execut path exampl may wise penal infrequ execut path combin longer frequent execut path remov branch join two 22 pitfal hyperblock select origin approach use impact compil support predic execut form hyperblock use heurist base four metric describ previou section hyperblock form earli backend compil procedur expos predic represent throughout backend compil phase heurist hyperblock format shown perform well rel regular machin model machin balanc resourc consumpt balanc depend height elimin hazard done effect care craft heurist howev experi show sever seriou problem exist difficult solv approach three problem present optim chang code characterist unpredict resourc interf enc partial path inclus optim first problem occur code may transform hyperblock format gener form hyperblock earli facilit optim techniqu take advantag predic represent howev hyperblock format decis chang dramat compil tran format convert seemingli bad format decis good one likewis convert seemingli good format decis bad one figur 1a show simpl hammock consid convers 1 taken path depend height three cycl consum three instruct slot ifconvers remov instruct 5 fallthrough path consist depen 1 code exampl present section simpl machin model use schedul three issu processor unit latenc resourc limit processor assum specifi exampl assumpt reflect machin model latenc use experiment evalu section 528 1 b 1 branch cond 2 jump figur 1 hyperblock format seemingli incompat path posit result due code transform f annot indic taken fallthrough path condit branch r2 referenc outsid block denc height six cycl resourc consumpt six instruct slot simpl estim indic combin path would result penalti taken path three cycl due fallthrough path larg depend height figur 1b show code segment hyperblock format optim first optim perform renam elimin fals depend 7 8 8 10 reduc depend height hyperblock three cycl heurist could forese depend height would longer issu may still choos form hyperblock due resourc consider estim ten instruct ifconvers could made inspect figur 1a un fortun ten instruct need least four cycl complet three issu machin would still penal taken path one cycl indic combin path may benefici instruct merg optim instruct 2 6 combin 4 11 combin instruct count becom eight final schedul consist three cycl figur 1 show even simpl case heurist form hyperblock optim must anticip effect optim order form profit hyperblock exampl optim could potenti done hyperblock format renam howev other like instruct merg could addit optim may appli differ perform ifconvers differ code characterist result differ tradeoff resourc interfer second problem heurist hyperblock format fals conclus regard resourc compat candid path may often reach result path seem compat ifconvers turn incompat problem aris resourc usag estim techniqu simpl one use section even complex techniqu gener assum 1 branch cond 2 jump a2 b figur 2 hyperblock format seemingli compat path result perform loss due resourc incompat resourc usag evenli distribut across block prac tice howev path exhibit uniform resourc util interact depend height resourc consumpt caus violat uniform util assumpt gen eral path subdivid section either rel parallel rel sequenti parallel section demand larg number resourc sequenti section requir resourc two path combin resourc interfer may occur parallel section path overlap section demand resourc like larger avail resourc result perform loss illustr problem consid exampl figur 2 processor assum exampl three issu one memori instruct may issu cycl origin code segment figur 2a consist two path depend height three cycl resourc consumpt path also ident four instruct path conclud good candid ifconvers figur 2b show hyperblock result schedul sinc obviou resourc shortag one would expect result schedul hyperblock ident length schedul individu path four cycl howev hyperblock schedul length turn six cycl increas due resourc interfer path path parallel start sequenti end addit parallel section path high demand memori resourc one memori resourc avail path sequenti parallel section note requir memori resourc uniformli distribut across path problem would exist individu schedul length four cycl total four memori instruct howev due characterist path resourc interfer result perform loss path select hyperblock 1 2 f branch r1 r10 jump c a2 1 jump b figur 3 effici hyperblock form inclus partial path partial path final problem current heurist hyperblock format path may subdivid consid inclus hyperblock mani case includ part path may benefici includ exclud entir path ifconvers refer partial ifconvers partial ifconvers gener effect resourc consumpt depend height entir candid path larg permit profit ifconvers perform gain overlap part candid path path select inclus hyperblock illustr effect partial ifconvers consid exampl figur 3 three issu processor assum exampl resourc limit issu width figur 3a show two path compat due mismatch depend height howev includ taken path four instruct fallthrough path effici hyperblock creat hyperblock shown figur 3b notic branch instruct 2 split two instruct condit comput label 2 0 branch base comput label 2 00 schedul benefit complet remov branch instruct 2 branch instruct 2 00 characterist orig inal howev schedul benefit partial overlap path destin branch instruct 2 00 contain code complet fallthrough path shown figur 3c theori hyperblock format heurist may extend support partial path sinc path could divid instruct path heurist would consid mani possibl select altern howev feasibl extend select heurist oper finer granular instruct rather whole path question due complex natur problem 3 propos compil framework compil predic execut challeng describ section 2 creat effici code delic balanc control flow predic must creat desir balanc highli depend final code characterist resourc characterist target processor effect compil framework predic execut must provid structur make intellig tradeoff control flow predic desir balanc achiev given difficulti present section 22 form hyperblock earli backend compil process seemingli natur strategi perform ifconvers conjunct instruct schedul achiev integr ifconvers within schedul process schedul accur model detail resourc constraint processor also understand perform characterist code therefor schedul ideal suit make intellig ifconvers decis addit compil optim usual complet schedul reach thu problem code chang ifconvers exist howev seriou problem associ perform ifconvers schedul time restrict com piler use predic represent perform control flow transform predic specif optim scheduletim framework introduct predic represent delay schedul time result transform target predic represent must either foregon delay transform delay much complex ad schedul must alreadi consid mani issu includ control specul data specul regist pressur achiev desir code perform ad dition delay optim schedul time creat phase order caus sever difficulti compil gener transform profound effect one anoth must repeatedli appli turn achiev desir result exampl transform control height reduct 12 may subsequ expos critic data depend edg broken express reformu lation howev control depend height reduc profit break data depend edg compil appli transform especi true sinc express reformul cost term ad struction net result scheduletim framework restrict use predic represent limit effect backend optim given ifconvers schedul time limit use predic represent optim given ifconvers earli stage limit abil estim final code characterist logic look altern compil framework paper propos frame work framework overcom limit scheme util two phase predic code manipul support predic execut aggress ifconvers appli earli compil phase creat predic represent allow flexibl applic predic optim throughout backend compil procedur sched classic optim classic optim optim ilp optim regist allocataion postpass schedul partial revers ifconvers integr prepass schedul aggress hyperblock format figur 4 phase order diagram compil framework ule time compil adjust final amount predic effici match target architectur compil frame work shown figur 4 consist two phase predic manipul surround classic predic specif ilp op timiz first predic manipul phase hyperblock format address thoroughli 14 second predic manipul phase adjust hyperblock schedul propos work term partial revers ifconvers first phase compil framework aggress perform hyperblock format hyperblock former need exactli comput path part path fit avail resourc complet compat instead form hyperblock larger target architectur handl larg hyperblock increas scope optim schedul enhanc benefit mani case hyperblock former includ almost path gener aggress decis resourc height depend height result hyperblock like much greater correspond height compon path howev ifconvert reli later compil phase ensur hyperblock effici one criteria still enforc first phase hyperblock format avoid path haz ard discuss section 2 hazard reduc com piler effect entir hyperblock thu avoid facilit aggress optim second phase compil framework adjust amount predic code hyperblock code schedul via partial revers ifconvers partial revers ifconvers conceptu applic revers ifconvers particular predic hyperblock chosen set instruct 16 revers ifconvers origin propos invers process ifconvers branch code contain predic gener block predic code allow code compil use predic represent execut processor without support predic execut schedul partial revers ifconvers oper identifi path compos hyperblock path profit overlap remain unchang convers path interact poorli path remov hyper block particular partial revers ifconvert decid eject certain path part path enhanc schedul revers ifconvert insert branch taken whenev remov path would execut effect divid lower portion hyperblock two part correspond taken fallthrough path insert branch decis revers ifconvert particular path consist three step first partial revers ifconvert determin save execut time insert control flow appli full resourc machin two hyperblock instead one second comput loss creat penalti associ insert branch final gain revers ifconvers exce cost ap pli partial revers ifconvers may repeatedli appli hyperblock result code desir strategi use compil framework view analog use virtual regist mani compil er virtual regist program variabl promot memori resid infinit space virtual regist earli compil procedur virtual regist domain provid effect intern represent memori oper compil transform result compil abl perform effect optim schedul virtual regist code schedul time virtual regist assign limit set physic regist memori oper reintroduc spill code number physic regist oversubscrib framework present paper branch virtual regist program variabl branch remov provid effect intern represent compil transform schedul time branch insert accord capabl target processor branch reinsert differ condit target predict branch origin remov result branch code benefit perform particular processor rather consequ code structur decis made programm key make predic control flow balanc framework effect partial revers ifconvert mechan perform partial revers ifconvers well propos polici use guid partial revers ifconvers present next section 4 partial revers ifconvers partial revers ifconvers process consist three compon analysi transform decis step discuss turn 41 analysi manipul analysi execut path perform path must identifi predic code execut path predic code refer predic path immedi hyperblock format structur predic path ident control flow graph 2 1000000111111111111 000000000000111111000000000000111111000000000000000000000011111111111000000000000000000000011111111111 2 b figur 5 predic flow graph partial dead code elimin given r3 r4 live region code hyperblock format structur predic path repres form call predic flow graph pfg predic flow graph simpli control flow graph cfg predic execut path also repr sent optim structur pfg chang dramat reason effici complex compil use work maintain pfg across opti mizat instead gener result predic naddress code synthesi pfg predic naddress code analog creat cfg naddress code simpl exampl present provid insight done figur 5 show predic code segment predic flow graph predic flow graph shown figur 5b creat follow manner first instruct figur 5a predic definit definit p1 assum true falsea path creat possibl complement p1 p2 share path independ creat new condit outcom predic defin instruct 2 also creat anoth path case predic p3 p4 true p1 true defin instruct predic p1 one path cre ate creation path determin interrel predic provid mechan address work 1718 rest instruct path contain instruct determin predic guard execut exampl instruct 3 base predic p1 therefor place path p1 true instruct 4 predic therefor exist path type predic defin use figur paper un condit mean alway write valu 8 sinc valu regardless predic predic ignor instruct destin must place path path pfg merg predic longer use affect predic later code howev merg path may suffici solv 1 jump b 2 figur flow graph partial revers ifconvers predic p1 locat instruct 1 2 b potenti path explos problem pfg number path pfg exponenti proport number independ predic whose live rang overlap fortun happen practic code schedul ing code schedul complet pfg larg number path may costli descript partial revers ifconvert overcom problem locat section 42 gener solut path explos problem aspect predic code analysi current construct author pfg compil inform necessari know instruct exist path figur 5 path p1 p3 true extract instruct would place path would 3 4 7 instruct remain two path seem 3 4 5 6 howev inspect dataflow characterist remain path reveal result instruct 3 4 use given r3 r4 live region fact make instruct dead code context path perform tradit dead code remov pfg instead cfg determin part oper dead sinc applic dead code remov indic instruct dead certain predic condit process term predic partial dead code remov relat type partial dead code remov 19 result partial dead code remov indic instruct 3 4 would gener correct code would execut unnecessarili predic p3 point path identifi unnecessari code remov partial dead code remov analysi possibl eject path becom possibl 42 transform predic analysi partial dead code elimin complet perform revers ifconvers point predic requir small amount addit process process determin whether instruct belong origin hyperblock new block form figur 7 simpl code size reduct multipl partial revers ifconvers appli unrol loop squar repres unrol origin loop vers ifconvers figur 6 use aid discuss partial revers ifconvert code subdivid three code segment code revers convert branch code eject hyperblock revers ifconvers code remain hyperblock revers ifconvert branch instruct locat partial revers ifconvert branch left untouch hyperblock figur 6b show partial revers ifconvers creat p1 instruct 1 2 mean instruct 1 2 left origin schedul locat revers ifconvert branch predic p1 schedul immedi follow locat instruct branch determin pfg use pfg without experienc path explos problem pfg gener schedul done respect predic revers ifconvert keep number path control sinc singl predic pfg contain two path figur 6a show pfg creat predic revers ifconvert p1 note partial dead code alreadi remov describ previou section instruct exist sole p1 fals path 5 6 remain origin block instruct exist sole p1 true path 3 4 7 move origin block newli form region instruct exist path must place region notic hyperblock condit jump code remov hyperblock branch code back origin hyperblock possibl implement work branch back hyperblock would violat hyperblock semant sinc would longer singl entri region violat hyperblock semant may problemat sinc benefit hyperblock alreadi realiz optim prepass schedul howev postpass hyperblock schedul may experi reduc schedul freedom sinc reentri hyperblock effect divid origin hyperblock two smaller hyperblock advantag branch back origin hyperblock larg reduct code size elimin unnecessarili duplic instruct howev shown experiment section code size gener problem one code size optim perform merg target partial revers ifconvers branch target block ident result larg code size reduct code loop unrol perform loop unrol hyperblock need revers ifconvert like iter need revers ifconvert creat mani ident copi loop bodi subsequ loop revers ifconvert figur 7a show origin result repeat revers ifconvers unrol loop figur 7b show result obtain combin ident target simpl method work well reduc code growth elimin unnecessari code growth remov unnecessari code growth method jump back hyperblock opportun locat need creat 43 polici creat predic flow graph remov partial dead code ident characterist path hyperblock known inform compil make decis transform perform decis process partial revers ifconvers consist two part decid predic revers ifconvert decid revers ifconvert select predic determin optim revers ifconvers given architectur compil could exhaust tri everi possibl revers ifconvers comput optim cycl count possibl choos one best perform unfortun enorm number possibl revers ifconvers given hy perblock consid hyperblock p predic n instruc tion hyperblock 2 p combin predic chosen revers ifconvers revers ifconvers locat branch n locat worst case given possibl must schedul measur cycl count prohibit expens obvi ousli heurist need mani heurist may perform effect revers ifconvers one studi paper heurist may best solut applic machin model studi work achiev desir balanc final code perform implement complex compil time process choos heurist perform partial revers ifconvers affect greatli type schedul use sinc partial revers ifconvers integr prepass schedul type inform provid schedul structur code variou point schedul process must match decis ifconvert operationbas schedul may yield one type heurist list schedul may yield anoth polici determin revers ifconvert present design work within context exist list schedul algorithm polici integr list schedul shown figur 8 first decis address propos heurist place predic select revers ifconvers locat shown gener effect rest number locat consid revers ifconvers reduc n 1 obviou improv ment locat exist assumpt revers ifconvert branch consum resourc code schedul perfect schedul shown number oper trip loop new cycl 6 num unsch 0 handl revers ifconvert branch first 7 foreach ric op ric queue 8 schedul opric op cycl 9 comput locat unschedul op sched ric taken comput dynam cycl ric taken path sched ric cycl ric hyperblock mipr ric estim ric mispr miss penalti 13 ric cycl sched ric hb sched ric taken 14 ric cycl ric cycl mispr ric sched ric ric cycl sched ric hb 17 place op ric schedul locat 19 unschedul opric op remov ric op ric queue handl regular oper 22 schedul opregular op cycl remov regular op readi prioriti queue 26 add revers ifconvert branch ric queue figur 8 algorithm incorpor partial revers ifconvers list schedul better placement first cycl valu predic revers ifconvert avail predic defin instruct 2 sinc insert branch mispredict taken penalti regardless locat effect favor one locat anoth howev locat revers ifconvert branch determin earli path share resourc separ given full machin bandwidth perfect schedul alway well better full bandwidth machin divid among fewer instruct given earlier path separ fewer number instruct compet machin resourc therefor best schedul occur revers ifconvert branch place earli possibl despit fact place revers ifconvert branch earli possibl heurist two assumpt made perfect schedul cost revers ifconvert branch valid gener seem reason abl howev heurist would well despit imperfect anoth consider code size sinc instruct exist multipl path must duplic path seper code size reduc revers ifconvert branch delay depend characterist exist machin placement branch number cycl comput condit remov mispredict 20 machin two locat consid immedi predic defin instruct cycl branch mispredict elimin code delay may cost small cost may less gain obtain reduct code size despit consider placement partial revers ifconvert branch earli possibl reason choic second decis address heurist revers ifconvert without heurist number revers convers would need consid heurist describ 2 p way optim determin combin revers ifconvers yield best result tri revers ifconvers one predic affect effect revers ifconvers interact among predic caus chang code char acteristec revers ifconvers remov instruct hyperblock context list schedul logic heurist consid potenti revers ifconvers topdown fashion order predic defin schedul heurist use algorithm shown figur 8 desir effect make revers ifconvers process fit seemlessli list schedul also desir revers ifconvers consid context decis made earlier schedul process order make decis revers ifconvers method evalu must employ prospect revers ifconvers three schedul must consid code schedul without revers ifconvers code schedul hyperblock revers ifconvert branch insert path exclud code schedul path exclud revers ifconvers togeth yield total 3p schedul given hyperblock three schedul need compar determin revers ifconvers prof itabl comparison written sched cyclesno ric sched cycl ric hb sched cycl ric taken miss penalti sched cyclesno ric number dynam cycl schedul without revers ifconvers ap pli sched cycl ric hb number dynam cycl schedul transform hyperblock sched cycl ric taken number dynam cycl target revers ifconvers mispredr number mispredict introduc revers ifconvers branch mispredr obtain profil static estim miss penalti branch mispredict penalti comparis comput line 9 15 figur 8 cost save due heurist quit signific 3p schedul complic machin model still quit costli reduc cost possibl reus inform gather one schedul later schedul first sourc reus deriv topdown properti list schedul point revers ifconvers consid previou instruct schedul final locat line 8 22 figur 8 perform schedul revers ifconvers origin scenario need start point number schedul still 3p number instruct schedul greatli reduc remov instruct alreadi schedul second sourc reus take advantag fact case revers ifconvers done schedul alreadi comput time previou predic consid revers ifconvers schedul comput outcom sinc result code schedul cycl alreadi known comput necessari current predic sched cyclesno ric sourc reus take total schedul comput 2p schedul consid unschedul instruct point due list schedul effect reus implement figur 8 line 5 16 anoth way reduc total number instruct schedul take advantag fact code purg block differ els block control equival split join block schedul complet schedul els part schedul necessari sinc remain schedul like similar differ may dangl latenc small differ avail resourc boundari accur schedul continu becom ident like occur point though guarante occur case addit use detect point code size reduct point logic locat branch eject block back origin hyperblock schedul reus reduct techniqu shown number time instruct schedul usual 1 instruct depth hammock predic domain depth number predic defin chain use comput instruct guard predic cost schedul still high estim may use stead mani type schedul estim propos found literatur mani may well machin regular structur other possibl creat hybrid schedulerestim may balanc good estim compil time cost mention previous schedul height two path hammock must obtain instead pure schedul path may costli estim path may inac curat part schedul part estim may obtain accur result lower cost context list schedul one solut follow schedul could schedul initi set oper estim schedul remain ing accur result obtain schedul portion addit estim may abl benefit inform obtain schedul characterist schedul code may like match characterist code estim experi present next section actual schedul use decis revers ifconvert addit compil time accept 5 experiment result section present experiment evalu partial revers ifconvers framework 51 methodolog partial revers ifconvers techniqu describ paper implement second gener instruct schedul impact compil compil util machin descript file gener code parameter superscalar processor measur effect partial revers ifconvers techniqu machin model similar mani current processor chosen machin model 4issu superscalar processor inord execut contain two integ alu two memori port one float point alu one branch unit instruct latenc assum match hp pa7100 microprocessor instruct set contain set nontrap version potenti except instruc tion except branch store instruct support aggress specul execut instruct set also contain support predic similar provid playdoh architectur 8 execut time benchmark deriv static code schedul weight dynam execut frequenc obtain profil static branch predict base profil also util previou experi method run time estim demonstr accur estim simul equival machin perfect cach benchmark use experi consist 14 nonnumer program six spec cint92 benchmark 008espresso 022li 023eqntott 026compress 072sc 085cc1 two spec cint95 benchmark 132ijpeg 134perl six unix util cccp cmp eqn grep wc yacc 52 result figur compar perform tradit hyperblock compil framework new compil framework partial revers ifconvers hyperblock form graph repres current form impact compil hyperblock format heurist target machin hyperblock also use input partial revers ifconvert result obtain therefor conserv sinc aggress hyperblock would creat potenti better result bar repres speedup achiev method rel superblock compil comput follow superblock cyclestechniqu cycl superblock compil perform chosen base repres best possibl perform current obtain impact compil without predic 21 figur 9 show perform hyperblock partial revers ifconvers compil framework assum perfect branch predict sinc branch mispredict factor benchmark exhibit perform improv graph show predic perform well compil model particular compil success overlap execut multipl path control increas ilp hyperblock compil achiev speedup half benchmark notabl 023eqntott cmp 072sc grep wc program hyperblock techniqu success overcom problem superblock techniqu fulli util processor resourc hand hyperblock compil result perform loss half benchmark dichotomi common problem experienc hyperblock indic hyperblock well often perform victim poor hyperblock select case partial revers ifconvers improv upon 40 20 0 20 40 80 100 008espresso 022li 023eqntott 026compress 072sc 085cc1 132ijpeg 134perl cccp cmp eqn grep wc yacc benchmark hyperblock framework partial ric framework figur 9 perform increas superblock exhibit hyperblock partial revers ifconvers framework mispredict penalti 40 20 0 20 40 80 100 008espresso 022li 023eqntott 026compress 072sc 085cc1 132ijpeg 134perl cccp cmp eqn grep wc yacc benchmark hyperblock framework partial ric framework figur 10 perform increas superblock exhibit hyperblock partial revers ifconvers framework four cycl mispredict penalti match perform hyperblock code six benchmark partial revers ifconvers abl chang loss perform hyperblock compil gain evid 008espresso 28 loss convert 39 gain 072sc 134perl cccp partial revers ifconvers abl significantli magnifi rel small gain achiev hyperblock compil result indic partial revers ifconvert success undo mani poor hyperblock format decis capit effect one four benchmark hyperblock techniqu highli effect 023eqntott cmp grep wc partial revers ifconvers larg opportun increas perform sinc hyperblock format heurist work well decid ifconvert use examin perform two benchmark close worst perform benchmark 085cc1 framework result perform loss respect superblock compil partial revers ifconvers complet success undo bad hyperblock format decis failur due polici requir list schedul decid locat revers ifconvert branch placement predic defin instruct un fortun list schedul may delay instruct may critic path often deem low schedul prioriti delay revers ifconvers point neg effect code perform extent problem occur benchmark evid 085cc1 one best perform benchmark 072sc program hyperblock compil increas perform fair margin partial revers ifconvers increas gain substanti 072sc perform gain achiev transform singl function updat function superblock compil execut 256 million cycl ever schedul rather spars due larg number data control depend hyperblock compil increas avail ilp elimin larg fraction branch overlap execut multipl path control bring execut time 197 million cycl hyperblock code much better superblock code excess resourc consumpt path penal path partial revers ifconvert abl adjust amount ifconvers match avail resourc effici util processor result execut time updat function reduc 168 million cycl partial revers ifconvers 52 perform improv superblock code figur show perform benchmark manner figur 9 except branch mispredict penalti four cycl gener rel perform hyperblock code increas mispredict consid fewest mispredict rel perform partial revers ifconvers code also increas fewer mispredict superblock code partial revers ifconvers insert new branch accomplish transform code contain mispredict hyperblock code sever benchmark number mispredict actual larger hyperblock partial revers ifconvers superblock appli control flow transform predic repr sentat branch combin compil actual creat branch much higher mispredict rate move addit branch creat partial revers ifconvers may unbias combin branch origin superblock repres static code size exhibit use hyperblock partial revers ifconvers compil framework respect superblock techniqu present figur 11 fig ure use predic execut compil vari effect code size reason behavior tradeoff increas code size caus ifconvers decreas code size due less tail duplic superblock tail duplic perform extens custom individu execut path wherea predic multipl path overlap via ifconvers less tail duplic requir figur also show code produc partial revers ifconvers framework consist larger hyper block averag partial revers ifconvers code 14 larger hyperblock code largest growth occur yacc common benchmark exhibit 40 30 20 10 0 10 20 30 40 50 008espresso 022li 023eqntott 026compress 072sc 085cc1 132ijpeg 134perl cccp cmp eqn grep wc yacc benchmark code growth hyperblock framework partial ric framework figur 11 rel static code size exhibit hyperblock partial revers ifconvers framework compar superblock benchmark revers ifconvers opportun 43 443 026compress 11 56 132ijpeg 134 1021 134perl 42 401 cccp 77 1046 tabl 1 applic frequenc partial revers ifconvers larg code growth failur simpl code size reduct mechan present earlier inspect result code indic mani instruct share lower portion taildupl creat partial revers ifconvert reason one expect benchmark respond well sophist code size reduct scheme final frequenc partial revers ifconvers perform gener perform data present tabl 1 revers ifconvers column specifi actual number revers ifconvers occur across entir benchmark opportun column specifi number revers ifconvers could potenti oc cur number opportun equival number uniqu predic definit applic sinc predic defin revers ifconvert exactli data tabl static count tabl show number revers ifconvers occur rel small fraction opportun behavior desir revers convert tri minim number branch insert achiev desir remov instruct hy perblock addit revers ifconvert invok perform problem exist case perform origin hyperblock improv revers ifconvers need perform tabl also show expect correl larg number revers ifconvers larger code size increas partial revers ifconvers hyperblock figur 11 6 conclus paper present effect framework compil applic architectur support predic execut framework consist two major part first aggress ifconvers appli earli compil process enabl compil take full advantag predic represent appli aggress ilp optim control flow transform second compon framework appli partial revers ifconvers schedul time delay final ifconvers decis point compil relev inform code content processor resourc util known first gener partial revers ifconvert implement effect framework measur paper framework abl capit benefit predic without subject sometim neg side effect overaggress hyperblock format furthermor addit opportun perform improv exploit framework partial path ifconvers point demonstr hyperblock perform loss convert perform gain moder gain magnifi expect continu develop partial revers ifconvert surround schedul infrastructur enhanc perform addit framework provid import mechan undo neg effect overli aggress transform schedul time backup mechan uniqu opportun introduc aggress use transform predic represent earli compil process acknowledg author would like thank john gyllenha teresa johnson brian deitrich daniel connor john sia kevin crozier member impact compil team support comment suggest research support nation scienc foundat nsf grant ccr9629948 intel corpor advanc micro de vice hewlettpackard sun microsystem ncr addit support provid intel foundat fellowship r studi branch predict strategi twolevel adapt train branch predic tion convers control depend data depend predic execut modulo schedul isomorph control tran format highli concurr scalar process cydra 5 department supercomput hpl playdoh architectur specif version 10 guard execut branch predict dynam ilp processor character impact predic execut branch predict effect predic execut branch pre diction height reduct control recurr ilp processor overlap loop support cydra 5 effect compil support predic execut use hyperblock comparison full partial predic execut support ilp processor revers convers analysi techniqu predic code global predic analysi applic regist alloc partial dead code elimina tion ar chitectur support compilersynthes dynam branch predict strategi rational initi result superblock effect techniqu vliw superscalar compil tr highli concurr scalar process cydra 5 department supercomput overlap loop support cydra 5 twolevel adapt train branch predict effect compil support predic execut use hyperblock revers ifconvers superblock partial dead code elimin guard execut branch predict dynam ilp processor height reduct control recurr ilp processor effect predic execut branch predict character impact predic execut branch predict modulo schedul isomorph control transform comparison full partial predic execut support ilp processor analysi techniqu predic code global predic analysi applic regist alloc convers control depend data depend studi branch predict strategi architectur support compilersynthes dynam branch predict strategi ctr hyesoon kim jo joao onur mutlu yale n patt profileassist compil support dynam predic divergemerg processor proceed intern symposium code gener optim p367378 march 1114 2007 walter lee rajeev barua matthew frank devabhaktuni srikrishna jonathan babb vivek sarkar saman amarasingh spacetim schedul instructionlevel parallel raw machin acm sigplan notic v33 n11 p4657 nov 1998 eduardo quion joanmanuel parcerisa antonio gonzalez select predic predict outoford processor proceed 20th annual intern confer supercomput june 28juli 01 2006 cairn queensland australia patrick akl andrea moshovo branchtap improv perform checkpoint adapt specul control proceed 20th annual intern confer supercomput june 28juli 01 2006 cairn queensland australia hyesoon kim jose joao onur mutlu yale n patt divergemerg processor dmp dynam predic execut complex controlflow graph base frequent execut path proceed 39th annual ieeeacm intern symposium microarchitectur p5364 decemb 0913 2006 david august john w sia jeanmichel puiatti scott mahlk daniel connor kevin crozier wenmei w hwu program decis logic approach predic execut acm sigarch comput architectur news v27 n2 p208219 may 1999 aaron smith ramadass nagarajan karthikeyan sankaralingam robert mcdonald doug burger stephen w keckler kathryn mckinley dataflow predic proceed 39th annual ieeeacm intern symposium microarchitectur p89102 decemb 0913 2006 john w sia wenmei w hwu david august accur effici predic analysi binari decis diagram proceed 33rd annual acmiee intern symposium microarchitectur p112123 decemb 2000 monterey california unit state mihai budiu girish venkataramani tiberiu chelcea seth copen goldstein spatial comput acm sigarch comput architectur news v32 n5 decemb 2004 yuan chou jason fung john paul shen reduc branch mispredict penalti via dynam control independ detect proceed 13th intern confer supercomput p109118 june 2025 1999 rhode greec spyridon triantafylli manish vachharajani neil vachharajani david august compil optimizationspac explor proceed intern symposium code gener optim feedbackdirect runtim optim march 2326 2003 san francisco california david august wenmei w hwu scott mahlk partial revers ifconvers framework balanc control flow predic intern journal parallel program v27 n5 p381423 oct 1999 lori carter beth simon brad calder larri carter jeann ferrant path analysi renam predic instruct schedul intern journal parallel program v28 n6 p563588 decemb 2000