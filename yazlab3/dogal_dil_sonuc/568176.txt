searchbas bind time analysi use typedirect prune introduc new way perform bind time analysi rather analyz program use constraint solv abstract interpret use method base search search guid type inform significantli prune size search space make algorithm practic claim comput new better inform comput new novel way clarifi process involvedth method base upon novel use higherord multistag type rich express medium express bindingtim specif type could use start point bta goal work demonstr singl unifi system seamlessli integr manual stage automat btabas stage possibl b introduct bind time analysi bta thought automat addit stage annot welltyp semant meaning term base languag permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee asiapepm02 septemb 1214 2002 aizu japan programm suppli two thing 1 welltyp base languag program 2 bind time specif set instruct part program static part dynam analysi produc new program old program plu stage annot success new program call well annot erasur stage annot new program produc origin base languag program introduc new kind bta work search space annot term produc ad one stage annot welltyp base term ad stage annot must consist origin type program user suppli bindingtim specif search space explor lazili ad stage annot maintain consist path discov could longer produc wellannot term path immedi prune search produc one wellannot term direct search algorithm adjust produc better wellannot term first 2 motiv work motiv work metaml metaprogram system meta program sy tem metaprogram manipul objectprogram metaprogram may construct objectprogram combin object program fragment larger objectprogram observ structur properti objectprogram design use medium express runtim code gener found mani use well metaml conserv extens core ml includ featur standard ml except modul system add four kind stage annot con struct manipul execut code first class object discuss three stage annot partit program stage bracket surround express lift surround express next stage escap appear within bracket drop surround express previou stage lift lift evalu argument ground valu first order valu like 5 construct program next stage constant valu two stage world bracket code dy namic unbracket code static apriori restrict two stage common use metaml stage program interpret overhead improv runtim per formanc reason partial evalu often employ use consid accomplish metaml earlier work22 identifi 7 step process greatli abbrevi exampl use tradit one stage power function use process mani program order magnitud larger first write unstag program n0 1 els x power n1 x second identifi sourc interpret overhead power exampl loop variabl repres expon n third consid type unstag function int int int consid extens type obtain ad code type constructor one place make sourc interpret overhead static paramet dynam may sever type exampl two dierent extens power type int int int int fourth choos one extens type place stage annot bracket escap lift origin program produc wellannot program exampl stage version power type int function pow1 n0 1 els x pow1 n1 x choic extend type use guid annot often depend context gener use sometim obviou time subtleti beyond scope short introduc tion relev sinc even automat base system user must suppli stage specif stage version use produc comput without interpret overhead exampl pow1 use sever context gener code fragment right evaluatesto arrow fn z pow1 4 fn z z z z z 1 3 unifi vision winter 2002 one author taught cours stage comput pattern emerg typic assign consist unstag function type target extend type instruct write stage version unstag function target type discuss aros class possibl automat produc stage version function could mix manual stage function singl system caus class instruc tor consid process follow stage function answer obviou use type inform contain type origin program target type guid placement stage annot argued20 21 23 manual annot give programm finer control automat process ever achiev must admit mani time automat annot would suce place less burden programm couldnt tightli integr system support manual annot practic metaml automat bta built view key obstacl system reconcil bind time specif given bta rich type structur possibl mix code type data structur higher order function mani bta driven bind time specif simpl direct indic certain global variabl andor paramet simpli static dynam newer one extend partial static first order data metaml code type complet first class metaml possibl data structur emb function manipul code kind partial static higher order function ie metafunct take metafunct argument miss bindingtim specif key insight use metaml rich type bind time specif key insight understood sever smaller hurdl easili resolv bta describ part partial evalu system system almost alway base upon sourc sourc transform work sourcefil level produc new sourcefil compil exist compil hard reconcil metaml view stage annot first class semant object part languag definit view metaml type stage specif easi next step view direct compil produc new program whose mean given term metaml semanticli meaning stage annot output bta opaqu user consist gener extens appli static argument produc residu program annot gener extens partial evalu paradigm encourag user look understand gener ex tension user idea look like use metaml user alreadi know stage program look like write manual annot program conceptu barrier lower idea use higherord partial static type func tion arrow code type direct guid automat bta otherwis manual stage system provid fine level control previous miss ing yet still enabl automat stage desir elabor vision integr system encompass manual automat bta simpl extens metaml produc annot term suggest stage type metaml add new declar form stage user wish indic desir annot version f function f annot extens type write stage f compil job produc function automat caus compiletim error cant declar follow stage power int caus compil gener compil new function pow1 n0 1 els x pow1 n1 x output produc hand similarli declar stage power int int int caus compil gener compil function pow2 n0 1 els x pow2 n1 x scheme quit flexibl use stage function partial static data partial static higher order type stage function two stage partial static data consid list list map f stage b list b list lead automat introduct map2 f higher order partial static type consid stage ba list b list lead automat introduct map3 f stage program two stage consid inner product function stage run three stages8 14 first stage know size two vector oer opportun special inner product function size remov loop overhead bodi function second stage know first vector oer opportun special base valu vector inner product vector taken mani time vector special remov overhead look element first vector time third stage know second vector comput brought complet nth v nnth w els 0 stage iprod int oper greaterthan oper metaml use oper normal greater oper conflict metaml use symbol stage annot stage declar would caus compil automat produc three stage annot version lift nth v n nth w n els 0 4 framework section describ minim languag use describ bta exampl previou section express metaml languag consider richer minim languag describ next properti show hold minim languag also hold metaml base term structur base term defin induct set product product defin set syntact correct term exampl variant lambda calculu integ constant could defin annot term stage annot ad set product defin set syntact correct annot term exampl add product bracket e lift erasur process remov annot annot term produc base term base type set base type base term also induct defin actual form type depend upon construct concept inher base languag lambda calculu variant type base term defin introduc type constant like constructor like list function type list annot type also extend set base type ad code type constructor produc set annot type note bracket overload work annot term annot type environ assum languag full complement primit function oper base type etc built data structur head tail n et br es figur 1 judgment welltyp base term extens wellannot term con nil null etc environ map global constant lambdabound variabl type welltyp term type judgment select subset syntact well form term semant meaning call term welltyp top half figur 1 give set judgment base term form judgment n read environ term e assign type stage n n natur number term level term without stage annot gener term level n surround n set match bracket base term stage inform safe ignor inde eras stage inform top half figur 1 reduc familiar type judgment lambda calculu wellannot term ad type judgment stage annot judgment base term defin new judgment select subset syntact correct annot term call wellannot term bottom half figur 1 extend top half judgment annot bracket escap lift stage inform n judgment count number bracket surround current term count ensur escap appear within bracket variabl use stage later bind stage annot extens two input process welltyp base term e base type t1 target annot type t2 type t2 annot extens type t1 type annot term wish bta find relat base type annot extens relat relat relat pbasetyp annotatedtyp intuit mean obtain remov stage annot made precis follow induct rule use notat b basetyp annotatedtyp remind reader two argument relat come dierent set b b list list relat simpli formal notion erasur type describ precis manner one type erasur anoth eras t2 t1 t2 note eras act homomorph type constructor except code bracket type constructor ad annot program e type t1 produc anoth program arbitrari type t2 type t1 t2 must relat fashion made precis given two partial function 1 2 repres envi ronment 1 map term variabl basetyp 2 map term variabl annotatedtyp domain lift relat pointwis environ ment 1 2 x dom1 21 x 2 x overload term overload relat pterm annotatedterm term well type two mean similar shouldnt problem conceptu b1 b2 b3 b b b use b baseterm annotatedterm lift relat simpli formal notion erasur term e1 erasur e2 e1 e2 5 stage check system given term e type target type extens wish find annot term e need adjust notat captur precis first extens term may seem syntact rigid exampl term equival relat bound variabl problem sinc intend gener annot term righthandsid relat alway use name bound variabl second order term quit satisfactori possibl relat annot term well annot welltyp base term sinc care relat welltyp term wellannot term well defin new relat captur distinct overload combin type judgment type term relat one 1 1 given e1 t1 e2 t2 infer e2 could well annot type t2 relat e1 term overload formal write new set judgment appear figur 2 lam app code escap figur 2 relat welltyp term well annot term judgment deriv straightforward manner figur 1 relat type term 6 check infer move type check system check two term relat stage annot algorithm comput stage program unstag program judgment figur 2 describ sever rule check relationship e1 e2 t1 t2 four known e2 unknown use rule guid search slight restructur rule help illustr let notat e2 denot search well annot term e2 whose erasur e1 let t1 type e1 t2 target type soughtaft term e2 current state well discuss state moment rule proceed search annot subterm e1 combin form e2 occasion search annot subterm fulli intend wrap new set bracket around result get call number pend bracket level search part state search let n level search check rule like lead natur search rule like e4 e5 e6 note environ check rule chang environ search rule check rule map term variabl type search algorithm map term variabl annot term infer algorithm comput annot term everi unannot counterpart term map unannot term variabl wellannot term check rule dont tell us order appli search rule rule fail point need make choic implement mechan use implement search prolog come immedi mind would probabl made good choic investig suggest sever annoy detail choos function languag haskel eas could modifi program even drastic chang consid search becom clear follow except rule code escap lift rule syntax direct structur e1 rule driven syntact structur t2 n use structur decid rule applic unfortun point one rule usual applic must also care rule code esc circular could lead deriv infinit height henc search infinit depth algorithm control paramet way key algorithm control two import aspect search partial may fail search nondeterminist may one annot term given type eectiv way control search attempt escap rule first follow syntax direct rule structur e1 next appli lift code rule rule fail eectiv strategi discuss section 13 control circular code escap emb algorithm small state machin three state clear ab app ab app ab app code escap escap code clear algorithm start state clear use rule code move state escap allow use escap move state code al low appli rule recurs sub term current term move machin back state clear exampl integ constant search term type state term suce term substructur need search notat particular type given term subterm exampl z z clear app code find annot version f f given type annot version x x find annot version applic f x search subterm fail search whole term fail search subterm produc one result search whole term may produc one result term two subterm b search produc n result search b produc result search whole term produc n result fortun wellstudi formal describ algorithm notion monad com putat sever paper give good overview monad comput 24 25 26 assum familiar monad program case monad nondetermin monad time call list monad data structur base monad multipleresult consid search rule specifi subsearch perform first specifi one fail succeed specifi combin two set result job monad express search implicit rule explicitli equat use monad notat z x return f x perform search annot subterm x first succe search annot f next succe combin result search wise build newli annot term f x use check rule figur 2 build search rule use notat control search ele ment rule lead small search compon complet search construct use notat con trol sequenc combin compon search complet algorithm found appendix written work haskel program program use follow definit type term data code list data el string e ev string x ei int 5 check rule figur 2 deriv one search compon written haskel function compon type type monad multipl result rule lead singl compon consid rule app goal search e1 e 1 t1 t2 known e2 e know e1 e 1 welltyp type t1 thu possibl comput type e1 s1 t1 possibl comput domain e2 label s2 rule know s1 s2 search rule base check rule choos s2 correctli relat s1 simpl choic lead two dierent search rule program addit rule possibl gener treatment discuss section 14 give tast compon construct discuss two rule two way stage express would stage whole term f type assum f type first way captur follow compon appcase1 compon trace app1 n e t2 let dom sig e0 comput domain type e0 return ea e2 e3 note state search subterm reset clear compon follow structur type judgment relat one direct rule appli nonappl default claus appcase1 compon fail second compon account code properti argument appcase2 n sig phi t1t2e ea e0 trace app2 n e t2 let dom sig e0 comput domain type e0 arr code s1 t2 e0 return ea e2 e3 appcase2 main algorithm compos search strategi appli individu search compon next section comment control mechan use direct strategi main algorithm 7 control search notat use control order search action failur propag failur aris mean singl failur anywher caus whole algorithm fail need mechan set sever search combin success result one larg set result monad multipl result support sever oper facilit leftchoic leftchoic leftchoic xs first first first donen first first first xs mani mani mani mani oper leftchoic take two comput produc multipl result first succe return result ignor second first fail run return result second comput oper first iter leftchoic list comput return result first success comput list oper mani run comput list return concaten result oper use specifi branch search 8 main algorithm main algorithm call regroup syntax direct argument tupl call a2 algorithm a2 defin larg search whose search strategi construct use first mani compon search strategi one possibl strategi strategi possibl discuss strategi section 13 function a1 take input level n environ map term variabl type sig term variabl annot term phi two type t1 t2 term e1 produc multipl result henc return type e meant correspond roughli notat a2 step n sig phi first esccas step n sig phi x note esc case first intcas step n sig phi x varcas step n sig phi x abscas step n sig phi x appcase1 step n sig phi x appcase2 step n sig phi x appcase3 step n sig phi x ifcas step n sig phi x liftcas step n sig phi x codecas step n sig phi x 9 exampl trace section show trace search stage term fxf x type ab 0 fn f fn x f x int int int ab 0 fn x fail app1 fail fail app2 fail fail app1 fail fail app2 fail fail succeed f esc succeed f esc fail var succeed x succeed lift x esc succeed lift x app1 succeed f lift x code succeed f lift x ab succeed fn x f lift x ab succeed fn f fn x f lift x 10 correct construct believ sound search algorithm respect check rule prove although yet done everi node search space consid search algorithm gener welltyp sourc express check rule search program never consid invalid term algorithm may return multipl result result may better other valid extens base term type given section 13 discuss use strategi order return solut best one first algorithm use strategi employ appendix easi argu algorithm alway termin measur function4 easili construct argument state decreas wellfound relat everi recurs call a1 n may increas code rule alway accompani decreas size t2 t2 bracket strip must decreas size e1 one syntax direct rule failur three state automata encod state enforc sinc measur function decreas everi recurs call fall zero algorithm must termin 11 polyvari polyvari allow singl function use multipl bind type algorithm need chang support polyvari recal one paramet search algorithm environ map term variabl type annot term allow environ map term variabl dierent type dierent annot term polyvari achiev exampl consid function f environ function h type int int int stage int produc bta environ sever stage h could better stage int stage int stage int stage h could work static use h1 h2 annot version f produc automat compil although definit f mention h automat make use declar stage h gener stage f polyvari use h tight integr automat manual stage use mutual advantag consid manual stage version op primit multipl oper metaml manual stage version exploit arithmet ident x beyond scope automat bta without use semant inform yet programm easili stage manual inject semant inform system times1 times1 times2 times2 inform automat bta time use variant stage declar stage stage without type sux stage declar check times1 times2 manual stage version stage type made precis relat add environ process thu manual stage version function use semant inform forc comput earlier stage use polyvariantli 12 polymorph techniqu easili extend languag hindleymiln polymorph hindleymiln polymorph univers quantifi type appear outer level allow simpl preprocess step extend bta languag hindleymiln polymor phism consid exampl programm want stage standard function type c c consid type univers quantifi outermost level free type variabl tick mark like stage type annot less gen eral type map order handl stage declar like stage int c int c first unifi erasur target type c c type map b b obtain substitut b appli sourc type uneras target type proceed algorithm must treat type variabl unknown type henc rule actual structur type immateri may appli right thing 13 strategi strategi use order individu compon matter two dierent properti output tri achiev simultan minim optim work precis definit properti complet work yet inform minim mean answer produc minimum number stage annot exampl f x f extens f x f type b x type first prefer fewer stage annot second wish arrang search strategi minim annot found larger one better yet search space contain nonminim one prune complet three state automata guid use code escap rule prevent infinit deriv also prune nonminim one annot prune sinc code rule appli immedi escap rule without first descend subterm inform optim mean comput perform earliest stage possibl static if x els prefer dynam one x els z first allow test perform earlier stage current search strategi use heurist push optim solut front result list tri esc rule first compon esccas alway fail level 0 level greater zero search solut lower level ie earlier stage place first first mani strategi order stage earliest possibl comput first explain compon escap first function a2 analysi proof alway lead optim result remain futur work 14 complex hard estim complex algorithm without know quit bit search strategi use strategi use appendix extrem simpl consist singl first control oper caus search whose maximum depth proport depth term e plu number bracket target type environ map term variabl singl annot term type algorithm alway find exactli 0 1 result breadth search easi estim depend upon term annot type annot sought sourc algorithm complex identifi two place clever implement techniqu overcom complex first naiv algorithm perform redund computa tion redund comput possibl search space annot program direct acycl graph often two path subproblem exampl algorithm trace show behavior stage largecalc e1 els e2 rule fire stage largecalc bool larg calcul rule fail rule fire stage largecalc e1 els e2 bool rule fire stage largecalc bool larg calcul fail fail solv standard techniqu dynam pro gram memoiz away result tabl comput tabl lookup attempt subsearch make sure recalcul anyth second problem caus multipl app rule men tion section 6 type check rule app figur lead mani possibl search rule app one search rule everi possibl solut side condit deepli applic nest deepli nest code type appear target type branch blow observ structur two search rule appcase1 appcase2 see much common clever program merg rule singl case thu drastic reduc branch henc size search space trick perform subsearch s2 instanti type variabl maintain list constraint type variabl thereaft whenev algorithm call equal check two type algorithm employ unif type failur unifi becom failur search constraint initi form type variabl base type inequ constraint either strengthen stronger inequ collaps equal upon unif follow singl app rule encompass previou two mani other unif new variabl gener constraint mainten handl underli monad machineri thu structur algorithm chang slightli appcas n sig phi t1 t2 eea e0 trace app n e t2 let arr s2 t2 e0 return ea e2 e3 appcas gener new type variabl s2 add constraint s1 s2 chang dynam program use unif implement rework underli monad upon search implement observ travers search space notabl smaller current work quantifi precis complex bound algorithm employ two techniqu believ import work lie describ new simpl framework describ bta advanc featur higherord function poli morphism polyvari partial static firstord data higherord partial static function unbound number stage believ potenti tune algorithm highli ecient one remain 15 relat work mogensen 16 bondorf 2 3 consel 5 present bta higher order languag base upon abstract interpret three paper bta type lambda calculi close relat work present express type infer problem nielson nielson 18 give bta base upon type infer twolevel simpli type lambdacalculu given simpl bind time compiletim runtim free variabl type express show algorithm comput uniqu express optim set annot minim runtim comput complex algorithm worst case exponenti size express gomard 11 present 3 algorithm annot untyp lambdacalculu term similar manner work interest use crude type system perform bta untyp languag type system treat second stage term singl type code term except function type valu use arrow simpl type specifi bindingtim function henglein 12 present ecient algorithm use similar trick express bindingtim similarli simpl type system algorithm complex n n invers ackerman function n n intent purpos small constant algorithm use constraint solv system determin annot place algorithm may look like type infer prob lem realli search base algorithm easi identifi search space search strategi employ possibl multipl solut also separ type infer use type bta specif found work le meur lawal consel15 describ modul base system write bind time specif program c system allow programm name multipl bind time specif function global variabl modul use name specif specif specif written stageannot type modul system propag inform multipl usesit annot function allow dierent special dierent occurr unlik use annot type bind time specif limit first order function mani bta base upon abstract analysi bta partial static data present launchbury13 mogensen17 polyvari bta present consel 6 1 dussart et al 7 rytz gengler 19 amongst other glueck joregensen 8 9 pioneer use multilevel languag work gener standard abstract interpret techniqu multipl level show search base techniqu also gener multipl level techniqu describ incorpor featur simpl framework base upon search 16 contribut paper describ radic new approach construct bind time analys approach base upon explor search space wellannot extens welltyp term type inform effect mean prune search space make algorithm practic algorithm surprisingli simpl yet support advanc featur higherord function polymorph polyvari partial static firstord data higherord partial static data unbound number stage complex algorithm fulli analyz remain futur work algorithm base upon use codeannot extens basetyp bind time specif type rich express mechan subsum mechan known author express bindingtim specif argu integr system combin manual stage function automat stage func tion eas burden programm yet allow fine control manual stage system support includ use semant inform stage version could never fulli autom propos system integr bta semant part languag depend upon intervent extern tool whose semant separ languag 17 acknowledg work describ support nsf grant ccr0098126 mj murdock charit trust depart defens author would also like thank student class cse583 fundament stage comput winter 2002 particip mani live discuss use stage 18 r fixpoint comput polyvari static analys higherord applic program automat autoproject higher order recurs equat comput logic bind time analysi higher order untyp function languag polyvari bindingtim analysi applic languag polyvari constructor specialis automat program gener multilevel special partial evalu untyp lambda calculu project factor partial evalu defer compil autom runtim code gener toward bridg gap program languag partial evalu bind time analysi polymorph type higher order languag partial static structur selfapplic partial evalu automat bind time analysi type lambdacalculu polyvari bind time analysi advanc function program accomplish research challeng metaprogram dsl implement use stage monad comprehend monad essenc function program monad function program tr automat bind time analysi type myampersandlgrcalculu comprehend monad bind time analysi high order untyp function languag automat autoproject higher order recurs equat effici type infer higherord bindingtim analysi essenc function program polyvari bindingtim analysi applic languag fixpoint comput polyvari static analys higherord applic program polyvari constructor specialis multistag program explicit annot automat program gener multilevel special dsl implement use stage monad toward bridg gap program languag partial evalu accomplish research challeng metaprogram effici multilevel gener extens program special bind time analysi polymorph type higher order languag monad function program defer compil autom runtim code gener