selfstabil clock synchron presenc byzantin fault initi studi bound clock synchron sever fault model propos lamport melliarsmith 1985 realist aspect problem synchron clock presenc fault consid one aspect clock synchron ongo task thu assumpt processor never fail optimist cope realiti suggest selfstabil protocol stabil long enough period less third processor faulti anoth aspect clock valu processor bound singl transient fault may caus clock reach upper bound therefor suggest bound clock wrap around appropriatew present two random selfstabil protocol synchron bound clock presenc byzantin processor failur first protocol assum processor common puls second protocol new type distribut counter base chines remaind theorem use part first protocol b introduct distribut system often necessari keep logic clock processor synchron system physic clock may drift messag could vari deliveri time moreov processor may faulti mani case type failur predict advanc handl situat worst type failur must consid name byzantin fault lsp82 presenc byzantin fault processor exhibit arbitrari malici two face behavior problem keep clock synchron presenc byzantin fault extens studi eg hs84 lm85 ms85 dhs86 st87 wl88 rsb90 lamport melliarsmith lm85 first present problem show 3f processor suffici toler f byzantin fault necess 3f processor toler f fault later prove dhs86 weaker fault model call authent byzantin allow protocol toler number faulti processor hs84 failur model reintegr repair processor possibl less half processor faulti mani protocol problem assum clock initi synchron thu focu keep synchron presenc clock drift problem ensur clock initi synchron address eg st87 wl88 protocol mechan assum allow nonfaulti processor begin protocol within bound time period mechan essenti process support part tamu engin excel fund nsf presidenti young investig award ccr9158478 depart mathemat comput scienc bengurion univers beersheva 84105 israel email shlomicsbguacil z depart comput scienc texa univers colleg station assum wake distinguish initi state uniqu perform initi action includ commun work weaken assumpt made design clock synchron protocol presenc byzantin fault goal protocol cope sever realist fault model tradit byzantin fault model lsp82 initi protocol toler byzantin fault design flight devic need extrem robust devic tradit assumpt could violat reason assum period execut less one third processor faulti happen short period third faulti perhap experi weaker fault byzantin fault happen messag sent nonfaulti processor lost one instant time paper present selfstabil protocol overcom problem temporari violat assumpt view leav system arbitrari initi state protocol resum selfstabil protocol work correctli start initi system state thu even system lose consist due unexpect temporari violat assumpt made eg onethird faulti unexpect messag loss system synchron clock subsequ assumpt hold eg less third experi byzantin fault origin dijkstra defin dij74 protocol selfstabil start arbitrari system state system converg consist global state realiz task selfstabil protocol resili transient fault fault caus state processor chang arbitrarili new state processor resum oper accord program perman fault fault caus processor perman misbehav protocol toler hybrid fault resili transient perman fault eg dw93 gp93 consid nap omiss fault respect interest clock synchron protocol toler hybrid fault work arbitrari initi configur toler less third processor exhibit perman byzantin fault realist assumpt clock synchron protocol 64bit clock unbound possibl applic howev context selfstabil protocol transient fault could caus system reach upper bound clock thu anoth aspect problem consid fact clock bound paper present two random selfstabil clock synchron protocol work presenc byzantin fault protocol work bound clock first assum exist common puls second make assumpt expect stabil time protocol exponenti n drawback number processor larg howev addit theoret interest believ protocol could practic interest least number backup processor small one contribut paper interest usag chines remaind theorem implement distribut counter counter use acceler first protocol remaind paper organ follow next section formal assumpt requir protocol section 3 present clock synchron protocol assumpt common puls section 4 present protocol assum exist common puls conclus section 5 distribut system consist set processor commun send messag messag bound delay processor bound physic clock constantli incr ment wrap around appropri physic clock differ processor run approxim rate processor also bound logic clock comput function current state physic clock valu goal logic clock nonfaulti processor becom subsequ remain close continu progress reason rate wrap around appropri consid two type time behavior system synchron semisynchron model processor take step either receiv messag physic clock reach predetermin valu addit synchron model common puls period occur simultan processor caus take step proceed formal processor p model state machin associ processor physic clock take integr valu 0 pc gamma 1 pc state contain distinguish timer variabl take valu 0 pc gamma 1 nil indic processor want take step next time physic clock given valu transit take current state processor current valu physic clock messag receiv produc new state processor set messag sent messag system hold messag sent yet receiv configur system set processor state one per processor set physic clock valu one per processor state messag system execut altern sequenc configur event c 0 delta semisynchron execut event happen real time take one configur next two type event one type tick processor physic clock caus increas 1 mod noth els chang requir real time elaps two success tick processor fix ae type event step processor processor take one step real time step processor may may receiv messag real time elaps send receiv messag must rang gamma ffl ffl fix ffl fix set faulti processor size f n 3f processor take step nonfaulti succeed configur must correctli reflect processor transit function act messag receiv state physic clock preced configur thu chang processor state messag system remov messag receiv ad messag sent processor take step faulti chang state arbitrarili add arbitrari messag messag system synchron execut addit constraint exist valu 0 everi processor p receiv special puls messag dummi processor time delta ie processor take step puls puls occur regularli period requir everi processor p exist function clock given state p valu p physic clock return valu rang 0 lc gamma 1 fix lc logic clock p given particular execut c 0 denot clock valu function clock appli p state physic clock valu c j j configur execut whose real time occurr largest exceed requir exist finit time follow two condit hold clock agreement exist 4 nonfaulti processor p clock valid exist delta 4 exist 0 real time clock 1 constant 4 chosen conveni constant larger 2 suffici note constant 2 condit hold arbitrari configur sinc everi two clock valu lc 2 apart clock agreement state differ two nonfaulti processor clock fl clock valid state amount logic clock time elaps delta real time linear function delta 3 synchron protocol first describ protocol synchron system nonfaulti processor access period common puls puls trigger processor synchron clock time two success puls appear import paramet problem case two success puls farther apart time requir run byzantin agreement protocol follow scheme solv problem everi puls start new version byzantin agreement agre common clock valu howev puls order round trip messag delay apart scheme work assum puls order round trip delay apart recal time two success puls nonfaulti processor send messag updat logic clock puls occur assum long enough puls take place messag sent nonfaulti processor previou puls present system whenev nonfaulti processor p trigger puls p send messag clock valu neighbor p wait receiv clock valu processor p wait period 1 ffl longer bound messag delay account clock drift period p receiv one messag neighbor say q p use latest valu arriv q thu end period p set least n gamma f logic clock valu one valu nonfaulti processor includ p p use set logic clock receiv order choos clock valu formal descript protocol appear figur 1 describ protocol inform protocol processor p work follow 1 valu p clock appear less set receiv logic clock p assign 0 clock otherwis 2 case valu p clock appear least n gamma f time distinguish case 21 p clock valu equal 0 case 22 equal 0 case 21 p increment clock 1 modulo number clock valu lc case 22 subdivid two case 221 accord state p previou puls p increment clock 1 result case 222 otherwis case 221 p increment clock 1 1 case 222 p toss coin assign result 0 1 clock protocol guarante probabl 1 system eventu reach global state nonfaulti processor clock valu 1 global state reach clock synchron everi puls everi nonfaulti processor p receiv messag least processor contain clock valu ident clock valu moreov puls nonfaulti processor set clock 0 alway follow puls everi nonfaulti processor increment clock valu 1 set 0 thu case 222 appli main idea protocol ensur enough nonfaulti processor clock valu valu increment prove sequel puls one clock valu nonfaulti processor increment 1 rest valu chang zero ensur first puls set clock valu nonfaulti processor contain two element moreov two element inde exist one 0 first glanc seem suffici coin toss need valu increment eventu wrap around 0 time clock nonfaulti processor 0 howev describ infinit execut e use coin toss clock never becom synchron consid system four processor p 4 p 4 exhibit byzantin behavior let 0 0 1 clock valu p 1 respect first configur e first puls p 4 send clock valu 1 p 1 p 3 clock valu 0 p 2 thu p 1 receiv clock valu vector 0 0 receiv 0 0 processor find processor clock valu name clock valu 0 increment clock valu one 1 time p 1 p 3 find two clock valu valu 1 two valu 0 assign 0 clock henc configur clock valu 0 respect obtain p 4 continu send clock valu receiv clock valu vector 0 receiv 0 receiv 0 1 0 0 similarli p 3 processor find processor clock valu assign 1 clock p 1 assign 0 reach configur clock valu 0 0 1 ident clock valu first configur therefor infinit execut nonfaulti processor never agre clock valu possibl overcom problem use coin toss puls nonfaulti processor clock valu clock valu valu 0 processor toss coin decid whether assign 1 clock lead possibl scenario probabl occur coin toss result caus nonfaulti processor simultan assign 1 clock puls occur broadcast clock collect clock valu 1 elaps physic clock case 1 last increment 06 els case 2 07 clock 6 0 case 21 last increment trueg els case 22 last increment els case 222 clock toss0 1 last increment true els last increment fals figur 1 synchron protocol p 31 correct proof synchron protocol throughout proof say processor p increment clock 1 certain puls p assign last increment true puls otherwis say assign 0 clock lemma 31 nonfaulti processor p p j increment clock 1 puls p immedi p clock proof assum toward contradict clock p henc p p find least n gamma f clock valu equal x least n gamma 2f belong nonfaulti processor thu p j also receiv n gamma 2f clock valu equal x henc p j receiv clock valu equal sinc n 3f hold contradict possibl p j receiv least n gamma f clock valu equal lemma 31 impli straightforward manner correct next two corollari corollari 32 everi puls set clock valu nonfaulti processor contain two element case two valu one 0 corollari 33 puls p nonfaulti processor p increment clock valu 1 result 0 immedi follow p clock valu nonfaulti processor 0 34 puls p follow first puls nonfaulti processor p increment clock 1 without toss coin p nonfaulti processor clock valu 0 proof variabl last increment assign everi puls thu sinc p follow first puls inde increment q puls p thu lemma 31 nonfaulti processor clock valu 0 q p next theorem use schedulerluck game dim91 dim95 analyz random pro tocol schedulerluck game two competitor schedul adversari luck goal schedul prevent protocol reach safe configur goal luck help protocol reach safe configur synchron protocol configur safe nonfaulti processor logic clock equal last increment true system schedul choos messag delay clock drift execut within predefin limit time processor activ schedul toss coin luck may interven determin result coin toss prove dim91 dim95 start possibl configur c luck strategi win schedulerluck game within intervent expect time system reach safe configur within expect time main observ use proof fact coin toss result differ desir result accord luck strategi configur reach new game begin theorem 35 expect lc delta 2 2ngammaf puls system reach configur valu everi nonfaulti processor clock 1 proof proof use lemma 1 dim91 theorem 5 dim95 present strategi luck win schedulerluck game 2n gamma f intervent within lc 2 time strategi luck 1 wait first puls elaps thereaft 2 luck wait till puls p nonfaulti processor clock valu 0 receiv clock valu 0 occur within next lc puls occur least one nonfaulti processor assign 0 clock success puls imposs case 21 puls nonfaulti processor either toss coin assign 1 without toss luck interven n gamma f time fix coin toss result nonfaulti processor 1 otherwis 22 nonfaulti processor p neither toss coin assign 1 without toss luck interven fix coin toss result less f 0 note p p clock equal 0 thu 34 processor assign 1 without toss coin lemma 31 fact nonfaulti processor toss coin p hold follow p clock valu nonfaulti processor 0 therefor next puls case 21 reach luck could interven fix n gamma f coin toss result ensur desir global state reach theorem 35 system reach configur valu everi nonfaulti processor clock 1 expect time lc delta 2 2ngammaf easi see success puls nonfaulti processor clock valu thu clock agreement requir hold clock nonfaulti processor increment 1 everi puls puls constant time apart clock valid requir also hold note clock valu could multipli known time differ two success puls order yield clock valu reflect real time otherwis valu clock valid requir encod 1 32 acceler protocol protocol converg expect 2 64 puls certainli time complex protocol use practic howev lc n f small 2 expect number puls requir reason small instanc expect number puls 128 use observ acceler protocol achiev synchron clock valu rang expect number puls less 381 synchron occur within expect number puls less 58 defin chines remaind counter use chines remaind theorem appear kn81 p 270 theorem 36 let 1 r posit integ rel prime pair ie r integ exactli one integ u satisfi condit u u j u use theorem case let 2 3 5 p j seri prime number jth prime 2 delta 3 run j parallel version protocol ith version run protocol lc messag carri valu j clock one clock valu version comput new clock valu version use valu receiv particular version independ comput version thu ith version converg within expect puls therefor expect time version synchron less p 1 upper bound expect sinc correspond scenario version start synchron everi appli chines remaind theorem show everi combin valu map one one number rang 0 2 wellknown techniqu could use order convert represent map eg garner method cf p 274 kn81 chines remaind theorem could use implement distribut counter base number present method suggest st67 one possibl use memori commun effici distribut counter let dc distribut counter maintain set processor trigger common puls increment counter mod p everi trigger need store entir bit clock send messag indic carri counter wrap around thu counter increment commun processor need valu counter scan commun requir 4 semisynchron protocol section drop assumpt common puls present selfstabil random protocol semisynchron system due space constraint formal descript protocol full correct proof exclud section 2 reason think n f small singl processor effici comput task addit processor ad ensur reliabl let reliabl fn ratio number faulti processor total number processor reach reliabl 025 number processor need thu gener term blowup hardwar cost four improv reliabl 27028 blowup would 7 asymptot need infinit blowup reach reliabl 13 thu devic would use rel small number processor protocol stabil rel short time protocol use faulttoler averag function first introduc dl86 solv approxim agreement later use clock synchron wl88 given multiset valu processor appli function discard f highest f lowest valu take midpoint remain valu shown function use context protocol dl86 wl88 approxim halv rang valu held nonfaulti processor situat bound clock notion highest lowest must appropri modifi real difficulti directli appli previou result analysi show rang cut half depend nonfaulti processor work approxim multiset round multiset differ arbitrarili valu correspond faulti processor valu correspond nonfaulti processor must close allow error introduc clock drift uncertain messag delay round structur achiev action processor roughli synchron time wl88 protocol due assumpt initi synchron distinguish initi state sinc protocol selfstabil reli either assumpt thu use faulttoler averag function obviou manner processor start arbitrari inform collect clock valu arbitrari time would ensur function appli processor round instanc p could appli function multiset subsequ q could appli function multiset 0 reflect p new valu instead p old valu achiev sort approxim round appli faulttoler averag function first use random bring clock valu nonfaulti processor close achiev nonfaulti processor collect approxim multiset nonfaulti processor stage midpoint averag function shown cf wl88 approxim halv nonfaulti clock valu thu overcom ongo effect clock drift uncertainti messag delay describ protocol processor p two synchron procedur first call averag procedur second jump procedur averag procedur execut valu clock rang greater 0 smaller ffi time elaps sinc previou time clock valu rang jump procedur execut j time elaps sinc previou execut jump procedur p current rang dedic execut averag function p measur j use physic clock roughli speak jump procedur caus clock nonfaulti processor within small rang averag procedur keep clock nonfaulti processor small rang approxim halv rang time clock valu wrap around synchron procedur processor p start request clock valu execut averag procedur processor measur 2d order make sure request clock valu arriv destin respons return proce decid new clock valu thu execut averag procedur take period time defin symmetr clock clock clock procedur p find clock valu within small rang ffi clock p elimin f valu side symmetr clock valu 3 jump procedur p choos one clock valu random reduc clock valu list averag procedur p choos midpoint reduc clock valu list procedur less processor found within ffi clock p choos randomli one clock valu 3 instanc collect valu 231011 symmetr clock valu 7 elimin 41 correct proof sketch semisynchron protocol period time jump period nonfaulti processor execut averag procedur period choos 2n gamma f5t j next lemma prove choic yield exist period length 5t ae jump period lemma 41 everi time jump period least 5t j long proof processor measur time use physic clock whose drift rate real time ae thu processor measur period time physic clock real time elaps measur least t1 ae t1 ae way chosen everi period length processor execut averag function processor measur 2d make sure request clock valu arriv destin respons arriv decid new clock valu thu time averag function execut processor period ae henc total time averag processor period 2n gamma f5t j ae ae therefor total non averag time least 2n gamma ae pigeon hole principl least one jump period length safe configur system configur nonfaulti processor clock within ffi8 moreov case processor middl collect clock valu clock valu transit sent nonfaulti processor within rang use follow assumpt correct proof assumpt 1 1 assumpt 2 n lemma 42 jump period length 5t j 1ae probabl least 1n 6ngammaf system reach safe configur sketch proof prove lemma present sequenc random choic result forc system reach configur clock nonfaulti processor less ffi 8 apart sequenc random choic result probabl least 1n 6ngammaf occur let c configur begin jump period without loss gener assum number faulti processor f maxim possibl 4 violat inequ n 3f let c first configur choos period everi nonfaulti processor p luck count number nonfaulti processor clock within clock configur c nonfaulti processor least clock valu call anchor claim anchor processor 2t r apart assum toward contradict two nonfaulti anchor processor p q clock valu 2t r apart thu p surround processor q surround differ nonfaulti 4 case fewer faulti processor one could assum nonfaulti processor behav like nonfaulti processor processor therefor total number nonfaulti processor least 2n gamma contradict note possibl anchor processor exist case luck choos one nonfaulti processor anchor processor luck choos singl anchor processor anchor processor everi nonfaulti processor execut jump procedur twice luck use follow strategi everi time processor p j choos clock valu valu clock possibl choic ie either find reduc clock valu list valu chosen otherwis valu clock j chang let c 1 first configur reach c processor execut jump procedur least twice result accord strategi luck let e 1 execut start c end c 1 sinc jump period everi nonfaulti processor choos clock valu least everi period length occur 2t c show c 1 nonfaulti processor within 2t r first show nonanchor processor p assign valu clock p clock either first execut jump procedur second one everi processor collect clock valu everi execut jump procedur particular nonanchor processor p j receiv valu clock second execut jump procedur next show second execut jump procedur p j choos valu clock choic p j restrict subset clock valu p j read p j find valu within ffi rang clock j sinc p j nonanchor processor hold c 1 less processor within ffi rang clock j moreov nonfaulti processor assign clock valu within rang clock j sinc 1 everi nonfaulti processor p k chang clock valu use jump procedur assign clock valu ffl rang clock 2 everi nonfaulti processor p k chang clock valu use jump procedur rate drift clock p j 2ae thu differ clock j clock k shorten 2t j r c p j consid p k clock ffi rang clock j assign clock j valu clock prove c 1 nonanchor processor within ffl ae clock anchor processor assign clock valu clock 2t r apart c thu 2t r fact nonfaulti processor within small rang use defin new anchor processor 0 0 nonfaulti processor left remov f nonfaulti processor highest clock valu mod lc f nonfaulti processor smallest valu mod lc c 1 everi processor execut jump procedur least twice luck continu follow processor p process collect clock valu c 1 chang clock first execut jump procedur execut jump function luck interven fix result clock 0 clock processor alreadi set clock valu 0 clock sinc c 1 prove possibl result jump function obviou processor find processor within ffi clock sinc choic restrict also clear first set processor execut jump procedur use clock valu c 1 base decis new clock valu moreov sinc luck interven fix result valu clock 0 reduc list everi processor use new clock valu includ either clock 0 clock processor assign clock clock 0 henc first configur c 2 follow first two execut jump function processor follow c 1 nonfaulti processor within n aeae assumpt 2 less ffi 8 follow c 2 processor wait answer process collect clock chang clock valu thu safe configur reach length execut 2t j reach 2t j c 2 addit configur reach thu safe configur reach follow ae c assumpt 1 5t ae thu processor could choos six time rang thu total number intervent lemma 43 configur execut start safe configur clock valu nonfaulti processor within ffi2 main observ made proof lemma start safe configur everi processor either execut jump averag procedur find clock valu within ffi clock valu thu new clock valu chosen jump averag rang clock valu nonfaulti processor averag procedur approxim halv rang clock valu nonfaulti processor whenev pass zero clock valu theorem 44 expect ot n 6ngammaf stabil conclud remark extens research done find effici clock synchron protocol presenc byzantin fault work consid sever realist model fault ie one take account transient fault well byzantin fault arbitrari corrupt state possibl often case transient fault longer reason approxim unbound clock bound clock matter larg consequ clock take bound number valu wrap around appropri assum paper present two random selfstabil protocol synchron bound clock presenc f byzantin processor failur n 3f believ observ definit type fault consid type clock name bound reflect realiti open new direct research protocol design fault toler model robust exist clock synchron protocol therefor protocol might prefer system implement protocol cope byzantin fault acknowledg mani thank brian coan injong rhee swami natarajan help discuss r self stabil system spite distribut control possibl imposs achiev clock synchron uniform dynam self stabil leader elect analyz expect time schedulerluck game reach approxim agreement presenc fault waitfre clock synchron unifi selfstabil faulttoler faulttoler clock synchron art comput program synchron clock presenc fault byzantin gener problem inexact agreement accuraci precis grace degrad faulttoler clock synchron distribut system optim clock synchron residu arithmet applic comput technolog new faulttoler algorithm clock synchron tr synchron clock presenc fault reach approxim agreement presenc fault possibl imposs achiev clock synchron optim clock synchron new faulttoler algorithm clock synchron faulttoler clock synchron distribut system waitfre clock synchron unifi selfstabil faulttoler art comput program volum 2 3rd ed inexact agreement byzantin gener problem selfstabil system spite distribut control analyz expect time schedulerluck game uniform dynam selfstabil leader elect extend absrtact faulttoler clock synchron ctr ariel daliot danni dolev selfstabil byzantin agreement proceed twentyfifth annual acm symposium principl distribut comput juli 2326 2006 denver colorado usa