profiledriven instruct level parallel schedul applic super block code schedul exploit instruct level parallel ilp critic problem compil optim research light increas use longinstructionword machin unfortun optimum schedul comput intract one must resort care craft heurist practic scope applic schedul heurist limit basic block consider perform loss may incur block boundari overcom obstacl basic block coalesc across branch form larger region super block literatur region typic schedul use algorithm either oblivi profil inform assumpt process form region fulli util profil inform use profil inform addendum classic schedul techniqu believ even simpl case linear code region super block addit perform improv gain util profil inform schedul well propos gener paradigm convert profileinsensit list schedul profilesensit schedul techniqu develop via theoret analysi simplifi abstract model gener problem profiledriven schedul acycl code region yield score measur rank branch instruct b introduct perform vliw machin depend strongli abil compil exploit instruct level parallel ilp program unfortun task compil made difficult presenc number intract optim problem instruct schedul regist alloc paper studi one problem schedul profil inform believ result serv good start point develop practic heurist includ compil vliw machin evid present experiment result valid heurist suggest analysi basic block program fragment may enter top exit bottom preced graph singl basic block direct acycl graph dag 2 practic typic consist fewer vertic schedul small basic block consecut separ lead underutil function unit due sequenti effect block bound ari overcom limit two broad approach propos one call ifconvers elimin branch via hardwar support predic execut allow instruct move outsid basic block see 4 instanc approach requir hardwar support involv format larger code region trace 7 super block 14 super block consist sequenc basic block strung togeth condit exit branch point separ basic block super block typic form follow given code region branch probabl avail branch region probabl obtain profil collect usag statist code execut start entri point code region follow domin fork branch certain branch probabl reach branch start fall certain threshold level termin path altern neither fork branch predom inant termin path chain basic block along path trace manner super block delet chain basic block defin super block code region repeat process modifi portion sinc basic block delet might entri block code region block must duplic modifi region process call tail duplic clear amount tail duplic affect size overal code therebi affect perform face fix instruct cach size light threshold paramet defin notion predomin empir determin outsid scope paper much literatur schedul ignor profil format assumpt region format algorithm fulli digest profil inform stanc super block typic schedul heurist oblivi profil inform although techniqu use profil inform addendum classic schedul techniqu eg specul yield techniqu 3 follow 7 exampl 1 examin sever techniqu region format algorithm becom sophist produc nonlinear code region encompass balanc branch less effect digest profil inform result increasingli import coderegion annot profil inform schedul techniqu effect util profil inform believ paper offer first step direct one might argu would better tackl problem profil driven schedul first principl treat gener code region rather process code region super block howev two good reason restrict studi process region 1 see shortli profiledriven schedul gener code region comput intract impract unless number branch region small say fewer 16 2 tail duplic format simpler region super block often expos instruct level parallel extant gener code region thu legitim goal studi good schedul heurist even limit case super block wenow make precis abstract gener problem schedul profil inform given direct acycl preced graph deriv sourc program describ vertex graph repres oper specifi execut time time requir execut vertex also carri weight w weight w probabl program exit vertex word w probabl portion preced graph root vertex need comput ie vertic upon vertex depend need comput assum target machin function unit schedul vertic graph function unit achiev lowest cost ie shortest weight execut time specif find schedul minim finish time oper start time gener problem everi node weight shown nphard even permit arbitrari preced constraint oper 9 15 problem polynomi solvabl preced graph forest 12 gener seriesparallel graph 1 15 1 problem nphard even without preced constraint unless weight ident case polynomi solvabl hand problem strongli nphard even weight ident preced graph collect chain 5 light intract natur problem adopt standard approach design approxim algorithm bound perform ra tio perform ratio approxim algorithm defin worstcas ratio cost approxim solut optim solut begin gener lemma show construct optim sequenti schedul gener preced graph weight construct lemma effici exploit two restrict version problem case preced graph tree ie vertex exactli one outgo edg sgraph case weight nonzero singl path sgraph defin formal next section abstract super block show use optim sequenti schedul list drive list schedul algorithm multipl function unit guarante perform ratio 2 final heurist extens basic lemma present gener scheme convert list schedul algorithm insensit profil inform schedul algorithm super block sensit profil inform show tight perform guarante heurist present experiment result number sampl super block obtain appli impact compil spec benchmark program report signific save possibl compar prior method exampl 1 consid preced graph figur 1 preced graph super block three branch vertic vertic 3 7 and28 mark figur probabl program exit via vertex 3 01 similarli probabl exit via vertic 7 28 03 06 respect assum given nonpipelin processor two ident function unit oper latenc one cycl schedul graph processor three way first carri critic path schedul equival pr1 pr6 figur 1 preced graph super block vertex correspond unit latenc op erat probabl label branch exit graph probabl exit taken list schedul distanc last exit vertex 28 list prioriti tabl 1 show schedul would obtain case along expect finish time schedul secondli schedul use specul yield prioriti 3 prioriti vertex weight sum longest path length exit weight probabl exit taken list vertic sort descend order prioriti list schedul tabl 2 show schedul would obtain case better expect finish time schedul critic path last exit lastli construct list schedul seek retir exit order earliest possibl time describ call success retir schedul construct prioriti list base critic path prior iti vertic preced inclus earliest exit vertex 3 figur delet vertic list graph iter procedur graph consum append order list creat iter listschedul use list creat tabl 3 show schedul would obtain case along tabl 1 list schedul super block figur 1 two function unit machin use critic path last exit list exit mark expect complet cycl tabl 2 specul yield schedul super block figur 1 two function unit machin exit mark expect complet cycl fu1 22 23 24 25 26 27 28 tabl 3 success retir list schedul super block figur 1 two function unit machin exit mark expect complet cycl expect finish time schedul although success retir schedul ignor profil inform complet lowest finish time three schedul 2 theoret result e denot preced graph sink graph vertex outgo edg assum without loss gener graph exactli one sink sinc easili ensur addit dummi vertex inedg sink given graph vertex assign weight w let p path sourc sink preced graph g defin notion sgraph graphtheoret abstract super block recal super block consist chain basic block condit exit branch point separ basic block graph g said sgraph respect p weight w zero everywher except path p without loss gener assum weight sink non zero delet sink break graph number compon retain compon contain p preced graph super block contain preced edg branch vertic sinc execut order sinc branch vertic vertic nonzero exit probabl preced graph super block sgraph say immedi preced v edg u v graph vertex u preced vertex v path u v vertex u 2 v let g u denot subgraph g induc set vertic preced u subgraph said close preced everi vertex u subgraph vertic preced u also subgraph defin rank vertex ratio r although vertex infinit rank becom evid shortli interest finit rank set vertic v defin weight execut time base rank instanc rank set vertic preced vertex 7 figur 1 175 notion rank set vertic meant captur rel import compar sum weight cost execut intuit sum weight contribut made set vertic weight finish time sum execut time delay suffer rest graph result schedul set vertic first becom evid basic lemma notion rank play key role character optim sequenti schedul 21 basic lemma section develop basic lemma character optim sequenti schedul weight preced graph ie schedul singl function unit effici algorithm two case preced graph tree preced graph sgraph obtain special applic basic lemma previ ousli optim sequenti algorithm weight tree describ literatur 1 8 12 applyingth basic lemma gener weight graph would cost time exponenti number vertic nonzero weight cost practic number vertic ie number branch small theoret point view best known approxim algorithm 11 sequenti schedul weight dag perform guarante 2 howev algorithm base round solut linear program impract compil set followingterm defin respect specif schedul use term segment refer set consecut oper schedul two segment b 1 schedul independ oper u preced v v preced u given weight preced graph g defin g smallest precedenceclos proper subgraph g minimum rank prove main lemma lemma graph g exist optim sequenti schedul optim schedul g occur segment start time zero proof let optim schedul g g decompos minimum number maxim segment suppos g decompos two segment k 1 let segment g increas order start time let segment b denot c let ff denot rg c j denot union block c definit g follow rc j ff sinc otherwis could includ c j g let b j similarli denot union block follow rb otherwis smaller g schedul form move ahead c preserv order within schedul 0 legal sinc g preced close show cost 0 finish proof compar cost two schedul ignor contribut vertic come b k sinc statu remain 0 schedul 0 ik ik ik schedul ik ik ik ik take differ give ik ik ik ik ik ik second inequ follow earlier observ third step follow simpl reorder order summat 22 schedul main lemma essenti reduc schedul problem problem find g recurs schedul g graph form remov g put schedul togeth obtain optim schedul entir graph unfortun problem find g arbitrari preced graph nphard howev number vertic graph nonzero weight small g feasibl determin exhaust enumer next show find g henc find optim sequenti schedul rel straightforward preced graph sgraph let g sgraph respect path p g sink path p sink zero weight sink delet rank number vertic g reduc appropri thu g must subgraph singl sink sink must vertex p nonzero weightdetermin g straightforward schedul obtain essenti one obtain greedili schedul success vertic path defin sgraph earli possibl term correspond super block amount schedul basic block compris super block controlflow order exactli success retir schedul given exampl 1 also obtain good ilp schedul super block sequenti schedul specif show list schedul use optim sequenti schedul list give good approxim solut sgraph defer proof full paper theorem sgraph oper equal execut time list schedul algorithmus optim sequenti schedul list approxim algorithm perform ratio 2 3 practic heurist notic theorem profiledriven ilp schedul quit limit sinc requir oper equal execut time practic situat offer qualiti heurist base theoret analysi earlier section 31 modifi rank function basic lemma comput rank set vertic sum latenc set divid sum exit probabl singl unit case numer good measur length time requir comput set vertic extend notion rank sequenti set ilp set replac numer length schedul comput set vertic call modifi rank mrank set vertic length schedul sum exit probabl basic lemma g defin smallest preced close subgraph g minimum modifi rank intuit behind modifi rank numer time requir retir denomin benefit retir thu ratio reflect amount computat time requir per unit exit probabl minim ratio select g effect maxim return invest schedul given sgraph g found follow simpl procedur algorithm find g modifi rank branch b sgraph given processor construct list schedul subgraph g b root b ignor profil inform let length schedul let w sum exit probabl exit g b g g b earliest b control order minimum modifi rank algorithm comput g modifi rank consider flexibl select list schedul includ oblivi profil inform 32 heurist know comput g modifi rank proceed schedul heurist given low word heurist convert list schedul preced graph one sensit profil inform sgraph sens heurist take profileinsens list schedul algorithm bootstrap profilesensit start heurist find g modifi rank use insensit list schedul make list g initi portion list g heurist delet g g iter append list time till g consum algorithm schedul 1 profilelist empti 2 find g modifi rank use insensit schedul 3 append schedul list g profilelist 4 remov g dag 5 branch remain goto step 2 6 list schedul use profilelist exampl 2 return graph figur 1 appli schedul heurist use critic path schedul insensit list schedul oblivi profil inform assum processor withtwo ident functionalunit equal latenc vertic 3 candid g initi consist subgraph root vertex 3 denot g 3 subgraph root vertex 7 denot g 7 entir graph g comput modifi rank get rankg 3 tabl 4 list schedul construct heurist super block figur 1 two function unit machin use critic path schedul insensit schedul exit mark expect complet cycl numer length critic path schedul given processor sinc g 7 lowest rank g therefor set profilelist critic path list g 7 remov g 7 g sinc vertex 28 exit remain append critic path list profilelist list schedul use profilelist two function unit processor yield schedul tabl 4 notic expect finish time schedul lower critic path schedul tabl 1 specul yield schedul tabl 2 success retir schedul tabl 3 4 experiment result studi perform heurist number optim super block gener impact compil spec benchmark program restrict attent integ benchmark sinc broadli speak floatingpoint benchmark yield super block nearzero sideexit probabl 16 use impact compil compil benchmark decompos program super block basic block report result schedul block two differ class machin model processor uniform function unit processor heterogen function unit model nonpipelin opcod execut time specifi tabl 6 assumpt machin pipelin interest simplic inher limit techniqu uniform processor model 2 4 8 ident function unit respect denot u 2 u 4 u 8 uniform machin model unrealist practic serv well studi effect scale number function unit processor heterogen model h 3 h 5 h 8 shown 5 model h 3 one ialu one falu one model ialu falu mem tabl 5 function unit three heterogen processor opcod time falu 4 cycl tabl 6 opcod execut time loadstor unit model h 5 two ialu one falu two loadstor unit model h 8 three ialu two falu three mem loadstor unit assum branch oper perform falu first use critic path schedul profil insensit schedul algorithm drive heurist compar perform three algorithm 1 critic path schedul last exit 2 specul yield exampl 1 3 3 success retir exampl 1 tabl 7 show improv achiev heurist criticalpath schedul benchmark studi variou machin model benchmark machin model show improv total schedul length benchmark formal defin total schedul length benchmark weight sum schedul length basic block super block benchmark weight execut frequenc obtain via profil experi good measur runtim benchmark typic machin suffici number regist tabl 8 show improv achiev heurist specul yield schedul tabl 9 show improv achiev heurist success retir schedul refer tabl 9 notic narrow machin u 2 h 3 littl perform gain evidenc success retir optim sequenti processor shown theoret analysi like good schedul narrow machin substanti claim heurist gener paradigm convert profileinsensit schedul benchmark improv espresso 128 92 54 113 105 89 li 60 14 12 36 21 09 compress 61 59 52 58 53 38 sc 47 48 51 54 62 51 cccp 43 47 41 31 46 38 cmp 12 22 25 11 18 20 eqn 24 23 21 20 19 20 lex 19 08 09 16 13 10 qsort 109 113 57 62 62 99 tbl 14 13 14 09 11 12 wc 38 38 40 30 37 45 yacc 69 41 43 47 45 44 averag 41 35 28 31 33 31 tabl 7 comparison heurist critic path schedul critic path schedul profileinsensit schedul shown improv total schedul length benchmark benchmark improv espresso 54 37 47 35 38 48 li 13 04 05 03 05 04 compress 36 44 51 36 31 30 sc 28 42 55 30 37 46 cccp 28 38 40 23 34 40 cmp 12 22 25 11 18 20 eqn 14 20 21 15 20 21 lex 11 07 08 10 09 09 qsort 89 101 64 29 38 76 tbl 06 15 13 07 10 07 wc 29 38 40 21 22 51 yacc 36 34 42 28 39 37 averag 24 27 28 16 21 26 tabl 8 comparison heurist specul yield schedul critic path schedul profileinsensit sched uler shown improv total schedul length benchmark benchmark improv espresso 04 47 49 04 52 67 li 21 12 03 01 30 38 compress 07 49 53 05 43 61 alvinn 11 15 12 05 01 17 sc 04 49 62 23 40 43 cccp 18 69 37 25 77 52 eqn 28 02 21 09 63 64 lex 16 17 11 20 15 15 qsort 21 64 95 27 49 84 tbl 35 04 11 01 31 18 wc 29 58 45 21 71 32 yacc 26 51 54 31 50 53 averag 07 28 32 11 36 35 tabl 9 comparison heurist success retir schedul critic path schedul profileinsensit sched uler shown improv total schedul length benchmark profilesensit one appli heurist use success retir profil insensit schedul set benchmark machin model result shown tabl 10 41 discuss perform studi total schedul length benchmark depend natur mix basic block super block produc compila tion heurist design improv perform super block side exit substanti exit fre quenci compil aggress creat super block side exit occur infrequ opportun perform gain limit examin detail introduc notion critic path ratio super block aim measur rel import side exit super block end defin expect critic path length weight sum length critic path exit weight exit probabl critic path ratio ratio expect critic path length length critic path last exit critic path ratio small compar uniti side exit signific critic path ratio close uniti last exit benchmark improv espresso 04 47 49 04 51 67 li 21 15 03 01 29 41 compress 07 41 48 05 47 56 alvinn 11 15 12 05 01 17 sc 04 49 60 23 40 42 cccp 17 69 37 25 78 51 eqn 28 03 21 09 62 64 lex 16 17 11 20 14 15 qsort 15 67 97 24 48 49 tbl 35 04 11 01 31 18 wc 26 58 45 21 71 32 yacc 26 53 54 31 50 50 averag 06 28 31 11 36 32 tabl 10 comparison heurist success retir schedul success retir schedul profil insensit schedul shown improv total schedul length benchmark predomin clear everi basic block critic path ratio uniti figur 2 show averag improv achiev heurist critic path schedul function critic path ratio plot repres averag basic block super block obtain compil benchmark studi plot mark u 2 u 4 u 8 figur refer respect uniform processor model exampl read plot observ block critic path ratio 02 enjoy 30 improv averag schedul heurist compar schedul critic path last exit respect twofunct unit machin u 2 critic path ratio near uniti achiev improv fall expect sinc case last exit predomin heurist converg critic path schedul notic also number avail function unit increas u 2 u 4 u 8 achiev improv fall critic path schedul increasingli good wider processor optim limit case infinit wide processor reduc opportun perform gain rearrang schedul also shown figur distribut block depict cumul percentag critic path ratio exampl read plot observ roughli 30 block sampl critic path ratio 08 less valu critic path ratio perform improv percent henc remain 70 block good candid improv via schedul heuri tic suggest super block format heurist could form super block lower critic path ratio schedul algorithm would increas opportun perform gain anoth factor affect perform gain realiz schedul heurist amount parallel present super block super block littl paral lelism critic path schedul satur processor littl perform gain obtain sinc schedul constrain resourc hand super block lot paral critic path schedul satur processor much perform gain rearrang schedul favor high probabl exit good measur parallel avail block processor util factor schedul block essenti averag load processor schedul express percentag formal procesor util factor number cycl functin unit busi sum function unit express percentag product length schedul number function unit thu two independ factor affect gain realiz schedul heurist 1 import side exit reflect critic path ratio 2 amount parallel avail reflect processor util examin result tabl 7 light two factor let us extend notion critic path ratio benchmarksth critic path ratio benchmark weight sum critic path ratio block compos weight execut probabl block sim ilarli util factor benchmark weight sum util factor block compos weight execut probabl block heurist perform well critic path ratio small util factor larg test hypothesi figur 3 horizont axi plot critic path ratio vertic axi processor util critic path schedul processor model box figur repres benchmark center box correspond critic path ratio processor util horizont vertic axe respect length side box directli proport improv achiev heurist bench mark correspond entri column u 4 tabl 7500 02 04 imp cumul distribut u2 u4 u8 critic path ratio figur 2 perform gain heurist critic path schedul critic path schedul profileinsensit sched uler shown improv run time block function critic path ratio distribut block cumul percentag critic path ratio benchmark high critic path ratio enjoy littl perform gain independ processor util benchmark shown small box also benchmark littl parallel manifest low processor util enjoy littl perform gain even low critic path ratio thu perform gain tabl 7 well explain tuition lend support conclus heurist exhibit gain gain possibl 5 acknowledg thank impact group univers illinoi permiss use impact compil studi c chekuri support nsf award ccr9357849 match fund ibm mitsubishi schlumberg foundat shell foundat xerox corp r motwani support alfr p sloan research fellow ship ibm faculti partnership award aro muri grant daah049610007 nsf young investig award ccr9357849 match fund ibm mit subishi schlumberg foundat shell foundat qsort070crit path ratio processor util ear alvinn compress sc li cccp cmp grep lex tbl wc espresso figur 3 scatter plot perform gain heurist critic path schedul u 4 processor model critic path schedul profileinsensit schedul box correspond benchmark length side box proport percentag improv perform 6 conclus present theoret analysi gener problem schedul preced graph profil informa tion main theoret result gener lemma character optim sequenti schedul weight preced graph heurist extens lemma present gener scheme convert profileinsensit list schedul algorithm profilesensit schedul algorithm super block experi show set heurist offer substanti perform improv prior method rang benchmark r singl machin job sequenc preced constraint compil princi ple enhanc instruct level parallel compil control optim compil cydra5 j schedulingchain structur oper minim makespan mean flow time trace schedul techniqu global microcod compact global code gener instruct level parallel optim task sequenc preced constraint comput tractabl bound multiprocessor time anoma lie schedul minim averag complet time offlin onlin algorithm parallel sequenc assembl line prob lem super block effect techniqu vliw superscalar compil sequenc job minim total weight complet time exploitinginstruct level parallel presenc condit branch effect compil support predic execut use hyperblock order problem approxim singleprocessor schedul interv graph complet tr compil principl techniqu tool schedul chainstructur task minim makespan mean flow time order problem approxim effect compil support predic execut use hyperblock compil cydra 5 superblock enhanc instruct level parallel compilercontrol specul exploit instruct level parallel presenc condit branch schedul minim averag complet time ctr chandra chekuri rajeev motwani minim weight complet time singl machin proceed tenth annual acmsiam symposium discret algorithm p873874 januari 1719 1999 baltimor maryland unit state ghassan shobaki kent wilken optim superblock schedul use enumer proceed 37th annual ieeeacm intern symposium microarchitectur p283293 decemb 0408 2004 portland oregon c chekuri r motwani b natarajan c stien approxim techniqu averag complet time schedul proceed eighth annual acmsiam symposium discret algorithm p609618 januari 0507 1997 new orlean louisiana unit state brian l deitrich wenmei w hwu specul hedg regul compiletim specul profil variat proceed 29th annual acmiee intern symposium microarchitectur p7079 decemb 0204 1996 pari franc mark heffernan kent wilken ghassan shobaki datadepend graph transform superblock schedul proceed 39th annual ieeeacm intern symposium microarchitectur p7788 decemb 0913 2006 wale melei alexandr e eichenberg ivan baev schedul superblock boundbas branch tradeoff ieee transact comput v50 n8 p784797 august 2001 john cavazo j eliot b moss induc heurist decid whether schedul acm sigplan notic v39 n6 may 2004 nicol megow marc uetz tjark vredeveld model algorithm stochast onlin schedul mathemat oper research v31 n3 p513525 august 2006 michael bender soumen chakrabarti muthukrishnan flow stretch metric schedul continu job stream proceed ninth annual acmsiam symposium discret algorithm p270279 januari 2527 1998 san francisco california unit state alexandr e eichenberg wale melei balanc schedul weight branch tradeoff superblock proceed 32nd annual acmiee intern symposium microarchitectur p272283 novemb 1618 1999 haifa israel hermann schichl arnold neumaier interv analysi direct acycl graph global optim journal global optim v33 n4 p541562 decemb 2005 aaron smith jon gibson bertrand maher nick nethercot bill yoder doug burger kathryn mckinl jim burril compil edg architectur proceed intern symposium code gener optim p185195 march 2629 2006 thoma kistler michael franz continu program optim case studi acm transact program languag system topla v25 n4 p500548 juli