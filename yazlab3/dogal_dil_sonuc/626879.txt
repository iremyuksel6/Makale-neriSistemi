comput display conflict string visual string use repres varieti object dna sequenc text numer sequenc model system visual analysi string propos mehta sahni 1992 problem display conflict aris model identifi method overcom suggest method requir comput display conflict present effici algorithm comput display conflict b introduct string data type use repres number object text string dna protein sequenc molecular biolog numer sequenc etc research molecular biolog text analysi interpret numer data involv identif recur pattern data hypothes caus andor effect 2 3 detect pattern visual long string tediou prone error 1 model propos allevi problem model consist identifi recur pattern string highlight ident pattern color first discuss notion maxim pattern let abc pattern occur time string let occurr ab occur abc pattern ab maxim alway follow c notion maxim motiv assumpt applic longer pattern signific shorter one maxim pattern occur least twice known display entiti problem identifi display entiti occurr solv result 4 display entiti occurr obtain confront problem color code string abc def display entiti would display highlight abc one color def anoth shown figur 1 string encount problem conflict consid string cdefcdegabchabcd display entiti abc cde maxim occur thrice must highlight differ color notic howev abc cde occur substr abcd occur suffix clearli display entiti highlight differ color abcd requir model figur 2 altern display model consequ fact letter c occur display entiti situat known prefixsuffix conflict prefix one display entiti suffix note also c display entiti consequ occurr c must highlight color differ use abc cde imposs c subword abc cde situat refer subword conflict problem subword conflict may partial allevi employ sophist display model figur 2 irrespect display model use usual possibl display occurr display entiti therefor forc choos one display three way achiev interact user select occurr interact use hisher judgement typi calli would done examin occurr involv conflict choos one meaning weight assign occurr higher weight greater desir display correspond occurr criteria could use assign weight occurr includ length posit number occurr pattern semant valu display entiti inform conflict etc inform fed routin select set occurr sum weight maxim algorithm discuss 1 practic environ appropri method would hybrid interact automat approach describ user could select occurr hesh want includ final display select remain occurr perform routin maxim display inform method describ requir knowledg conflict either choos occurr display interact assign weight occurr au tomat automat method would requir list conflict interact method requir inform conflict local particular segment string sinc prefix suffix subword conflict handl differ differ display model separ list requir paper identifi famili problem relat identif conflict variou level detail problem relat statist inform conflict also identifi effici algorithm problem present algorithm make use symmetr compact direct acycl word graph scdawg data structur 4 may thought oper travers scdawg scdawg use repres string set string evolv string data structur posit tree suffix tree direct acycl word graph 5 6 7 8 section 2 contain preliminari includ definit display entiti conflict scdawg section 3 present optim algorithm determin whether string conflict comput subword prefix suffix conflict string section 4 5 6 discuss relat size restrict pattern restrict statist problem show implement modifi algorithm section 3 final section 7 present experiment data run time algorithm preliminari 21 definit string length n whose charact chosen fix alphabet sigma constant size pattern said maxim iff occurr preced letter follow letter consid string abczdefydefxabc abc def maxim pattern occurr def preced differ letter z follow differ letter x occurr abc preced letter first occurr predecessor follow letter howev de maxim occurr follow f pattern said display entiti display iff maxim occur maxim pattern display entiti except occur subword conflict two display entiti 1 2 exist iff 1 substr 2 ii prefixsuffix conflict two display entiti 1 2 exist iff exist substr p sm occur p string sm known intersect conflict conflict said occur 1 2 respect sm 22 symmetr compact direct acycl word graph scdawg scdawg scd correspond string direct acycl graph defin set vertic v set rs label direct edg call right extens edg set ls label direct edg call left extens le edg vertex v repres substr specif v consist sourc repres empti word sink repres vertex correspond display entiti let dev denot string repres vertex v v ffl v defin implic imp ff string ff smallest superword ff fdev v ffl v sg superword exist otherwis imp ff exist edg vertex v 1 obtain follow letter x sigma imp dev 1 x exist equal dev 2 exist edg v 1 v 2 label xfl fi empti string edg known prefix extens edg le edg vertex v 1 obtain follow letter x sigma imp xdev 1 exist equal dev 2 exist le edg v 1 v 2 label flx fi empti string edg known suffix extens edg figur 3 show v rs correspond gabcd de e de c abc bc de gabcd fabcgabcd gabcd fabcgabcd cde sink abc c sourc figur 3 scdawg display entiti two outgo edg vertex repres abc edg correspond g imp consequ edg incid sink edg correspond letter alphabet imp abcx exist x ffl fa b c e fg space requir scd time need construct 5 4 defin scdawg data structur singl string extend repres set string 23 comput occurr display entiti figur 4 present algorithm comput end posit occurr dev base outlin provid 4 complex occurrencess v proport number occurr dev algorithm procedur occurrencessstringuvertexiinteg begin deu suffix right edg e u begin let w vertex e incid figur 4 algorithm obtain occurr display entiti 24 prefix suffix extens tree prefix extens tree pet v vertex v v subgraph scd consist root v ii pet w defin recurs vertex w v exist prefix extens edg v w iii prefix extens edg leav v suffix extens tree set v v defin analog figur consist vertic repres c cde sink also includ prefix extens edg c cde cde sink similarli set v consist vertic repres c abc suffix extens edg c abc shown figur contain direct path v vertex w v iff dev prefix suffix dew proof direct path pet v v vertex w definit prefix extens edg transit prefix relat dev must prefix dew dev prefix dew exist seri edg v w dev concaten label edg yield dew edg must prefix extens edg direct path v w exist proof set v analog 2 comput conflict 31 algorithm determin whether string conflict free describ algorithm determin string free conflict establish properti conflict free string use algorithm lemma 2 prefixsuffix conflict occur string subword conflict must occur proof prefixsuffix conflict occur two display entiti w 1 w 2 exist w p wmw w p follow letter w 2 isnt alway preced letter ie wm isnt alway follow letter wm isnt alway preced letter wm maxim w 1 occur least twice sinc w 1 display entiti wm occur least twice sinc wm subword w 1 display entiti wm subword w 1 subword conflict occur wm w 1 2 corollari 1 string free subword conflict free conflict lemma 3 dew subword dev iff path compris right extens suffix extens edg w v proof definit scd exist edg u v deu subword dev exist suffix extens edg u v deu suffix therefor subword dev exist path compris right suffix extens edg w v transit dew subword dev algorithm noconflictss 1 construct scd 2 comput 3 scan right suffix extens edg element v sourc edg point vertex sink conflict exist otherwis conflict free figur 5 algorithm determin whether string conflict free dew suffix dev path lemma 1 suffix extens edg w v dew subword suffix dev definit scdawg path edg w vertex repres suffix dev 2 sourc denot vertic v suffix extens edg exist sourc vertex scd element v sourc lemma 4 string conflict free iff right extens suffix extens edg leav vertic v sourc end sink vertex scd proof string conflict free iff exist right suffix extens edg two vertic neither sourc sink scd corollari 1 lemma 3 assum conflict free consid vertex v v sourc v right suffix extens edg v w v 6 sink w 6 sink dev subword dew string conflict free contradict assumpt next assum right suffix extens edg leav vertic v sourc end sink vertex clearli exist right suffix extens edg two vertic v w v 6 sink w 6 sink v sourc exist vertex x v x 6 sourc x 6 sink x sourc vertex exist must exist path consist right suffix extens edg vertex v sourc x clearli true conflict free 2 preced develop lead algorithm noconflict figur 5 theorem 1 algorithm noconflict correct optim proof correct immedi consequ lemma 4 step 1 take time 4 step 2 take o1 time sinc jv sourc j 2jsigmaj step 3 take o1 time sinc number edg leav v sourc less 4jsigma 2 j noconflict take time optim actual step 2 3 merg step 1 construct scd abort soon edg violat lemma 4 creat 2 32 subword conflict consid problem find subword conflict string let k number subword conflict algorithm solv problem requir time read input string ii ok time output subword conflict lower bound time complex problem string upper bound number conflict maximum number substr occurr 2 worst case occurr conflict section compact method repres conflict present let k sc size represent k sc n 3 6 3 n compact never increas size output may yield factor n reduct exampl compact method describ consid abcdbcgabcdbchbc display entiti end posit 1 6 13 2 3 6 10 13 16 list subword conflict 1 2 written f63 66 1310 1313g first element order pair last posit instanc superstr 1 involv conflict second element order pair last posit instanc substr 2 involv conflict cardin set number subword conflict 1 2 given frequencyd 1 lambdanumb occurr 2 1 sinc conflict repres order pair size output 2frequencyd 1 lambdanumb occurr 2 1 observ occurr 2 1 rel posit instanc 1 therefor possibl write list subword conflict 1 2 61303 first list give occurr superstr 1 second give rel posit occurr substr 2 superstr 1 right end 1 size output frequencyd 1 number occurr 2 1 econom earlier represent gener substr conflict mani instanc number display entiti say z superword would write conflict l 1 z l repres occurr l 0 z repres rel posit occurr z one list requir display entiti contain display entiti subword follow equal easili obtain size compact represent size origin represent f frequenc conflict consid r ij frequenc j one instanc repres set display entiti repres set display entiti subword defin subgraph scd consist set vertic sv v ae v repres display entiti subword dev set se v suffix extens edg connect pair vertic sv v defin sgr v sg v direct edg se v revers lemma 5 sg v consist vertic w path compris right suffix extens edg join w v scd proof follow lemma 3 2 2 vertex v scd 5 vertic u right suffix extens edg u v incid v 6 u 6 sourc 8 vertex v scd v 6 sink vsubword true 9 getsubwordsv procedur getsubwordsv 7 vertex x 6 sourc revers topolog order sg v 9 dex suffix dev xsublist f0g els xsublist fg vertex w sg v edg e x incid 12 element l wsublist xsublist 14 end figur optim algorithm comput subword conflict algorithm b figur 6 comput subword conflict subword conflict comput precis display entiti subword display entiti line 4 6 algorithm b determin whether dev subword display entiti incom right suffix extens edg v check see whether origin sourc incom edg origin vertex sourc vsubword set true lemma 3 incom edg origin sourc vsubword set fals procedur getsubwordsv comput subword conflict dev invok vsubword true procedur occurrencess v line 2 getsubword comput occurr dev place vlist procedur setup line 5 travers sgr v initi field vertex sgr v revers topolog travers sg v may subsequ perform procedur setsuffix line 6 mark vertic whose display entiti suffix dev accomplish follow chain revers suffix extens pointer start v mark vertic encount suffix v list rel occurr sublist associ vertex x sg v xsublist repres rel posit dex occurr dev rel occur denot posit rel last posit dev repres 0 dex suffix dev xsublist initi element 0 remain element xsublist comput sublist field vertic w v right extens edg goe x w consequ wsublist must comput xsublist achiev travers sg v revers topolog order 9 lemma 6 xsublist vertex x sg v contain rel occurr dex dev complet getsubwordsv proof correct lemma follow correct procedur occurrencess v section 23 observ line 7 15 procedur getsubword achiev effect occurrencess v 0 sg v 2 theorem space therefor optim proof comput vsubword vertex v v take time constant time spent vertex edg scd consid complex getsubwordsv line 2 3 take ojvlistj time let number vertic sg v number edg sg v om line 5 travers sg v therefor consum om time line 6 worst case could involv travers sg v take om time comput rel occurr dex dev line 915 take ojxsublistj time vertex x sg v total complex getsubwordsv ojvlistj howev xfflsv svx6v jxsublistj sinc jxsublistj 1 x ffl sg v xfflsv svx6v jxsublistj size output getsubwordsv complex algorithm b 33 prefix suffix conflict subword conflict lower bound problem comput prefixsuffix conflict k p k p number prefixsuffix conflict also upper bound k p unlik subword conflict possibl compact output represent let w x respect vertic set v pet v let vertex repres imp www v w x vertex exist otherwis pshadoww v defin pimagew v w www v w x possibl empti string w otherwis pimagew v vertex w set v shadow prefix dag spdw v root vertex w compris set vertic fpshadoww v xj x pet v pshadoww v x 6 nilg figur 7 illustr concept broken line repres suffix extens edg dot line repres right extens edg solid line repres prefix extens edg ff l c r z x figur 7 illustr prefix suffix tree shadow prefix dag set v pet v spdw v enclos dash solid dot line respect pshadoww v lemma 7 prefixsuffix conflict occur two display entiti w respect third display entiti set v x occur pet v ii pshadoww v x 6 nil number conflict dew dex respect dev equal number occurr depshadoww v x proof definit prefixsuffix conflict occur display entiti w 1 respect wm iff exist w p wmw w wmw clearli wm suffix w 1 wm prefix w 2 iff w occur set v x occur pet v w p wmw occur iff imp w p wmw nil number conflict dew dex equal number occurr imp w p wmw lemma 8 prefixsuffix conflict occur dew dex respect dev w occur set v x occur pet v prefixsuffix conflict display entiti repres descend w set v display entiti repres descend x pet v respect dev proof sinc w set v x pet v repres dew w p dev dex devw conflict occur w p devw occur descend w set v repres display entiti form w w w p dev descend x pet v repres display entiti form dexw substr prefixsuffix e f r z x figur 8 illustr condit lemma 9 conflict occur w dew dexw b respect dev w w p devw w b must exist howev possibl w p devw occur result follow 2 lemma 9 scd prefix extens edg e x z label aff iii right extens edg f u label afi pshadoww v proof let possibl empti string w w b w ww devw x afi string w b prove lemma must show u ie ww devw x aff subword deu ii deu smallest superword ww devw x aff repres vertex scd assum ww devw x aff subword ff prefix fi case 1 fi proper prefix ff sinc w b w ww devw x afi maxim occurr follow letter true suffix particular occurr devw x afi follow letter similarli occurr devw x afi preced letter prefix devw x dez devw x afi display entiti consequ prefix extens edg x correspond letter must direct vertex repres devw x afi contradict case 2 afi match aff first k charact th charact 1 k 1 clearli string devw x aflff 1 w b w ww devw x aflfi 1 occur ie occurr devw x afl follow letter occurr devw x afl preced letter prefix devw x display entiti consequ prefix extens edg x correspond letter must direct vertex repres devw x afl result contradict thu ff prefix fi ii ff prefix fi assum w b w ww devw x afi smallest su perword ww devw x aff sinc x smallest superword ww devw x smallest superword ww devw x aff must form w ww devw x afl ff prefix fl proper prefix fi andor w b 1 proper suffix w b right edg f z point smallest superword w ww devw x definit scd w b w ww devw x afi w b 1 contradict 2 scd path prefix extens edg x x 1 let concaten label aff iii prefix extens edg x 1 z label bfl iv right extens edg f u label affbfi proof similar proof lemma 9 2 path p aff z x f r figur 9 illustr condit lemma 10 11 algorithm c construct scd 2 vertex v scd procedur nextsuffixcurrentv 1 suffix extens edg current w 2 fthere one suffix extens edg current wg 6 exist nextsuffixwv figur 10 optim algorithm comput prefixsuffix conflict lemma 11 lemma 9 lemma 10 jlabelfj sum length label edg prefix extens edg path p x z labelf concaten label p proof lemma 10 concaten label edg p prefix labelf jlabelfj sum length label edg p ie labelf concaten label seri edg p x pet v proof follow lemma 7 8 2 algorithm c figur 10 comput prefixsuffix conflict line 1 construct scd line 2 3 comput prefixsuffix conflict separ comput display entiti dev prefixsuffix conflict intersect procedur nextsuffixcurrentv comput prefixsuffix conflict display entiti repres descend current set v display entiti repres descend v pet v respect dev call nextsuffixvv line 3 algorithm c comput prefixsuffix conflict respect dev identifi spdw v child w current set v call shad owsearchvwvw line 5 identifi spdw v comput prefixsuffix conflict dew display entiti repres descend v pet v respect dev shadowsearchvwvw report prefixsuffix conflict global variabl exist unchang shadowsearchvwvw ie exist fals line 4 otherwis set true shadowsearch line 6 ensur nextsuffixwv call shadowsearchvwvw detect prefix suffix conflict dew display entiti repres descend v pet v respect dev lemma 8 descend q vertex x pet v procedur shadowsearchvwxi comput prefix suffix conflict dew deq respect dev repres pshadoww v x show call shadowsearch maintain invari refer imag invari hereaft nil notic invari hold shadowsearch call nextsuffix v statement line 1 examin prefix edg x line 3 28 comput prefix suffix conflict dew display entiti repres vertic pet z z vertex prefix extens edg x incid truth condit statement line 1 line 4 truth condit insid statement line 5 establish condit lemma 9 satisfi prior execut line 8 9 truth comment line 8 correct line 9 establish lemma 9 procedur listconflict line 9 list prefix suffix conflict dew dez respect dev similarli truth condit insid statement line 11 line 13 14 truth condit insid statement line 15 establish condit lemma satisfi prior execut line 1820 correct line 1820 establish lemma 10 done remain fals exit loop condit statement line 15 must evalu true consequ condit appli sinc loop line 11 termin addit condit lemma 11 also satisfi henc lemma 11 procedur shadowsearchv w x 1 prefix extens edg 2 fthere one prefix extens edg x zg first charact label 5 right extens edg whose label start fc 6 9 done jlabelfj jlabelej 14 th charact labelf 15 prefix extens edg start nc 22 els 26 shadowsearchvwzu 28 end 29 end figur 11 algorithm shadow search imag invari recurs call shadowsearchv w z u maintain line 27 set global variabl exist true sinc execut claus statement line 5 ensur least one prefixsuffix conflict report shadowsearchv w v w lemma 7 9 exist remain fals claus statement line 5 never execut theorem 3 algorithm c comput prefixsuffix conflict time optim proof line 1 algorithm c take time 4 cost line 2 3 without includ execut time nextsuffixv v next show nextsuffixv v take ok v time k v number prefix suffix conflict respect v ie k v repres size output nextsuffixv v assum nextsuffix invok p time comput let set invoc nextsuffix call nextsuffix recurs let p j let f set invoc nextsuffix call nextsuffix recurs let p element f directli call jsigmaj element p p f jsigmaj line 46 nextsuffixcurrentv element f yield least one distinct conflict call shadowsearch thu p f k v cost execut nextsuffix without includ cost recurs call nextsuffix shadowsearch ojsigmaj o1 jsigmaj suffix edg leav vertex total cost execut invoc nextsuffix spawn nextsuffixv v without includ cost recurs call shadowsearch next consid call shadowsearch spawn nextsuffixv v let set invoc shadowsearch call shadowsearch recurs let q jt j let tb set invoc shadowsearch call shadowsearch recurs let q q jsigmaj1q bjsigmajp algorithm element tb yield distinct conflict q b cost execut singl call shadowsearch without includ cost execut recurs call shadowsearch o1 ocomplex listconflict line complex listconflict line 20 th iter loop w denot number iter loop complex listconflict proport number conflict report sinc listconflict alway yield least one distinct conflict complex shadowsearch o1 sum call shadowsearch spawn nextsuffixv v obtain oq thu total complex algorithm c 34 altern algorithm section algorithm comput conflict ie subword prefixsuffix conflict present solut rel simpl competit run time howev lack flexibl requir effici solv mani problem list section 4 5 6 algorithm algorithm present figur 12 step 1 comput list occurr display entiti list obtain first comput list occurr correspond vertex v except sourc sink concaten list occurr repres start end posit step 2 sort list occurr obtain step 1 increas order start posit occurr start posit sort decreas order end posit done use radix sort step 3 comput ith occurr occ prefix suffix conflict occurr whose start posit greater subword conflict subword occ check conflict c smallest integ conflict occ occ ic start posit occ ic greater end posit occ start posit occ j j c also greater end posit occ sinc list occurr sort increas order start posit start posit occ i1 occ greater equal start posit occ less equal end posit occurr among whose start posit equal occ end posit smaller sinc occurr start posit sort decreas order end posit remain conflict occ ie subword conflict superword prefix suffix conflict occurr whose start posit less occ alreadi comput earlier iter statement algorithm exampl let input step 3 follow list order pairs16 13 11 22 38 35 46 58 610 first element order pair denot start posit second element denot end posit occurr consid occurr 35 conflict 16 13 38 comput iter 1 2 5 loop conflict 46 58 comput iter 6 loop theorem 4 algorithm take proof step 1 take number occurr display entiti step 2 also take element sort use radix sort n bucket step 3 take oo time loop execut oo time iter loop yield distinct conflict total complex onok show number occurr involv conflict number occurr involv least one conflict singl conflict occur two occurr 2k algorithm modifi size output may achiev check whether occurr first repres pattern loop step 3 subword conflict report first occur pattern howev time complex algorithm remain k sens suboptim algorithm step 1 obtain list occurr display entiti string list obtain first comput list occurr correspond vertex scdawg except sourc sink concaten list step 2 sort list occurr use start posit occurr primari key increas order end posit secondari key decreas order done use step3 1 number occurr begin begin occ superword occ j els prefixsuffix conflict figur 12 simpl algorithm comput conflict 4 size restrict queri experiment data show random string contain larg number display entiti small length applic small display entiti less interest larg one henc use list display entiti whose length greater integ k similarli use report exactli conflict conflict display entiti length greater k give rise follow problem p1 list occurr display entiti whose length greater k p2 comput prefix suffix conflict involv display entiti length greater k p3 comput subword conflict involv display entiti length greater k overlap conflict defin string common conflict display entiti overlap subword conflict subword display entiti overlap prefixsuffix conflict intersect size conflict length overlap altern formul size restrict problem also seek achiev goal outlin base report conflict whose size greater k formul problem particularli relev conflict interest display entiti also establish conflict display entiti report size greater k follow problem p4 obtain prefixsuffix conflict size greater integ k p5 obtain subword conflict size greater integ k p1 solv optim invok occurrencess v 0 vertex v v combin solut p2 p3 use approach section 34 modif algorithm figur 12 step 1 becom obtain occurr display entiti whose length greater k result algorithm optim respect expand represent subword conflict howev gener problem possibl obtain separ optim solut p2 p3 use techniqu section 34 optim solut p4 obtain execut line 3 algorithm c figur 10 vertic v v jdevj k optim solut p5 obtaind follow modif algorithm b figur 6 right extens suffix extens edg mark disabl ii definit sg v modifi sg v v ffl v defin subgraph scd consist set vertic sv v ae v repres display entiti length greater k subword dev set suffix extens edg connect pair vertic sv v algorithm b modifi modifi algorithm shown figur 13 note p2 p5 ident sinc overlap subword conflict subword display entiti algorithm b 2 vertex v scd 4 vertex v scd jdevj k 5 vertic u non disabl right suffix extens edg u v exist 7 vertex v scd v 6 sink vsubword true 9 end figur 13 modifi version algorithm b 5 pattern orient queri queri use applic fact two pattern conflict import number locat conflict follow problem aris result list pair display entiti subword conflict p7 list triplet display entiti 1 2 dm prefix suffix conflict 1 2 respect dm p8 p6 size restrict p5 p9 p7 size restrict p4 p6 may solv optim report vertex v v v repres sink csd subword display entiti dev accomplish report dew vertex w w 6 sourc sg v p7 may also solv optim modifi procedur listconflict figur 11 report conflict display entiiti intersect p8 p9 may also solv make similar modif algorithm previou section 6 statist queri queri use conclus drawn data base statist fact let fd denot frequenc number occurr string number occurr display entiti 1 display entiti 2 follow queri may defin p10 pair display entiti 1 2 involv subword conflict 1 subword 2 obtain number occurr 1 occur subword p11 pair display entiti 1 2 involv prefixsuffix conflict number occurr 1 prefixsuffix conflict greater statist determin threshold follow could said confid presenc 1 impli presenc 2 number prefix suffix conflict 1 2 respect dm psfd 1 2 number prefix suffix conflict 1 2 approxim pd two quantiti ident unless singl occurr 1 subword two distinct occurr 2 similarli approxim qd two quantiti ident unless singl occurr 1 prefix suffix conflict two distinct occurr 2 fd 1 comput display entiti scd time singl travers scd revers topolog order comput optim 1 2 modifi procedur getsubwordsv shown figur 14 comput optim 1 2 dm 1 prefix suffix conflict 2 respect dm modifi listconflictsu z w figur 11 return fdeu sinc number conflict dew dez respect dev psfd calcul sum psfd 1 2 dm intersect dm prefix suffix conflict 1 2 pd may comput simpl modif algorithm use comput rfd procedur getsubwordsv 5 vertex x 6 sourc revers topolog order sg v 6 begin 7 dex suffix dev rfdex 8 vertex win sg v edg e x incid 9 figur 14 modif getsubwordsv comput rel frequenc problem may solv size restrict p4 p5 modif similar made section 4 7 experiment result algorithm b section 32 c section 33 section 34 program gnu c run sun sparcstat 1 test data use 120 randomli gener string alphabet size chosen one f5 15 25 35g string length 500 1000 2000 test set string consist 10 differ string possibl combin input size alphabet size combin averag run time 10 string given figur 1518 figur 15 give averag time comput conflict combin algorithm b c figur give averag time comput prefixsuffix conflict use algorithm c figur 17 give averag time comput pattern restrict prefixsuffix conflict problem p7 section 5 modifi algorithm c describ section 5 figur 18 repres averag time algorithm figur 15 17 repres theoret superior solut correspond prob lem figur repres algorithm provid simpler suboptim size size string alphabet 500 1000 2000 figur 15 time ms comput conflict use optim algorithm solut three problem case time construct scdawg write result file includ step common solut result show suboptim algorithm superior optim solut comput conflict prefixsuffix conflict randomli gener string due simplic algorithm fact number conflict randomli gener string small howev string 100 repres worst case scenario term number conflict report follow run time obtain conflict optim algorithm 14190 ms prefixsuffix conflict optim algorithm 10840 ms pattern restrict prefixsuffix conflict optim algorithm 5000 ms algorithm 26942 ms experiment result use random string also show expect optim algorithm fare better algorithm restrict problem comput pattern orient prefixsuffix conflict conclud algorithm use gener problem comput conflict optim solut use restrict version henc algorithm use automat environ optim solut use interact semiautomat environ size size string alphabet 500 1000 2000 figur time ms comput prefix suffix conflict use optim algorithm size size string alphabet 500 1000 2000 figur 17 time ms comput pattern restrict prefix suffix conflict use optim algorithm size size string alphabet 500 1000 2000 figur 18 time ms algorithm conclus paper describ effici algorithm analysi visual pattern string current extend discret object circular string graph extend techniqu domain approxim string match would use appear difficult r string visual sequenc landscap match protein sequenc use color intrasequ homolog display complet invert file effici text retriev analysi smallest automaton recogn subword text effici onlin construct correct posit tree spaceeconom suffix tree construct algorithm effici eleg subword tree construct fundament data structur pascal tr transduc repetit complet invert file effici text retriev analysi match protein sequenc use color intrasequ homolog display model techniqu visual label discret object spaceeconom suffix tree construct algorithm fundament data structur pascal data structur circular string analysi visual ctr hsuan chang nengwen lo wei c lu chung j kuo visual comparison dna sequenc use threedimension trajectori proceed first asiapacif bioinformat confer bioinformat 2003 p8185 februari 01 2003 adelaid australia