optim direct thread code select inlin achiev good perform bytecod languag interpret difficult without sacrif simplic portabl due complex dynam translat justintim compil bytecod nativ code mechan employ univers highperform interpretersw demonstr simpl techniqu make possibl creat highlyport dynam translat attain much 70 perform optim c certain numer comput translat base techniqu offer respect perform without sacrif either simplic portabl much slower pure bytecod interpret b introduct bytecod languag smalltalk gol83 caml ler97 java arn96 lin97 offer signific engin advantag convent languag higher level abstract dynam execut environ increment debug code modif compact represent execut code case platform independ success java due larg promis platform independ compact code compact bytecod import advantag network comput code must download ondemand execut arbitrari platform oper system keep bandwidth requir minimum disadvantag bytecod interpret typic offer lower perform compil code consum significantli resourc modern virtual machin perform degre dynam translat improv program perform deu84 techniqu significantli increas complex virtual machin must tailor permiss make digit hard copi part work person classroom use grant without fee provid copi made distribut profit commerci advantag copi bear notic full citat first page copi otherwis republish post server redistribut list requir prior specif permiss andor fee sigplan 98 montreal canada c hardwar architectur much way convent compil backend increas develop cost requir specif knowledg target architectur time write specif code reduc reliabl introduc code debug support languag caml exampl also tradit compil produc highperform nativ code defeat advantag come platform independ compact propos novel dynam retransl techniqu appli certain class virtual machin techniqu deliv high perform 70 optim c easi retrofit exist virtual machin requir almost effort port new architectur paper continu follow next section give brief survey bytecod interpret mechan provid context remaind paper novel dynam retransl techniqu explain section 3 section 4 present result appli techniqu two interpret small risclik interpret inspir work product virtual machin object caml last two section contrast techniqu relat work present conclud remark background interpret perform depend heavili represent chosen execut code mechan use dispatch opcod section describ common techniqu 21 pure bytecod interpret inner loop pure bytecod interpret simpl fetch next bytecod dispatch implement use switch statement figur 1 show typic pure bytecod interpret loop array bytecod calcul use run exampl interpret infinit loop contain switch statement dispatch success bytecod case bodi switch implement one bytecod pass control next bytecod break switch pass control back start infinit loop assum compil optim jump chain break implicit jump end bodi back begin overhead associ approach follow compil code unsign char bytecodeadd bytecod implement unsign char unsign char switch bytecod case bytecodepush3 break case bytecodepush4 break case bytecodeadd stackpoint stackpointer1 break figur 1 pure bytecod interpret ffl increment instructionpoint ffl fetch next bytecod memori ffl redund rang check argument switch ffl fetch address destin case label tabl ffl jump address end bytecod ffl jump back start bodi fetch next bytecod eleven machin instruct must execut powerpc perform push3 bytecod nine instruct dedic dispatch mechan includ two memori refer two jump among expens instruct modern architectur pure bytecod interpret easi write stand highli portabl rather slow case bytecod perform simpl oper push3 exampl major execut time wast perform dispatch 22 thread code interpret thread code bel73 popular forth program languag moo70 variou kind thread code effici gener direct thread ert93 bytecod simpli integ dispatch involv fetch next opcod bytecod look address associ implement either explicit tabl implicitli use switch transfer control address direct thread code improv perform elimin tabl lookup execut code repres sequenc opcod implement address dispatch involv fetch next opcod implemen tation address jump directli address addit optim elimin central di patch instead return central dispatch loop compil code void opcodeadd opcod implement dispatch next instruct defin next goto instructionpoint void start execut dispatch first opcod opcod implement opcodepush3 opcodepush4 opcodeadd stackpoint stackpointer1 figur 2 direct thread code direct thread opcod implement end code requir dispatch next opcod direct thread version 3 exampl shown figur 2 1 execut begin fetch address first op code implement compil code jump address opcod perform work dispatch next opcod impli compil code henc name control flow thread way opcod order impli compil code without ever return central dispatch loop overhead associ thread code much lower associ pure bytecod inter preter opcod execut addit overhead dispatch next opcod ffl increment instructionpoint ffl fetch next opcod address memori ffl jump address five machin instruct requir implement push3 powerpc three associ opcod dispatch one memori refer one jump save six instruct pure bytecod approach importantli save one memori refer one jump instruct ex pensiv 23 dynam translat thread code benefit direct thread code easili obtain bytecod languag translat bytecod 1 thread code exampl written use firstclass label provid gnu c express void assign address type void statement attach given label addr control transfer locat use goto derefer address goto addr note gcc firstclass label requir implement techniqu effect achiev coupl macro contain line asm translat tabl void opcod dynam translat unsign char bytecodepoint firstbytecod void morebytecodestotransl figur 3 dynam translat bytecod thread code direct thread code execut illustr figur 3 translat loop read bytecod look address implement tabl write address direct thread code complic bytecod set extens byte provid addit inform encod within bytecod branch offset indic liter tabl environ extens byte normal place inlin translat thread code translat immedi thread opcod correspond bytecod translat thread code permit kind op timiz exampl smalltalk provid four bytecod push implicit integ constant 1 onto stack translat loop could easili translat singl pushinteg opcod follow constant push inlin operand treatment appli kind liter quantiti rel branch offset anoth possibl partial decod translat loop examin load bytecod translat time translat one sever thread opcod translat loop must awar kind operand copi rel offset exampl might requir modif scale translat loop possibl make approxim evalu approach realist system squeak ing97 portabl pure bytecod implement smalltalk80 perform numer comput approxim 37 speed optim c brouhaha mir87 portabl smalltalk virtual machin similar squeak vm except dynam translat bytecod direct thread code execut mir91 brouhaha perform numer comput 15 speed optim c implement care handtun perform essenti differ use dynam translat direct thread code brouhaha 24 optim common bytecod sequenc bytecod typic repres thread opcod repres mani sinc encod pointer translat bytecod thread code therefor give us opportun make arbitrari transform execut code one transform detect common sequenc bytecod translat singl thread macro opcod macro opcod perform work entir sequenc origin bytecod exampl bytecod push liter push variabl add store variabl translat singl addliteraltovari opcod thread code optim effect avoid overhead multipl dispatch impli origin bytecod elid within macro opcod singl macro opcod translat sequenc n origin bytecod avoid dispatch execut time techniqu particularli import case bytecod simpl 3 implement bytecod short singl registerregist machin instruct cost thread often significantli larger cost use execut three instruct must execut dispatch next opcod overhead thread instruct execut 12 instruct dispatch thread opcod overhead drop 43 oper optim singl macro opcod four use instruct 3 instruct thread 2 dispatch opcod implement noncontigu address also undermin code local caus unnecessari processor pipelin stall ineffici util instruct cach tlb combin common sequenc bytecod singl macro opcod consider reduc effect compil also chanc make interbytecod optim within implement singl macro opcod imposs make implement individu bytecod determin appropri set common bytecod sequenc difficult virtual machin instrument record execut trace simpl offlin analysi reveal like candid correspond pattern match macro opcod implement incorpor manual vm exampl analysi appli earlier version object caml bytecod set result new set bytecod includ sever macrostyl oper 25 problem static optim signific problem static approach number possibl permut even shortest common sequenc consecut bytecod pro hibit exampl smalltalk provid 4 bytecod push popular integ constant minu one two bytecod load store 32 temporari 256 receiv variabl manual optim possibl permut increment decrement variabl small constant would requir translat implement 2304 explicit special case clearli unreason problem made acut sinc differ applic run virtual machin favor differ sequenc bytecod static chose singl optim set common sequenc therefor imposs techniqu focus make choic runtim allow set common sequenc nearli optim particular applic run instruct count accur way estim save sinc instruct avoid expens execut dynamicopcodepush3push4add stackpoint stackpoint stackpointer1 goto figur 4 equival macro opcod push3 push4 add int nfibsint n return n 2 figur 5 benchmark function c dynam rewrit opcod sequenc gener implement common bytecod sequenc dynam implement avail new macro opcod singl macro opcod replac sever thread opcod gener origin common bytecod sequenc dynam gener macro opcod execut precis manner interpret predefin opcod origin execut mechan direct thread requir modif transform perform either bytecodetothread code translat separ pass alreadi thread code figur 4 show equival c dynam gener thread opcod sequenc three bytecod need evalu 3 4 exampl translat concaten compil c implement sever intrins thread opcod one correspond bytecod sequenc optim sinc involv reloc code safe perform concaten thread opcod whose implement posit independ gener three case consid concaten opcod implement ffl thread opcod inlin implement contain call c function destin address rel processor pc destin address would invalid copi form new macro opcod implement ffl thread opcod chang flow control thread code must appear end translat sequenc differ path sequenc might consum differ number inlin argument ffl thread opcod branch destin appear begin macro opcod sinc incorpor middl macro opcod would delet branch destin final thread code simplifi follow rule consid basic block inlin basic block begin jump destin end either jump nfib push r1 r1 save call move jge r0 r1 cont pop r1 restor r1 return cont move r0 r1 els arg r1 call nfib call nfib add add pop r1 restor r1 return start move 32 r0 call nfibs32 call nfib print figur thread code nfib benchmark inlin destin chang control flow inlin pur pose opcod contain c function call consid singleopcod basic block restrict relax target architectur andor compil use build vm use absolut address function call destin techniqu design work best finegrain opcod implement short typic machin instruct therefor cost opcod dispatch domin next section present exampl context 31 simpl exampl illustr techniqu appli simpl risclik virtual machin execut nfib func tion shown figur 5 3 exampl interpret implement registerbas execut model hand regist perform arithmet stack use save return address content clobber regist subroutin call direct thread code two kind inlin operand instruct pointerrel offset branch destin absolut address function call destin interpret translat bytecod thread code two pass make first pass bytecod expand thread opcod inlin exactli explain section 23 figur 6 show symbol list nfib function implement exampl interpret opcod set initi translat thread code bytecod operand place inlin thread code translat exampl offset jge opcod call destin place directli opcod stream immedi associ opcod repres pseudooperand fig 3 doublyrecurs function interest properti result number function call requir calcul result nfib cont nfib nfib figur 7 thread code nfib benchmark inlin implement new macro opcod shown right ure appear separ line code prefix initi translat thread code second pass perform inlin thread code basic block identifi use dynam gener new thread macro opcod correspond origin sequenc thread opcod replac singl macro opcod rewrit thread code perform insitu sinc optim opcod sequenc alway result shorter sequenc optim code possibl overwrit opcod yet consid inlin figur 7 show code nfib function inlin taken place function reduc five thread macro opcod shown 1 5 replac basic block origin code implement new macro opcod concaten implement opcod replac new implement written separ area memori call macro cach five implement requir nfib shown within curli brace figur one end copi implement pseudoopcod thr thread oper dispatch next opcod inlin argument copi verbatim except cont jump offset adjust appropri transla tor inlin argument use macro opcod implement point mark figur help identif basic block divid thread opcod four class follow inlin opcod implement inlin macro opcod without restrict arithmet opcod belong class protect implement contain c function call therefor inlin print opcod belong class final opcod chang flow control therefor defin end basic block eg call rel opcod chang flow control therefor defin end basic block eg condit branch jge differ final rel way opcod inlin operand treat first case operand absolut copi directli final translat code second case operand rel current thread program counter must adjust appropri final translat code figur 8 show translat code initi thread opcod tabl along repres implement sever thread opcod four class thread opcod repres defin defin pop sp defin get longip read inlin operand defin next goto ip dispatch next opcod defin protect 0x00 never expand defin inlin 10 expand defin final 11 expand end basic block defin rel 12 expand end basic block offset follow defin opnam narg flag case initialip break startnam opcod bodi defin initi rather execut see macro op int switch op opjger0r1 1 rel regist long r0 r1 ip offset opcal 1 final regist long dest get dest default fprintfstderr panic op undefinedn op abort figur 8 opcod tabl initi translat inlin loop shown figur 9 complex might first appear code pointer translat thread code rewritten insitu indic code point next opcod copi inlin locat copi respect time loop consid opcod inlin inlin loop enter current opcod opcod follow inlin case opcod copi along inlin argument directli nextmacro pointer next unus locat macro cach inlin loop first write address repres thread opcod macro implement gener copi compil implement opcod macro cach inlin thread opcod copi although inlin argument encount copi directli inlin loop continu copi implement opcod explicitli end basic block rel next opcod either noninlin int int nextin long infothisopflag inlin infonextopflag protect inlin creat new macro opcod nextmacro void new macro opcod infothisopflag protect icopyinfothisopaddr ep infothisops infothisopflag rel locn offset int infothisopflag final infothisopflag rel destinationin break end basic block copi thread oper icopyinfothraddr ep infothrs cant inlin copi opcod inlin argument infothisopflag rel copi liter argument int figur 9 dynam translat loop protect branch destin implicitli end current basic block translat append implement pseudoopcod thr thre ade oper final nextmacro locat updat readi next inlin oper translat loop use array flag destin identifi branch destin within thread code array easili construct translat first pass bytecod expand noninlin thread code loop also creat two array reloc patchlist use recalcul rel branch offset 4 inlin loop concaten opcod implement use icopi function shown figur 10 function similar bcopi except also synchron pro cessor instruct data cach ensur new macro opcod implement execut contain line platformdepend code interpret 4 branch destin identif rel offset recalcul shown seen full sourc code exampl interpret see appendix static inlin void icopyvoid sourc void dest sizet size bcopysourc dest size size asm dcbst 00 sync icbi 00 isync rp elif definedsparc asm flush 0 stbar rp noop elif defin endif dest 4 size 4 figur 10 icopi function contain singl line platformdepend code 32 save space translat multipl copi opcod sequenc would wast space therefor keep cach dynam gener macro opcod key hash valu comput incom unoptim opcod translat case cach hit reus exist macro opcod translat code immedi reclaim macro cach space occupi newli translat version case cach miss newli gener macro opcod use translat code hash tabl updat includ new opcod ensur never one macro opcod correspond given sequenc unoptim opcod 4 experiment result particularli interest perform benefit dynam inlin appli interpret finegrain instruct set nevertheless also curiou see techniqu would perform appli interpret coarsegrain bytecod set took measur context use risclik interpret widelyus less suit interpret object caml languag 41 finegrain opcod risclik interpret opcod set similar present section 31 configur compil time use bytecod direct thread code direct thread code dynamicallygener macro opcod perform two benchmark measur use terpret functioncal intens fibonacci benchmark present earlier nfib memori intens function call free prime number gener siev tabl 1 show number second requir execut benchmark sever architectur 133mhz pentium sparcstat 20 200mhz powerpc 603ev figur shown simpl bytecod interpret interpret perform translat direct thread code direct thread code dynam inlin common opcod sequenc benchmark written c compil optim option o2 interpret final column show perform inlin thread code compar optim c nfib machin bytecod thread inlin c inlinedc pentium 632 371 223 111 498 siev machin bytecod thread inlin c inlinedc pentium 251 176 132 46 348 tabl 1 nfib siev benchmark result three architectur test final column show speed inlin thread code rel optim c pentium pentium bytecod direct thread inlin figur 11 benchmark perform rel optim c nfib spend much time perform arithmet regist memori stack oper perform function call return interpret alloc first vm regist physic machin regist whenev possibl opcod perform arithmet therefor typic compil singl machin instruct sparc powerpc two architectur show mark improv perform common sequenc inlin singl macro opcod due significantli reduc ratio opcod dispatch real work effect less pronounc pentium machin regist vm regist must kept memori arithmet opcod compil sever pentium instruct therefor ratio dispatch overhead real work lower risc architectur observ mark improv approxim factor two success version interpret nfib siev show less pronounc improv spend major time perform memori opera tion contribut opcod dispatch overal execut time therefor smaller nfib also interest observ perform version interpret rel optim c figur 11 show nfib gain approxim 14 speed optim c move bytecod represent thread code gain move thread inlin thread code depend architectur approxim 20 pentium 38 sparc gain siev smaller less depend architectur approxim 9 step three architectur 42 object caml also appli techniqu object caml bytecod interpret order obtain realist measur perform overhead less favor environ object caml chosen design implement interpret core clean simpl understand make requir modif present signific challeng furthermor fullyfledg system includ bytecod com piler benchmark suit larg applic made easier collect meaning statist interpret also equip mechan bulktransl bytecod thread code startup platform support 5 need extend initi translat phase perform analysi opcod sequenc gener macro opcod implementa tion rewrit thread code insitu use dynamicallygener macro opcod implement techniqu caml virtual machin took one day two small detail requir care attent first presenc switch opcod perform multiway branch follow thread code inlin tabl map valu onto branch offset ad special case translat loop handl opcod second exist hand opcod consum two inlin argument liter rel offset introduc new opcod class relative2 differ rel copi addit inlin liter argument offset translat loop translat algorithm ident respect one present section 3 ran standard object caml benchmark suit 6 modifi vm see tabl 2 vm instrument gather statist relat execut speed 5 use gcc firstclass label portablyftpftpinriafrinriaprojectscristalxavierleroy benchmarksobjcamltargz boyer fib genlex qsort qsort siev soli soli takc taku speed inlinednoninlin pentium sparc powerpc figur 12 objectivecaml benchmark result three architectur test vertic axi show perform rel origin noninlin interpret asterisk indic version benchmark compil array bound check disabl boyer term process function call fib integ arithmet function call 1 arg genlex lex pars symbol process kb term process function call function qsort integ array loop siev integ arithmet list process function soli puzzl solv array loop takc integ arithmet function call 3 arg curri taku integ arithmet function call 3 arg tuplifi tabl 2 object caml benchmark memori usag characterist dynam gener macro opcod figur 12 show perform benchmark inlin rel origin perform without inlin import note object caml bytecod set alreadi optim static describ section 24 ler98 improv therefor due mainli elimin dispatch overhead common sequenc particular applic virtual machin whose bytecod set stat ical optim way would benefit techniqu see figur major benchmark benefit signific perform advantag inlin case inlin version run 50 faster origin two benchmark run twice fast origin noninlin version sparc clear improv relat processor architectur probabl due differ cost thread oper sparc ex ampl avoid pipelin stall associ thread seem make signific differ figur 13 show final size macro cach benchmark sparc plot factor size origin unoptim code final macro cache135 cach size origin code size origin code size kbyte figur 13 macro cach size diamond optim thread code size cross plot factor origin code size size vari slightli architectur sinc depend size bytecod implement howev shape case averag ratio origin bytecod size macro cach size show cost three four time size origin code sparc ratio almost ident powerpc slightli smaller pentium observ ratio decreas gradual origin code size increas expect sinc larger bodi code tend reus macro opcod rather gener new one test translat bytecod version object caml compil 421532 byte origin code gener 941008 byte macro opcod implement sparc approxim 22 time size origin code shown rightmost point graph inlin thread code alway smaller origin code gener figur 13 also show final optim code size benchmark observ ratio independ size benchmark also expect sinc reduct size depend averag number opcod common sequenc densiti correspond macro opcod final code depend mainli characterist languag opcod set system longliv object memori gener new execut code runtim realist implement system would recycl macro cach space possibl use profil optim popular area program exampl 68040lc emul found macintosh system perform dynam translat 68040 powerpc code normal requir 250kb cach commonli use translat code sequenc store tho95 similar fix cach size effect brouhaha smalltalk system mir97 translat speed also import factor measur ran object caml bytecod compil much larger program benchmark modifi interpret 105383 opcod object caml compil translat 022 second sparc rate 480000 opcod per second inlin interpret execut compil rate 24 million opcod per sec ond translat therefor approxim five time slower execut 7 5 relat work brouhaha object caml demonstr benefit creat special macro opcod perform work sequenc common opcod object caml led new bytecod set brouhaha standard smalltalk80 bytecod translat thread code execut detect limit number predetermin common bytecod sequenc perform translat special opcod substitut execut code contribut extens techniqu dynam analyz gener implement new macro opcod runtim sever system use concaten precompil sequenc code runtim aus96 noe98 complet differ context precompil code sequenc gener templat parameter runtim particular constant valu templatebas approach also use commerci smalltalk virtual machin perform dynam compil nativ code mir97 howev techniqu complex requir signific effort implement templat new architectur interest system portabl dynam code gener vcode eng96 architectureneutr runtim sembler gener code approach perform c architectur main disadvantag retrofit exist virtual machin requir signific amount effort certainli singl day requir implement techniqu product virtual machin simpl nfib benchmark run 40 faster use vcode compar risclik inlin thread code virtual machin superoper pro95 techniqu special bytecod c interpret accord program execut possibl special 7 sinc translat perform opcod breakeven point pass program execut six time number opcod contain interpret gener time compil bytecod represent program compiletim analysi program choos like candid super oper implement new interpret bytecod superoper similar macro opcod one advantag correspond synthes bytecod benefit interopcod optim simpl concaten implement fail exploit howev superoper requir bytecod correspond precis node use build pars tree might alway best choic bytecod set would also tricki use superoper increment system smalltalk new execut code gener runtim nevertheless investig merg techniqu superoper dynamicallygener macro opcod might worthwhil 6 conclus work inspir need creat interpret finegrain risclik opcod set gener tie particular highlevel languag amen tradit compil optim cost opcod dispatch signific context compar abstract interpret whose bytecod care match languag semant expect benefit techniqu relat averag semant content bytecod would expect languag tcl perl rel highlevel opcod benefit less macroiz interpret risclik opcod set benefit sinc cost dispatch signific compar cost execut bodi bytecod object caml bytecod set posit two extrem contain simpl complex opcod 8 vcode better perform techniqu instruct set match close underli architectur exert fine control code gener perform degre reorder better instruct schedul believ similar result achiev risclik inlin thread code interpret portabl manner perform macro opcod limit inabl compil perform interopcod optim possibl static analysi perform new macro opcod implement manual terpret believ limit less import use finegrain opcod set correspond close tradit risc architectur opcod implement singl machin instruct new opportun interopcod optim avail translat code gener techniqu portabl simpl implement orthogon implement virtual machin op code reduc overhead opcod dispatch help bring perform finegrain bytecod level abstract languagedepend opcod set 8 signific overhead associ techniqu use check stack overflow pend signal object caml discuss beyond scope paper speed second space byte pentium sparc powerpc sparc benchmark origin inlin origin inlin origin inlin origin inlin cach boyer 20 181 111 23 150 154 14 119 113 13800 8324 42012 fib 20 144 140 40 247 163 16 112 139 5288 3320 20160 genlex 10 093 110 11 084 127 07 059 118 45696 26856 156892 kb 103 815 126 169 771 219 63 536 118 20968 13048 75868 qsort 58 395 146 95 539 175 41 298 137 6676 3932 26416 qsort 48 304 158 80 426 188 33 227 147 6532 3884 25280 siev 30 279 107 25 222 110 19 186 100 5200 3312 20124 soli 31 218 144 51 298 170 21 150 142 6644 3952 25516 soli 24 138 172 40 200 202 16 093 168 6544 3908 24548 takc 28 191 144 50 326 152 21 147 142 4784 3012 18652 taku 49 320 152 70 414 170 32 233 139 4812 3036 18296 tabl 3 raw result objectivecaml benchmark acknowledg author would like thank xavier leroy john mal oney eliot miranda dave ungar mario wolczko anonym refere help comment draft paper r java program lan guag commun acm effici implement smalltalk80 system engler vcode retarget portabl forth engin back futur stori squeak object caml system releas 105 java virtual machin specif fast direct optim ansi c interpret superoper build better virtual cpu tr smalltalk80 languag implement brouhaha portabl smalltalk interpret fast effect dynam compil back futur java program languag 2nd ed java virtual machin specif effici implement smalltalk80 system ctr alex iliasov templatesbas portabl justintim compil acm sigplan notic v38 n8 august fabric bellard qemu fast portabl dynam translat proceed usenix annual technic confer 2005 usenix annual technic confer p4141 april 1015 2005 anaheim ca jinzhan peng gansha wu gueiyuan lueh code share among state stackcach interpret proceed 2004 workshop interpret virtual machin emul june 0707 2004 washington dc ben stephenson wade holst multicod optim virtual machin use bytecod sequenc companion 18th annual acm sigplan confer objectori program system languag applic octob 2630 2003 anaheim ca usa brian davi john waldron survey optimis java virtual machin proceed 2nd intern confer principl practic program java june 1618 2003 kilkenni citi ireland anton ertl david gregg combin stack cach dynam superinstruct proceed 2004 workshop interpret virtual machin emul june 0707 2004 washington dc andrew beatti kevin casey david gregg andrew nisbet optim java interpret connect devic embed system proceed acm symposium appli comput march 0912 2003 melbourn florida bertil folliot ian piumarta fabio riccardi dynam configur multilanguag execut platform proceed 8th acm sigop european workshop support compos distribut applic p175181 septemb 1998 sintra portug marc berndl lauri hendren dynam profil trace cach gener proceed intern symposium code gener optim feedbackdirect runtim optim march 2326 2003 san francisco california brian davi andrew beatti kevin casey david gregg john waldron case virtual regist machin proceed workshop interpret virtual machin emul p4149 june 1212 2003 san diego california anton ertl david gregg retarget jit compil use ccompil gener execut code proceed 13th intern confer parallel architectur compil techniqu p4150 septemb 29octob 03 2004 henrik nssn mat carlsson konstantino sagona instruct merg special sicstu prolog virtual machin proceed 3rd acm sigplan intern confer principl practic declar program p4960 septemb 0507 2001 florenc itali mourad debbabi abdelouah gherbi lamia ketari chamseddin talhi hamdi yahyaoui sami zhioua synergi effici interpret fast select dynam compil acceler embed java virtual machin proceed 3rd intern symposium principl practic program java june 1618 2004 la vega nevada mathew zaleski marc berndl angela demk brown mix mode execut context thread proceed 2005 confer centr advanc studi collabor research p305319 octob 1720 2005 toranto ontario canada anton ertl david gregg optim indirect branch predict accuraci virtual machin interpret acm sigplan notic v38 n5 may yunh shi david gregg andrew beatti anton ertl virtual machin showdown stack versu regist proceed 1st acmusenix intern confer virtual execut environ june 1112 2005 chicago il usa marc berndl benjamin vital mathew zaleski angela demk brown context thread flexibl effici dispatch techniqu virtual machin interpret proceed intern symposium code gener optim p1526 march 2023 2005 benjamin vital tarek abdelrahman caten special tcl virtual machin perform proceed 2004 workshop interpret virtual machin emul june 0707 2004 washington dc k venugop geetha manjunath venkatesh krishnan sec portabl interpret optim techniqu embed java virtual machin proceed 2nd java virtual machin research technolog symposium p127138 august 0102 2002 anton ertl david gregg andrea krall bernd paysan vmgen gener effici virtual machin interpret softwarepractic experi v32 n3 p265294 march 2002 jefferi von ronn ning wang michael franz interpret program static singl assign form proceed 2004 workshop interpret virtual machin emul june 0707 2004 washington dc mathew zaleski angela demk brown kevin stoodley yeti gradual extens trace interpret proceed 3rd intern confer virtual execut environ june 1315 2007 san diego california usa mourad debbabi abdelouah gherbi azzam mourad hamdi yahyaoui select dynam compil embed java virtual machin target arm processor scienc comput program v59 n12 p3863 januari 2006 arun kejariw xinmin tian milind girkar wei li sergey kozhukhov utpal banerje alexand nicolau alexand v veidenbaum constantin polychronopoulo tight analysi perform potenti thread specul use spec cpu 2006 proceed 12th acm sigplan symposium principl practic parallel program march 1417 2007 san jose california usa david gregg andrew beatti kevin casey brain davi andi nisbet case virtual regist machin scienc comput program v57 n3 p319338 septemb 2005 etienn gagnon lauri j hendren sablevm research framework effici execut java bytecod proceed javatm virtual machin research technolog symposium javatm virtual machin research technolog symposium p33 april 2324 2001 monterey california gregori sullivan derek l bruen iri baron timothi garnett saman amarasingh dynam nativ optim interpret proceed workshop interpret virtual machin emul p5057 june 1212 2003 san diego california ana azevedo arun kejariw alex veidenbaum alexandru nicolau high perform annotationawar jvm java card proceed 5th acm intern confer embed softwar septemb 1822 2005 jersey citi nj usa scott thibault charl consel julia l lawal renaud marlet gill muller static dynam program compil interpret special higherord symbol comput v13 n3 p161178 sept 2000 mahmut taylan kandemir improv wholeprogram local use intraprocedur interprocedur transform journal parallel distribut comput v65 n5 p564582 may 2005 john aycock brief histori justintim acm comput survey csur v35 n2 p97113 june