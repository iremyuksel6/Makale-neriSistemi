simul studi decoupl vector architectur decoupl techniqu appli vector processor result larg increas perform vectoriz program simul select perfect club specfp92 benchmark suit compar execut time convent singl port vector architectur decoupl vector architectur decoupl increas perform factor greater 14 realist memori latenc ideal memori system zero latenc still speedup much 13 signific portion paper devot studi tradeoff involv choos suitabl size queue decoupl architectur hardwar cost queue need larg achiev perform advantag decoupl b introduct recent year wit increas gap processor speed memori speed due two main reason first technolog improv cpu speed match similar improv memori chip second instruct level parallel avail recent processor increas sinc sever instruct issu processor cycl total amount data request per cycl memori system much higher two factor led situat memori chip order 10 100 time slower cpu total execut time program greatli domin averag memori access time current superscalar processor attack memori latenc problem basic three main type techniqu cach multithread decoupl sometim may appear togeth cachebas superscalar processor reduc averag memori access time place work set program faster level memori hierarchi softwar hardwar techniqu 5 23 devis prefetch data high level memori hierarchi lower level closer cpu data actual need top program transform loop block 16 proven use fit work set program cach recent address data predict receiv much attent potenti solut indirectli mask memori latenc 21 multithread processor 1 30 attack memori latenc problem switch thread comput amount parallel exploit aug ment probabl halt cpu due hazard decreas occup function unit increas total throughput system improv singl thread still pay latenc delay cpu presum never idl thank mix differ thread comput decoupl scalar processor 27 25 18 focus numer comput attack memori latenc problem make observ execut program split two differ task move data processor execut arithmet instruct perform program com putat decoupl processor typic two independ processor address processor comput processor perform two task asynchron commun architectur queue latenc hidden fact usual address processor abl slip ahead comput processor start load data need soon comput processor excess data produc address processor store queue stay retriev comput processor vector machin tradit tackl latenc problem use long vector memori vector oper start pay initi po tential long latenc work long stream element effect amort latenc across element although vector machin success mani year certain type numer calcul still much room improv sever studi recent year 24 8 show perform achiev vector architectur real program far theoret peak perform machin 8 shown memori port singleport vector comput heavili underutil even program memori bound also show vector processor could spend 50 execut cycl wait data come memori despit need improv memori respons time vector architectur possibl appli hardwar softwar techniqu use scalar processor techniqu either expens exhibit poor perform vector context exampl cach softwar pipelin two techniqu studi 17 19 28 22 context vector processor prove use enough widespread use current vector machin conclus order obtain full perform vector processor addit mechan use reduc memori delay com ing lack bandwidth long latenc experienc program mani techniqu borrow superscalar microprocessor world paper focu decoupl also explor altern multithread 12 outoford execut 13 purpos paper show use decoupl techniqu vector processor 11 perform vector program greatli improv show even ideal memori system zero latenc decoupl provid signific advantag standard mode oper also present data show realist latenc decoupl vector architectur perform substanti better nondecoupl vector architectur anoth benefit journal supercomput 3 decoupl also allow toler latenc insid processor function unit regist crossbar latenc paper organ follow section 2 describ baselin decoupl architectur studi throughout paper section 3 discuss simul environ benchmark program use experi present section 4 provid background analysi perform tradit vector machin section 5 detail perform decoupl vector propos final section 6 present conclus futur line work 2 vector architectur implement studi base tradit vector processor numer applic primarili matur compil avail benchmark simul tool feel gener conclus extend vector applic howev decoupl vector architectur propos model convex c3400 section describ base c3400 architectur implement henceforth refer architectur decoupl vector architectur gener refer dva main implic elect c3400 studi restrict class vector comput one memori port two function unit also import point use output convex compil evalu decoupl architectur mean propos studi paper abl execut fulli transpar manner alreadi exist instruct set 21 refer architectur convex c3400 7 consist scalar unit independ vector unit see fig 1 scalar unit execut instruct involv scalar regist regist issu maximum one instruct per cycl vector unit consist two comput unit fu1 fu2 one memori access unit mem fu2 unit gener purpos arithmet unit capabl execut vector instruct fu1 unit restrict function unit execut vector instruct except multipl divis squar root function unit fulli pipelin vector unit 8 vector regist hold 128 element 64 bit eight vector regist connect function unit restrict crossbar pair vector regist group regist bank share two read port one write port link function unit compil respons schedul vector instruct alloc vector regist port conflict aris fetch decod unit sreg areg rxbar wxbar figur 1 refer vector architectur model convex c3400 22 decoupl vector architectur decoupl vector architectur propos use fetch processor split incom nondecoupl instruct stream three differ decoupl stream see fig 2 three stream goe differ processor address processor ap perform memori access behalf two processor scalar processor sp perform scalar comput vector processor vp perform vector comput three processor commun set implement queue proceed independ set queue akin implement queue found float point part r8000 microprocessor15 main differ decoupl architectur previou scalar decoupl architectur zs 1 26 map200 6 pipe 14 fom 4 two comput processor instead one two comput processor sp vp split due differ natur operand work scalar vector respect fetch processor fetch instruct sequenti nondecoupl instruct stream translat decoupl version translat processor proceed independ yet synchron commun queue need exampl memori instruct load regist v5 fetch fp translat two pseudoinstruct load instruct sent ap load data vector load data queue vldq queue 1 fig 2 qmov instruct sent vp dictat move oper vldq final destin regist v5 import note qmov gener fp journal supercomput 5 2 1 figur 2 decoupl vector architectur studi paper queue name 1 vector load data queue vldq 2 vector store data queue vsdq 3 address load queue alq 4 address store queue asq 5 scalar load data queue sldq 6 scalar store data queue ssdq scalaraddress control queue vectoraddress control queue 1011 scalarvector control queue instruct real sens ie belong programm visibl instruct set qmov opcod hidden insid implement note total hardwar ad origin refer architectur shown figur 1 consist commun queue privat decod unit one three processor resourc insid processor decoupl vector architectur refer architectur worth note though queue ad scalar queue therefor requir small amount extra area vldq vsdq hold full vector regist queue 2 3 fig 2 slot queue equival normal vector regist 128 element thu requir 1kb storag space one key point architectur achiev good perform rel slot two queue address processor perform memori access scalar vector well address comput scalar memori access go first scalar cach hold scalar data vector access go cach access main memori directli one pipelin port access memori share memori access address processor insert load instruct address load queue alq store instruct address store queue asq store stay queue associ data 6 roger espasa mateo valero show either output queue vp vector store data queue vsdq output queue sp scalar store data queue ssdq either load store becom readi ie depend associ data necessari present sent address bu soon becom avail case load store readi ap alway give prioriti load preserv sequenti semant program address processor need ensur safe order memori instruct held alq asq memori access process two step first associ memori region comput second region use disambigu memori instruct previou memori instruct still held address queue ap use disambigu inform depend scoreboard maintain scoreboard ensur 1 load execut inord 2 store execut inord 3 load execut older store associ memori region overlap depend found scoreboard guarante load store perform origin program order correct guarante memori region defin 5tupl h start end address resp consecut region byte memori vl vs sz vector length vector stride access granular need vector memori oper end address 2 comput 1 sz scalar memori access vl set 1 vs 0 special case gather scatter properli character memori region 1 set 0 2 set 2 scoreboard find depend gatherscatt previou futur memori instruct vector processor perform vector comput main differ vp refer architectur vp two function unit dedic move data processor two unit qmov unit abl move data vldq data queue fill ap vector regist move data regist vadq drain ap send content memori includ two qmov unit instead one otherwis vp would pay high overhead common sequenc code compar refer architectur set control queue connect three processor queue 711 fig 2 need instruct mix operand common case vector instruct scalar regist sourc operand ie mul v0s3 v5 case includ mix regist instruct vector gather requir address vector sent ap vector reduct produc scalar regist result journal supercomput 7 3 methodolog 31 simul environ ass perform benefit decoupl vector architectur taken trace driven approach perfect club specfp92 program chosen benchmark 3 trace procedur follow perfect club program compil convex c3480 7 machin use fortran compil version 80 optim level o2 impli scalar optim plu vector execut process use dixi 9 tool decompos execut basic block instrument basic block produc four type trace basic block trace trace valu set vector length regist trace valu set vector stride regist trace memori refer actual trace base address memori refer dixi instrument basic block program includ librari code especi import sinc number fortran intrins routin sin co exp etc translat compil librari call librari routin highli vector tune underli architectur repres high fraction vector oper execut program thu essenti captur behavior order accur model execut time program execut process dixi modifi execut run convex machin run produc desir set trace accur repres execut program trace fed two differ simul develop first simul model convex c34 architectur repres singl memori port vector comput second simul extens first introduc decoupl use two cyclebycycl simul gather data necessari discuss perform benefit decoupl 32 benchmark program interest benefit decoupl vector architectur select benchmark program highli vectoriz 70 program perfect specfp92 benchmark chose 10 program achiev least 70 vector tabl 1 present statist select perfect club specfp92 program column number 2 indic suit program belong column 3 present total number memori access includ vector scalar load store access next column total number oper perform vector mode column 5 number scalar instruct execut sixth column percentag vector program defin percentag vector ratio number vector oper total number oper perform program final column seven present averag vector length use vector instruct ratio vector oper vector instruct tabl 1 basic oper count perfect club program column 35 million mem vect scal avg program suit op op in vect vl hydro2d spec 1785 2203 23 990 101 arc2d perf 1959 2157 flo52 perf 706 551 su2cor spec 1561 1862 66 957 125 bdna perf 795 889 128 869 81 trfd perf 826 438 156 757 22 dyfesm perf 502 298 108 747 21 import thing remark tabl 1 program memori bound run refer machin take column label vect op divid 2 get minimum number cycl requir execut vector comput two vector function unit avail compar column mem op result divis see bottleneck program alway memori port absolut minimum execut time program determin total amount memori access perform remark worth keep mind sinc follow section show even memori port bottleneck program usag alway good one would intuit expect 4 bottleneck refer architectur first present analysi execut ten benchmark program run refer architectur simul consid three vector function unit refer architectur fu2 fu1 mem machin state repres 3tupl repres individu state one three unit given point time exampl 3tupl hfu2 fu1mem repres state unit work repres state vector unit idl execut time program thu split eight possibl state figur 3 present split execut time state ten benchmark program plot time spent state memori latenc 1 20 70 100 cycl figur see number cycl program proceed peak float point speed state low number cycl state chang rel littl memori latenc increas fraction journal supercomput 9 swm25620006000 execut cycl hydro2d10003000 arc2d10003000 nasa710003000 execut cycl dyfesm5001500 figur 3 function unit usag refer architectur bar repres total execut time program given latenc valu xaxi repres memori latenc cycl fulli use cycl decreas memori latenc high impact total execut time program dyfesm trfd flo52 rel small vector length effect memori latenc seen note increas cycl spent state h sum cycl correspond state mem unit idl quit high program four state correspond cycl memori port could potenti use fetch data memori futur comput figur 4 present percentag cycl total execut time latenc 70 port idl time rang 30 65 total execut time 10 benchmark program memori bound run singl port vector machin two function unit therefor unus memori cycl result lack loadstor work done 5 perform dva section present perform decoupl vector architectur versu refer architectur ref first start ignor latenc function unit insid processor concentr studi effect main memori latenc section 5155 studi determin swm256 hydro2d arc2d flo52 nasa7 su2cor tomcatv bdna trfd dyfesm2060 idl memori port 170 figur 4 percentag cycl memori port idl 4 differ memori latenc costeffect paramet achiev highest perform proceed consid effect arithmet function unit regist crossbar latenc execut time section 56 first show decoupl toler well memori latenc also use toler smaller latenc insid processor start defin dva architectur infinit queue latenc delay unbound dva udva short compar refer architectur introduc limit udva branch mispredict penalti limit queue size real function unit laten cie step step see individu effect restrict step reach realist version dva rdva compar ref udva machin 51 udva versu ref unbound dva architectur udva version decoupl architectur queue set larg valu 128 slot latenc delay moreov perfect branch predict model assum icach model follow experi sinc previou data indic low pressur icach 10 arithmet function unit scalar vector 1 cycl latenc vector regist file read write crossbar latenc startup penalti vector instruct benefit decoupl seen fig 5 program plot total execut time udva ref architectur memori latenc vari 1 100 cycl graph also show minimum absolut execut time theoret achiev curv ideal along bottom graph comput ideal execut time program use total number cycl con journal supercomput 11 swm2565060cycl x flo5210cycl cycl dyfesm10cycl ref udva ideal figur 5 udva versu refer architectur benchmark program sume heavili use vector unit fu1 fu2 mem thu ideal essenti elimin data memori depend program consid perform limit satur resourc across entir execut overal result suggest two import point first dva architectur show clear speedup ref architectur even memori latenc 1 cycl even latenc memori system decoupl produc similar effect prefetch techniqu advantag ap know data load incorrect prefetch second import point slope execut time curv refer decoupl architectur substanti differ impli decoupl toler long memori delay much better current vector architectur memori latenc cycles1216 hydro2d arc2d su2cor bdna trfd dyfesm figur 6 speedup dva refer architectur benchmark program overal decoupl help minim number cycl machin halt wait memori recal section 4 execut time program could partit eight differ state decoupl greatli reduc cycl spent state h summar speedup obtain fig 6 present speedup dva ref architectur particular valu memori latenc speedup latenc 100 rang 132 tomcatv 170 dyfesm 52 reduc iq length first limit introduc udva reduct instruct queue feed three comput processor ap sp vp section look slowdown experienc udva size apiq spiq vpiq queue reduc 128 instruct 32 16 8 4 instruct order reduc amount simul requir chosen fix valu memori latenc paramet 50 cycl seen previou section udva toler well wide rang memori latenc thu expect valu 50 cycl quit repres full 1100 latenc rang size instruct queue import sinc give upper bound occup queue system exampl determin maximum number entri wait load address queue figur 7 present slowdown respect udva ten benchmark three instruct queue reduc 32 16 8 4 slot fig 7 see perform 128 32 16entri instruct queue virtual benchmark number decid set iq length 16 entri rest experi present paper size line typic instruct queue found current microprocessor 31 journal supercomput 13 swm256 hydro2d arc2d flo52 nasa7 su2cor tomcatv bdna trfd dyfesm102106 figur 7 slowdown experienc udva reduc iq size swm256 hydro2d arc2d flo52 nasa7 su2cor tomcatv bdna trfd dyfesm101103 slowdown figur 8 slowdown due branch mispredict three model specul 53 effect branch predict section look neg effect introduc branch mispredict branch predict mechan evalu directmap btb hold entri branch target address 2bit predictor predictor found 20 augment basic btb mechan 8deep return stack akin one found 2 evalu accuraci branch predictor 64 entri btb accuraci vari lot across set benchmark program flo52 nasa7 come worst mispredict rate around 30 tomcatv less 04 mispredict branch nonetheless mispredict rate rather high set program consid easi jump pattern numer code tend domin doloop due combin two fact first vector reduc absolut total number branch perform program unbalanc way number easili predict loop branch diminish factor proport vector length could high 128 difficult branch found remain scalar portion code essenti second factor use small btb compar found current superscalar microprocessor typic btb could 4096 entri 29 although predict accuraci good impact mispredict branch total execut time small figur 8 present slowdown 14 roger espasa mateo valero due mispredict branch rel perform architectur section 52 sinc predict accuraci high test benefit could obtain abl specul across sever branch fig 8 bar label u1 correspond architectur allow one unresolv branch bar label u2 u3 correspond abl specul across 2 3 branch respect first observ impact mispredict branch rather low see flo52 30 mispredict rate total impact mispredict branch 05 second observ specul across multipl branch provid benefit special dyfesm cost certainli justifi simplic one outstand branch resolv plu vector architectur simul follow section perform use 64entri btb allow 1 unresolv branch 54 reduc vector queue length 541 vector load data queue section look usag vector load data queue goal determin queue size achiev almost perform 128slot queue use previou section yet minim much possibl hardwar cost figur 9 present distribut busi slot vldq benchmark program program plot three distribut correspond three differ memori latenc valu bar graph repres total number cycl vldq certain number busi slot exampl trfd latenc 1 vldq complet empti zero busi slot around 500 million cycl fig 9 see common use 6 slot except swm256 tomcatv 6 slot enough cover around 8590 cycl latenc increas 1 cycl 50 100 cycl graph show shift occup toward higher number slot exampl consid program arc2d nasa7 su2cor 1 cycl memori latenc program typic 23 busi slot latenc increas three program show increas total usag vldq typic use around 45 slot expect longer memori latenc higher number busi slot sinc memori system outstand request therefor need slot queue execut impact reduc vldq size seen fig 10 expect data seen fig 9 reduc queue size 16 8 slot notic program go 4 slot affect mostli nasa7 bdna impact less 1 reduc vldq 2 slot would start hurt perform although much worst case would nasa7 around 4 impact alreadi discuss 2 slot clearli lower bound size vldq accommod memori journal supercomput 15 swm256500cycl arc2d100300500 flo52100200cycl tomcatv100cycl dyfesm100300cycl figur 9 busi slot vldq benchmark program three differ memori latenc valu bound loop reduc queue 1 slot would stop decoupl effect present architectur look data present section decid pick 4 slot vldq follow section use size vldq 542 vector store data queue usag vector store data queue present differ pattern vldq recal ap alway tri give prioriti load oper front store effect put much pressur vsdq point becom full even 128 slot situat unusu may seem long ap encount depend load store long swm256 hydro2d arc2d flo52 nasa7 su2cor tomcatv bdna trfd dyfesm102106 figur 10 slowdown due reduc vldq size rel section 53 load dispatch store retriev vsdq sent memori thu occup vsdq much higher vldq figur 11 present distribut busi slot vsdq benchmark program load queue plot three distribut correspond three differ memori latenc valu bar graph repres total number cycl vsdq certain number busi slot make plot clear prune graph next name program indic quartil amount shown exampl full set data shown nasa7 q100 bar hydro2d graph present 95 avail data rest data set small seen plot compens loss inform graph also includ maximum valu x axi took particular program hydro2d graph show maximum occup vsdq reach 118 slot although xaxi plot goe 50 note 6 program point queue complet fill 128 full slot although common occup rang slot 4 program occup queue bound bdna maximum occup 34 slot queue su2cor maximum 23 bound mostli due high percentag spill code time vector load tri recov vector stack previous spill store ap detect depend need updat content memori drain queue heavili limit amount old store kept vsdq program trfd dyfesm qualit differ two program simpli dont decoupl well program dyfesm recurr forc three main processor ap sp vp work lock step thu typic allow maximum 1 full slot program trfd core triangular matrix decomposit order matrix access make iter main loop depend previou iter caus lot loadstor depend queue depend resolv journal supercomput 17 q999400800cycl hydro2d q95400800 arc2d q9421000 cycl 28 78 128 su2cor q999400800 tomcatv q10050cycl trfd q1005000 1 dyfesm q999200600cycl figur 11 busi slot vsdq benchmark three differ memori latenc valu case spill code drain queue updat memori thu queue never reach larg occup execut impact reduc vsdq size seen fig 12 bar show amount storag vsdq import perform mostli due fact singlememori port environ matter reorder load store everi singl store perform anyway thu send store memori point data readi later chang much overal comput rate data present section select 4slot vsdq follow experi swm256 hydro2d arc2d flo52 nasa7 su2cor tomcatv bdna trfd dyfesm100102 figur 12 slowdown due reduc vsdq queue size rel section 541 swm256 hydro2d arc2d flo52 nasa7 su2cor tomcatv bdna trfd dyfesm100slowdown figur 13 slowdown due reduc scalar queue size rel section 542 55 reduc scalar queue length section look impact reduc size variou scalar queue system look back fig 2 reduc queue number 38 1011 128 slot 16 slot queue number 9 vacq vp toap control queue reduc 128 slot 1 slot note queue hold one full vector regist use gatherscatt oper size chosen reason close modern outoford superscalar processor queue 31 impact reduct seen fig 13 overal use 8 entri queue scalar queue enough sustain perform 128 entri queue even small 2 entri queue slowdown around 101 3 program dyfesm bdna nasa7 nonetheless beard mind program heavili vector small degrad perform scalar side temper small percentag scalar code present benchmark order make safe decis took 16 entri queue scalar queue present architectur journal supercomput 19 tabl 2 latenc paramet vector scalar function unit paramet latenc scal vect intfp vector startup 1 read xbar 2 add 12 6 mul 52 7 logicshift 12 4 div 349 20 sqrt 349 20 56 effect function unit latenc section look effect latenc insid comput processor architectur far model simul function unit use 1 cycl latenc vector regist readwrit crossbar model free go section proceed three step first add architectur latenc vector function unit tabl 2 show valu chosen second step add penalti 1 cycl vector startup vector oper third step add 2 cycl vector read crossbar latenc add 2 cycl vector write crossbar latenc last step set latenc scalar unit also shown tabl 2 figur 14 show set stack bar degrad perform aforement effect ad bar bottom label vect lat repres slowdown rel section 55 follow bar label startup slowdown respect perform vect lat bar similarli follow bar thu total height bar combin slowdown effect figur 14 show two differ behavior seven ten program latenc small impact 5 due fact decoupl good toler memori latenc gener help cover latenc insid processor hand two program trfd dyfesm show slowdown bad 111 115 respect behavior two program surpris given alreadi saw section 541 trfd dyfesm difficulti decoupl interiter depend trfd recurr dyfesm saw achiev small occup vector load data queue indic bad degre decoupl coupl fact swm256 hydro2d arc2d flo52 nasa7 su2cor tomcatv bdna trfd dyfesm105slowdown scal lat r xbar startup vect lat figur 14 slowdown due model arithmet unit latenc vector pipelin crossbar rel section 55 rel low vector length trfd dyfesm see cycl ad vector depend graph typic enlarg critic path program go detail breakdown fig 14 show vector function unit latenc highest impact latenc ad section worth note though order latenc ad might impact rel import individu categori nonetheless sinc vector latenc unit largest latenc ad sinc program highli vector group like impact perform fig 14 confirm startup penalti seen program trfd dyfesm impact less 1 vector regist file readwrit crossbar latenc impact program except swm256 tomcatv typic latenc amount impact 05 1 percentag point vector code around 23 percentag point less vector trfd dyfesm scalar latenc low impact program partli due shorter vector one partli due small fraction scalar code partli due scalar latenc mask vector latenc decid compar impact function unit latenc refer machin dva machin simul refer machin latenc refer machin standard latenc comput result slowdown compar slowdown slowdown fig 14 present result comparison seen fig 15 result show case effect function unit latenc much wors inord refer machin decoupl machin sinc decoupl introduc form dynam schedul hide latenc previous critic path perform memori load advanc journal supercomput 21 swm256 hydro2d arc2d flo52 nasa7 su2cor tomcatv bdna trfd dyfesm105115 slowdown udva ref figur 15 comparison function unit latenc impact udva ref machin 57 rdva versu ref data present last section reach realist implement origin propos udva realist version refer rdva main paramet follow instruct queue scalar queue 16 entri long address queue ap also entri long latenc use function unit readwrit crossbar regist file shown tabl 2 vldq vsdq 4 slot control queue connect vp ap singl slot branch predict mechan 64 entri btb 1 unresolv branch support section replot fullscal comparison udva rdva ref sever latenc figur 16 present data three architectur memori latenc vari 1 cycl 100 cycl almost program differ udva rdva rather small slope rel parallel swm256 differ almost 0 program hydro2d tomcatv arc2d su2cor slowdown rdva udva less respect 1029 1031 1037 1044 program flo52 bdna nasa7 higher slowdown moreov slope curv rdva perform start diverg udva high valu latenc final dyfesm trfd seen previou section take signific perform hit go udva rdva 6 summari futur work paper describ basic decoupl vector architectur dva use principl decoupl hide memori latenc seen vector processor 22 roger espasa mateo valero swm2565060cycl x flo5210cycl x cycl x dyfesm10cycl x ref rdva udva ideal figur 16 comparison ref udva rdva execut time sever latenc dva architectur show clear speedup ref architectur even memori latenc 1 cycl speedup due fact ap slip ahead vp load data advanc vp need input operand almost alway readi queue even latenc memori system slip produc similar effect prefetch techniqu advantag ap know data load incorrect prefetch thu partit program separ task help exploit parallel ap vp translat increas perform even absenc memori latenc moreov increas latenc see slope curv execut time benchmark remain fairli stabl wherea ref architectur much sensit increas memori latenc memori latenc set journal supercomput 23 50 cycl exampl speedup rdva ref machin rang 118140 latenc increas 100 cycl speedup go high 15 seen speed improv implement reason costperform tradeoff section 54 shown length queue need larg allow decoupl take place vector load queue four slot enough achiev high fraction maximumperform obtain infinit queue side vector store queue need larg experi vari store queue length indic store queue two element achiev almost perform one sixteen slot abil toler larg memori latenc critic futur high perform comput order reduc cost high perform sram vector memori system turn sdram base memori sy tem chang unfortun significantli increas memori latenc point decoupl come rescu shown 100 cycl latenc grace toler perform increas respect tradit inord machin moreov although paper look singl processor case decoupl techniqu would also effect vector multiprocessor help reduc neg effect conflict interconnect network memori modul simul result present paper indic vector architectur benefit mani techniqu current found superscalar processor appli decoupl altern appli multithread techniqu improv memori port usag 12 outoford execut togeth regist renam 13 current pursu latter approach r perform tradeoff multithread processor perfect club benchmark effect perform evalu supercomput er organ architectur tradeoff fom perform studi softwar hardwar data prefetch strategi function parallel architectur array processor convex architectur refer manual c seri quantit analysi vector code dixi trace gener system c3480 instruct level character perfect club program vector comput decoupl vector architectur multithread vector architectur pipe vlsi decoupl architectur optim parallel data local cach perform vector supercomput memori latenc effect decoupl architectur softwar pipelin effect schedul techniqu vliw machin branch predict strategi branch target buffer design valu local load valu predict vector regist design polycycl vector schedul design evalu compil algorithm prefetch explain gap theoret peak perform real perform supercomput architectur decoupl accessexecut comput architectur simul studi decoupl architectur comput polycycl vector schedul vs chain 1port vector supercomput design microarchitectur ultrasparci exploit choic instruct fetch issu implement simultan multithread processor mip r10000 superscalar microprocessor tr simul studi decoupl architectur comput zs1 central processor softwar pipelin effect schedul techniqu vliw machin polycycl vector schedul vs chain 1port vector supercomput optim parallel data local design evalu compil algorithm prefetch design tfp microprocessor perform studi softwar hardwar data prefetch scheme cach perform vector supercomput explain gap theoret peak perform real perform supercomput architectur outoford vector architectur vector regist design polycycl vector schedul decoupl accessexecut comput architectur mip r10000 superscalar microprocessor memori latenc effect decoupl architectur perform tradeoff multithread processor decoupl vector architectur multithread vector architectur quantit analysi vector code ctr mostafa soliman stanislav g sedukhin matrix bidiagon implement evalu trident processor neural parallel scientif comput v11 n4 p395422 decemb mostafa soliman stanislav g sedukhin trident scalabl architectur scalar vector matrix oper australian comput scienc commun v24 n3 p9199 januaryfebruari 2002