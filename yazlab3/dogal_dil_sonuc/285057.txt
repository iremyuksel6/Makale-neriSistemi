formal verif complex coher protocol use symbol state model directorybas coher protocol sharedmemori multiprocessor complex verif techniqu base autom procedur requir establish correct state enumer approach wellsuit verif cach protocol face problem state space explos lead unaccept verif time memori consumpt even small system configur one way manag complex make verif feasibl map system model verifi onto symbol state model ssm sinc number symbol state consider less number system state exhaust state search becom possibl even largescal sytem complex protocolsin paper develop concept notat verifiy properti directorybas protocol design nonfifo interconnect network compar verif protocol ssm stanford mur 4 verif tool enumer system state show ssm much effici term verif time memori consumpt therefor hold promis verifi much complex protocol uniqu featur ssm verifi protocol system size therefor provid reliabl verif result one run tool b introduct cach data close processor dynam import techniqu reduc latenc memori access sharedmemori multiprocessor system multipl copi memori block may exist cach coher protocol often maintain coher among data copi 29 largescal system directorybas protocol 4 5 19 remain solut choic reli effici broadcast mechan moreov optim adapt variou share pattern current trend toward complex protocol usual implement softwar protocol processor 18 flexibl propos even exist let user defin protocol perappl basi 28 one major problem prove protocol correct sever coher transact bear block initi time differ processor messag may enter race condit protocol behavior often hard predict 2 protocol design visual possibl tempor interleav coher messag autom procedur verifi protocol therefor highli desir sever approach verifi properti cach protocol recent paper survey approach 24 one import class verif techniqu deriv state enumer method reachabl perturb analysi explor possibl system state 7 15 gener method start system model finit state machin specifi behavior compon protocol global state composit state compon state expans process start given initi state exercis possibl transit lead number new state process appli repeatedli everi new state new state gener end global state transit diagram reachabl graph show transit relat among global state report major drawback state enumer approach size system state space increas quickli number complex compon protocol often creat state space explos problem 15 verifi system increas number cach becom rapidli impract term comput time memori requir protocol becom complex clear whether verifi smallscal system model provid reliabl error coverag system size 25 recent introduc new approach call ssm symbol state model address state space explos problem 23 appli simpl snoopi protocol singl bu 2 ssm gener framework verif system compos homogen commun finit state machin thu applic verif cach protocol homogen sharedmemori multiprocessor ssm take advantag equival among global state precis respect properti verifi data consist ssm exploit abstract correspond relat among global state met 3astat repres larg set state 23 base observ behavior cach character finit state machin cach state combin class global state compos class moreov number cach state class abstractli repres set repetit constructor indic 0 1 multipl instanc cach class abstract global state repres famili global state effici expand expand abstract state equival expand larg set state ssm verifi properti protocol system size therefor verif reliabl verif reli state enumer small system size develop tool appli new approach illustr applic concret case verifi paper three import coher properti protocol design nonfifo interconnect network nonfifo network network messag two node receiv differ order sent therefor number possibl race among coher messag much larger system fifo net work demonstr effici tool compar murj 8 show ssm much effici term verif time memori consumpt therefor hold promis verifi much complex protocol paper structur follow section 2 provid outlin protocol nonfifo network verif model correct issu mechan detect variou type error discuss section 3 develop verif method section 4 5 result studi section 6 section 7 contain conclus directorybas protocol nonfifo network protocol inspir censier feautrier writeinvalid protocol 4 everi memori block associ directori entri contain vector presenc bit indic whether cach copi block presenc bit set copi first load cach reset copi invalid replac multipl copi exist differ cach must ident memori copi extra dirti bit per block directori entri indic whether dirti cach copi exist case one cach copi say copi exclus cach exclus copi also often call owner line enforc ownership block invalid must sent cach presenc bit set final replac share copi silent sens presenc bit reset memori protocol applic gener ccnuma cachecoher nonuniform memori access machin ccnuma share memori distribut equal among processor node cach privat cach processor case directori attach memori partit cover memori block alloc thu block home memori directori entri resid implement conceptu simpl protocol requir care synchron cach directori involv mani cach state memori state messag cach memori complet specif design found 26 coher messag exchang memori cach given tabl 1 messag basic two type control data control messag includ request acknowledg messag role selfexplanatori except sack synchron messag whose role becom clear later follow describ salient featur protocol use verifica tion simplifi follow descript refer state block cach state cach convent appli state block directori state machin throughout paper 21 cach state cach three stabl state invalid share clean copi potenti share cach owner modifi cach copyalso call exclu sive howev sinc cach state transit instantan three transient state ad keep track request issu cach yet complet 1 readmisspend rmp state block frame empti pend recept block read miss 2 writemisspend wmp state block frame empti pend recept block ownership write miss 1 coher messag type messag action memori inv request invalid local copi invo request invalid local copi write back memori updm request updat main memori copi chang local copi share state oship ownership grant data block copi suppli memori control nack neg acknowledg indic request reject lock directori entri cach reqsc request share copi reqo request ownership reqoc request ownership block copi dxm block copi suppli owner respons updm messag memori doxmr block copi suppli owner replac doxmu block copi suppli owner respons invo messag memori iack acknowledg indic invalid complet sack synchron messag 3 writehitpend whp state block frame contain share copi pend recept ownership right complet write access state suffici system fifo network nonfifo network possibl race exist coher request sent time two differ cach block request serial home node respons gener may enter race reach cach order consid follow case assum two process node p 1 p 2 issu request exclus copi block time request p 1 reach home node first grant copi request p 2 process home invalid sent p 1 nonfifo network possibl invalid reach p 1 exclus copi similar scenario occur p 1 request share copi time p 2 want exclus copi p 1 request exclus copi p 2 want share copi deal three race condit protocol use three addit transient cach state synchron interact cach memori state transient ownertoinvalid txoi transient sharedtoinvalid txsi transient ownertoshar txo resolv race two process node request exclus copi cach state wmp move state txoi receiv invalid receiv data block execut pend write write block back memori invalid copi end state state txsi txo solv two race similar fashion 22 memori state stabl memori state indic presenc dirti bit directori share exclus uncach memori block stabl state free unlock mean memori control may accept new request block howev memori state transit instantan time directori control start process incom request time consid request complet directori entri transient state lock maintain semicrit section memori block 30 request reach lock busi directori entri nack three correspond transient memori state xdata xown xownc indic transact progress share copi ownership right exclus copi respect typic system fifo network protocol base intervent forward process node request copi block exclus remot cach home node first request copi dirti block updat memori forward request owner victim modifi copi replac memori state remain exclus writeback messag reach memori control transmiss recept writeback messag memori control may receiv request share copi issu anoth cach forward owner memori control receiv block copi sent time replac believ block copi sent respons forward request meanwhil forward request still pend problem also identifi 2 solut suggest 2 count presum owner ignor forward request ever largescal system unpredict network delay intract problem caus forward request outpac messag 25 1 directori state transit synchron owner memori solv problem ambigu writeback messag use differ messag id cach write back caus replac doxmr invalid doxmu see tabl 1 moreov add two transient state directori synch1 synch2 memori control unlock directori entri receiv replac data block synchron messag exampl memori control receiv request share copi reqsc request forward owner memori state chang xdata presum owner written back block repli synchron messag receiv request forward memori memori control receiv block messag type doxmr synchron messag sack owner directori enter transient state synch2 wait synchron messag sack writeback messag doxmr owner respect state synch1 take care similar case origin request messag reqoc shown figur 1 3 protocol model correct properti 31 system model first step verif construct system model manag verif complex model leav detail peculiar implement retain featur essenti properti verifi earli stage protocol design approach also facilit rapid design modif model section describ system model use verif protocol first singl block model suffici check properti relat cach coher 20 replac take place time model processor access second abstract directorybas ccnuma architectur system model figur 2a appropri sinc model singl block model consist directori xdata reqoc doxmu sackor sackor sackor sackor reqsc doxmr doxmr doxmr doxmr multipl processorcach pair processor associ one messag send channel ch one messag receiv channel ch model messag flow cach main memori messag channel preserv execut order memori access order model nonfifo interconnect messag never lost may receiv differ order issu cach protocol treat differ messag local processor remot processor model figur 2a equival model figur 2b home memori model independ activ entiti use system model figur 2b throughout paper 2 verif model directorybas ccnuma architectur third valu data copi track abstract first propos 22 cach may data block one three statu nodata cach valid copi fresh cach uptod copi obsolet cach outofd copi ch ch home memori directori fullmap ch ch ch ch base machin ch ch home memori ch ch ch ch home node abstract model ccnuma multiprocessor singl block b refin model protocol machin memori copi either fresh obsolet cours verif expans process keep track statu block copi conform protocol semant third abstract necessari discov verif s3mp protocol 21 25 differ protocol use paper consid protocol transact illustr figur 3 initi cach dirti copi block replac perform writeback home node cach keep valid copi block receiv acknowledg memori order guarante memori receiv block safe meanwhil cach b send request exclus copi home subsequ cach process dataforwardrequest home consid acknowledg prior writeback request send block b b execut write replac block due miss shown figur 3 race condit exist two writeback request writeback b win race stale writeback overwrit valu updat b note exampl state transit permiss overcom problem verif model need maintain global variabl rememb writeback carri latest valu 3 stale writeback error 32 formal protocol model given architectur model figur 2 formal defin constitu finit state machin interact protocol conveni languag specifi machin csp 14 messag transmiss repres postfix messag recept postfix definit 1 receiv channel receiv channel machin record messag receiv memori transit cach structur rchm q r r xm d1 r xc set memorytocach messag tabl 1 messag memori home 1 writeback 2 exclusiverequest 3 dataforwardrequest 4 exclusiveforward 5 writeback messag cach messag issu memori control consum cach respect definit 2 send channel send channel machin record messag issu cach transit memori control structur schm q xc d1 xm d2 set cachetomemori messag tabl 1 messag cach messag memori messag issu cach consum memori respect state channel machin made messag transit state expans step receiv send channel may record command sent memori cach may propag command cach memori behavior cach control given definit 3 definit 3 cach machin state machin character cach behavior structur cm q c r xc d1 c xc d2 c coher messag defin definit 1 2 xc xc messag consum produc cach respect upon receiv messag cach control may may respond gener respons messag accord d1 c addit emb processor machin cach machin processor may issu access local cach may caus cach state chang issuanc coher messag specifi d2 c finit state machin main memori protocol formal follow definit 4 memorydirectori main memori machin keep directori structur messag defin definit 1 2 xm xm cachestomemori memorytocach command respect memori machin consum messag respons messag may may sent cach q bm denot set possibl state base machin defin definit 5 base machin base machin composit cach machin two correspond channel machin bm definit 6 protocol machin protocol machin defin composit base machin memori machin pm n cach state tabl use verif d1 c d2 c found 26 memori control consum messag cach respond accord block state messag type final state protocol machin also refer global state paper 33 correct properti protocol paper verifi three properti data consist incomplet protocol specif livelock follow definit 331 data consist basic condit cach coher given 4 load must alway return valu updat latest store address formul condit within framework reachabl expans follow definit 7 data consist respect particular memori locat protocol preserv data consist follow condit alway true reachabl analysi famili global state origin g includ g consist return load valu written store access write recent valu memori locat bring global state g g valu written store transit state reach expand g allow access old valu defin architectur model figur 2 memori access made sever consecut event thu atom constrain way sequenc access gener processor moreov hardwar distinguish synchron instruct regular loadstor instruct paper latenc toler mechan processor cach model assum mechan correct enforc proper sequenc order memori access cooper softwar base model data valu section 31 data inconsist detect processor allow read data obsolet valu definit 8 detect data inconsist data copi tag valu set nodata fresh obsolet data transfer emul expans data inconsist detect processor allow read data obsolet valu 332 incomplet protocol specif unforeseen interleav event protocol specif often incom plete especi earli phase develop flaw manifest unspecifi messag recept ie entiti protocol receiv messag unexpect given current state 31 state machin model effect detect unspecifi messag recept procedur simpl directli tie structur reachabl graph unspecifi messag recept detect system state messag receiv transit state specifi protocol descript besid detect error state enumer show path lead erron state 333 deadlock livelock protocol deadlock enter global state without possibl exit livelock situat process interact protocol could theoret make progress trap loop state eg processor keep retri request alway reject anoth processor deadlock easi detect state enumer sinc state without exit state difficult detect livelock level abstract adopt paper protocol compon commun via messag thu detect deadlock livelock deriv servic function iti provid cach coher protocol exampl protocolintrins livelock block processor wait messag eg invalid acknowledg never sent anoth processor protocol specif deadlock livelock condit due particular implement protocol finit messag buffer fair serv memori request detect level abstract definit 9 livelock context coher protocol livelock condit given block lock processor processor perman prevent access block 20 state expans process check follow condit order detect livelock correct protocol condit livelockfre protocol visit everi state global state transit diagram infinit mani time global state transit diagram stronglyconnect given global state everi state global state transit diagram reachabl 2 b processor issu memori access block memori access must eventu satisfi eg valu alway return load resum processor execut specifi calli given initi global state cach invalid state must exist reachabl global state cach state becom share dirti read miss access 20 condit b suffici avoid livelock defin definit 9 assur everi processor read modifi block arbitrari number time condit stronger necessari assum cach protocol oper steadi state cach protocol machin might start initi state never return later case global state graph would compris two subgraph one subgraph consist initi state would exit second subgraph correspond steadi state oper protocol vice versa special case identifi care analysi state graph livelock report 4 verif method model figur 2 order state base machin global state represent irrelev protocol correct symmetri size state space reduc factor n given system n processor symbol state model ssm exploit power abstract relat symmetr relat order reduc size state space reliabl new abstract must equival system model respect properti verifi 41 equival state transit system gener formal system verifi finit state transit system definit 10 finit state transit system respect cach block behavior cach system local cach automata model finit state transit system ms 0 0 initi state set state symbol global state space subset set oper caus state transit repres state transit function consid state transit system 0 respect properti p verifi want find abstract state transit system correspond r smaller error state map error state r definit 11 correspond given two state transit system 0 r correspond exist correspond relat j 1 0r correspond 0 ie 0r js 0 2 least one state correspond ie r js 3 state make transit state enabl oper state r r correspond state exist state r r move r r r correspond figur 4 illustr correspond relat 4 correspond relat definit 12 equival two state transit system r r correspond equival respect properti p verifi iff follow condit verifi step expans r let r current correct state r let r next state r transit 1 p verifi r p hold state r jt 2 p hold r jt p hold r 3 p hold r must exist state r js r jt p hold first condit definit 12 establish expans r complet without violat properti p expans would also complet without violat p second third condit definit 12 ensur error state discov expans r iff error state exist error state r correspond error state follow first specifi abstract machin r correspond protocol machin definit 6 prove r equival respect cor rect properti section 33 42 abstract ssm model atom memori access ssm method first introduc 22 assumpt atom memori access develop abstract relat among global state base observ order model cach protocol state must keep track whether exist 0 1 multipl copi exclus state latest copi data hand number readonli share data copi affect protocol behavior provid least one cach copi symbol state repres use repetit constructor definit 13 repetit constructorsatom memori access 1 null 0 specifi zero instanc 2 singleton 1 specifi one one instanc constructor omit state represent 3 plu specifi one multipl instanc 4 star specifi zero one multipl instanc repetit constructor repres exampl set global state one multipl cach invalid state zero one multipl cach share state metast correspond set explicit state 5 order relat among repetit constructor repetit constructor order set state repres thu 1 figur 5 order relat extend metast call composit state 22 exampl contain set global state repres first composit state subset repres second composit state contain relat among composit state composit state contain composit state kept verif end state expans state space collect repres rel small number essenti composit state r 23 43 ssm model nonatom memori access model protocol nonatom access need defin element form basi repetit abstract add new repetit constructor call univers constructor model figur 2 base machin natur form unit abstract repetit henceforth set base machin state repres c cach state p valu presenc bit directori r number base machin set specifi one repetit constructor r state receiv channel state send channel r specifi messag transit channel sinc channel model nonfifo network order messag channel irrelev often confus part notat may omit exampl use notat q combin cach state state two messag channel although singleton plu star use repres unspecifi number instanc given construct base machin given global state precis enough model intermedi state complex protocol transact trigger event count consid abstract state write miss occur cach share state must invalid ultim state processor state exclus dirti copi behavior level 23 state transit done one step memori access assum atom howev access longer atom invalid sent cach state number share copi count onebyon upon receiv invalid acknowledg result need distinguish two state contain metast two state correspond case either cach state deal problem first defin inval idationset definit 14 invalidationset invalidationset invset contain set cach presenc bit set must invalid memori grant exclus copi request exclus copi requestforownership reqo requestfor ownercopi reqoc protocol pend memori copi must invalid state expans process need keep track whether invalidationset empti sinc cach state specifi repetit constructor exact number cach particular state unknown use constructor alon repres number copi may prevent expans possibl state consid follow composit state invalidationset brack et q denot base machin presenc bit reset 6 expans step null nonnul instanc cover constructor memori receiv request exclus copi reqoc cach state c determin whether invalidationset empti definit includ case null nonnul instanc one way solv shortcom notat explor case expans process global state expand two state correspond empti nonempti invalidationset gener expans step shown figur 6 expans step q 1 mean machin state q 1 chang state q 2 other remain q 1 c1 c2 c f reqoc f reqoc data f s3 qc1 f iack f iack s4 qc2 data f f iack cach c1 acknowledg invalid request c1 chang c1 memori receiv iack cach c2 cach c2 respond inv c2 chang c2 memori receiv iack cach c2 1 s0 suppos memori receiv request exclus copi cach state c two state correspond empti nonempti invalidationset gener s2 invalid sent cach invalidationset wherea s1 request obtain exclus copi new owner invalidationset empti 2 expans s2 cach state c2 receiv invalid respond invalid acknowledg chang state c2 3 memori receiv invalid acknowledg cach state c2 s3 two state empti nonempti invalidationset gener 4 global state s5 assum cach state c1 acknowledg invalid incorrect design s6 acknowledg messag cach state c2 receiv memori expans may consid invalidationset empti make transit s4 howev case invalidationset empti also cover must also expand either process never stop error go undetect order solv problem expans process need rememb expans path follow figur 6 transit s0 s1 s0 s2 correspond empti nonempti invalidationset respect howev invalidationset s2 fact cover three case 1 2 3 unfortu nate split state s2 result combinatori explos state space effici solut work state s2 keep track whether invalidationset empti end introduc new constructor call univers constructor u construc tor transit appli nonempti invalidationset form null case gener rather compon insid invalidationset expand one one without consid null case keep track fact expand compon least without consid null case use u constructor compon expans type u constructor similar except transit null case exercis expans inval idationset invalidationset may consid empti form let examin expans step use u constructor see procedur work figur 7 1 global state s1 expans process explor path cach respond invalid global state s2 constructor replac u class cach x n q 2 q remain c2 next time expand expans process consid null case 7 resolut provid u constructor 2 global state s3 expans process choos expand class cach state c1 consid case nonempti set cach state c1 acknowledg invalida tion process move state s4 accord condit empti invalidationset pend request exclus copi state s4 never resum cach class c1 situat easili detect livelock situat protocol trap loop s2 qc1 f iack s3 qc1 f iack f iack f iack c2 f iack f iack c2 f iack data f cach c1 dont acknowledg inv cach c1 acknowledg inv c1 chang c1 cach c2 respond inv c2 chang c2 memori receiv iack cach c2 memori receiv iack cach c1 memori receiv iack cach c1 c2 pend request f reqoc never resum 3 hand cach invalidationset acknowledg memori expans process take anoth path state s4 s5 s6 occurr event count writeinvalid protocol collect acknowledg invalid writeupd protocol updat must acknowledg way equival invalidationset could call updateset 44 symbol state model combin basic framework section 42 refin section 43 system unspecifi number cach group base machin state state class specifi number class one follow repetit constructor definit 15 enhanc set repetit constructor 1 null 0 specifi zero instanc 2 singleton 1 specifi one one instanc constructor omit state represent 3 plu specifi one multipl instanc 4 star specifi zero one multipl instanc howev case zero instanc explor transact depend event count expans 5 univers u specifi zero one multipl instanc case zero instanc explor transact depend event count expans definit 16 composit state composit state repres state protocol machin system arbitrari number base machin construct state class form nq bm number state base machin q q bm r 0 1 u q mm q memori machin state repetit constructor order possibl state specifi name 1 8 order lead definit state contain 8 order relat among repetit constructor enhanc set q n definit 17 contain say composit state 2 contain composit state 1 1 q consequ contain famili state repres 2 superset famili state repres 1 therefor 1 discard verif process provid prove expans process base expans rule section 441 monoton oper set composit state memori event appli 1 2 441 rule expans process set oper applic composit state state gener process defin follow stand show state transit 1 aggreg q 0 q r 2 coincid transit q 1 r r 1 u observ transit 3 onestep transit q q 1 b q q 1 machin state q 1 denot q tupl transit appli base machin state q 1 q 1 q 2 caus base machin q 1 move state q 3 transit machin q may affect shown chang q q 4 nstep transit rule specifi repetit applic transit n time n arbitrari posit integ q q 1 q mm b q q 1 c q q 1 5 progress transit provid q 1 q 2 q mm q r 1 q mm state bracket form invalidationset base machin invalida tionset denot q tupl aggreg rule group base machin state one exampl coincid transit memori control send invalid signal everi cach valid copi onestep transit occur exampl memori receiv request exclus copi base machin class q 1 base machin chang state q 2 request messag remov send channel memori normal process one request exclus copi time case machin q 1 q may stay state may chang state new invalid messag sent receiv channel rule b c nstep transit correspond two chain transit transit q 1 q 2 appli unlimit number time long base machin state q 1 transit effect machin denot q tupl typic exampl 1 processor replac copi state share 2 processor receiv type messag 3 processor issu memori access independ two addit rule similar interpret nstep transit requir progress expans process progress transit deal protocol transact involv event count explain section 43 correspond two chain transit q mm q mm protocol model process request exclus copi memori transit recept invalid acknowledg iack tabl 1 invset set cach presenc bit set memori must invalid memori grant exclus copi rule appli invalid process wherea rule b appli success invalid copi state expans process cach transact possibl current state explor state expans step two phase first new composit state produc appli one transit rule current state second aggreg rule appli lump base machin state see exampl figur 11 45 monoton state expans gener system verifi compos finit state machin one machin commun machin directli composit state ssm form possibl state machin r repetit constructor partial order exist among repetit constructor one figur 8 state expans rule includ aggreg rule onestep transit rule compound transit rule correspond multipl applic onestep transit rule aggreg rule rule use repres symbol state compactli possibl base partial order repetit constructor abstract state represent contain composit state base partial order among constructor context prove expans rule ssm monoton oper name intuit ssm state 1 contain 2 expans step done correctli next state state includ 1 must also contain 2 expans contain abstract state ssm independ properti verifi properti data consist see definit 7 formul user check reduc state space lemma 1 aggreg process monoton q possibl state state machin r repetit constructor proof proof follow order relat among repetit constructor check possibl combin r 11 r 12 r 21 r 22 subject constraint lemma aggreg rule q lemma 2 immedi successor 1 origin state contain state 2 origin state expans rule taken memori event q n q r 21 q n q n appli 1 2 proof need consid effect appli machin state q 1 2 simplifi notat class q j j lump q provid q q k follow two state gener onestep transit rule appli 1 2 q mean transit may caus state chang machin sinc includ case singl base machin must contain case zero base machin clear 1 contain relat also true compound rule involv multipl onestep transit nstep rule progress rule appli 1 2 q lemma 3 claim 1 2 hold proof aggreg process monoton lemma 1 lemma 3 simpli extend result lemma 2 q theorem 1 monoton 1 2 everi 1 reachabl 1 exist 2 reachabl 2 1 2 proof immedi result lemma 3 q algorithm state expans process shown figur 9 two list keep track nonexpand visit state step new state produc state contain state prune final output set essenti state definit 18 essenti state composit state essenti exist composit state reader awar fact gener essenti state success verifi system correct system incorrect expand error state lead unpredict state practic meaningless assum state expans process termin whenev error detect illustr figur 10 state space report end errorfre expans process partit sever famili state may r r overlap repres essenti composit state 23 9 algorithm gener essenti state theorem 2 essenti composit state gener algorithm figur 9 complet symbol repres state produc basic state enumer method state abstract proof consid state state enumer method composit ssm state r r r r symbol form r cover result next state r also cover gener composit state transit function appli inform accumul expans q 451 uniqu set essenti state set essenti state uniqu provid state graph connect essenti state strongli connect name exist least one path everi essenti state essenti state algorithm essenti state gener w list work composit state h list visit composit statesoutputessenti state w empti begin get current state w state class v applic oper v state p w q h discard els begin remov p w p remov q h q add w discard termin loop start new run insert h fulli expand contain end theorem 3 success run verif start legal initi state gener set essenti state es state transit graph form essenti state es strongli connect set es uniqu sens state expans process alway produc set essenti state es start legal reachabl state proof set essenti state defin fixpoint state expans process termin theorem 2 state es repres possibl configur system reach therefor must contain least one e es symbol state expans monoton state deriv contain state deriv e state transit graph es strongli connect must exist least one path e essenti state imposs reach essenti state e es q 10 represent state space essenti state theorem 3 hold state graph strongli connect consid simpl case state graph consist two subgraph g1 g2 g1 g2 individu strongli connect path exist g1 g2 vice versa state expans process start state contain state g2 state g1 subgraph g2 produc order gener entir state graph state expans must start state g1 howev livelock error g2 transit g1 may report case accord condit section 333 overcom problem isol subgraph analyz protocol design determin whether state graph strongli connect advanc howev normal safe start state expans process initi state cach invalid usual state system turn 46 accumul state inform accumul compact state inform composit state major strength ssm method approach consid simpl state transit caus read miss assumpt atom memori access essenti state initi processor copi block read miss cach receiv share data copi cach remain invalid state order reach state share share invalid cover share tradit state enumer method would need model least three cach gener difficult predict number cach need model reach possibl state protocol ssm method elimin uncertainti sinc verifi protocol model independ number processor 5 correspond state enumer ssm model shown ssm expans monoton still need prove abstract ssm state transit system r 0r r r equival explicit state transit system ms 0 respect properti section 33 correspond relat j ssm follow definit 19 correspond relat state correspond state ie r js one state abstractli repres r state local automaton number local automata state must case cover repetit constructor r j name alway find abstract initi state 0r correspond initi state 0 explicit model instanc normal start verif initi state cach copi exist case cach invalid invalid invalidinvalid theorem 4 consid state transit system ms 0 explicit model arbitrari number local automata abstract state transit model r ssm consid two state state local automaton given r js find r jtthen state violat properti section 33 iff r error state r proof 1 regard data consist complet specif proof direct cons r2 q n rn 1 2 i1m q j1n i1m q j i1m q j 1 2 r2 q n rn i1m q j1n quenc theorem 1 2 one state repres r ie r js monoton oper ssm guarante state character r furthermor data consist complet specif properti check current state independ state instanc data inconsist found processor allow read stale data definit 8 thu r must error state error state vice versa 2 show absenc simpl deadlock livelock defin definit 9 need show processor never trap abl complet read write eventu sec tion 33 consid explicit model trap subset state s1 s2 s3 sn s1 abstract ssm model r must correspond set state s1 r s2 r s3 r sn r s1 r si r jsi theorem 1 theorem 2 suppos circular loop s1 r s2 r s3 r sn r s1 r broken enabl transit si r r correspond exit si must exist ti r jt r constitu finit state machin q 6 protocol error detect sinc unexpect messag recept error easi detect describ model procedur detect inconsist also present subtl livelock error found cours verif final compar perform ssm method murj term time complex memori usag verif result report expans process start initi state cach copi empti messag channel state ssm method initi state free 61 data inconsist detect mechan data inconsist base model describ section 331 statu variabl ad cach channel messag carri data possibl valu nodata n fresh f obsolet statu memori copi fresh f obsolet movement data copi model assign statu one variabl anoth variabl figur 11 state class augment parenthes statu associ everi data valu figur illustr state transit trigger read miss request reqsc transit end owner copi cach accord definit 7 owner fresh copi wherea copi includ memori copi becom obsolet data inconsist detect whenev processor read obsolet data 62 livelock expans step lead livelock origin protocol describ ini tialli consid system state owner request progress directori entri free state form free 11 data transfer detect data inconsist ssm consid follow scenario 1 owner replac copi write block back memori state indic writeback messag output channel n data f f reqsc wmp n fresh copi cach state fresh copi propag cach copi directori free accept new request memori copi fresh n data f data f f reqsc wmp n state transit memori respond reqsc request n data f f reqsc wmp n load data memori aggreg state transit n data f f reqsc wmp n mani intermedi state shown writemiss request load data memori success invalid cach copi n f reqsc wmp n state transit receiv data execut pend write new owner fresh data memori copi becom obsolet 2 next cach experi write miss send request exclus copi new state free race exist writeback ownership messag case nonfifo network 12 livelock detect ssm 3 memori receiv ownership messag writeback messag case memori state chang xownc invalid invo sent cach memori still record cach owner result state xownc 4 cach receiv invo messag chang state txoi system state becom xownc wmp f doxmr reqoc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpinvo doxmr xownc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpinvo f synch1 nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo txoif doxmr xownc nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo txoif f synch1 nack f rmp f reqsc wmp nack f wmp f reqoc wmp f reqo wmpf doxmr reqoc initi state loop forev sink state memori receiv reqoc read miss miss miss read miss read miss read miss miss miss cach receiv nack memori receiv abort reqsc cach receiv nack cach receiv nack cach receiv nack memori receiv abort reqsc memori receiv abort reqsc memori receiv abort reqsc memori receiv abort request memori receiv abort request memori receiv abort request memori receiv abort request cach receiv nack cach receiv nack cach receiv nack cach receiv nack memori receiv doxmr cach receiv invo memori receiv doxmr wmp invo doxmr txoi 5 final memori receiv writeback messag enter synchron state synch1 expect synchron messag sack cach figur 1 system state synch1 howev synchron messag never sent cach lock directori entri forev ssm method error success detect report cycl exist four global state without exit state outsid loop shown figur 12 global state transit diagram strongli connect error detect present murj system check connect global state diagram overwhelmingli complex size global state diagram larg livelock condit origin fact memori check presenc bit receiv ownership request livelock remov follow correct protocol memori receiv reqoc messag check whether processor identifi messag correspond current owner memori state chang synchron state synch1 directli follow state diagram figur 1 later writeback messag arriv memori updat copi block suppli cach copi block unlock directori entri 63 comparison murj system murj system develop dill et al 8 base state enumer two version murj nonsymmetr murj system murjn symmetr murj system murj murjn two system state equival ident wherea murj exploit symmetri system use characterist state repres state permut 16 exampl two system state compos three local cach state share share invalid invalid share share deem equival order cach state global state represent irrelev correct protocol time complex memori usag verif close relat size system state space gener exhaust search algorithm perform three fundament oper 1 gener new state left otherwis termin report final set global state 2 compar new state set previous visit state 3 keep new state futur expans new state visit timeconsum step compar new state previous visit state time complex grow proport size search space set state gener analyz procedur memori usag increas size global txoi state space set state save report end sinc search space direct expans global state space reduc size global state space particularli import murj incorpor state encod reduc memori usag hash tabl speed search comparison oper optim implement ssm tabl show perform comparison murjn murj ssm run model mbyte memori verif protocol make follow observ first smallscal system less five processor time complex memori usag murjn murj toler second size global state space search space murj significantli less murjn littl differ time taken method case four processor system observ murj take longer murjn extra overhead due state permut map murj may explain processor ad model verif time memori usag increas drastic case compar murj ssm effici verif base ssm run 09 second mbyte memori state space 123 global state compar small fact perform classic enumer techniqu accept small system size rais question whether elabor approach ssm realli need sinc final set essenti state report ssm cover possibl state system reach essenti state maximum number base machin differ state repres complex state system verif use ssm complex essenti state consist 25 base machin differ state mean system model least 25 processor requir obtain 100 error coverag state enumer method case murjn observ roughli time increas size search space time one process ad model trend continu 25 proce sor search space could reach size 10 37 state model 25 processor time 2 comparison ssm murjn murj method number processor size global state space size search space verif time memori usag mbyte murjn 5 excess memori usag 200mbyte murj ssm n 1 123 4205 09 002 memori space need verif complex would prohibit exist machin protocol verifi paper number messag float one messag channel time bound spite fact number processor model arbitrari howev ssm method preclud possibl protocol may allow processor send multipl even arbitrari number messag type 25 result model messag channel may need adapt use finit variabl repres infinit system behavior 13 case repetit constructor might use keep track abstractli number messag type ssm method detect protocolintrins livelock section 333 number global state report rel small 123 state case time complex check connect global state transit diagram manag murj 7 conclus cach coher protocol design system assum nonfifo network requir system adapt rout faulttoler interconnect network paper verifi directorybas cach coher protocol nonfifo network verif protocol done murj system ssm method gener speak ing studi found murj system effect verifi smallscal system manag complex howev shown protocol verifi paper system model least 25 processor requir order reach 100 error cover age mani processor complex state space search would prohibit murj system wherea perform ssm show could deal much complex protocol one use paper overal ssm method offer three advantag classic state enumer method state abstract first overcom state explos problem second sinc entir global state space symbol repres small number essenti state time complex check connect global state transit diagram need livelock detect manag third verifi protocol system size recent ip dill integr variat ssm method murj 17 tool expand explicit state infer abstract state base gener explicit state wherea tool work directli abstract state therefor new murj tool may requir multipl run ad one processor model consecut run reach complet verif result obtain method experi confirm classic state enumer approach suffici verifi protocol system small number processor wherea method base symbol state represent ssm critic futur design complex protocol largescal multiprocessor architectur model figur 2 memori access made sever consecut event thu atom constrain way sequenc access gener processor moreov hardwar distinguish synchron instruct regular loadstor instruct paper latenc toler mechan processor cach model assum mechan correct enforc proper sequenc order memori access 9 howev methodolog ssm preclud verif consist presenc latenc toler hard ware order includ latenc toler hardwar synchron access must model sequenc access gener processor constrain memori consist model 11 approach appli 26 27 delay consist protocol specifi 10 wherea state enumer approach appropri verifi coher properti seem applic verif memori access order reason one found way far formul verif properti memori order state enumer graph thu verif memori access order must still reli test procedur 6 manual proof 1 12 acknowledg research support nation scienc foundat grant ccr 9222734 also want acknowledg contribut david l dill c norri ip provid invalu inform murj system r lazi cach algorithm cach coher problem sharedmemori multiprocessor cach coher protocol evalu use multiprocessor simul model new solut coher problem multicach sy tem directorybas cach coher larg scale multiprocessor reason parallel architectur protocol represent finitest model protocol verif hardwar design aid memori access buffer multiprocessor delay consist effect miss rate parallel program mem ori consist event order sharedmemori multiprocessor prove sequenti consist high perform share memori verif distribut cach memori use abstract commun sequenti process algorithm autom protocol verif better verif symmetri verifi system replic compon murj stanford flash multiprocessor design directorybas cach coher protocol dash multiprocessor formal verif gigamax cach consist protocol s3mp scalabl share memori multiprocessor verif cach coher protocol new approach verif cach coher proto col survey techniqu verifi cach coher proto col verifi distribut directorybas cach coher protocol s3mp case studi symbol state model new approach verif cach coher protocol formal verif delay consist protocol tempest typhoon userlevel share memori survey cach coher scheme multiprocessor data coher problem multicach system toward analyz synthes protocol tr cach coher protocol evalu use multiprocessor simul model memori access buffer multiprocessor cach coher problem sharedmemori multiprocessor lazi cach algorithm survey cach coher scheme multiprocessor directorybas cach coher largescal multiprocessor prove sequenti consist highperform share memori extend abstract delay consist effect miss rate parallel program reason parallel architectur verif cach coher protocol stanford flash multiprocessor tempest typhoon symbol state model verif techniqu cach coher protocol commun sequenti process new approach verif cach coher protocol protocol verif hardwar design aid formal verif delay consist protocol verifi distribut directorybas cahc coher protocol verif distribut cach memori use abstract verifi system replic compon murphi better verif symmetri